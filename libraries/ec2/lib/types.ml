open Aws
open Aws.BaseTypes
open CalendarLib
type calendar = Calendar.t
module VolumeType =
  struct
    type t =
      | Standard 
      | Io1 
      | Io2 
      | Gp2 
      | Sc1 
      | St1 
    let str_to_t =
      [("st1", St1);
      ("sc1", Sc1);
      ("gp2", Gp2);
      ("io2", Io2);
      ("io1", Io1);
      ("standard", Standard)]
    let t_to_str =
      [(St1, "st1");
      (Sc1, "sc1");
      (Gp2, "gp2");
      (Io2, "io2");
      (Io1, "io1");
      (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module PrivateIpAddressSpecification =
  struct
    type t =
      {
      primary: Boolean.t option ;
      private_ip_address: String.t option }
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let of_json j =
      {
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module Tag =
  struct
    type t = {
      key: String.t ;
      value: String.t }
    let make ~key  ~value  () = { key; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module InstanceNetworkInterfaceAssociation =
  struct
    type t =
      {
      carrier_ip: String.t option ;
      ip_owner_id: String.t option ;
      public_dns_name: String.t option ;
      public_ip: String.t option }
    let make ?carrier_ip  ?ip_owner_id  ?public_dns_name  ?public_ip  () =
      { carrier_ip; ip_owner_id; public_dns_name; public_ip }
    let parse xml =
      Some
        {
          carrier_ip =
            (Util.option_bind (Xml.member "carrierIp" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.carrier_ip
             (fun f -> Query.Pair ("CarrierIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.carrier_ip
             (fun f -> ("carrier_ip", (String.to_json f)))])
    let of_json j =
      {
        carrier_ip =
          (Util.option_map (Json.lookup j "carrier_ip") String.of_json);
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module EbsBlockDevice =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option ;
      kms_key_id: String.t option ;
      encrypted: Boolean.t option }
    let make ?delete_on_termination  ?iops  ?snapshot_id  ?volume_size 
      ?volume_type  ?kms_key_id  ?encrypted  () =
      {
        delete_on_termination;
        iops;
        snapshot_id;
        volume_size;
        volume_type;
        kms_key_id;
        encrypted
      }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encrypted
              (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encrypted
              (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json)
      }
  end
module InstanceIpv6AddressList =
  struct
    type t = InstanceIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6Address.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceIpv6Address.to_query v
    let to_json v = `List (List.map InstanceIpv6Address.to_json v)
    let of_json j = Json.to_list InstanceIpv6Address.of_json j
  end
module PrivateIpAddressSpecificationList =
  struct
    type t = PrivateIpAddressSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrivateIpAddressSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PrivateIpAddressSpecification.to_query v
    let to_json v = `List (List.map PrivateIpAddressSpecification.to_json v)
    let of_json j = Json.to_list PrivateIpAddressSpecification.of_json j
  end
module SecurityGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResourceType =
  struct
    type t =
      | Client_vpn_endpoint 
      | Customer_gateway 
      | Dedicated_host 
      | Dhcp_options 
      | Egress_only_internet_gateway 
      | Elastic_ip 
      | Elastic_gpu 
      | Export_image_task 
      | Export_instance_task 
      | Fleet 
      | Fpga_image 
      | Host_reservation 
      | Image 
      | Import_image_task 
      | Import_snapshot_task 
      | Instance 
      | Internet_gateway 
      | Key_pair 
      | Launch_template 
      | Local_gateway_route_table_vpc_association 
      | Natgateway 
      | Network_acl 
      | Network_interface 
      | Placement_group 
      | Reserved_instances 
      | Route_table 
      | Security_group 
      | Snapshot 
      | Spot_fleet_request 
      | Spot_instances_request 
      | Subnet 
      | Traffic_mirror_filter 
      | Traffic_mirror_session 
      | Traffic_mirror_target 
      | Transit_gateway 
      | Transit_gateway_attachment 
      | Transit_gateway_multicast_domain 
      | Transit_gateway_route_table 
      | Volume 
      | Vpc 
      | Vpc_peering_connection 
      | Vpn_connection 
      | Vpn_gateway 
      | Vpc_flow_log 
    let str_to_t =
      [("vpc-flow-log", Vpc_flow_log);
      ("vpn-gateway", Vpn_gateway);
      ("vpn-connection", Vpn_connection);
      ("vpc-peering-connection", Vpc_peering_connection);
      ("vpc", Vpc);
      ("volume", Volume);
      ("transit-gateway-route-table", Transit_gateway_route_table);
      ("transit-gateway-multicast-domain", Transit_gateway_multicast_domain);
      ("transit-gateway-attachment", Transit_gateway_attachment);
      ("transit-gateway", Transit_gateway);
      ("traffic-mirror-target", Traffic_mirror_target);
      ("traffic-mirror-session", Traffic_mirror_session);
      ("traffic-mirror-filter", Traffic_mirror_filter);
      ("subnet", Subnet);
      ("spot-instances-request", Spot_instances_request);
      ("spot-fleet-request", Spot_fleet_request);
      ("snapshot", Snapshot);
      ("security-group", Security_group);
      ("route-table", Route_table);
      ("reserved-instances", Reserved_instances);
      ("placement-group", Placement_group);
      ("network-interface", Network_interface);
      ("network-acl", Network_acl);
      ("natgateway", Natgateway);
      ("local-gateway-route-table-vpc-association",
        Local_gateway_route_table_vpc_association);
      ("launch-template", Launch_template);
      ("key-pair", Key_pair);
      ("internet-gateway", Internet_gateway);
      ("instance", Instance);
      ("import-snapshot-task", Import_snapshot_task);
      ("import-image-task", Import_image_task);
      ("image", Image);
      ("host-reservation", Host_reservation);
      ("fpga-image", Fpga_image);
      ("fleet", Fleet);
      ("export-instance-task", Export_instance_task);
      ("export-image-task", Export_image_task);
      ("elastic-gpu", Elastic_gpu);
      ("elastic-ip", Elastic_ip);
      ("egress-only-internet-gateway", Egress_only_internet_gateway);
      ("dhcp-options", Dhcp_options);
      ("dedicated-host", Dedicated_host);
      ("customer-gateway", Customer_gateway);
      ("client-vpn-endpoint", Client_vpn_endpoint)]
    let t_to_str =
      [(Vpc_flow_log, "vpc-flow-log");
      (Vpn_gateway, "vpn-gateway");
      (Vpn_connection, "vpn-connection");
      (Vpc_peering_connection, "vpc-peering-connection");
      (Vpc, "vpc");
      (Volume, "volume");
      (Transit_gateway_route_table, "transit-gateway-route-table");
      (Transit_gateway_multicast_domain, "transit-gateway-multicast-domain");
      (Transit_gateway_attachment, "transit-gateway-attachment");
      (Transit_gateway, "transit-gateway");
      (Traffic_mirror_target, "traffic-mirror-target");
      (Traffic_mirror_session, "traffic-mirror-session");
      (Traffic_mirror_filter, "traffic-mirror-filter");
      (Subnet, "subnet");
      (Spot_instances_request, "spot-instances-request");
      (Spot_fleet_request, "spot-fleet-request");
      (Snapshot, "snapshot");
      (Security_group, "security-group");
      (Route_table, "route-table");
      (Reserved_instances, "reserved-instances");
      (Placement_group, "placement-group");
      (Network_interface, "network-interface");
      (Network_acl, "network-acl");
      (Natgateway, "natgateway");
      (Local_gateway_route_table_vpc_association,
        "local-gateway-route-table-vpc-association");
      (Launch_template, "launch-template");
      (Key_pair, "key-pair");
      (Internet_gateway, "internet-gateway");
      (Instance, "instance");
      (Import_snapshot_task, "import-snapshot-task");
      (Import_image_task, "import-image-task");
      (Image, "image");
      (Host_reservation, "host-reservation");
      (Fpga_image, "fpga-image");
      (Fleet, "fleet");
      (Export_instance_task, "export-instance-task");
      (Export_image_task, "export-image-task");
      (Elastic_gpu, "elastic-gpu");
      (Elastic_ip, "elastic-ip");
      (Egress_only_internet_gateway, "egress-only-internet-gateway");
      (Dhcp_options, "dhcp-options");
      (Dedicated_host, "dedicated-host");
      (Customer_gateway, "customer-gateway");
      (Client_vpn_endpoint, "client-vpn-endpoint")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TagList =
  struct
    type t = Tag.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Tag.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Tag.to_query v
    let to_json v = `List (List.map Tag.to_json v)
    let of_json j = Json.to_list Tag.of_json j
  end
module InstanceType =
  struct
    type t =
      | T1_micro 
      | T2_nano 
      | T2_micro 
      | T2_small 
      | T2_medium 
      | T2_large 
      | T2_xlarge 
      | T2_2xlarge 
      | T3_nano 
      | T3_micro 
      | T3_small 
      | T3_medium 
      | T3_large 
      | T3_xlarge 
      | T3_2xlarge 
      | T3a_nano 
      | T3a_micro 
      | T3a_small 
      | T3a_medium 
      | T3a_large 
      | T3a_xlarge 
      | T3a_2xlarge 
      | T4g_nano 
      | T4g_micro 
      | T4g_small 
      | T4g_medium 
      | T4g_large 
      | T4g_xlarge 
      | T4g_2xlarge 
      | M1_small 
      | M1_medium 
      | M1_large 
      | M1_xlarge 
      | M3_medium 
      | M3_large 
      | M3_xlarge 
      | M3_2xlarge 
      | M4_large 
      | M4_xlarge 
      | M4_2xlarge 
      | M4_4xlarge 
      | M4_10xlarge 
      | M4_16xlarge 
      | M2_xlarge 
      | M2_2xlarge 
      | M2_4xlarge 
      | Cr1_8xlarge 
      | R3_large 
      | R3_xlarge 
      | R3_2xlarge 
      | R3_4xlarge 
      | R3_8xlarge 
      | R4_large 
      | R4_xlarge 
      | R4_2xlarge 
      | R4_4xlarge 
      | R4_8xlarge 
      | R4_16xlarge 
      | R5_large 
      | R5_xlarge 
      | R5_2xlarge 
      | R5_4xlarge 
      | R5_8xlarge 
      | R5_12xlarge 
      | R5_16xlarge 
      | R5_24xlarge 
      | R5_metal 
      | R5a_large 
      | R5a_xlarge 
      | R5a_2xlarge 
      | R5a_4xlarge 
      | R5a_8xlarge 
      | R5a_12xlarge 
      | R5a_16xlarge 
      | R5a_24xlarge 
      | R5d_large 
      | R5d_xlarge 
      | R5d_2xlarge 
      | R5d_4xlarge 
      | R5d_8xlarge 
      | R5d_12xlarge 
      | R5d_16xlarge 
      | R5d_24xlarge 
      | R5d_metal 
      | R5ad_large 
      | R5ad_xlarge 
      | R5ad_2xlarge 
      | R5ad_4xlarge 
      | R5ad_8xlarge 
      | R5ad_12xlarge 
      | R5ad_16xlarge 
      | R5ad_24xlarge 
      | R6g_metal 
      | R6g_medium 
      | R6g_large 
      | R6g_xlarge 
      | R6g_2xlarge 
      | R6g_4xlarge 
      | R6g_8xlarge 
      | R6g_12xlarge 
      | R6g_16xlarge 
      | R6gd_metal 
      | R6gd_medium 
      | R6gd_large 
      | R6gd_xlarge 
      | R6gd_2xlarge 
      | R6gd_4xlarge 
      | R6gd_8xlarge 
      | R6gd_12xlarge 
      | R6gd_16xlarge 
      | X1_16xlarge 
      | X1_32xlarge 
      | X1e_xlarge 
      | X1e_2xlarge 
      | X1e_4xlarge 
      | X1e_8xlarge 
      | X1e_16xlarge 
      | X1e_32xlarge 
      | I2_xlarge 
      | I2_2xlarge 
      | I2_4xlarge 
      | I2_8xlarge 
      | I3_large 
      | I3_xlarge 
      | I3_2xlarge 
      | I3_4xlarge 
      | I3_8xlarge 
      | I3_16xlarge 
      | I3_metal 
      | I3en_large 
      | I3en_xlarge 
      | I3en_2xlarge 
      | I3en_3xlarge 
      | I3en_6xlarge 
      | I3en_12xlarge 
      | I3en_24xlarge 
      | I3en_metal 
      | Hi1_4xlarge 
      | Hs1_8xlarge 
      | C1_medium 
      | C1_xlarge 
      | C3_large 
      | C3_xlarge 
      | C3_2xlarge 
      | C3_4xlarge 
      | C3_8xlarge 
      | C4_large 
      | C4_xlarge 
      | C4_2xlarge 
      | C4_4xlarge 
      | C4_8xlarge 
      | C5_large 
      | C5_xlarge 
      | C5_2xlarge 
      | C5_4xlarge 
      | C5_9xlarge 
      | C5_12xlarge 
      | C5_18xlarge 
      | C5_24xlarge 
      | C5_metal 
      | C5a_large 
      | C5a_xlarge 
      | C5a_2xlarge 
      | C5a_4xlarge 
      | C5a_8xlarge 
      | C5a_12xlarge 
      | C5a_16xlarge 
      | C5a_24xlarge 
      | C5ad_large 
      | C5ad_xlarge 
      | C5ad_2xlarge 
      | C5ad_4xlarge 
      | C5ad_8xlarge 
      | C5ad_12xlarge 
      | C5ad_16xlarge 
      | C5ad_24xlarge 
      | C5d_large 
      | C5d_xlarge 
      | C5d_2xlarge 
      | C5d_4xlarge 
      | C5d_9xlarge 
      | C5d_12xlarge 
      | C5d_18xlarge 
      | C5d_24xlarge 
      | C5d_metal 
      | C5n_large 
      | C5n_xlarge 
      | C5n_2xlarge 
      | C5n_4xlarge 
      | C5n_9xlarge 
      | C5n_18xlarge 
      | C6g_metal 
      | C6g_medium 
      | C6g_large 
      | C6g_xlarge 
      | C6g_2xlarge 
      | C6g_4xlarge 
      | C6g_8xlarge 
      | C6g_12xlarge 
      | C6g_16xlarge 
      | C6gd_metal 
      | C6gd_medium 
      | C6gd_large 
      | C6gd_xlarge 
      | C6gd_2xlarge 
      | C6gd_4xlarge 
      | C6gd_8xlarge 
      | C6gd_12xlarge 
      | C6gd_16xlarge 
      | Cc1_4xlarge 
      | Cc2_8xlarge 
      | G2_2xlarge 
      | G2_8xlarge 
      | G3_4xlarge 
      | G3_8xlarge 
      | G3_16xlarge 
      | G3s_xlarge 
      | G4dn_xlarge 
      | G4dn_2xlarge 
      | G4dn_4xlarge 
      | G4dn_8xlarge 
      | G4dn_12xlarge 
      | G4dn_16xlarge 
      | G4dn_metal 
      | Cg1_4xlarge 
      | P2_xlarge 
      | P2_8xlarge 
      | P2_16xlarge 
      | P3_2xlarge 
      | P3_8xlarge 
      | P3_16xlarge 
      | P3dn_24xlarge 
      | P4d_24xlarge 
      | D2_xlarge 
      | D2_2xlarge 
      | D2_4xlarge 
      | D2_8xlarge 
      | F1_2xlarge 
      | F1_4xlarge 
      | F1_16xlarge 
      | M5_large 
      | M5_xlarge 
      | M5_2xlarge 
      | M5_4xlarge 
      | M5_8xlarge 
      | M5_12xlarge 
      | M5_16xlarge 
      | M5_24xlarge 
      | M5_metal 
      | M5a_large 
      | M5a_xlarge 
      | M5a_2xlarge 
      | M5a_4xlarge 
      | M5a_8xlarge 
      | M5a_12xlarge 
      | M5a_16xlarge 
      | M5a_24xlarge 
      | M5d_large 
      | M5d_xlarge 
      | M5d_2xlarge 
      | M5d_4xlarge 
      | M5d_8xlarge 
      | M5d_12xlarge 
      | M5d_16xlarge 
      | M5d_24xlarge 
      | M5d_metal 
      | M5ad_large 
      | M5ad_xlarge 
      | M5ad_2xlarge 
      | M5ad_4xlarge 
      | M5ad_8xlarge 
      | M5ad_12xlarge 
      | M5ad_16xlarge 
      | M5ad_24xlarge 
      | H1_2xlarge 
      | H1_4xlarge 
      | H1_8xlarge 
      | H1_16xlarge 
      | Z1d_large 
      | Z1d_xlarge 
      | Z1d_2xlarge 
      | Z1d_3xlarge 
      | Z1d_6xlarge 
      | Z1d_12xlarge 
      | Z1d_metal 
      | U_6tb1_metal 
      | U_9tb1_metal 
      | U_12tb1_metal 
      | U_18tb1_metal 
      | U_24tb1_metal 
      | A1_medium 
      | A1_large 
      | A1_xlarge 
      | A1_2xlarge 
      | A1_4xlarge 
      | A1_metal 
      | M5dn_large 
      | M5dn_xlarge 
      | M5dn_2xlarge 
      | M5dn_4xlarge 
      | M5dn_8xlarge 
      | M5dn_12xlarge 
      | M5dn_16xlarge 
      | M5dn_24xlarge 
      | M5n_large 
      | M5n_xlarge 
      | M5n_2xlarge 
      | M5n_4xlarge 
      | M5n_8xlarge 
      | M5n_12xlarge 
      | M5n_16xlarge 
      | M5n_24xlarge 
      | R5dn_large 
      | R5dn_xlarge 
      | R5dn_2xlarge 
      | R5dn_4xlarge 
      | R5dn_8xlarge 
      | R5dn_12xlarge 
      | R5dn_16xlarge 
      | R5dn_24xlarge 
      | R5n_large 
      | R5n_xlarge 
      | R5n_2xlarge 
      | R5n_4xlarge 
      | R5n_8xlarge 
      | R5n_12xlarge 
      | R5n_16xlarge 
      | R5n_24xlarge 
      | Inf1_xlarge 
      | Inf1_2xlarge 
      | Inf1_6xlarge 
      | Inf1_24xlarge 
      | M6g_metal 
      | M6g_medium 
      | M6g_large 
      | M6g_xlarge 
      | M6g_2xlarge 
      | M6g_4xlarge 
      | M6g_8xlarge 
      | M6g_12xlarge 
      | M6g_16xlarge 
      | M6gd_metal 
      | M6gd_medium 
      | M6gd_large 
      | M6gd_xlarge 
      | M6gd_2xlarge 
      | M6gd_4xlarge 
      | M6gd_8xlarge 
      | M6gd_12xlarge 
      | M6gd_16xlarge 
    let str_to_t =
      [("m6gd.16xlarge", M6gd_16xlarge);
      ("m6gd.12xlarge", M6gd_12xlarge);
      ("m6gd.8xlarge", M6gd_8xlarge);
      ("m6gd.4xlarge", M6gd_4xlarge);
      ("m6gd.2xlarge", M6gd_2xlarge);
      ("m6gd.xlarge", M6gd_xlarge);
      ("m6gd.large", M6gd_large);
      ("m6gd.medium", M6gd_medium);
      ("m6gd.metal", M6gd_metal);
      ("m6g.16xlarge", M6g_16xlarge);
      ("m6g.12xlarge", M6g_12xlarge);
      ("m6g.8xlarge", M6g_8xlarge);
      ("m6g.4xlarge", M6g_4xlarge);
      ("m6g.2xlarge", M6g_2xlarge);
      ("m6g.xlarge", M6g_xlarge);
      ("m6g.large", M6g_large);
      ("m6g.medium", M6g_medium);
      ("m6g.metal", M6g_metal);
      ("inf1.24xlarge", Inf1_24xlarge);
      ("inf1.6xlarge", Inf1_6xlarge);
      ("inf1.2xlarge", Inf1_2xlarge);
      ("inf1.xlarge", Inf1_xlarge);
      ("r5n.24xlarge", R5n_24xlarge);
      ("r5n.16xlarge", R5n_16xlarge);
      ("r5n.12xlarge", R5n_12xlarge);
      ("r5n.8xlarge", R5n_8xlarge);
      ("r5n.4xlarge", R5n_4xlarge);
      ("r5n.2xlarge", R5n_2xlarge);
      ("r5n.xlarge", R5n_xlarge);
      ("r5n.large", R5n_large);
      ("r5dn.24xlarge", R5dn_24xlarge);
      ("r5dn.16xlarge", R5dn_16xlarge);
      ("r5dn.12xlarge", R5dn_12xlarge);
      ("r5dn.8xlarge", R5dn_8xlarge);
      ("r5dn.4xlarge", R5dn_4xlarge);
      ("r5dn.2xlarge", R5dn_2xlarge);
      ("r5dn.xlarge", R5dn_xlarge);
      ("r5dn.large", R5dn_large);
      ("m5n.24xlarge", M5n_24xlarge);
      ("m5n.16xlarge", M5n_16xlarge);
      ("m5n.12xlarge", M5n_12xlarge);
      ("m5n.8xlarge", M5n_8xlarge);
      ("m5n.4xlarge", M5n_4xlarge);
      ("m5n.2xlarge", M5n_2xlarge);
      ("m5n.xlarge", M5n_xlarge);
      ("m5n.large", M5n_large);
      ("m5dn.24xlarge", M5dn_24xlarge);
      ("m5dn.16xlarge", M5dn_16xlarge);
      ("m5dn.12xlarge", M5dn_12xlarge);
      ("m5dn.8xlarge", M5dn_8xlarge);
      ("m5dn.4xlarge", M5dn_4xlarge);
      ("m5dn.2xlarge", M5dn_2xlarge);
      ("m5dn.xlarge", M5dn_xlarge);
      ("m5dn.large", M5dn_large);
      ("a1.metal", A1_metal);
      ("a1.4xlarge", A1_4xlarge);
      ("a1.2xlarge", A1_2xlarge);
      ("a1.xlarge", A1_xlarge);
      ("a1.large", A1_large);
      ("a1.medium", A1_medium);
      ("u-24tb1.metal", U_24tb1_metal);
      ("u-18tb1.metal", U_18tb1_metal);
      ("u-12tb1.metal", U_12tb1_metal);
      ("u-9tb1.metal", U_9tb1_metal);
      ("u-6tb1.metal", U_6tb1_metal);
      ("z1d.metal", Z1d_metal);
      ("z1d.12xlarge", Z1d_12xlarge);
      ("z1d.6xlarge", Z1d_6xlarge);
      ("z1d.3xlarge", Z1d_3xlarge);
      ("z1d.2xlarge", Z1d_2xlarge);
      ("z1d.xlarge", Z1d_xlarge);
      ("z1d.large", Z1d_large);
      ("h1.16xlarge", H1_16xlarge);
      ("h1.8xlarge", H1_8xlarge);
      ("h1.4xlarge", H1_4xlarge);
      ("h1.2xlarge", H1_2xlarge);
      ("m5ad.24xlarge", M5ad_24xlarge);
      ("m5ad.16xlarge", M5ad_16xlarge);
      ("m5ad.12xlarge", M5ad_12xlarge);
      ("m5ad.8xlarge", M5ad_8xlarge);
      ("m5ad.4xlarge", M5ad_4xlarge);
      ("m5ad.2xlarge", M5ad_2xlarge);
      ("m5ad.xlarge", M5ad_xlarge);
      ("m5ad.large", M5ad_large);
      ("m5d.metal", M5d_metal);
      ("m5d.24xlarge", M5d_24xlarge);
      ("m5d.16xlarge", M5d_16xlarge);
      ("m5d.12xlarge", M5d_12xlarge);
      ("m5d.8xlarge", M5d_8xlarge);
      ("m5d.4xlarge", M5d_4xlarge);
      ("m5d.2xlarge", M5d_2xlarge);
      ("m5d.xlarge", M5d_xlarge);
      ("m5d.large", M5d_large);
      ("m5a.24xlarge", M5a_24xlarge);
      ("m5a.16xlarge", M5a_16xlarge);
      ("m5a.12xlarge", M5a_12xlarge);
      ("m5a.8xlarge", M5a_8xlarge);
      ("m5a.4xlarge", M5a_4xlarge);
      ("m5a.2xlarge", M5a_2xlarge);
      ("m5a.xlarge", M5a_xlarge);
      ("m5a.large", M5a_large);
      ("m5.metal", M5_metal);
      ("m5.24xlarge", M5_24xlarge);
      ("m5.16xlarge", M5_16xlarge);
      ("m5.12xlarge", M5_12xlarge);
      ("m5.8xlarge", M5_8xlarge);
      ("m5.4xlarge", M5_4xlarge);
      ("m5.2xlarge", M5_2xlarge);
      ("m5.xlarge", M5_xlarge);
      ("m5.large", M5_large);
      ("f1.16xlarge", F1_16xlarge);
      ("f1.4xlarge", F1_4xlarge);
      ("f1.2xlarge", F1_2xlarge);
      ("d2.8xlarge", D2_8xlarge);
      ("d2.4xlarge", D2_4xlarge);
      ("d2.2xlarge", D2_2xlarge);
      ("d2.xlarge", D2_xlarge);
      ("p4d.24xlarge", P4d_24xlarge);
      ("p3dn.24xlarge", P3dn_24xlarge);
      ("p3.16xlarge", P3_16xlarge);
      ("p3.8xlarge", P3_8xlarge);
      ("p3.2xlarge", P3_2xlarge);
      ("p2.16xlarge", P2_16xlarge);
      ("p2.8xlarge", P2_8xlarge);
      ("p2.xlarge", P2_xlarge);
      ("cg1.4xlarge", Cg1_4xlarge);
      ("g4dn.metal", G4dn_metal);
      ("g4dn.16xlarge", G4dn_16xlarge);
      ("g4dn.12xlarge", G4dn_12xlarge);
      ("g4dn.8xlarge", G4dn_8xlarge);
      ("g4dn.4xlarge", G4dn_4xlarge);
      ("g4dn.2xlarge", G4dn_2xlarge);
      ("g4dn.xlarge", G4dn_xlarge);
      ("g3s.xlarge", G3s_xlarge);
      ("g3.16xlarge", G3_16xlarge);
      ("g3.8xlarge", G3_8xlarge);
      ("g3.4xlarge", G3_4xlarge);
      ("g2.8xlarge", G2_8xlarge);
      ("g2.2xlarge", G2_2xlarge);
      ("cc2.8xlarge", Cc2_8xlarge);
      ("cc1.4xlarge", Cc1_4xlarge);
      ("c6gd.16xlarge", C6gd_16xlarge);
      ("c6gd.12xlarge", C6gd_12xlarge);
      ("c6gd.8xlarge", C6gd_8xlarge);
      ("c6gd.4xlarge", C6gd_4xlarge);
      ("c6gd.2xlarge", C6gd_2xlarge);
      ("c6gd.xlarge", C6gd_xlarge);
      ("c6gd.large", C6gd_large);
      ("c6gd.medium", C6gd_medium);
      ("c6gd.metal", C6gd_metal);
      ("c6g.16xlarge", C6g_16xlarge);
      ("c6g.12xlarge", C6g_12xlarge);
      ("c6g.8xlarge", C6g_8xlarge);
      ("c6g.4xlarge", C6g_4xlarge);
      ("c6g.2xlarge", C6g_2xlarge);
      ("c6g.xlarge", C6g_xlarge);
      ("c6g.large", C6g_large);
      ("c6g.medium", C6g_medium);
      ("c6g.metal", C6g_metal);
      ("c5n.18xlarge", C5n_18xlarge);
      ("c5n.9xlarge", C5n_9xlarge);
      ("c5n.4xlarge", C5n_4xlarge);
      ("c5n.2xlarge", C5n_2xlarge);
      ("c5n.xlarge", C5n_xlarge);
      ("c5n.large", C5n_large);
      ("c5d.metal", C5d_metal);
      ("c5d.24xlarge", C5d_24xlarge);
      ("c5d.18xlarge", C5d_18xlarge);
      ("c5d.12xlarge", C5d_12xlarge);
      ("c5d.9xlarge", C5d_9xlarge);
      ("c5d.4xlarge", C5d_4xlarge);
      ("c5d.2xlarge", C5d_2xlarge);
      ("c5d.xlarge", C5d_xlarge);
      ("c5d.large", C5d_large);
      ("c5ad.24xlarge", C5ad_24xlarge);
      ("c5ad.16xlarge", C5ad_16xlarge);
      ("c5ad.12xlarge", C5ad_12xlarge);
      ("c5ad.8xlarge", C5ad_8xlarge);
      ("c5ad.4xlarge", C5ad_4xlarge);
      ("c5ad.2xlarge", C5ad_2xlarge);
      ("c5ad.xlarge", C5ad_xlarge);
      ("c5ad.large", C5ad_large);
      ("c5a.24xlarge", C5a_24xlarge);
      ("c5a.16xlarge", C5a_16xlarge);
      ("c5a.12xlarge", C5a_12xlarge);
      ("c5a.8xlarge", C5a_8xlarge);
      ("c5a.4xlarge", C5a_4xlarge);
      ("c5a.2xlarge", C5a_2xlarge);
      ("c5a.xlarge", C5a_xlarge);
      ("c5a.large", C5a_large);
      ("c5.metal", C5_metal);
      ("c5.24xlarge", C5_24xlarge);
      ("c5.18xlarge", C5_18xlarge);
      ("c5.12xlarge", C5_12xlarge);
      ("c5.9xlarge", C5_9xlarge);
      ("c5.4xlarge", C5_4xlarge);
      ("c5.2xlarge", C5_2xlarge);
      ("c5.xlarge", C5_xlarge);
      ("c5.large", C5_large);
      ("c4.8xlarge", C4_8xlarge);
      ("c4.4xlarge", C4_4xlarge);
      ("c4.2xlarge", C4_2xlarge);
      ("c4.xlarge", C4_xlarge);
      ("c4.large", C4_large);
      ("c3.8xlarge", C3_8xlarge);
      ("c3.4xlarge", C3_4xlarge);
      ("c3.2xlarge", C3_2xlarge);
      ("c3.xlarge", C3_xlarge);
      ("c3.large", C3_large);
      ("c1.xlarge", C1_xlarge);
      ("c1.medium", C1_medium);
      ("hs1.8xlarge", Hs1_8xlarge);
      ("hi1.4xlarge", Hi1_4xlarge);
      ("i3en.metal", I3en_metal);
      ("i3en.24xlarge", I3en_24xlarge);
      ("i3en.12xlarge", I3en_12xlarge);
      ("i3en.6xlarge", I3en_6xlarge);
      ("i3en.3xlarge", I3en_3xlarge);
      ("i3en.2xlarge", I3en_2xlarge);
      ("i3en.xlarge", I3en_xlarge);
      ("i3en.large", I3en_large);
      ("i3.metal", I3_metal);
      ("i3.16xlarge", I3_16xlarge);
      ("i3.8xlarge", I3_8xlarge);
      ("i3.4xlarge", I3_4xlarge);
      ("i3.2xlarge", I3_2xlarge);
      ("i3.xlarge", I3_xlarge);
      ("i3.large", I3_large);
      ("i2.8xlarge", I2_8xlarge);
      ("i2.4xlarge", I2_4xlarge);
      ("i2.2xlarge", I2_2xlarge);
      ("i2.xlarge", I2_xlarge);
      ("x1e.32xlarge", X1e_32xlarge);
      ("x1e.16xlarge", X1e_16xlarge);
      ("x1e.8xlarge", X1e_8xlarge);
      ("x1e.4xlarge", X1e_4xlarge);
      ("x1e.2xlarge", X1e_2xlarge);
      ("x1e.xlarge", X1e_xlarge);
      ("x1.32xlarge", X1_32xlarge);
      ("x1.16xlarge", X1_16xlarge);
      ("r6gd.16xlarge", R6gd_16xlarge);
      ("r6gd.12xlarge", R6gd_12xlarge);
      ("r6gd.8xlarge", R6gd_8xlarge);
      ("r6gd.4xlarge", R6gd_4xlarge);
      ("r6gd.2xlarge", R6gd_2xlarge);
      ("r6gd.xlarge", R6gd_xlarge);
      ("r6gd.large", R6gd_large);
      ("r6gd.medium", R6gd_medium);
      ("r6gd.metal", R6gd_metal);
      ("r6g.16xlarge", R6g_16xlarge);
      ("r6g.12xlarge", R6g_12xlarge);
      ("r6g.8xlarge", R6g_8xlarge);
      ("r6g.4xlarge", R6g_4xlarge);
      ("r6g.2xlarge", R6g_2xlarge);
      ("r6g.xlarge", R6g_xlarge);
      ("r6g.large", R6g_large);
      ("r6g.medium", R6g_medium);
      ("r6g.metal", R6g_metal);
      ("r5ad.24xlarge", R5ad_24xlarge);
      ("r5ad.16xlarge", R5ad_16xlarge);
      ("r5ad.12xlarge", R5ad_12xlarge);
      ("r5ad.8xlarge", R5ad_8xlarge);
      ("r5ad.4xlarge", R5ad_4xlarge);
      ("r5ad.2xlarge", R5ad_2xlarge);
      ("r5ad.xlarge", R5ad_xlarge);
      ("r5ad.large", R5ad_large);
      ("r5d.metal", R5d_metal);
      ("r5d.24xlarge", R5d_24xlarge);
      ("r5d.16xlarge", R5d_16xlarge);
      ("r5d.12xlarge", R5d_12xlarge);
      ("r5d.8xlarge", R5d_8xlarge);
      ("r5d.4xlarge", R5d_4xlarge);
      ("r5d.2xlarge", R5d_2xlarge);
      ("r5d.xlarge", R5d_xlarge);
      ("r5d.large", R5d_large);
      ("r5a.24xlarge", R5a_24xlarge);
      ("r5a.16xlarge", R5a_16xlarge);
      ("r5a.12xlarge", R5a_12xlarge);
      ("r5a.8xlarge", R5a_8xlarge);
      ("r5a.4xlarge", R5a_4xlarge);
      ("r5a.2xlarge", R5a_2xlarge);
      ("r5a.xlarge", R5a_xlarge);
      ("r5a.large", R5a_large);
      ("r5.metal", R5_metal);
      ("r5.24xlarge", R5_24xlarge);
      ("r5.16xlarge", R5_16xlarge);
      ("r5.12xlarge", R5_12xlarge);
      ("r5.8xlarge", R5_8xlarge);
      ("r5.4xlarge", R5_4xlarge);
      ("r5.2xlarge", R5_2xlarge);
      ("r5.xlarge", R5_xlarge);
      ("r5.large", R5_large);
      ("r4.16xlarge", R4_16xlarge);
      ("r4.8xlarge", R4_8xlarge);
      ("r4.4xlarge", R4_4xlarge);
      ("r4.2xlarge", R4_2xlarge);
      ("r4.xlarge", R4_xlarge);
      ("r4.large", R4_large);
      ("r3.8xlarge", R3_8xlarge);
      ("r3.4xlarge", R3_4xlarge);
      ("r3.2xlarge", R3_2xlarge);
      ("r3.xlarge", R3_xlarge);
      ("r3.large", R3_large);
      ("cr1.8xlarge", Cr1_8xlarge);
      ("m2.4xlarge", M2_4xlarge);
      ("m2.2xlarge", M2_2xlarge);
      ("m2.xlarge", M2_xlarge);
      ("m4.16xlarge", M4_16xlarge);
      ("m4.10xlarge", M4_10xlarge);
      ("m4.4xlarge", M4_4xlarge);
      ("m4.2xlarge", M4_2xlarge);
      ("m4.xlarge", M4_xlarge);
      ("m4.large", M4_large);
      ("m3.2xlarge", M3_2xlarge);
      ("m3.xlarge", M3_xlarge);
      ("m3.large", M3_large);
      ("m3.medium", M3_medium);
      ("m1.xlarge", M1_xlarge);
      ("m1.large", M1_large);
      ("m1.medium", M1_medium);
      ("m1.small", M1_small);
      ("t4g.2xlarge", T4g_2xlarge);
      ("t4g.xlarge", T4g_xlarge);
      ("t4g.large", T4g_large);
      ("t4g.medium", T4g_medium);
      ("t4g.small", T4g_small);
      ("t4g.micro", T4g_micro);
      ("t4g.nano", T4g_nano);
      ("t3a.2xlarge", T3a_2xlarge);
      ("t3a.xlarge", T3a_xlarge);
      ("t3a.large", T3a_large);
      ("t3a.medium", T3a_medium);
      ("t3a.small", T3a_small);
      ("t3a.micro", T3a_micro);
      ("t3a.nano", T3a_nano);
      ("t3.2xlarge", T3_2xlarge);
      ("t3.xlarge", T3_xlarge);
      ("t3.large", T3_large);
      ("t3.medium", T3_medium);
      ("t3.small", T3_small);
      ("t3.micro", T3_micro);
      ("t3.nano", T3_nano);
      ("t2.2xlarge", T2_2xlarge);
      ("t2.xlarge", T2_xlarge);
      ("t2.large", T2_large);
      ("t2.medium", T2_medium);
      ("t2.small", T2_small);
      ("t2.micro", T2_micro);
      ("t2.nano", T2_nano);
      ("t1.micro", T1_micro)]
    let t_to_str =
      [(M6gd_16xlarge, "m6gd.16xlarge");
      (M6gd_12xlarge, "m6gd.12xlarge");
      (M6gd_8xlarge, "m6gd.8xlarge");
      (M6gd_4xlarge, "m6gd.4xlarge");
      (M6gd_2xlarge, "m6gd.2xlarge");
      (M6gd_xlarge, "m6gd.xlarge");
      (M6gd_large, "m6gd.large");
      (M6gd_medium, "m6gd.medium");
      (M6gd_metal, "m6gd.metal");
      (M6g_16xlarge, "m6g.16xlarge");
      (M6g_12xlarge, "m6g.12xlarge");
      (M6g_8xlarge, "m6g.8xlarge");
      (M6g_4xlarge, "m6g.4xlarge");
      (M6g_2xlarge, "m6g.2xlarge");
      (M6g_xlarge, "m6g.xlarge");
      (M6g_large, "m6g.large");
      (M6g_medium, "m6g.medium");
      (M6g_metal, "m6g.metal");
      (Inf1_24xlarge, "inf1.24xlarge");
      (Inf1_6xlarge, "inf1.6xlarge");
      (Inf1_2xlarge, "inf1.2xlarge");
      (Inf1_xlarge, "inf1.xlarge");
      (R5n_24xlarge, "r5n.24xlarge");
      (R5n_16xlarge, "r5n.16xlarge");
      (R5n_12xlarge, "r5n.12xlarge");
      (R5n_8xlarge, "r5n.8xlarge");
      (R5n_4xlarge, "r5n.4xlarge");
      (R5n_2xlarge, "r5n.2xlarge");
      (R5n_xlarge, "r5n.xlarge");
      (R5n_large, "r5n.large");
      (R5dn_24xlarge, "r5dn.24xlarge");
      (R5dn_16xlarge, "r5dn.16xlarge");
      (R5dn_12xlarge, "r5dn.12xlarge");
      (R5dn_8xlarge, "r5dn.8xlarge");
      (R5dn_4xlarge, "r5dn.4xlarge");
      (R5dn_2xlarge, "r5dn.2xlarge");
      (R5dn_xlarge, "r5dn.xlarge");
      (R5dn_large, "r5dn.large");
      (M5n_24xlarge, "m5n.24xlarge");
      (M5n_16xlarge, "m5n.16xlarge");
      (M5n_12xlarge, "m5n.12xlarge");
      (M5n_8xlarge, "m5n.8xlarge");
      (M5n_4xlarge, "m5n.4xlarge");
      (M5n_2xlarge, "m5n.2xlarge");
      (M5n_xlarge, "m5n.xlarge");
      (M5n_large, "m5n.large");
      (M5dn_24xlarge, "m5dn.24xlarge");
      (M5dn_16xlarge, "m5dn.16xlarge");
      (M5dn_12xlarge, "m5dn.12xlarge");
      (M5dn_8xlarge, "m5dn.8xlarge");
      (M5dn_4xlarge, "m5dn.4xlarge");
      (M5dn_2xlarge, "m5dn.2xlarge");
      (M5dn_xlarge, "m5dn.xlarge");
      (M5dn_large, "m5dn.large");
      (A1_metal, "a1.metal");
      (A1_4xlarge, "a1.4xlarge");
      (A1_2xlarge, "a1.2xlarge");
      (A1_xlarge, "a1.xlarge");
      (A1_large, "a1.large");
      (A1_medium, "a1.medium");
      (U_24tb1_metal, "u-24tb1.metal");
      (U_18tb1_metal, "u-18tb1.metal");
      (U_12tb1_metal, "u-12tb1.metal");
      (U_9tb1_metal, "u-9tb1.metal");
      (U_6tb1_metal, "u-6tb1.metal");
      (Z1d_metal, "z1d.metal");
      (Z1d_12xlarge, "z1d.12xlarge");
      (Z1d_6xlarge, "z1d.6xlarge");
      (Z1d_3xlarge, "z1d.3xlarge");
      (Z1d_2xlarge, "z1d.2xlarge");
      (Z1d_xlarge, "z1d.xlarge");
      (Z1d_large, "z1d.large");
      (H1_16xlarge, "h1.16xlarge");
      (H1_8xlarge, "h1.8xlarge");
      (H1_4xlarge, "h1.4xlarge");
      (H1_2xlarge, "h1.2xlarge");
      (M5ad_24xlarge, "m5ad.24xlarge");
      (M5ad_16xlarge, "m5ad.16xlarge");
      (M5ad_12xlarge, "m5ad.12xlarge");
      (M5ad_8xlarge, "m5ad.8xlarge");
      (M5ad_4xlarge, "m5ad.4xlarge");
      (M5ad_2xlarge, "m5ad.2xlarge");
      (M5ad_xlarge, "m5ad.xlarge");
      (M5ad_large, "m5ad.large");
      (M5d_metal, "m5d.metal");
      (M5d_24xlarge, "m5d.24xlarge");
      (M5d_16xlarge, "m5d.16xlarge");
      (M5d_12xlarge, "m5d.12xlarge");
      (M5d_8xlarge, "m5d.8xlarge");
      (M5d_4xlarge, "m5d.4xlarge");
      (M5d_2xlarge, "m5d.2xlarge");
      (M5d_xlarge, "m5d.xlarge");
      (M5d_large, "m5d.large");
      (M5a_24xlarge, "m5a.24xlarge");
      (M5a_16xlarge, "m5a.16xlarge");
      (M5a_12xlarge, "m5a.12xlarge");
      (M5a_8xlarge, "m5a.8xlarge");
      (M5a_4xlarge, "m5a.4xlarge");
      (M5a_2xlarge, "m5a.2xlarge");
      (M5a_xlarge, "m5a.xlarge");
      (M5a_large, "m5a.large");
      (M5_metal, "m5.metal");
      (M5_24xlarge, "m5.24xlarge");
      (M5_16xlarge, "m5.16xlarge");
      (M5_12xlarge, "m5.12xlarge");
      (M5_8xlarge, "m5.8xlarge");
      (M5_4xlarge, "m5.4xlarge");
      (M5_2xlarge, "m5.2xlarge");
      (M5_xlarge, "m5.xlarge");
      (M5_large, "m5.large");
      (F1_16xlarge, "f1.16xlarge");
      (F1_4xlarge, "f1.4xlarge");
      (F1_2xlarge, "f1.2xlarge");
      (D2_8xlarge, "d2.8xlarge");
      (D2_4xlarge, "d2.4xlarge");
      (D2_2xlarge, "d2.2xlarge");
      (D2_xlarge, "d2.xlarge");
      (P4d_24xlarge, "p4d.24xlarge");
      (P3dn_24xlarge, "p3dn.24xlarge");
      (P3_16xlarge, "p3.16xlarge");
      (P3_8xlarge, "p3.8xlarge");
      (P3_2xlarge, "p3.2xlarge");
      (P2_16xlarge, "p2.16xlarge");
      (P2_8xlarge, "p2.8xlarge");
      (P2_xlarge, "p2.xlarge");
      (Cg1_4xlarge, "cg1.4xlarge");
      (G4dn_metal, "g4dn.metal");
      (G4dn_16xlarge, "g4dn.16xlarge");
      (G4dn_12xlarge, "g4dn.12xlarge");
      (G4dn_8xlarge, "g4dn.8xlarge");
      (G4dn_4xlarge, "g4dn.4xlarge");
      (G4dn_2xlarge, "g4dn.2xlarge");
      (G4dn_xlarge, "g4dn.xlarge");
      (G3s_xlarge, "g3s.xlarge");
      (G3_16xlarge, "g3.16xlarge");
      (G3_8xlarge, "g3.8xlarge");
      (G3_4xlarge, "g3.4xlarge");
      (G2_8xlarge, "g2.8xlarge");
      (G2_2xlarge, "g2.2xlarge");
      (Cc2_8xlarge, "cc2.8xlarge");
      (Cc1_4xlarge, "cc1.4xlarge");
      (C6gd_16xlarge, "c6gd.16xlarge");
      (C6gd_12xlarge, "c6gd.12xlarge");
      (C6gd_8xlarge, "c6gd.8xlarge");
      (C6gd_4xlarge, "c6gd.4xlarge");
      (C6gd_2xlarge, "c6gd.2xlarge");
      (C6gd_xlarge, "c6gd.xlarge");
      (C6gd_large, "c6gd.large");
      (C6gd_medium, "c6gd.medium");
      (C6gd_metal, "c6gd.metal");
      (C6g_16xlarge, "c6g.16xlarge");
      (C6g_12xlarge, "c6g.12xlarge");
      (C6g_8xlarge, "c6g.8xlarge");
      (C6g_4xlarge, "c6g.4xlarge");
      (C6g_2xlarge, "c6g.2xlarge");
      (C6g_xlarge, "c6g.xlarge");
      (C6g_large, "c6g.large");
      (C6g_medium, "c6g.medium");
      (C6g_metal, "c6g.metal");
      (C5n_18xlarge, "c5n.18xlarge");
      (C5n_9xlarge, "c5n.9xlarge");
      (C5n_4xlarge, "c5n.4xlarge");
      (C5n_2xlarge, "c5n.2xlarge");
      (C5n_xlarge, "c5n.xlarge");
      (C5n_large, "c5n.large");
      (C5d_metal, "c5d.metal");
      (C5d_24xlarge, "c5d.24xlarge");
      (C5d_18xlarge, "c5d.18xlarge");
      (C5d_12xlarge, "c5d.12xlarge");
      (C5d_9xlarge, "c5d.9xlarge");
      (C5d_4xlarge, "c5d.4xlarge");
      (C5d_2xlarge, "c5d.2xlarge");
      (C5d_xlarge, "c5d.xlarge");
      (C5d_large, "c5d.large");
      (C5ad_24xlarge, "c5ad.24xlarge");
      (C5ad_16xlarge, "c5ad.16xlarge");
      (C5ad_12xlarge, "c5ad.12xlarge");
      (C5ad_8xlarge, "c5ad.8xlarge");
      (C5ad_4xlarge, "c5ad.4xlarge");
      (C5ad_2xlarge, "c5ad.2xlarge");
      (C5ad_xlarge, "c5ad.xlarge");
      (C5ad_large, "c5ad.large");
      (C5a_24xlarge, "c5a.24xlarge");
      (C5a_16xlarge, "c5a.16xlarge");
      (C5a_12xlarge, "c5a.12xlarge");
      (C5a_8xlarge, "c5a.8xlarge");
      (C5a_4xlarge, "c5a.4xlarge");
      (C5a_2xlarge, "c5a.2xlarge");
      (C5a_xlarge, "c5a.xlarge");
      (C5a_large, "c5a.large");
      (C5_metal, "c5.metal");
      (C5_24xlarge, "c5.24xlarge");
      (C5_18xlarge, "c5.18xlarge");
      (C5_12xlarge, "c5.12xlarge");
      (C5_9xlarge, "c5.9xlarge");
      (C5_4xlarge, "c5.4xlarge");
      (C5_2xlarge, "c5.2xlarge");
      (C5_xlarge, "c5.xlarge");
      (C5_large, "c5.large");
      (C4_8xlarge, "c4.8xlarge");
      (C4_4xlarge, "c4.4xlarge");
      (C4_2xlarge, "c4.2xlarge");
      (C4_xlarge, "c4.xlarge");
      (C4_large, "c4.large");
      (C3_8xlarge, "c3.8xlarge");
      (C3_4xlarge, "c3.4xlarge");
      (C3_2xlarge, "c3.2xlarge");
      (C3_xlarge, "c3.xlarge");
      (C3_large, "c3.large");
      (C1_xlarge, "c1.xlarge");
      (C1_medium, "c1.medium");
      (Hs1_8xlarge, "hs1.8xlarge");
      (Hi1_4xlarge, "hi1.4xlarge");
      (I3en_metal, "i3en.metal");
      (I3en_24xlarge, "i3en.24xlarge");
      (I3en_12xlarge, "i3en.12xlarge");
      (I3en_6xlarge, "i3en.6xlarge");
      (I3en_3xlarge, "i3en.3xlarge");
      (I3en_2xlarge, "i3en.2xlarge");
      (I3en_xlarge, "i3en.xlarge");
      (I3en_large, "i3en.large");
      (I3_metal, "i3.metal");
      (I3_16xlarge, "i3.16xlarge");
      (I3_8xlarge, "i3.8xlarge");
      (I3_4xlarge, "i3.4xlarge");
      (I3_2xlarge, "i3.2xlarge");
      (I3_xlarge, "i3.xlarge");
      (I3_large, "i3.large");
      (I2_8xlarge, "i2.8xlarge");
      (I2_4xlarge, "i2.4xlarge");
      (I2_2xlarge, "i2.2xlarge");
      (I2_xlarge, "i2.xlarge");
      (X1e_32xlarge, "x1e.32xlarge");
      (X1e_16xlarge, "x1e.16xlarge");
      (X1e_8xlarge, "x1e.8xlarge");
      (X1e_4xlarge, "x1e.4xlarge");
      (X1e_2xlarge, "x1e.2xlarge");
      (X1e_xlarge, "x1e.xlarge");
      (X1_32xlarge, "x1.32xlarge");
      (X1_16xlarge, "x1.16xlarge");
      (R6gd_16xlarge, "r6gd.16xlarge");
      (R6gd_12xlarge, "r6gd.12xlarge");
      (R6gd_8xlarge, "r6gd.8xlarge");
      (R6gd_4xlarge, "r6gd.4xlarge");
      (R6gd_2xlarge, "r6gd.2xlarge");
      (R6gd_xlarge, "r6gd.xlarge");
      (R6gd_large, "r6gd.large");
      (R6gd_medium, "r6gd.medium");
      (R6gd_metal, "r6gd.metal");
      (R6g_16xlarge, "r6g.16xlarge");
      (R6g_12xlarge, "r6g.12xlarge");
      (R6g_8xlarge, "r6g.8xlarge");
      (R6g_4xlarge, "r6g.4xlarge");
      (R6g_2xlarge, "r6g.2xlarge");
      (R6g_xlarge, "r6g.xlarge");
      (R6g_large, "r6g.large");
      (R6g_medium, "r6g.medium");
      (R6g_metal, "r6g.metal");
      (R5ad_24xlarge, "r5ad.24xlarge");
      (R5ad_16xlarge, "r5ad.16xlarge");
      (R5ad_12xlarge, "r5ad.12xlarge");
      (R5ad_8xlarge, "r5ad.8xlarge");
      (R5ad_4xlarge, "r5ad.4xlarge");
      (R5ad_2xlarge, "r5ad.2xlarge");
      (R5ad_xlarge, "r5ad.xlarge");
      (R5ad_large, "r5ad.large");
      (R5d_metal, "r5d.metal");
      (R5d_24xlarge, "r5d.24xlarge");
      (R5d_16xlarge, "r5d.16xlarge");
      (R5d_12xlarge, "r5d.12xlarge");
      (R5d_8xlarge, "r5d.8xlarge");
      (R5d_4xlarge, "r5d.4xlarge");
      (R5d_2xlarge, "r5d.2xlarge");
      (R5d_xlarge, "r5d.xlarge");
      (R5d_large, "r5d.large");
      (R5a_24xlarge, "r5a.24xlarge");
      (R5a_16xlarge, "r5a.16xlarge");
      (R5a_12xlarge, "r5a.12xlarge");
      (R5a_8xlarge, "r5a.8xlarge");
      (R5a_4xlarge, "r5a.4xlarge");
      (R5a_2xlarge, "r5a.2xlarge");
      (R5a_xlarge, "r5a.xlarge");
      (R5a_large, "r5a.large");
      (R5_metal, "r5.metal");
      (R5_24xlarge, "r5.24xlarge");
      (R5_16xlarge, "r5.16xlarge");
      (R5_12xlarge, "r5.12xlarge");
      (R5_8xlarge, "r5.8xlarge");
      (R5_4xlarge, "r5.4xlarge");
      (R5_2xlarge, "r5.2xlarge");
      (R5_xlarge, "r5.xlarge");
      (R5_large, "r5.large");
      (R4_16xlarge, "r4.16xlarge");
      (R4_8xlarge, "r4.8xlarge");
      (R4_4xlarge, "r4.4xlarge");
      (R4_2xlarge, "r4.2xlarge");
      (R4_xlarge, "r4.xlarge");
      (R4_large, "r4.large");
      (R3_8xlarge, "r3.8xlarge");
      (R3_4xlarge, "r3.4xlarge");
      (R3_2xlarge, "r3.2xlarge");
      (R3_xlarge, "r3.xlarge");
      (R3_large, "r3.large");
      (Cr1_8xlarge, "cr1.8xlarge");
      (M2_4xlarge, "m2.4xlarge");
      (M2_2xlarge, "m2.2xlarge");
      (M2_xlarge, "m2.xlarge");
      (M4_16xlarge, "m4.16xlarge");
      (M4_10xlarge, "m4.10xlarge");
      (M4_4xlarge, "m4.4xlarge");
      (M4_2xlarge, "m4.2xlarge");
      (M4_xlarge, "m4.xlarge");
      (M4_large, "m4.large");
      (M3_2xlarge, "m3.2xlarge");
      (M3_xlarge, "m3.xlarge");
      (M3_large, "m3.large");
      (M3_medium, "m3.medium");
      (M1_xlarge, "m1.xlarge");
      (M1_large, "m1.large");
      (M1_medium, "m1.medium");
      (M1_small, "m1.small");
      (T4g_2xlarge, "t4g.2xlarge");
      (T4g_xlarge, "t4g.xlarge");
      (T4g_large, "t4g.large");
      (T4g_medium, "t4g.medium");
      (T4g_small, "t4g.small");
      (T4g_micro, "t4g.micro");
      (T4g_nano, "t4g.nano");
      (T3a_2xlarge, "t3a.2xlarge");
      (T3a_xlarge, "t3a.xlarge");
      (T3a_large, "t3a.large");
      (T3a_medium, "t3a.medium");
      (T3a_small, "t3a.small");
      (T3a_micro, "t3a.micro");
      (T3a_nano, "t3a.nano");
      (T3_2xlarge, "t3.2xlarge");
      (T3_xlarge, "t3.xlarge");
      (T3_large, "t3.large");
      (T3_medium, "t3.medium");
      (T3_small, "t3.small");
      (T3_micro, "t3.micro");
      (T3_nano, "t3.nano");
      (T2_2xlarge, "t2.2xlarge");
      (T2_xlarge, "t2.xlarge");
      (T2_large, "t2.large");
      (T2_medium, "t2.medium");
      (T2_small, "t2.small");
      (T2_micro, "t2.micro");
      (T2_nano, "t2.nano");
      (T1_micro, "t1.micro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttachmentStatus =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
    let str_to_t =
      [("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module GroupIdentifier =
  struct
    type t = {
      group_name: String.t option ;
      group_id: String.t option }
    let make ?group_name  ?group_id  () = { group_name; group_id }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_id
              (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json)
      }
  end
module InstancePrivateIpAddress =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option ;
      primary: Boolean.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option }
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module IKEVersionsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1DHGroupNumbersListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase1EncryptionAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1IntegrityAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2DHGroupNumbersListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase2EncryptionAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2IntegrityAlgorithmsListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module DiskImageFormat =
  struct
    type t =
      | VMDK 
      | RAW 
      | VHD 
    let str_to_t = [("VHD", VHD); ("RAW", RAW); ("VMDK", VMDK)]
    let t_to_str = [(VHD, "VHD"); (RAW, "RAW"); (VMDK, "VMDK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementResponse =
  struct
    type t = {
      group_name: String.t option }
    let make ?group_name  () = { group_name }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module BlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t ;
      virtual_name: String.t option ;
      ebs: EbsBlockDevice.t option ;
      no_device: String.t option }
    let make ~device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Xml.required "deviceName"
               (Util.option_bind (Xml.member "deviceName" xml) String.parse));
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml) EbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (EbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Some (Query.Pair ("DeviceName", (String.to_query v.device_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (EbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Some ("device_name", (String.to_json v.device_name))])
    let of_json j =
      {
        device_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "device_name")));
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs = (Util.option_map (Json.lookup j "ebs") EbsBlockDevice.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: SecurityGroupIdStringList.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option ;
      associate_carrier_ip_address: Boolean.t option ;
      interface_type: String.t option ;
      network_card_index: Integer.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count 
      ?subnet_id  ?associate_carrier_ip_address  ?interface_type 
      ?network_card_index  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id;
        associate_carrier_ip_address;
        interface_type;
        network_card_index
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          associate_carrier_ip_address =
            (Util.option_bind (Xml.member "AssociateCarrierIpAddress" xml)
               Boolean.parse);
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse);
          network_card_index =
            (Util.option_bind (Xml.member "NetworkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f ->
                Query.Pair
                  ("AssociateCarrierIpAddress", (Boolean.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f -> ("associate_carrier_ip_address", (Boolean.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        associate_carrier_ip_address =
          (Util.option_map (Json.lookup j "associate_carrier_ip_address")
             Boolean.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module SpotFleetTagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Tenancy =
  struct
    type t =
      | Default 
      | Dedicated 
      | Host 
    let str_to_t =
      [("host", Host); ("dedicated", Dedicated); ("default", Default)]
    let t_to_str =
      [(Host, "host"); (Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      spot_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option }
    let make ?instance_type  ?spot_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  () =
      {
        instance_type;
        spot_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.priority
              (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json)
      }
  end
module ClassicLoadBalancer =
  struct
    type t = {
      name: String.t option }
    let make ?name  () = { name }
    let parse xml =
      Some { name = (Util.option_bind (Xml.member "name" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      { name = (Util.option_map (Json.lookup j "name") String.of_json) }
  end
module TargetGroup =
  struct
    type t = {
      arn: String.t option }
    let make ?arn  () = { arn }
    let parse xml =
      Some { arn = (Util.option_bind (Xml.member "arn" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.arn
              (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      { arn = (Util.option_map (Json.lookup j "arn") String.of_json) }
  end
module EbsInstanceBlockDevice =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      delete_on_termination: Boolean.t option ;
      status: AttachmentStatus.t option ;
      volume_id: String.t option }
    let make ?attach_time  ?delete_on_termination  ?status  ?volume_id  () =
      { attach_time; delete_on_termination; status; volume_id }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module GroupIdentifierList =
  struct
    type t = GroupIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map GroupIdentifier.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list GroupIdentifier.to_query v
    let to_json v = `List (List.map GroupIdentifier.to_json v)
    let of_json j = Json.to_list GroupIdentifier.of_json j
  end
module InstanceNetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option ;
      device_index: Integer.t option ;
      status: AttachmentStatus.t option ;
      network_card_index: Integer.t option }
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?status  ?network_card_index  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        status;
        network_card_index
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse);
          network_card_index =
            (Util.option_bind (Xml.member "networkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module InstancePrivateIpAddressList =
  struct
    type t = InstancePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstancePrivateIpAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstancePrivateIpAddress.to_query v
    let to_json v = `List (List.map InstancePrivateIpAddress.to_json v)
    let of_json j = Json.to_list InstancePrivateIpAddress.of_json j
  end
module NetworkInterfaceStatus =
  struct
    type t =
      | Available 
      | Associated 
      | Attaching 
      | In_use 
      | Detaching 
    let str_to_t =
      [("detaching", Detaching);
      ("in-use", In_use);
      ("attaching", Attaching);
      ("associated", Associated);
      ("available", Available)]
    let t_to_str =
      [(Detaching, "detaching");
      (In_use, "in-use");
      (Attaching, "attaching");
      (Associated, "associated");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeValues =
  struct
    type t =
      | Devpay 
      | Marketplace 
    let str_to_t = [("marketplace", Marketplace); ("devpay", Devpay)]
    let t_to_str = [(Marketplace, "marketplace"); (Devpay, "devpay")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttributeValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Scope =
  struct
    type t =
      | Availability_Zone 
      | Region 
    let str_to_t =
      [("Region", Region); ("Availability Zone", Availability_Zone)]
    let t_to_str =
      [(Region, "Region"); (Availability_Zone, "Availability Zone")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StatusName =
  struct
    type t =
      | Reachability 
    let str_to_t = [("reachability", Reachability)]
    let t_to_str = [(Reachability, "reachability")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module StatusType =
  struct
    type t =
      | Passed 
      | Failed 
      | Insufficient_data 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("insufficient-data", Insufficient_data);
      ("failed", Failed);
      ("passed", Passed)]
    let t_to_str =
      [(Initializing, "initializing");
      (Insufficient_data, "insufficient-data");
      (Failed, "failed");
      (Passed, "passed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UserIdGroupPair =
  struct
    type t =
      {
      description: String.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      peering_status: String.t option ;
      user_id: String.t option ;
      vpc_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?description  ?group_id  ?group_name  ?peering_status  ?user_id 
      ?vpc_id  ?vpc_peering_connection_id  () =
      {
        description;
        group_id;
        group_name;
        peering_status;
        user_id;
        vpc_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          peering_status =
            (Util.option_bind (Xml.member "peeringStatus" xml) String.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.peering_status
             (fun f -> Query.Pair ("PeeringStatus", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.peering_status
             (fun f -> ("peering_status", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        peering_status =
          (Util.option_map (Json.lookup j "peering_status") String.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module FpgaDeviceMemoryInfo =
  struct
    type t = {
      size_in_mi_b: Integer.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Integer.of_json)
      }
  end
module GpuDeviceMemoryInfo =
  struct
    type t = {
      size_in_mi_b: Integer.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Integer.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Integer.of_json)
      }
  end
module DiskType =
  struct
    type t =
      | Hdd 
      | Ssd 
    let str_to_t = [("ssd", Ssd); ("hdd", Hdd)]
    let t_to_str = [(Ssd, "ssd"); (Hdd, "hdd")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IKEVersionsList =
  struct
    type t = IKEVersionsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IKEVersionsListValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IKEVersionsListValue.to_query v
    let to_json v = `List (List.map IKEVersionsListValue.to_json v)
    let of_json j = Json.to_list IKEVersionsListValue.of_json j
  end
module Phase1DHGroupNumbersList =
  struct
    type t = Phase1DHGroupNumbersListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersListValue.to_query v
    let to_json v = `List (List.map Phase1DHGroupNumbersListValue.to_json v)
    let of_json j = Json.to_list Phase1DHGroupNumbersListValue.of_json j
  end
module Phase1EncryptionAlgorithmsList =
  struct
    type t = Phase1EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsListValue.to_query v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsListValue.to_json v)
    let of_json j =
      Json.to_list Phase1EncryptionAlgorithmsListValue.of_json j
  end
module Phase1IntegrityAlgorithmsList =
  struct
    type t = Phase1IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsListValue.to_query v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsListValue.to_json v)
    let of_json j = Json.to_list Phase1IntegrityAlgorithmsListValue.of_json j
  end
module Phase2DHGroupNumbersList =
  struct
    type t = Phase2DHGroupNumbersListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersListValue.to_query v
    let to_json v = `List (List.map Phase2DHGroupNumbersListValue.to_json v)
    let of_json j = Json.to_list Phase2DHGroupNumbersListValue.of_json j
  end
module Phase2EncryptionAlgorithmsList =
  struct
    type t = Phase2EncryptionAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsListValue.to_query v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsListValue.to_json v)
    let of_json j =
      Json.to_list Phase2EncryptionAlgorithmsListValue.of_json j
  end
module Phase2IntegrityAlgorithmsList =
  struct
    type t = Phase2IntegrityAlgorithmsListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsListValue.to_query v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsListValue.to_json v)
    let of_json j = Json.to_list Phase2IntegrityAlgorithmsListValue.of_json j
  end
module DiskImageDescription =
  struct
    type t =
      {
      checksum: String.t option ;
      format: DiskImageFormat.t option ;
      import_manifest_url: String.t option ;
      size: Long.t option }
    let make ?checksum  ?format  ?import_manifest_url  ?size  () =
      { checksum; format; import_manifest_url; size }
    let parse xml =
      Some
        {
          checksum =
            (Util.option_bind (Xml.member "checksum" xml) String.parse);
          format =
            (Util.option_bind (Xml.member "format" xml) DiskImageFormat.parse);
          import_manifest_url =
            (Util.option_bind (Xml.member "importManifestUrl" xml)
               String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.import_manifest_url
             (fun f -> Query.Pair ("ImportManifestUrl", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (DiskImageFormat.to_query f)));
           Util.option_map v.checksum
             (fun f -> Query.Pair ("Checksum", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.import_manifest_url
             (fun f -> ("import_manifest_url", (String.to_json f)));
           Util.option_map v.format
             (fun f -> ("format", (DiskImageFormat.to_json f)));
           Util.option_map v.checksum
             (fun f -> ("checksum", (String.to_json f)))])
    let of_json j =
      {
        checksum =
          (Util.option_map (Json.lookup j "checksum") String.of_json);
        format =
          (Util.option_map (Json.lookup j "format") DiskImageFormat.of_json);
        import_manifest_url =
          (Util.option_map (Json.lookup j "import_manifest_url")
             String.of_json);
        size = (Util.option_map (Json.lookup j "size") Long.of_json)
      }
  end
module DiskImageVolumeDescription =
  struct
    type t = {
      id: String.t option ;
      size: Long.t option }
    let make ?id  ?size  () = { id; size }
    let parse xml =
      Some
        {
          id = (Util.option_bind (Xml.member "id" xml) String.parse);
          size = (Util.option_bind (Xml.member "size" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size
              (fun f -> Query.Pair ("Size", (Long.to_query f)));
           Util.option_map v.id
             (fun f -> Query.Pair ("Id", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size (fun f -> ("size", (Long.to_json f)));
           Util.option_map v.id (fun f -> ("id", (String.to_json f)))])
    let of_json j =
      {
        id = (Util.option_map (Json.lookup j "id") String.of_json);
        size = (Util.option_map (Json.lookup j "size") Long.of_json)
      }
  end
module RouteTableAssociationStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateEbsBlockDevice =
  struct
    type t =
      {
      encrypted: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option }
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "volumeType" xml) VolumeType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let of_json j =
      {
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json)
      }
  end
module InstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceType =
  struct
    type t =
      | One_time 
      | Persistent 
    let str_to_t = [("persistent", Persistent); ("one-time", One_time)]
    let t_to_str = [(Persistent, "persistent"); (One_time, "one-time")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module GroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "groupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module IpRange =
  struct
    type t = {
      cidr_ip: String.t ;
      description: String.t option }
    let make ~cidr_ip  ?description  () = { cidr_ip; description }
    let parse xml =
      Some
        {
          cidr_ip =
            (Xml.required "cidrIp"
               (Util.option_bind (Xml.member "cidrIp" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("CidrIp", (String.to_query v.cidr_ip)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("cidr_ip", (String.to_json v.cidr_ip))])
    let of_json j =
      {
        cidr_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_ip")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module Ipv6Range =
  struct
    type t = {
      cidr_ipv6: String.t option ;
      description: String.t option }
    let make ?cidr_ipv6  ?description  () = { cidr_ipv6; description }
    let parse xml =
      Some
        {
          cidr_ipv6 =
            (Util.option_bind (Xml.member "cidrIpv6" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr_ipv6
             (fun f -> Query.Pair ("CidrIpv6", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr_ipv6
             (fun f -> ("cidr_ipv6", (String.to_json f)))])
    let of_json j =
      {
        cidr_ipv6 =
          (Util.option_map (Json.lookup j "cidr_ipv6") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module PrefixListId =
  struct
    type t = {
      description: String.t option ;
      prefix_list_id: String.t option }
    let make ?description  ?prefix_list_id  () =
      { description; prefix_list_id }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_id
              (fun f -> ("prefix_list_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json)
      }
  end
module FleetLaunchTemplateOverrides =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      max_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option ;
      placement: PlacementResponse.t option }
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               PlacementResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f ->
                 Query.Pair ("Placement", (PlacementResponse.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (PlacementResponse.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             PlacementResponse.of_json)
      }
  end
module FleetLaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module FleetReplacementStrategy =
  struct
    type t =
      | Launch 
    let str_to_t = [("launch", Launch)]
    let t_to_str = [(Launch, "launch")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BlockDeviceMappingList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module IamInstanceProfileSpecification =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module InstanceNetworkInterfaceSpecificationList =
  struct
    type t = InstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceNetworkInterfaceSpecification.to_query v
    let to_json v =
      `List (List.map InstanceNetworkInterfaceSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceNetworkInterfaceSpecification.of_json j
  end
module SpotFleetMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module SpotFleetTagSpecificationList =
  struct
    type t = SpotFleetTagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetTagSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotFleetTagSpecification.to_query v
    let to_json v = `List (List.map SpotFleetTagSpecification.to_json v)
    let of_json j = Json.to_list SpotFleetTagSpecification.of_json j
  end
module SpotPlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option ;
      tenancy: Tenancy.t option }
    let make ?availability_zone  ?group_name  ?tenancy  () =
      { availability_zone; group_name; tenancy }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.tenancy
              (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json)
      }
  end
module LaunchTemplateOverridesList =
  struct
    type t = LaunchTemplateOverrides.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateOverrides.to_query v
    let to_json v = `List (List.map LaunchTemplateOverrides.to_json v)
    let of_json j = Json.to_list LaunchTemplateOverrides.of_json j
  end
module ClassicLoadBalancers =
  struct
    type t = ClassicLoadBalancer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLoadBalancer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLoadBalancer.to_query v
    let to_json v = `List (List.map ClassicLoadBalancer.to_json v)
    let of_json j = Json.to_list ClassicLoadBalancer.of_json j
  end
module TargetGroups =
  struct
    type t = TargetGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TargetGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetGroup.to_query v
    let to_json v = `List (List.map TargetGroup.to_json v)
    let of_json j = Json.to_list TargetGroup.of_json j
  end
module ReplacementStrategy =
  struct
    type t =
      | Launch 
    let str_to_t = [("launch", Launch)]
    let t_to_str = [(Launch, "launch")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeStatusName =
  struct
    type t =
      | Io_enabled 
      | Io_performance 
    let str_to_t =
      [("io-performance", Io_performance); ("io-enabled", Io_enabled)]
    let t_to_str =
      [(Io_performance, "io-performance"); (Io_enabled, "io-enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationPreference =
  struct
    type t =
      | Open 
      | None 
    let str_to_t = [("none", None); ("open", Open)]
    let t_to_str = [(None, "none"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationTargetResponse =
  struct
    type t =
      {
      capacity_reservation_id: String.t option ;
      capacity_reservation_resource_group_arn: String.t option }
    let make ?capacity_reservation_id 
      ?capacity_reservation_resource_group_arn  () =
      { capacity_reservation_id; capacity_reservation_resource_group_arn }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          capacity_reservation_resource_group_arn =
            (Util.option_bind
               (Xml.member "capacityReservationResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_resource_group_arn
              (fun f ->
                 Query.Pair
                   ("CapacityReservationResourceGroupArn",
                     (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_resource_group_arn
              (fun f ->
                 ("capacity_reservation_resource_group_arn",
                   (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        capacity_reservation_resource_group_arn =
          (Util.option_map
             (Json.lookup j "capacity_reservation_resource_group_arn")
             String.of_json)
      }
  end
module ElasticGpuAssociation =
  struct
    type t =
      {
      elastic_gpu_id: String.t option ;
      elastic_gpu_association_id: String.t option ;
      elastic_gpu_association_state: String.t option ;
      elastic_gpu_association_time: String.t option }
    let make ?elastic_gpu_id  ?elastic_gpu_association_id 
      ?elastic_gpu_association_state  ?elastic_gpu_association_time  () =
      {
        elastic_gpu_id;
        elastic_gpu_association_id;
        elastic_gpu_association_state;
        elastic_gpu_association_time
      }
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          elastic_gpu_association_id =
            (Util.option_bind (Xml.member "elasticGpuAssociationId" xml)
               String.parse);
          elastic_gpu_association_state =
            (Util.option_bind (Xml.member "elasticGpuAssociationState" xml)
               String.parse);
          elastic_gpu_association_time =
            (Util.option_bind (Xml.member "elasticGpuAssociationTime" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticGpuAssociationTime", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f ->
                Query.Pair
                  ("ElasticGpuAssociationState", (String.to_query f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f ->
                Query.Pair ("ElasticGpuAssociationId", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_gpu_association_time
              (fun f -> ("elastic_gpu_association_time", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_state
             (fun f -> ("elastic_gpu_association_state", (String.to_json f)));
           Util.option_map v.elastic_gpu_association_id
             (fun f -> ("elastic_gpu_association_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let of_json j =
      {
        elastic_gpu_id =
          (Util.option_map (Json.lookup j "elastic_gpu_id") String.of_json);
        elastic_gpu_association_id =
          (Util.option_map (Json.lookup j "elastic_gpu_association_id")
             String.of_json);
        elastic_gpu_association_state =
          (Util.option_map (Json.lookup j "elastic_gpu_association_state")
             String.of_json);
        elastic_gpu_association_time =
          (Util.option_map (Json.lookup j "elastic_gpu_association_time")
             String.of_json)
      }
  end
module ElasticInferenceAcceleratorAssociation =
  struct
    type t =
      {
      elastic_inference_accelerator_arn: String.t option ;
      elastic_inference_accelerator_association_id: String.t option ;
      elastic_inference_accelerator_association_state: String.t option ;
      elastic_inference_accelerator_association_time: DateTime.t option }
    let make ?elastic_inference_accelerator_arn 
      ?elastic_inference_accelerator_association_id 
      ?elastic_inference_accelerator_association_state 
      ?elastic_inference_accelerator_association_time  () =
      {
        elastic_inference_accelerator_arn;
        elastic_inference_accelerator_association_id;
        elastic_inference_accelerator_association_state;
        elastic_inference_accelerator_association_time
      }
    let parse xml =
      Some
        {
          elastic_inference_accelerator_arn =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorArn" xml) String.parse);
          elastic_inference_accelerator_association_id =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationId" xml)
               String.parse);
          elastic_inference_accelerator_association_state =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationState" xml)
               String.parse);
          elastic_inference_accelerator_association_time =
            (Util.option_bind
               (Xml.member "elasticInferenceAcceleratorAssociationTime" xml)
               DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 Query.Pair
                   ("ElasticInferenceAcceleratorAssociationTime",
                     (DateTime.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationState",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorAssociationId",
                    (String.to_query f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                Query.Pair
                  ("ElasticInferenceAcceleratorArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.elastic_inference_accelerator_association_time
              (fun f ->
                 ("elastic_inference_accelerator_association_time",
                   (DateTime.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_state
             (fun f ->
                ("elastic_inference_accelerator_association_state",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_association_id
             (fun f ->
                ("elastic_inference_accelerator_association_id",
                  (String.to_json f)));
           Util.option_map v.elastic_inference_accelerator_arn
             (fun f ->
                ("elastic_inference_accelerator_arn", (String.to_json f)))])
    let of_json j =
      {
        elastic_inference_accelerator_arn =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_arn")
             String.of_json);
        elastic_inference_accelerator_association_id =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_id")
             String.of_json);
        elastic_inference_accelerator_association_state =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_state")
             String.of_json);
        elastic_inference_accelerator_association_time =
          (Util.option_map
             (Json.lookup j "elastic_inference_accelerator_association_time")
             DateTime.of_json)
      }
  end
module InstanceBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDevice.t option }
    let make ?device_name  ?ebs  () = { device_name; ebs }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDevice.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f ->
                 Query.Pair ("Ebs", (EbsInstanceBlockDevice.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs
              (fun f -> ("ebs", (EbsInstanceBlockDevice.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDevice.of_json)
      }
  end
module HttpTokensState =
  struct
    type t =
      | Optional 
      | Required 
    let str_to_t = [("required", Required); ("optional", Optional)]
    let t_to_str = [(Required, "required"); (Optional, "optional")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataEndpointState =
  struct
    type t =
      | Disabled 
      | Enabled 
    let str_to_t = [("enabled", Enabled); ("disabled", Disabled)]
    let t_to_str = [(Enabled, "enabled"); (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataOptionsState =
  struct
    type t =
      | Pending 
      | Applied 
    let str_to_t = [("applied", Applied); ("pending", Pending)]
    let t_to_str = [(Applied, "applied"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceNetworkInterface =
  struct
    type t =
      {
      association: InstanceNetworkInterfaceAssociation.t option ;
      attachment: InstanceNetworkInterfaceAttachment.t option ;
      description: String.t option ;
      groups: GroupIdentifierList.t ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      mac_address: String.t option ;
      network_interface_id: String.t option ;
      owner_id: String.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: InstancePrivateIpAddressList.t ;
      source_dest_check: Boolean.t option ;
      status: NetworkInterfaceStatus.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      interface_type: String.t option }
    let make ?association  ?attachment  ?description  ?(groups= []) 
      ?(ipv6_addresses= [])  ?mac_address  ?network_interface_id  ?owner_id 
      ?private_dns_name  ?private_ip_address  ?(private_ip_addresses= []) 
      ?source_dest_check  ?status  ?subnet_id  ?vpc_id  ?interface_type  () =
      {
        association;
        attachment;
        description;
        groups;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        source_dest_check;
        status;
        subnet_id;
        vpc_id;
        interface_type
      }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               InstanceNetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               InstanceNetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  InstancePrivateIpAddressList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (InstancePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (InstanceNetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (InstanceNetworkInterfaceAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_type
              (fun f -> ("interface_type", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("private_ip_addresses",
               (InstancePrivateIpAddressList.to_json v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment",
                  (InstanceNetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (InstanceNetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             InstanceNetworkInterfaceAssociation.of_json);
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             InstanceNetworkInterfaceAttachment.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (InstancePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json)
      }
  end
module InstanceStateName =
  struct
    type t =
      | Pending 
      | Running 
      | Shutting_down 
      | Terminated 
      | Stopping 
      | Stopped 
    let str_to_t =
      [("stopped", Stopped);
      ("stopping", Stopping);
      ("terminated", Terminated);
      ("shutting-down", Shutting_down);
      ("running", Running);
      ("pending", Pending)]
    let t_to_str =
      [(Stopped, "stopped");
      (Stopping, "stopping");
      (Terminated, "terminated");
      (Shutting_down, "shutting-down");
      (Running, "running");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LicenseConfiguration =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module MonitoringState =
  struct
    type t =
      | Disabled 
      | Disabling 
      | Enabled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("enabled", Enabled);
      ("disabling", Disabling);
      ("disabled", Disabled)]
    let t_to_str =
      [(Pending, "pending");
      (Enabled, "enabled");
      (Disabling, "disabling");
      (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCode =
  struct
    type t =
      {
      product_code_id: String.t option ;
      product_code_type: ProductCodeValues.t option }
    let make ?product_code_id  ?product_code_type  () =
      { product_code_id; product_code_type }
    let parse xml =
      Some
        {
          product_code_id =
            (Util.option_bind (Xml.member "productCode" xml) String.parse);
          product_code_type =
            (Util.option_bind (Xml.member "type" xml) ProductCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> Query.Pair ("Type", (ProductCodeValues.to_query f)));
           Util.option_map v.product_code_id
             (fun f -> Query.Pair ("ProductCode", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.product_code_type
              (fun f -> ("product_code_type", (ProductCodeValues.to_json f)));
           Util.option_map v.product_code_id
             (fun f -> ("product_code_id", (String.to_json f)))])
    let of_json j =
      {
        product_code_id =
          (Util.option_map (Json.lookup j "product_code_id") String.of_json);
        product_code_type =
          (Util.option_map (Json.lookup j "product_code_type")
             ProductCodeValues.of_json)
      }
  end
module VpcCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetCidrBlockStateCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
      | Failing 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("failing", Failing);
      ("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Failed, "failed");
      (Failing, "failing");
      (Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DhcpConfigurationValueList =
  struct
    type t = AttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AttributeValue.to_query v
    let to_json v = `List (List.map AttributeValue.to_json v)
    let of_json j = Json.to_list AttributeValue.of_json j
  end
module ReservedInstancesConfiguration =
  struct
    type t =
      {
      availability_zone: String.t option ;
      instance_count: Integer.t option ;
      instance_type: InstanceType.t option ;
      platform: String.t option ;
      scope: Scope.t option }
    let make ?availability_zone  ?instance_count  ?instance_type  ?platform 
      ?scope  () =
      { availability_zone; instance_count; instance_type; platform; scope }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json)
      }
  end
module TrafficDirection =
  struct
    type t =
      | Ingress 
      | Egress 
    let str_to_t = [("egress", Egress); ("ingress", Ingress)]
    let t_to_str = [(Egress, "egress"); (Ingress, "ingress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorPortRange =
  struct
    type t = {
      from_port: Integer.t option ;
      to_port: Integer.t option }
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json)
      }
  end
module TrafficMirrorRuleAction =
  struct
    type t =
      | Accept 
      | Reject 
    let str_to_t = [("reject", Reject); ("accept", Accept)]
    let t_to_str = [(Reject, "reject"); (Accept, "accept")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ListingState =
  struct
    type t =
      | Available 
      | Sold 
      | Cancelled 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("cancelled", Cancelled);
      ("sold", Sold);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Cancelled, "cancelled");
      (Sold, "sold");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CurrencyCodeValues =
  struct
    type t =
      | USD 
    let str_to_t = [("USD", USD)]
    let t_to_str = [(USD, "USD")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventCode =
  struct
    type t =
      | Instance_reboot 
      | System_reboot 
      | System_maintenance 
      | Instance_retirement 
      | Instance_stop 
    let str_to_t =
      [("instance-stop", Instance_stop);
      ("instance-retirement", Instance_retirement);
      ("system-maintenance", System_maintenance);
      ("system-reboot", System_reboot);
      ("instance-reboot", Instance_reboot)]
    let t_to_str =
      [(Instance_stop, "instance-stop");
      (Instance_retirement, "instance-retirement");
      (System_maintenance, "system-maintenance");
      (System_reboot, "system-reboot");
      (Instance_reboot, "instance-reboot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusDetails =
  struct
    type t =
      {
      impaired_since: DateTime.t option ;
      name: StatusName.t option ;
      status: StatusType.t option }
    let make ?impaired_since  ?name  ?status  () =
      { impaired_since; name; status }
    let parse xml =
      Some
        {
          impaired_since =
            (Util.option_bind (Xml.member "impairedSince" xml) DateTime.parse);
          name = (Util.option_bind (Xml.member "name" xml) StatusName.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) StatusType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (StatusType.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (StatusName.to_query f)));
           Util.option_map v.impaired_since
             (fun f -> Query.Pair ("ImpairedSince", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (StatusType.to_json f)));
           Util.option_map v.name (fun f -> ("name", (StatusName.to_json f)));
           Util.option_map v.impaired_since
             (fun f -> ("impaired_since", (DateTime.to_json f)))])
    let of_json j =
      {
        impaired_since =
          (Util.option_map (Json.lookup j "impaired_since") DateTime.of_json);
        name = (Util.option_map (Json.lookup j "name") StatusName.of_json);
        status =
          (Util.option_map (Json.lookup j "status") StatusType.of_json)
      }
  end
module InstanceCapacity =
  struct
    type t =
      {
      available_capacity: Integer.t option ;
      instance_type: String.t option ;
      total_capacity: Integer.t option }
    let make ?available_capacity  ?instance_type  ?total_capacity  () =
      { available_capacity; instance_type; total_capacity }
    let parse xml =
      Some
        {
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_capacity =
            (Util.option_bind (Xml.member "totalCapacity" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> Query.Pair ("TotalCapacity", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f -> Query.Pair ("AvailableCapacity", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_capacity
              (fun f -> ("total_capacity", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (Integer.to_json f)))])
    let of_json j =
      {
        available_capacity =
          (Util.option_map (Json.lookup j "available_capacity")
             Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        total_capacity =
          (Util.option_map (Json.lookup j "total_capacity") Integer.of_json)
      }
  end
module DisableFastSnapshotRestoreStateError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module IpRanges =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PrefixListIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserIdGroupPairSet =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let of_json j = Json.to_list UserIdGroupPair.of_json j
  end
module VolumeAttachmentState =
  struct
    type t =
      | Attaching 
      | Attached 
      | Detaching 
      | Detached 
      | Busy 
    let str_to_t =
      [("busy", Busy);
      ("detached", Detached);
      ("detaching", Detaching);
      ("attached", Attached);
      ("attaching", Attaching)]
    let t_to_str =
      [(Busy, "busy");
      (Detached, "detached");
      (Detaching, "detaching");
      (Attached, "attached");
      (Attaching, "attaching")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IKEVersionsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1DHGroupNumbersRequestListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase1EncryptionAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase1IntegrityAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2DHGroupNumbersRequestListValue =
  struct
    type t = {
      value: Integer.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) Integer.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Integer.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Integer.of_json) }
  end
module Phase2EncryptionAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module Phase2IntegrityAlgorithmsRequestListValue =
  struct
    type t = {
      value: String.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "Value" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") String.of_json) }
  end
module FpgaDeviceInfo =
  struct
    type t =
      {
      name: String.t option ;
      manufacturer: String.t option ;
      count: Integer.t option ;
      memory_info: FpgaDeviceMemoryInfo.t option }
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               FpgaDeviceMemoryInfo.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (FpgaDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (FpgaDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info")
             FpgaDeviceMemoryInfo.of_json)
      }
  end
module GpuDeviceInfo =
  struct
    type t =
      {
      name: String.t option ;
      manufacturer: String.t option ;
      count: Integer.t option ;
      memory_info: GpuDeviceMemoryInfo.t option }
    let make ?name  ?manufacturer  ?count  ?memory_info  () =
      { name; manufacturer; count; memory_info }
    let parse xml =
      Some
        {
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml)
               GpuDeviceMemoryInfo.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f ->
                 Query.Pair ("MemoryInfo", (GpuDeviceMemoryInfo.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.manufacturer
             (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.memory_info
              (fun f -> ("memory_info", (GpuDeviceMemoryInfo.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.manufacturer
             (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)))])
    let of_json j =
      {
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info")
             GpuDeviceMemoryInfo.of_json)
      }
  end
module InferenceDeviceInfo =
  struct
    type t =
      {
      count: Integer.t option ;
      name: String.t option ;
      manufacturer: String.t option }
    let make ?count  ?name  ?manufacturer  () = { count; name; manufacturer }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          manufacturer =
            (Util.option_bind (Xml.member "manufacturer" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> Query.Pair ("Manufacturer", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.manufacturer
              (fun f -> ("manufacturer", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        manufacturer =
          (Util.option_map (Json.lookup j "manufacturer") String.of_json)
      }
  end
module DiskInfo =
  struct
    type t =
      {
      size_in_g_b: Long.t option ;
      count: Integer.t option ;
      type_: DiskType.t option }
    let make ?size_in_g_b  ?count  ?type_  () = { size_in_g_b; count; type_ }
    let parse xml =
      Some
        {
          size_in_g_b =
            (Util.option_bind (Xml.member "sizeInGB" xml) Long.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) DiskType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (DiskType.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.size_in_g_b
             (fun f -> Query.Pair ("SizeInGB", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> ("type_", (DiskType.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.size_in_g_b
             (fun f -> ("size_in_g_b", (Long.to_json f)))])
    let of_json j =
      {
        size_in_g_b =
          (Util.option_map (Json.lookup j "size_in_g_b") Long.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") DiskType.of_json)
      }
  end
module NetworkCardInfo =
  struct
    type t =
      {
      network_card_index: Integer.t option ;
      network_performance: String.t option ;
      maximum_network_interfaces: Integer.t option }
    let make ?network_card_index  ?network_performance 
      ?maximum_network_interfaces  () =
      { network_card_index; network_performance; maximum_network_interfaces }
    let parse xml =
      Some
        {
          network_card_index =
            (Util.option_bind (Xml.member "networkCardIndex" xml)
               Integer.parse);
          network_performance =
            (Util.option_bind (Xml.member "networkPerformance" xml)
               String.parse);
          maximum_network_interfaces =
            (Util.option_bind (Xml.member "maximumNetworkInterfaces" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.maximum_network_interfaces
              (fun f ->
                 Query.Pair
                   ("MaximumNetworkInterfaces", (Integer.to_query f)));
           Util.option_map v.network_performance
             (fun f -> Query.Pair ("NetworkPerformance", (String.to_query f)));
           Util.option_map v.network_card_index
             (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.maximum_network_interfaces
              (fun f -> ("maximum_network_interfaces", (Integer.to_json f)));
           Util.option_map v.network_performance
             (fun f -> ("network_performance", (String.to_json f)));
           Util.option_map v.network_card_index
             (fun f -> ("network_card_index", (Integer.to_json f)))])
    let of_json j =
      {
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json);
        network_performance =
          (Util.option_map (Json.lookup j "network_performance")
             String.of_json);
        maximum_network_interfaces =
          (Util.option_map (Json.lookup j "maximum_network_interfaces")
             Integer.of_json)
      }
  end
module PlacementGroupStrategy =
  struct
    type t =
      | Cluster 
      | Partition 
      | Spread 
    let str_to_t =
      [("spread", Spread); ("partition", Partition); ("cluster", Cluster)]
    let t_to_str =
      [(Spread, "spread"); (Partition, "partition"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ArchitectureType =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TelemetryStatus =
  struct
    type t =
      | UP 
      | DOWN 
    let str_to_t = [("DOWN", DOWN); ("UP", UP)]
    let t_to_str = [(DOWN, "DOWN"); (UP, "UP")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TunnelOption =
  struct
    type t =
      {
      outside_ip_address: String.t option ;
      tunnel_inside_cidr: String.t option ;
      tunnel_inside_ipv6_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      dpd_timeout_seconds: Integer.t option ;
      dpd_timeout_action: String.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersList.t ;
      ike_versions: IKEVersionsList.t ;
      startup_action: String.t option }
    let make ?outside_ip_address  ?tunnel_inside_cidr 
      ?tunnel_inside_ipv6_cidr  ?pre_shared_key  ?phase1_lifetime_seconds 
      ?phase2_lifetime_seconds  ?rekey_margin_time_seconds 
      ?rekey_fuzz_percentage  ?replay_window_size  ?dpd_timeout_seconds 
      ?dpd_timeout_action  ?(phase1_encryption_algorithms= []) 
      ?(phase2_encryption_algorithms= [])  ?(phase1_integrity_algorithms= [])
       ?(phase2_integrity_algorithms= [])  ?(phase1_d_h_group_numbers= []) 
      ?(phase2_d_h_group_numbers= [])  ?(ike_versions= [])  ?startup_action 
      () =
      {
        outside_ip_address;
        tunnel_inside_cidr;
        tunnel_inside_ipv6_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        dpd_timeout_seconds;
        dpd_timeout_action;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        ike_versions;
        startup_action
      }
    let parse xml =
      Some
        {
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "tunnelInsideCidr" xml)
               String.parse);
          tunnel_inside_ipv6_cidr =
            (Util.option_bind (Xml.member "tunnelInsideIpv6Cidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "preSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "rekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "rekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "replayWindowSize" xml)
               Integer.parse);
          dpd_timeout_seconds =
            (Util.option_bind (Xml.member "dpdTimeoutSeconds" xml)
               Integer.parse);
          dpd_timeout_action =
            (Util.option_bind (Xml.member "dpdTimeoutAction" xml)
               String.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1EncryptionAlgorithmSet" xml)
                  Phase1EncryptionAlgorithmsList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2EncryptionAlgorithmSet" xml)
                  Phase2EncryptionAlgorithmsList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase1IntegrityAlgorithmSet" xml)
                  Phase1IntegrityAlgorithmsList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "phase2IntegrityAlgorithmSet" xml)
                  Phase2IntegrityAlgorithmsList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase1DHGroupNumberSet" xml)
                  Phase1DHGroupNumbersList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "phase2DHGroupNumberSet" xml)
                  Phase2DHGroupNumbersList.parse));
          ike_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ikeVersionSet" xml)
                  IKEVersionsList.parse));
          startup_action =
            (Util.option_bind (Xml.member "startupAction" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> Query.Pair ("StartupAction", (String.to_query f)));
           Some
             (Query.Pair
                ("IkeVersionSet", (IKEVersionsList.to_query v.ike_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumberSet",
                  (Phase2DHGroupNumbersList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumberSet",
                  (Phase1DHGroupNumbersList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithmSet",
                  (Phase2IntegrityAlgorithmsList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithmSet",
                  (Phase1IntegrityAlgorithmsList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithmSet",
                  (Phase2EncryptionAlgorithmsList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithmSet",
                  (Phase1EncryptionAlgorithmsList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.dpd_timeout_action
             (fun f -> Query.Pair ("DpdTimeoutAction", (String.to_query f)));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> Query.Pair ("DpdTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f ->
                Query.Pair ("TunnelInsideIpv6Cidr", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> ("startup_action", (String.to_json f)));
           Some ("ike_versions", (IKEVersionsList.to_json v.ike_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersList.to_json v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersList.to_json v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.dpd_timeout_action
             (fun f -> ("dpd_timeout_action", (String.to_json f)));
           Util.option_map v.dpd_timeout_seconds
             (fun f -> ("dpd_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f -> ("tunnel_inside_ipv6_cidr", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)))])
    let of_json j =
      {
        outside_ip_address =
          (Util.option_map (Json.lookup j "outside_ip_address")
             String.of_json);
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        tunnel_inside_ipv6_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_ipv6_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        dpd_timeout_seconds =
          (Util.option_map (Json.lookup j "dpd_timeout_seconds")
             Integer.of_json);
        dpd_timeout_action =
          (Util.option_map (Json.lookup j "dpd_timeout_action")
             String.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        ike_versions =
          (IKEVersionsList.of_json
             (Util.of_option_exn (Json.lookup j "ike_versions")));
        startup_action =
          (Util.option_map (Json.lookup j "startup_action") String.of_json)
      }
  end
module VpnState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnStaticRouteSource =
  struct
    type t =
      | Static 
    let str_to_t = [("Static", Static)]
    let t_to_str = [(Static, "Static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CidrBlock =
  struct
    type t = {
      cidr_block: String.t option }
    let make ?cidr_block  () = { cidr_block }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block
              (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json)
      }
  end
module Ipv6CidrBlock =
  struct
    type t = {
      ipv6_cidr_block: String.t option }
    let make ?ipv6_cidr_block  () = { ipv6_cidr_block }
    let parse xml =
      Some
        {
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> ("ipv6_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json)
      }
  end
module IcmpTypeCode =
  struct
    type t = {
      code: Integer.t option ;
      type_: Integer.t option }
    let make ?code  ?type_  () = { code; type_ }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) Integer.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (Integer.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (Integer.to_json f)));
           Util.option_map v.code (fun f -> ("code", (Integer.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") Integer.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") Integer.of_json)
      }
  end
module PortRange =
  struct
    type t = {
      from: Integer.t option ;
      to_: Integer.t option }
    let make ?from  ?to_  () = { from; to_ }
    let parse xml =
      Some
        {
          from = (Util.option_bind (Xml.member "from" xml) Integer.parse);
          to_ = (Util.option_bind (Xml.member "to" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_
              (fun f -> Query.Pair ("To", (Integer.to_query f)));
           Util.option_map v.from
             (fun f -> Query.Pair ("From", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_ (fun f -> ("to_", (Integer.to_json f)));
           Util.option_map v.from (fun f -> ("from", (Integer.to_json f)))])
    let of_json j =
      {
        from = (Util.option_map (Json.lookup j "from") Integer.of_json);
        to_ = (Util.option_map (Json.lookup j "to_") Integer.of_json)
      }
  end
module RuleAction =
  struct
    type t =
      | Allow 
      | Deny 
    let str_to_t = [("deny", Deny); ("allow", Allow)]
    let t_to_str = [(Deny, "deny"); (Allow, "allow")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceAssociation =
  struct
    type t =
      {
      allocation_id: String.t option ;
      association_id: String.t option ;
      ip_owner_id: String.t option ;
      public_dns_name: String.t option ;
      public_ip: String.t option ;
      customer_owned_ip: String.t option ;
      carrier_ip: String.t option }
    let make ?allocation_id  ?association_id  ?ip_owner_id  ?public_dns_name 
      ?public_ip  ?customer_owned_ip  ?carrier_ip  () =
      {
        allocation_id;
        association_id;
        ip_owner_id;
        public_dns_name;
        public_ip;
        customer_owned_ip;
        carrier_ip
      }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ip_owner_id =
            (Util.option_bind (Xml.member "ipOwnerId" xml) String.parse);
          public_dns_name =
            (Util.option_bind (Xml.member "publicDnsName" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          carrier_ip =
            (Util.option_bind (Xml.member "carrierIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> Query.Pair ("CarrierIp", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("PublicDnsName", (String.to_query f)));
           Util.option_map v.ip_owner_id
             (fun f -> Query.Pair ("IpOwnerId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> ("carrier_ip", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Util.option_map v.ip_owner_id
             (fun f -> ("ip_owner_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ip_owner_id =
          (Util.option_map (Json.lookup j "ip_owner_id") String.of_json);
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        customer_owned_ip =
          (Util.option_map (Json.lookup j "customer_owned_ip") String.of_json);
        carrier_ip =
          (Util.option_map (Json.lookup j "carrier_ip") String.of_json)
      }
  end
module RecurringChargeFrequency =
  struct
    type t =
      | Hourly 
    let str_to_t = [("Hourly", Hourly)]
    let t_to_str = [(Hourly, "Hourly")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceType =
  struct
    type t =
      | Interface 
      | Gateway 
      | GatewayLoadBalancer 
    let str_to_t =
      [("GatewayLoadBalancer", GatewayLoadBalancer);
      ("Gateway", Gateway);
      ("Interface", Interface)]
    let t_to_str =
      [(GatewayLoadBalancer, "GatewayLoadBalancer");
      (Gateway, "Gateway");
      (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceVolumeDetailItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      bytes_converted: Long.t option ;
      description: String.t option ;
      image: DiskImageDescription.t option ;
      status: String.t option ;
      status_message: String.t option ;
      volume: DiskImageVolumeDescription.t option }
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?status  ?status_message  ?volume  () =
      {
        availability_zone;
        bytes_converted;
        description;
        image;
        status;
        status_message;
        volume
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        bytes_converted =
          (Util.option_map (Json.lookup j "bytes_converted") Long.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image")
             DiskImageDescription.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume")
             DiskImageVolumeDescription.of_json)
      }
  end
module TransitGatewayAttachmentResourceType =
  struct
    type t =
      | Vpc 
      | Vpn 
      | Direct_connect_gateway 
      | Peering 
      | Tgw_peering 
    let str_to_t =
      [("tgw-peering", Tgw_peering);
      ("peering", Peering);
      ("direct-connect-gateway", Direct_connect_gateway);
      ("vpn", Vpn);
      ("vpc", Vpc)]
    let t_to_str =
      [(Tgw_peering, "tgw-peering");
      (Peering, "peering");
      (Direct_connect_gateway, "direct-connect-gateway");
      (Vpn, "vpn");
      (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EnableFastSnapshotRestoreStateError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module RouteOrigin =
  struct
    type t =
      | CreateRouteTable 
      | CreateRoute 
      | EnableVgwRoutePropagation 
    let str_to_t =
      [("EnableVgwRoutePropagation", EnableVgwRoutePropagation);
      ("CreateRoute", CreateRoute);
      ("CreateRouteTable", CreateRouteTable)]
    let t_to_str =
      [(EnableVgwRoutePropagation, "EnableVgwRoutePropagation");
      (CreateRoute, "CreateRoute");
      (CreateRouteTable, "CreateRouteTable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteState =
  struct
    type t =
      | Active 
      | Blackhole 
    let str_to_t = [("blackhole", Blackhole); ("active", Active)]
    let t_to_str = [(Blackhole, "blackhole"); (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RouteTableAssociationState =
  struct
    type t =
      {
      state: RouteTableAssociationStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               RouteTableAssociationStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (RouteTableAssociationStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteTableAssociationStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             RouteTableAssociationStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module ElasticGpuSpecificationResponse =
  struct
    type t = {
      type_: String.t option }
    let make ?type_  () = { type_ }
    let parse xml =
      Some
        { type_ = (Util.option_bind (Xml.member "type" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.type_
              (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let of_json j =
      { type_ = (Util.option_map (Json.lookup j "type_") String.of_json) }
  end
module LaunchTemplateBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      virtual_name: String.t option ;
      ebs: LaunchTemplateEbsBlockDevice.t option ;
      no_device: String.t option }
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               LaunchTemplateEbsBlockDevice.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair ("Ebs", (LaunchTemplateEbsBlockDevice.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (LaunchTemplateEbsBlockDevice.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             LaunchTemplateEbsBlockDevice.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorResponse =
  struct
    type t = {
      type_: String.t option ;
      count: Integer.t option }
    let make ?type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)))])
    let of_json j =
      {
        type_ = (Util.option_map (Json.lookup j "type_") String.of_json);
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module LaunchTemplateSpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "maxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "spotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module MarketType =
  struct
    type t =
      | Spot 
    let str_to_t = [("spot", Spot)]
    let t_to_str = [(Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateHttpTokensState =
  struct
    type t =
      | Optional 
      | Required 
    let str_to_t = [("required", Required); ("optional", Optional)]
    let t_to_str = [(Required, "required"); (Optional, "optional")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateInstanceMetadataEndpointState =
  struct
    type t =
      | Disabled 
      | Enabled 
    let str_to_t = [("enabled", Enabled); ("disabled", Disabled)]
    let t_to_str = [(Enabled, "enabled"); (Disabled, "disabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateInstanceMetadataOptionsState =
  struct
    type t =
      | Pending 
      | Applied 
    let str_to_t = [("applied", Applied); ("pending", Pending)]
    let t_to_str = [(Applied, "applied"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateInstanceNetworkInterfaceSpecification =
  struct
    type t =
      {
      associate_carrier_ip_address: Boolean.t option ;
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: GroupIdStringList.t ;
      interface_type: String.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option ;
      network_card_index: Integer.t option }
    let make ?associate_carrier_ip_address  ?associate_public_ip_address 
      ?delete_on_termination  ?description  ?device_index  ?(groups= []) 
      ?interface_type  ?ipv6_address_count  ?(ipv6_addresses= []) 
      ?network_interface_id  ?private_ip_address  ?(private_ip_addresses= [])
       ?secondary_private_ip_address_count  ?subnet_id  ?network_card_index 
      () =
      {
        associate_carrier_ip_address;
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id;
        network_card_index
      }
    let parse xml =
      Some
        {
          associate_carrier_ip_address =
            (Util.option_bind (Xml.member "associateCarrierIpAddress" xml)
               Boolean.parse);
          associate_public_ip_address =
            (Util.option_bind (Xml.member "associatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  InstanceIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          network_card_index =
            (Util.option_bind (Xml.member "networkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f ->
                Query.Pair
                  ("AssociateCarrierIpAddress", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f -> ("associate_carrier_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_carrier_ip_address =
          (Util.option_map (Json.lookup j "associate_carrier_ip_address")
             Boolean.of_json);
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module LaunchTemplateLicenseConfiguration =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceIpv6AddressRequest =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module IpRangeList =
  struct
    type t = IpRange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpRange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpRange.to_query v
    let to_json v = `List (List.map IpRange.to_json v)
    let of_json j = Json.to_list IpRange.of_json j
  end
module Ipv6RangeList =
  struct
    type t = Ipv6Range.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Ipv6Range.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6Range.to_query v
    let to_json v = `List (List.map Ipv6Range.to_json v)
    let of_json j = Json.to_list Ipv6Range.of_json j
  end
module PrefixListIdList =
  struct
    type t = PrefixListId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixListId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixListId.to_query v
    let to_json v = `List (List.map PrefixListId.to_json v)
    let of_json j = Json.to_list PrefixListId.of_json j
  end
module UserIdGroupPairList =
  struct
    type t = UserIdGroupPair.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UserIdGroupPair.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UserIdGroupPair.to_query v
    let to_json v = `List (List.map UserIdGroupPair.to_json v)
    let of_json j = Json.to_list UserIdGroupPair.of_json j
  end
module AssociatedNetworkType =
  struct
    type t =
      | Vpc 
    let str_to_t = [("vpc", Vpc)]
    let t_to_str = [(Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ClientVpnEndpointAttributeStatusCode =
  struct
    type t =
      | Applying 
      | Applied 
    let str_to_t = [("applied", Applied); ("applying", Applying)]
    let t_to_str = [(Applied, "applied"); (Applying, "applying")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CertificateAuthentication =
  struct
    type t = {
      client_root_certificate_chain: String.t option }
    let make ?client_root_certificate_chain  () =
      { client_root_certificate_chain }
    let parse xml =
      Some
        {
          client_root_certificate_chain =
            (Util.option_bind (Xml.member "clientRootCertificateChain" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChain", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain
              (fun f -> ("client_root_certificate_chain", (String.to_json f)))])
    let of_json j =
      {
        client_root_certificate_chain =
          (Util.option_map (Json.lookup j "client_root_certificate_chain")
             String.of_json)
      }
  end
module ClientVpnAuthenticationType =
  struct
    type t =
      | Certificate_authentication 
      | Directory_service_authentication 
      | Federated_authentication 
    let str_to_t =
      [("federated-authentication", Federated_authentication);
      ("directory-service-authentication", Directory_service_authentication);
      ("certificate-authentication", Certificate_authentication)]
    let t_to_str =
      [(Federated_authentication, "federated-authentication");
      (Directory_service_authentication, "directory-service-authentication");
      (Certificate_authentication, "certificate-authentication")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DirectoryServiceAuthentication =
  struct
    type t = {
      directory_id: String.t option }
    let make ?directory_id  () = { directory_id }
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "directoryId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let of_json j =
      {
        directory_id =
          (Util.option_map (Json.lookup j "directory_id") String.of_json)
      }
  end
module FederatedAuthentication =
  struct
    type t =
      {
      saml_provider_arn: String.t option ;
      self_service_saml_provider_arn: String.t option }
    let make ?saml_provider_arn  ?self_service_saml_provider_arn  () =
      { saml_provider_arn; self_service_saml_provider_arn }
    let parse xml =
      Some
        {
          saml_provider_arn =
            (Util.option_bind (Xml.member "samlProviderArn" xml) String.parse);
          self_service_saml_provider_arn =
            (Util.option_bind (Xml.member "selfServiceSamlProviderArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.self_service_saml_provider_arn
              (fun f ->
                 Query.Pair
                   ("SelfServiceSamlProviderArn", (String.to_query f)));
           Util.option_map v.saml_provider_arn
             (fun f -> Query.Pair ("SamlProviderArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.self_service_saml_provider_arn
              (fun f ->
                 ("self_service_saml_provider_arn", (String.to_json f)));
           Util.option_map v.saml_provider_arn
             (fun f -> ("saml_provider_arn", (String.to_json f)))])
    let of_json j =
      {
        saml_provider_arn =
          (Util.option_map (Json.lookup j "saml_provider_arn") String.of_json);
        self_service_saml_provider_arn =
          (Util.option_map (Json.lookup j "self_service_saml_provider_arn")
             String.of_json)
      }
  end
module Placement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      partition_number: Integer.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?partition_number 
      ?host_id  ?tenancy  ?spread_domain  ?host_resource_group_arn  () =
      {
        availability_zone;
        affinity;
        group_name;
        partition_number;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          partition_number =
            (Util.option_bind (Xml.member "partitionNumber" xml)
               Integer.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.partition_number
             (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.partition_number
             (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module InstanceLifecycle =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchTemplateAndOverridesResponse =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: FleetLaunchTemplateOverrides.t option }
    let make ?launch_template_specification  ?overrides  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.option_bind (Xml.member "overrides" xml)
               FleetLaunchTemplateOverrides.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 Query.Pair
                   ("Overrides", (FleetLaunchTemplateOverrides.to_query f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.overrides
              (fun f ->
                 ("overrides", (FleetLaunchTemplateOverrides.to_json f)));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (Util.option_map (Json.lookup j "overrides")
             FleetLaunchTemplateOverrides.of_json)
      }
  end
module InstanceIdsSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PlatformValues =
  struct
    type t =
      | Windows 
    let str_to_t = [("Windows", Windows)]
    let t_to_str = [(Windows, "Windows")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesList =
  struct
    type t = FleetLaunchTemplateOverrides.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverrides.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverrides.to_query v
    let to_json v = `List (List.map FleetLaunchTemplateOverrides.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateOverrides.of_json j
  end
module FleetCapacityReservationUsageStrategy =
  struct
    type t =
      | Use_capacity_reservations_first 
    let str_to_t =
      [("use-capacity-reservations-first", Use_capacity_reservations_first)]
    let t_to_str =
      [(Use_capacity_reservations_first, "use-capacity-reservations-first")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetSpotCapacityRebalance =
  struct
    type t = {
      replacement_strategy: FleetReplacementStrategy.t option }
    let make ?replacement_strategy  () = { replacement_strategy }
    let parse xml =
      Some
        {
          replacement_strategy =
            (Util.option_bind (Xml.member "replacementStrategy" xml)
               FleetReplacementStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 Query.Pair
                   ("ReplacementStrategy",
                     (FleetReplacementStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 ("replacement_strategy",
                   (FleetReplacementStrategy.to_json f)))])
    let of_json j =
      {
        replacement_strategy =
          (Util.option_map (Json.lookup j "replacement_strategy")
             FleetReplacementStrategy.of_json)
      }
  end
module SpotFleetLaunchSpecification =
  struct
    type t =
      {
      security_groups: GroupIdentifierList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: SpotFleetMonitoring.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      spot_price: String.t option ;
      subnet_id: String.t option ;
      user_data: String.t option ;
      weighted_capacity: Double.t option ;
      tag_specifications: SpotFleetTagSpecificationList.t }
    let make ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?monitoring 
      ?(network_interfaces= [])  ?placement  ?ramdisk_id  ?spot_price 
      ?subnet_id  ?user_data  ?weighted_capacity  ?(tag_specifications= []) 
      () =
      {
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        spot_price;
        subnet_id;
        user_data;
        weighted_capacity;
        tag_specifications
      }
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               SpotFleetMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "weightedCapacity" xml)
               Double.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  SpotFleetTagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecificationSet",
                   (SpotFleetTagSpecificationList.to_query
                      v.tag_specifications)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair ("Monitoring", (SpotFleetMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (SpotFleetTagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (SpotFleetMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups))])
    let of_json j =
      {
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             SpotFleetMonitoring.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        tag_specifications =
          (SpotFleetTagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module LaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: LaunchTemplateOverridesList.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  LaunchTemplateOverridesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (LaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (LaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (LaunchTemplateOverridesList.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module ClassicLoadBalancersConfig =
  struct
    type t = {
      classic_load_balancers: ClassicLoadBalancers.t }
    let make ?(classic_load_balancers= [])  () = { classic_load_balancers }
    let parse xml =
      Some
        {
          classic_load_balancers =
            (Util.of_option []
               (Util.option_bind (Xml.member "classicLoadBalancers" xml)
                  ClassicLoadBalancers.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ClassicLoadBalancers",
                   (ClassicLoadBalancers.to_query v.classic_load_balancers)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("classic_load_balancers",
                (ClassicLoadBalancers.to_json v.classic_load_balancers))])
    let of_json j =
      {
        classic_load_balancers =
          (ClassicLoadBalancers.of_json
             (Util.of_option_exn (Json.lookup j "classic_load_balancers")))
      }
  end
module TargetGroupsConfig =
  struct
    type t = {
      target_groups: TargetGroups.t }
    let make ?(target_groups= [])  () = { target_groups }
    let parse xml =
      Some
        {
          target_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "targetGroups" xml)
                  TargetGroups.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetGroups", (TargetGroups.to_query v.target_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("target_groups", (TargetGroups.to_json v.target_groups))])
    let of_json j =
      {
        target_groups =
          (TargetGroups.of_json
             (Util.of_option_exn (Json.lookup j "target_groups")))
      }
  end
module SpotCapacityRebalance =
  struct
    type t = {
      replacement_strategy: ReplacementStrategy.t option }
    let make ?replacement_strategy  () = { replacement_strategy }
    let parse xml =
      Some
        {
          replacement_strategy =
            (Util.option_bind (Xml.member "replacementStrategy" xml)
               ReplacementStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 Query.Pair
                   ("ReplacementStrategy", (ReplacementStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 ("replacement_strategy", (ReplacementStrategy.to_json f)))])
    let of_json j =
      {
        replacement_strategy =
          (Util.option_map (Json.lookup j "replacement_strategy")
             ReplacementStrategy.of_json)
      }
  end
module TagSpecification =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VolumeStatusDetails =
  struct
    type t = {
      name: VolumeStatusName.t option ;
      status: String.t option }
    let make ?name  ?status  () = { name; status }
    let parse xml =
      Some
        {
          name =
            (Util.option_bind (Xml.member "name" xml) VolumeStatusName.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (VolumeStatusName.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.name
             (fun f -> ("name", (VolumeStatusName.to_json f)))])
    let of_json j =
      {
        name =
          (Util.option_map (Json.lookup j "name") VolumeStatusName.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module ArchitectureValues =
  struct
    type t =
      | I386 
      | X86_64 
      | Arm64 
    let str_to_t = [("arm64", Arm64); ("x86_64", X86_64); ("i386", I386)]
    let t_to_str = [(Arm64, "arm64"); (X86_64, "x86_64"); (I386, "i386")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTargetResponse.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTargetResponse.of_json)
      }
  end
module CpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module DeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuAssociationList =
  struct
    type t = ElasticGpuAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpuAssociation.to_query v
    let to_json v = `List (List.map ElasticGpuAssociation.to_json v)
    let of_json j = Json.to_list ElasticGpuAssociation.of_json j
  end
module ElasticInferenceAcceleratorAssociationList =
  struct
    type t = ElasticInferenceAcceleratorAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAcceleratorAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticInferenceAcceleratorAssociation.to_query v
    let to_json v =
      `List (List.map ElasticInferenceAcceleratorAssociation.to_json v)
    let of_json j =
      Json.to_list ElasticInferenceAcceleratorAssociation.of_json j
  end
module EnclaveOptions =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module HibernationOptions =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module HypervisorType =
  struct
    type t =
      | Ovm 
      | Xen 
    let str_to_t = [("xen", Xen); ("ovm", Ovm)]
    let t_to_str = [(Xen, "xen"); (Ovm, "ovm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IamInstanceProfile =
  struct
    type t = {
      arn: String.t option ;
      id: String.t option }
    let make ?arn  ?id  () = { arn; id }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          id = (Util.option_bind (Xml.member "id" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.id
              (fun f -> Query.Pair ("Id", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.id (fun f -> ("id", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        id = (Util.option_map (Json.lookup j "id") String.of_json)
      }
  end
module InstanceBlockDeviceMappingList =
  struct
    type t = InstanceBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMapping.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMapping.to_query v
    let to_json v = `List (List.map InstanceBlockDeviceMapping.to_json v)
    let of_json j = Json.to_list InstanceBlockDeviceMapping.of_json j
  end
module InstanceLifecycleType =
  struct
    type t =
      | Spot 
      | Scheduled 
    let str_to_t = [("scheduled", Scheduled); ("spot", Spot)]
    let t_to_str = [(Scheduled, "scheduled"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMetadataOptionsResponse =
  struct
    type t =
      {
      state: InstanceMetadataOptionsState.t option ;
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option }
    let make ?state  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  () =
      { state; http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               InstanceMetadataOptionsState.parse);
          http_tokens =
            (Util.option_bind (Xml.member "httpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "httpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "httpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (InstanceMetadataOptionsState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (InstanceMetadataOptionsState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             InstanceMetadataOptionsState.of_json);
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json)
      }
  end
module InstanceNetworkInterfaceList =
  struct
    type t = InstanceNetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceNetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceNetworkInterface.to_query v
    let to_json v = `List (List.map InstanceNetworkInterface.to_json v)
    let of_json j = Json.to_list InstanceNetworkInterface.of_json j
  end
module InstanceState =
  struct
    type t = {
      code: Integer.t ;
      name: InstanceStateName.t }
    let make ~code  ~name  () = { code; name }
    let parse xml =
      Some
        {
          code =
            (Xml.required "code"
               (Util.option_bind (Xml.member "code" xml) Integer.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml)
                  InstanceStateName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Name", (InstanceStateName.to_query v.name)));
           Some (Query.Pair ("Code", (Integer.to_query v.code)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("name", (InstanceStateName.to_json v.name));
           Some ("code", (Integer.to_json v.code))])
    let of_json j =
      {
        code = (Integer.of_json (Util.of_option_exn (Json.lookup j "code")));
        name =
          (InstanceStateName.of_json
             (Util.of_option_exn (Json.lookup j "name")))
      }
  end
module LicenseList =
  struct
    type t = LicenseConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LicenseConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LicenseConfiguration.to_query v
    let to_json v = `List (List.map LicenseConfiguration.to_json v)
    let of_json j = Json.to_list LicenseConfiguration.of_json j
  end
module Monitoring =
  struct
    type t = {
      state: MonitoringState.t option }
    let make ?state  () = { state }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) MonitoringState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (MonitoringState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (MonitoringState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") MonitoringState.of_json)
      }
  end
module ProductCodeList =
  struct
    type t = ProductCode.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ProductCode.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ProductCode.to_query v
    let to_json v = `List (List.map ProductCode.to_json v)
    let of_json j = Json.to_list ProductCode.of_json j
  end
module StateReason =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VirtualizationType =
  struct
    type t =
      | Hvm 
      | Paravirtual 
    let str_to_t = [("paravirtual", Paravirtual); ("hvm", Hvm)]
    let t_to_str = [(Paravirtual, "paravirtual"); (Hvm, "hvm")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcCidrBlockState =
  struct
    type t =
      {
      state: VpcCidrBlockStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               VpcCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (VpcCidrBlockStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VpcCidrBlockStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             VpcCidrBlockStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module SubnetCidrBlockState =
  struct
    type t =
      {
      state: SubnetCidrBlockStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               SubnetCidrBlockStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (SubnetCidrBlockStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SubnetCidrBlockStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             SubnetCidrBlockStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module UserBucketDetails =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module ScheduledInstancesPrivateIpAddressConfig =
  struct
    type t =
      {
      primary: Boolean.t option ;
      private_ip_address: String.t option }
    let make ?primary  ?private_ip_address  () =
      { primary; private_ip_address }
    let parse xml =
      Some
        {
          primary =
            (Util.option_bind (Xml.member "Primary" xml) Boolean.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)))])
    let of_json j =
      {
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module ScheduledInstancesIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "Ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module DhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: DhcpConfigurationValueList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "valueSet" xml)
                  DhcpConfigurationValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValueSet", (DhcpConfigurationValueList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (DhcpConfigurationValueList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (DhcpConfigurationValueList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module VpcAttachment =
  struct
    type t = {
      state: AttachmentStatus.t option ;
      vpc_id: String.t option }
    let make ?state  ?vpc_id  () = { state; vpc_id }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) AttachmentStatus.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AttachmentStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AttachmentStatus.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") AttachmentStatus.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ReservedInstancesModificationResult =
  struct
    type t =
      {
      reserved_instances_id: String.t option ;
      target_configuration: ReservedInstancesConfiguration.t option }
    let make ?reserved_instances_id  ?target_configuration  () =
      { reserved_instances_id; target_configuration }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               ReservedInstancesConfiguration.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration",
                     (ReservedInstancesConfiguration.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration",
                   (ReservedInstancesConfiguration.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        target_configuration =
          (Util.option_map (Json.lookup j "target_configuration")
             ReservedInstancesConfiguration.of_json)
      }
  end
module ReservedInstancesId =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module PermissionGroup =
  struct
    type t =
      | All 
    let str_to_t = [("all", All)]
    let t_to_str = [(All, "all")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DnsEntry =
  struct
    type t = {
      dns_name: String.t option ;
      hosted_zone_id: String.t option }
    let make ?dns_name  ?hosted_zone_id  () = { dns_name; hosted_zone_id }
    let parse xml =
      Some
        {
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          hosted_zone_id =
            (Util.option_bind (Xml.member "hostedZoneId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> Query.Pair ("HostedZoneId", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.hosted_zone_id
              (fun f -> ("hosted_zone_id", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)))])
    let of_json j =
      {
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json);
        hosted_zone_id =
          (Util.option_map (Json.lookup j "hosted_zone_id") String.of_json)
      }
  end
module TrafficMirrorFilterRule =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      traffic_direction: TrafficDirection.t option ;
      rule_number: Integer.t option ;
      rule_action: TrafficMirrorRuleAction.t option ;
      protocol: Integer.t option ;
      destination_port_range: TrafficMirrorPortRange.t option ;
      source_port_range: TrafficMirrorPortRange.t option ;
      destination_cidr_block: String.t option ;
      source_cidr_block: String.t option ;
      description: String.t option }
    let make ?traffic_mirror_filter_rule_id  ?traffic_mirror_filter_id 
      ?traffic_direction  ?rule_number  ?rule_action  ?protocol 
      ?destination_port_range  ?source_port_range  ?destination_cidr_block 
      ?source_cidr_block  ?description  () =
      {
        traffic_mirror_filter_rule_id;
        traffic_mirror_filter_id;
        traffic_direction;
        rule_number;
        rule_action;
        protocol;
        destination_port_range;
        source_port_range;
        destination_cidr_block;
        source_cidr_block;
        description
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          traffic_direction =
            (Util.option_bind (Xml.member "trafficDirection" xml)
               TrafficDirection.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml)
               TrafficMirrorRuleAction.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) Integer.parse);
          destination_port_range =
            (Util.option_bind (Xml.member "destinationPortRange" xml)
               TrafficMirrorPortRange.parse);
          source_port_range =
            (Util.option_bind (Xml.member "sourcePortRange" xml)
               TrafficMirrorPortRange.parse);
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source_cidr_block =
            (Util.option_bind (Xml.member "sourceCidrBlock" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.source_cidr_block
             (fun f -> Query.Pair ("SourceCidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange", (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRange.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f ->
                Query.Pair
                  ("RuleAction", (TrafficMirrorRuleAction.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.traffic_direction
             (fun f ->
                Query.Pair
                  ("TrafficDirection", (TrafficDirection.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.source_cidr_block
             (fun f -> ("source_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range", (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRange.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (TrafficMirrorRuleAction.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.traffic_direction
             (fun f -> ("traffic_direction", (TrafficDirection.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule_id
             (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        traffic_direction =
          (Util.option_map (Json.lookup j "traffic_direction")
             TrafficDirection.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action")
             TrafficMirrorRuleAction.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRange.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRange.of_json);
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source_cidr_block =
          (Util.option_map (Json.lookup j "source_cidr_block") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module TrafficMirrorNetworkService =
  struct
    type t =
      | Amazon_dns 
    let str_to_t = [("amazon-dns", Amazon_dns)]
    let t_to_str = [(Amazon_dns, "amazon-dns")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutoAcceptSharedAttachmentsValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultRouteTableAssociationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultRouteTablePropagationValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DnsSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MulticastSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnEcmpSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCount =
  struct
    type t =
      {
      instance_count: Integer.t option ;
      state: ListingState.t option }
    let make ?instance_count  ?state  () = { instance_count; state }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ListingState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ListingState.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ListingState.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ListingState.of_json)
      }
  end
module PriceSchedule =
  struct
    type t =
      {
      active: Boolean.t option ;
      currency_code: CurrencyCodeValues.t option ;
      price: Double.t option ;
      term: Long.t option }
    let make ?active  ?currency_code  ?price  ?term  () =
      { active; currency_code; price; term }
    let parse xml =
      Some
        {
          active = (Util.option_bind (Xml.member "active" xml) Boolean.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.active
             (fun f -> Query.Pair ("Active", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.active
             (fun f -> ("active", (Boolean.to_json f)))])
    let of_json j =
      {
        active = (Util.option_map (Json.lookup j "active") Boolean.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        term = (Util.option_map (Json.lookup j "term") Long.of_json)
      }
  end
module ClientVpnConnectionStatusCode =
  struct
    type t =
      | Active 
      | Failed_to_terminate 
      | Terminating 
      | Terminated 
    let str_to_t =
      [("terminated", Terminated);
      ("terminating", Terminating);
      ("failed-to-terminate", Failed_to_terminate);
      ("active", Active)]
    let t_to_str =
      [(Terminated, "terminated");
      (Terminating, "terminating");
      (Failed_to_terminate, "failed-to-terminate");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusEvent =
  struct
    type t =
      {
      instance_event_id: String.t option ;
      code: EventCode.t option ;
      description: String.t option ;
      not_after: DateTime.t option ;
      not_before: DateTime.t option ;
      not_before_deadline: DateTime.t option }
    let make ?instance_event_id  ?code  ?description  ?not_after  ?not_before
       ?not_before_deadline  () =
      {
        instance_event_id;
        code;
        description;
        not_after;
        not_before;
        not_before_deadline
      }
    let parse xml =
      Some
        {
          instance_event_id =
            (Util.option_bind (Xml.member "instanceEventId" xml) String.parse);
          code = (Util.option_bind (Xml.member "code" xml) EventCode.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          not_before_deadline =
            (Util.option_bind (Xml.member "notBeforeDeadline" xml)
               DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f ->
                 Query.Pair ("NotBeforeDeadline", (DateTime.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (EventCode.to_query f)));
           Util.option_map v.instance_event_id
             (fun f -> Query.Pair ("InstanceEventId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.not_before_deadline
              (fun f -> ("not_before_deadline", (DateTime.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (EventCode.to_json f)));
           Util.option_map v.instance_event_id
             (fun f -> ("instance_event_id", (String.to_json f)))])
    let of_json j =
      {
        instance_event_id =
          (Util.option_map (Json.lookup j "instance_event_id") String.of_json);
        code = (Util.option_map (Json.lookup j "code") EventCode.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json);
        not_before_deadline =
          (Util.option_map (Json.lookup j "not_before_deadline")
             DateTime.of_json)
      }
  end
module InstanceStatusDetailsList =
  struct
    type t = InstanceStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusDetails.to_query v
    let to_json v = `List (List.map InstanceStatusDetails.to_json v)
    let of_json j = Json.to_list InstanceStatusDetails.of_json j
  end
module SummaryStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
      | Not_applicable 
      | Initializing 
    let str_to_t =
      [("initializing", Initializing);
      ("not-applicable", Not_applicable);
      ("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Initializing, "initializing");
      (Not_applicable, "not-applicable");
      (Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfacePermissionStateCode =
  struct
    type t =
      | Pending 
      | Granted 
      | Revoking 
      | Revoked 
    let str_to_t =
      [("revoked", Revoked);
      ("revoking", Revoking);
      ("granted", Granted);
      ("pending", Pending)]
    let t_to_str =
      [(Revoked, "revoked");
      (Revoking, "revoking");
      (Granted, "granted");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailableInstanceCapacityList =
  struct
    type t = InstanceCapacity.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCapacity.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceCapacity.to_query v
    let to_json v = `List (List.map InstanceCapacity.to_json v)
    let of_json j = Json.to_list InstanceCapacity.of_json j
  end
module HostInstance =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_type: String.t option ;
      owner_id: String.t option }
    let make ?instance_id  ?instance_type  ?owner_id  () =
      { instance_id; instance_type; owner_id }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module TransitGatewayMulitcastDomainAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IdFormat =
  struct
    type t =
      {
      deadline: DateTime.t option ;
      resource: String.t option ;
      use_long_ids: Boolean.t option }
    let make ?deadline  ?resource  ?use_long_ids  () =
      { deadline; resource; use_long_ids }
    let parse xml =
      Some
        {
          deadline =
            (Util.option_bind (Xml.member "deadline" xml) DateTime.parse);
          resource =
            (Util.option_bind (Xml.member "resource" xml) String.parse);
          use_long_ids =
            (Util.option_bind (Xml.member "useLongIds" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> Query.Pair ("UseLongIds", (Boolean.to_query f)));
           Util.option_map v.resource
             (fun f -> Query.Pair ("Resource", (String.to_query f)));
           Util.option_map v.deadline
             (fun f -> Query.Pair ("Deadline", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.use_long_ids
              (fun f -> ("use_long_ids", (Boolean.to_json f)));
           Util.option_map v.resource
             (fun f -> ("resource", (String.to_json f)));
           Util.option_map v.deadline
             (fun f -> ("deadline", (DateTime.to_json f)))])
    let of_json j =
      {
        deadline =
          (Util.option_map (Json.lookup j "deadline") DateTime.of_json);
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json);
        use_long_ids =
          (Util.option_map (Json.lookup j "use_long_ids") Boolean.of_json)
      }
  end
module DeleteFleetErrorCode =
  struct
    type t =
      | FleetIdDoesNotExist 
      | FleetIdMalformed 
      | FleetNotInDeletableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetNotInDeletableState", FleetNotInDeletableState);
      ("fleetIdMalformed", FleetIdMalformed);
      ("fleetIdDoesNotExist", FleetIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetNotInDeletableState, "fleetNotInDeletableState");
      (FleetIdMalformed, "fleetIdMalformed");
      (FleetIdDoesNotExist, "fleetIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DisableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      error: DisableFastSnapshotRestoreStateError.t option }
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               DisableFastSnapshotRestoreStateError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (DisableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (DisableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             DisableFastSnapshotRestoreStateError.of_json)
      }
  end
module OccurrenceDaySet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module S3Storage =
  struct
    type t =
      {
      a_w_s_access_key_id: String.t option ;
      bucket: String.t option ;
      prefix: String.t option ;
      upload_policy: Blob.t option ;
      upload_policy_signature: String.t option }
    let make ?a_w_s_access_key_id  ?bucket  ?prefix  ?upload_policy 
      ?upload_policy_signature  () =
      {
        a_w_s_access_key_id;
        bucket;
        prefix;
        upload_policy;
        upload_policy_signature
      }
    let parse xml =
      Some
        {
          a_w_s_access_key_id =
            (Util.option_bind (Xml.member "AWSAccessKeyId" xml) String.parse);
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          upload_policy =
            (Util.option_bind (Xml.member "uploadPolicy" xml) Blob.parse);
          upload_policy_signature =
            (Util.option_bind (Xml.member "uploadPolicySignature" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f ->
                 Query.Pair ("UploadPolicySignature", (String.to_query f)));
           Util.option_map v.upload_policy
             (fun f -> Query.Pair ("UploadPolicy", (Blob.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> Query.Pair ("AWSAccessKeyId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_policy_signature
              (fun f -> ("upload_policy_signature", (String.to_json f)));
           Util.option_map v.upload_policy
             (fun f -> ("upload_policy", (Blob.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)));
           Util.option_map v.a_w_s_access_key_id
             (fun f -> ("a_w_s_access_key_id", (String.to_json f)))])
    let of_json j =
      {
        a_w_s_access_key_id =
          (Util.option_map (Json.lookup j "a_w_s_access_key_id")
             String.of_json);
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        upload_policy =
          (Util.option_map (Json.lookup j "upload_policy") Blob.of_json);
        upload_policy_signature =
          (Util.option_map (Json.lookup j "upload_policy_signature")
             String.of_json)
      }
  end
module StaleIpPermission =
  struct
    type t =
      {
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      ip_ranges: IpRanges.t ;
      prefix_list_ids: PrefixListIdSet.t ;
      to_port: Integer.t option ;
      user_id_group_pairs: UserIdGroupPairSet.t }
    let make ?from_port  ?ip_protocol  ?(ip_ranges= [])  ?(prefix_list_ids=
      [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml) IpRanges.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdSet.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairSet.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdSet.to_query v.prefix_list_ids)));
           Some (Query.Pair ("IpRanges", (IpRanges.to_query v.ip_ranges)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairSet.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids", (PrefixListIdSet.to_json v.prefix_list_ids));
           Some ("ip_ranges", (IpRanges.to_json v.ip_ranges));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        ip_ranges =
          (IpRanges.of_json (Util.of_option_exn (Json.lookup j "ip_ranges")));
        prefix_list_ids =
          (PrefixListIdSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")));
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        user_id_group_pairs =
          (UserIdGroupPairSet.of_json
             (Util.of_option_exn (Json.lookup j "user_id_group_pairs")))
      }
  end
module VolumeAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      device: String.t option ;
      instance_id: String.t option ;
      state: VolumeAttachmentState.t option ;
      volume_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attach_time  ?device  ?instance_id  ?state  ?volume_id 
      ?delete_on_termination  () =
      {
        attach_time;
        device;
        instance_id;
        state;
        volume_id;
        delete_on_termination
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          device = (Util.option_bind (Xml.member "device" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "status" xml)
               VolumeAttachmentState.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("Status", (VolumeAttachmentState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (VolumeAttachmentState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             VolumeAttachmentState.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module IKEVersionsRequestList =
  struct
    type t = IKEVersionsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IKEVersionsRequestListValue.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list IKEVersionsRequestListValue.to_query v
    let to_json v = `List (List.map IKEVersionsRequestListValue.to_json v)
    let of_json j = Json.to_list IKEVersionsRequestListValue.of_json j
  end
module Phase1DHGroupNumbersRequestList =
  struct
    type t = Phase1DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1DHGroupNumbersRequestListValue.to_query v
    let to_json v =
      `List (List.map Phase1DHGroupNumbersRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1DHGroupNumbersRequestListValue.of_json j
  end
module Phase1EncryptionAlgorithmsRequestList =
  struct
    type t = Phase1EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_json v =
      `List (List.map Phase1EncryptionAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1EncryptionAlgorithmsRequestListValue.of_json j
  end
module Phase1IntegrityAlgorithmsRequestList =
  struct
    type t = Phase1IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase1IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase1IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_json v =
      `List (List.map Phase1IntegrityAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase1IntegrityAlgorithmsRequestListValue.of_json j
  end
module Phase2DHGroupNumbersRequestList =
  struct
    type t = Phase2DHGroupNumbersRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2DHGroupNumbersRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2DHGroupNumbersRequestListValue.to_query v
    let to_json v =
      `List (List.map Phase2DHGroupNumbersRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2DHGroupNumbersRequestListValue.of_json j
  end
module Phase2EncryptionAlgorithmsRequestList =
  struct
    type t = Phase2EncryptionAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2EncryptionAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2EncryptionAlgorithmsRequestListValue.to_query
        v
    let to_json v =
      `List (List.map Phase2EncryptionAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2EncryptionAlgorithmsRequestListValue.of_json j
  end
module Phase2IntegrityAlgorithmsRequestList =
  struct
    type t = Phase2IntegrityAlgorithmsRequestListValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Phase2IntegrityAlgorithmsRequestListValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list Phase2IntegrityAlgorithmsRequestListValue.to_query
        v
    let to_json v =
      `List (List.map Phase2IntegrityAlgorithmsRequestListValue.to_json v)
    let of_json j =
      Json.to_list Phase2IntegrityAlgorithmsRequestListValue.of_json j
  end
module EbsEncryptionSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
    let str_to_t = [("supported", Supported); ("unsupported", Unsupported)]
    let t_to_str = [(Supported, "supported"); (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsNvmeSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Required 
    let str_to_t =
      [("required", Required);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Required, "required");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsOptimizedInfo =
  struct
    type t =
      {
      baseline_bandwidth_in_mbps: Integer.t option ;
      baseline_throughput_in_m_bps: Double.t option ;
      baseline_iops: Integer.t option ;
      maximum_bandwidth_in_mbps: Integer.t option ;
      maximum_throughput_in_m_bps: Double.t option ;
      maximum_iops: Integer.t option }
    let make ?baseline_bandwidth_in_mbps  ?baseline_throughput_in_m_bps 
      ?baseline_iops  ?maximum_bandwidth_in_mbps 
      ?maximum_throughput_in_m_bps  ?maximum_iops  () =
      {
        baseline_bandwidth_in_mbps;
        baseline_throughput_in_m_bps;
        baseline_iops;
        maximum_bandwidth_in_mbps;
        maximum_throughput_in_m_bps;
        maximum_iops
      }
    let parse xml =
      Some
        {
          baseline_bandwidth_in_mbps =
            (Util.option_bind (Xml.member "baselineBandwidthInMbps" xml)
               Integer.parse);
          baseline_throughput_in_m_bps =
            (Util.option_bind (Xml.member "baselineThroughputInMBps" xml)
               Double.parse);
          baseline_iops =
            (Util.option_bind (Xml.member "baselineIops" xml) Integer.parse);
          maximum_bandwidth_in_mbps =
            (Util.option_bind (Xml.member "maximumBandwidthInMbps" xml)
               Integer.parse);
          maximum_throughput_in_m_bps =
            (Util.option_bind (Xml.member "maximumThroughputInMBps" xml)
               Double.parse);
          maximum_iops =
            (Util.option_bind (Xml.member "maximumIops" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.maximum_iops
              (fun f -> Query.Pair ("MaximumIops", (Integer.to_query f)));
           Util.option_map v.maximum_throughput_in_m_bps
             (fun f ->
                Query.Pair ("MaximumThroughputInMBps", (Double.to_query f)));
           Util.option_map v.maximum_bandwidth_in_mbps
             (fun f ->
                Query.Pair ("MaximumBandwidthInMbps", (Integer.to_query f)));
           Util.option_map v.baseline_iops
             (fun f -> Query.Pair ("BaselineIops", (Integer.to_query f)));
           Util.option_map v.baseline_throughput_in_m_bps
             (fun f ->
                Query.Pair ("BaselineThroughputInMBps", (Double.to_query f)));
           Util.option_map v.baseline_bandwidth_in_mbps
             (fun f ->
                Query.Pair ("BaselineBandwidthInMbps", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.maximum_iops
              (fun f -> ("maximum_iops", (Integer.to_json f)));
           Util.option_map v.maximum_throughput_in_m_bps
             (fun f -> ("maximum_throughput_in_m_bps", (Double.to_json f)));
           Util.option_map v.maximum_bandwidth_in_mbps
             (fun f -> ("maximum_bandwidth_in_mbps", (Integer.to_json f)));
           Util.option_map v.baseline_iops
             (fun f -> ("baseline_iops", (Integer.to_json f)));
           Util.option_map v.baseline_throughput_in_m_bps
             (fun f -> ("baseline_throughput_in_m_bps", (Double.to_json f)));
           Util.option_map v.baseline_bandwidth_in_mbps
             (fun f -> ("baseline_bandwidth_in_mbps", (Integer.to_json f)))])
    let of_json j =
      {
        baseline_bandwidth_in_mbps =
          (Util.option_map (Json.lookup j "baseline_bandwidth_in_mbps")
             Integer.of_json);
        baseline_throughput_in_m_bps =
          (Util.option_map (Json.lookup j "baseline_throughput_in_m_bps")
             Double.of_json);
        baseline_iops =
          (Util.option_map (Json.lookup j "baseline_iops") Integer.of_json);
        maximum_bandwidth_in_mbps =
          (Util.option_map (Json.lookup j "maximum_bandwidth_in_mbps")
             Integer.of_json);
        maximum_throughput_in_m_bps =
          (Util.option_map (Json.lookup j "maximum_throughput_in_m_bps")
             Double.of_json);
        maximum_iops =
          (Util.option_map (Json.lookup j "maximum_iops") Integer.of_json)
      }
  end
module EbsOptimizedSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Default 
    let str_to_t =
      [("default", Default);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Default, "default");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaDeviceInfoList =
  struct
    type t = FpgaDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FpgaDeviceInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FpgaDeviceInfo.to_query v
    let to_json v = `List (List.map FpgaDeviceInfo.to_json v)
    let of_json j = Json.to_list FpgaDeviceInfo.of_json j
  end
module GpuDeviceInfoList =
  struct
    type t = GpuDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map GpuDeviceInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list GpuDeviceInfo.to_query v
    let to_json v = `List (List.map GpuDeviceInfo.to_json v)
    let of_json j = Json.to_list GpuDeviceInfo.of_json j
  end
module InferenceDeviceInfoList =
  struct
    type t = InferenceDeviceInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InferenceDeviceInfo.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InferenceDeviceInfo.to_query v
    let to_json v = `List (List.map InferenceDeviceInfo.to_json v)
    let of_json j = Json.to_list InferenceDeviceInfo.of_json j
  end
module DiskInfoList =
  struct
    type t = DiskInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DiskInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DiskInfo.to_query v
    let to_json v = `List (List.map DiskInfo.to_json v)
    let of_json j = Json.to_list DiskInfo.of_json j
  end
module EphemeralNvmeSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Required 
    let str_to_t =
      [("required", Required);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Required, "required");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EnaSupport =
  struct
    type t =
      | Unsupported 
      | Supported 
      | Required 
    let str_to_t =
      [("required", Required);
      ("supported", Supported);
      ("unsupported", Unsupported)]
    let t_to_str =
      [(Required, "required");
      (Supported, "supported");
      (Unsupported, "unsupported")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkCardInfoList =
  struct
    type t = NetworkCardInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkCardInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkCardInfo.to_query v
    let to_json v = `List (List.map NetworkCardInfo.to_json v)
    let of_json j = Json.to_list NetworkCardInfo.of_json j
  end
module PlacementGroupStrategyList =
  struct
    type t = PlacementGroupStrategy.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlacementGroupStrategy.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PlacementGroupStrategy.to_query v
    let to_json v = `List (List.map PlacementGroupStrategy.to_json v)
    let of_json j = Json.to_list PlacementGroupStrategy.of_json j
  end
module ArchitectureTypeList =
  struct
    type t = ArchitectureType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ArchitectureType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ArchitectureType.to_query v
    let to_json v = `List (List.map ArchitectureType.to_json v)
    let of_json j = Json.to_list ArchitectureType.of_json j
  end
module RootDeviceType =
  struct
    type t =
      | Ebs 
      | Instance_store 
    let str_to_t = [("instance-store", Instance_store); ("ebs", Ebs)]
    let t_to_str = [(Instance_store, "instance-store"); (Ebs, "ebs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UsageClassType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CoreCountList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ThreadsPerCoreList =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Integer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ClientVpnRouteStatusCode =
  struct
    type t =
      | Creating 
      | Active 
      | Failed 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("failed", Failed);
      ("active", Active);
      ("creating", Creating)]
    let t_to_str =
      [(Deleting, "deleting");
      (Failed, "failed");
      (Active, "active");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VgwTelemetry =
  struct
    type t =
      {
      accepted_route_count: Integer.t option ;
      last_status_change: DateTime.t option ;
      outside_ip_address: String.t option ;
      status: TelemetryStatus.t option ;
      status_message: String.t option ;
      certificate_arn: String.t option }
    let make ?accepted_route_count  ?last_status_change  ?outside_ip_address 
      ?status  ?status_message  ?certificate_arn  () =
      {
        accepted_route_count;
        last_status_change;
        outside_ip_address;
        status;
        status_message;
        certificate_arn
      }
    let parse xml =
      Some
        {
          accepted_route_count =
            (Util.option_bind (Xml.member "acceptedRouteCount" xml)
               Integer.parse);
          last_status_change =
            (Util.option_bind (Xml.member "lastStatusChange" xml)
               DateTime.parse);
          outside_ip_address =
            (Util.option_bind (Xml.member "outsideIpAddress" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) TelemetryStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (TelemetryStatus.to_query f)));
           Util.option_map v.outside_ip_address
             (fun f -> Query.Pair ("OutsideIpAddress", (String.to_query f)));
           Util.option_map v.last_status_change
             (fun f -> Query.Pair ("LastStatusChange", (DateTime.to_query f)));
           Util.option_map v.accepted_route_count
             (fun f ->
                Query.Pair ("AcceptedRouteCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.certificate_arn
              (fun f -> ("certificate_arn", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (TelemetryStatus.to_json f)));
           Util.option_map v.outside_ip_address
             (fun f -> ("outside_ip_address", (String.to_json f)));
           Util.option_map v.last_status_change
             (fun f -> ("last_status_change", (DateTime.to_json f)));
           Util.option_map v.accepted_route_count
             (fun f -> ("accepted_route_count", (Integer.to_json f)))])
    let of_json j =
      {
        accepted_route_count =
          (Util.option_map (Json.lookup j "accepted_route_count")
             Integer.of_json);
        last_status_change =
          (Util.option_map (Json.lookup j "last_status_change")
             DateTime.of_json);
        outside_ip_address =
          (Util.option_map (Json.lookup j "outside_ip_address")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") TelemetryStatus.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json)
      }
  end
module TunnelInsideIpVersion =
  struct
    type t =
      | Ipv4 
      | Ipv6 
    let str_to_t = [("ipv6", Ipv6); ("ipv4", Ipv4)]
    let t_to_str = [(Ipv6, "ipv6"); (Ipv4, "ipv4")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TunnelOptionsList =
  struct
    type t = TunnelOption.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TunnelOption.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TunnelOption.to_query v
    let to_json v = `List (List.map TunnelOption.to_json v)
    let of_json j = Json.to_list TunnelOption.of_json j
  end
module VpnStaticRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      source: VpnStaticRouteSource.t option ;
      state: VpnState.t option }
    let make ?destination_cidr_block  ?source  ?state  () =
      { destination_cidr_block; source; state }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          source =
            (Util.option_bind (Xml.member "source" xml)
               VpnStaticRouteSource.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.source
             (fun f ->
                Query.Pair ("Source", (VpnStaticRouteSource.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.source
             (fun f -> ("source", (VpnStaticRouteSource.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source =
          (Util.option_map (Json.lookup j "source")
             VpnStaticRouteSource.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json)
      }
  end
module AssociationStatusCode =
  struct
    type t =
      | Associating 
      | Associated 
      | Association_failed 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("association-failed", Association_failed);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Association_failed, "association-failed");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcPeeringConnectionStateReasonCode =
  struct
    type t =
      | Initiating_request 
      | Pending_acceptance 
      | Active 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
      | Provisioning 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("provisioning", Provisioning);
      ("expired", Expired);
      ("failed", Failed);
      ("rejected", Rejected);
      ("deleted", Deleted);
      ("active", Active);
      ("pending-acceptance", Pending_acceptance);
      ("initiating-request", Initiating_request)]
    let t_to_str =
      [(Deleting, "deleting");
      (Provisioning, "provisioning");
      (Expired, "expired");
      (Failed, "failed");
      (Rejected, "rejected");
      (Deleted, "deleted");
      (Active, "active");
      (Pending_acceptance, "pending-acceptance");
      (Initiating_request, "initiating-request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CidrBlockSet =
  struct
    type t = CidrBlock.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map CidrBlock.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CidrBlock.to_query v
    let to_json v = `List (List.map CidrBlock.to_json v)
    let of_json j = Json.to_list CidrBlock.of_json j
  end
module Ipv6CidrBlockSet =
  struct
    type t = Ipv6CidrBlock.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Ipv6CidrBlock.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6CidrBlock.to_query v
    let to_json v = `List (List.map Ipv6CidrBlock.to_json v)
    let of_json j = Json.to_list Ipv6CidrBlock.of_json j
  end
module VpcPeeringConnectionOptionsDescription =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module NetworkAclAssociation =
  struct
    type t =
      {
      network_acl_association_id: String.t option ;
      network_acl_id: String.t option ;
      subnet_id: String.t option }
    let make ?network_acl_association_id  ?network_acl_id  ?subnet_id  () =
      { network_acl_association_id; network_acl_id; subnet_id }
    let parse xml =
      Some
        {
          network_acl_association_id =
            (Util.option_bind (Xml.member "networkAclAssociationId" xml)
               String.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.network_acl_association_id
             (fun f ->
                Query.Pair ("NetworkAclAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.network_acl_association_id
             (fun f -> ("network_acl_association_id", (String.to_json f)))])
    let of_json j =
      {
        network_acl_association_id =
          (Util.option_map (Json.lookup j "network_acl_association_id")
             String.of_json);
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module NetworkAclEntry =
  struct
    type t =
      {
      cidr_block: String.t option ;
      egress: Boolean.t option ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      port_range: PortRange.t option ;
      protocol: String.t option ;
      rule_action: RuleAction.t option ;
      rule_number: Integer.t option }
    let make ?cidr_block  ?egress  ?icmp_type_code  ?ipv6_cidr_block 
      ?port_range  ?protocol  ?rule_action  ?rule_number  () =
      {
        cidr_block;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          egress = (Util.option_bind (Xml.member "egress" xml) Boolean.parse);
          icmp_type_code =
            (Util.option_bind (Xml.member "icmpTypeCode" xml)
               IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Util.option_bind (Xml.member "protocol" xml) String.parse);
          rule_action =
            (Util.option_bind (Xml.member "ruleAction" xml) RuleAction.parse);
          rule_number =
            (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.rule_action
             (fun f -> Query.Pair ("RuleAction", (RuleAction.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (String.to_query f)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("IcmpTypeCode", (IcmpTypeCode.to_query f)));
           Util.option_map v.egress
             (fun f -> Query.Pair ("Egress", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.rule_number
              (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (RuleAction.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (String.to_json f)));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Util.option_map v.egress
             (fun f -> ("egress", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        egress = (Util.option_map (Json.lookup j "egress") Boolean.of_json);
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") String.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action") RuleAction.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json)
      }
  end
module CancelBatchErrorCode =
  struct
    type t =
      | FleetRequestIdDoesNotExist 
      | FleetRequestIdMalformed 
      | FleetRequestNotInCancellableState 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("fleetRequestNotInCancellableState",
        FleetRequestNotInCancellableState);
      ("fleetRequestIdMalformed", FleetRequestIdMalformed);
      ("fleetRequestIdDoesNotExist", FleetRequestIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (FleetRequestNotInCancellableState,
        "fleetRequestNotInCancellableState");
      (FleetRequestIdMalformed, "fleetRequestIdMalformed");
      (FleetRequestIdDoesNotExist, "fleetRequestIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AccountAttributeValue =
  struct
    type t = {
      attribute_value: String.t option }
    let make ?attribute_value  () = { attribute_value }
    let parse xml =
      Some
        {
          attribute_value =
            (Util.option_bind (Xml.member "attributeValue" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> Query.Pair ("AttributeValue", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute_value
              (fun f -> ("attribute_value", (String.to_json f)))])
    let of_json j =
      {
        attribute_value =
          (Util.option_map (Json.lookup j "attribute_value") String.of_json)
      }
  end
module SecurityGroupIdentifier =
  struct
    type t = {
      group_id: String.t option ;
      group_name: String.t option }
    let make ?group_id  ?group_name  () = { group_id; group_name }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module TransitGatewayAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceIpv6Address =
  struct
    type t = {
      ipv6_address: String.t option }
    let make ?ipv6_address  () = { ipv6_address }
    let parse xml =
      Some
        {
          ipv6_address =
            (Util.option_bind (Xml.member "ipv6Address" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> Query.Pair ("Ipv6Address", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_address
              (fun f -> ("ipv6_address", (String.to_json f)))])
    let of_json j =
      {
        ipv6_address =
          (Util.option_map (Json.lookup j "ipv6_address") String.of_json)
      }
  end
module NetworkInterfacePrivateIpAddress =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option ;
      primary: Boolean.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option }
    let make ?association  ?primary  ?private_dns_name  ?private_ip_address 
      () = { association; primary; private_dns_name; private_ip_address }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          primary =
            (Util.option_bind (Xml.member "primary" xml) Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.primary
             (fun f -> Query.Pair ("Primary", (Boolean.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.primary
             (fun f -> ("primary", (Boolean.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json);
        primary = (Util.option_map (Json.lookup j "primary") Boolean.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module RecurringCharge =
  struct
    type t =
      {
      amount: Double.t option ;
      frequency: RecurringChargeFrequency.t option }
    let make ?amount  ?frequency  () = { amount; frequency }
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          frequency =
            (Util.option_bind (Xml.member "frequency" xml)
               RecurringChargeFrequency.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f ->
                 Query.Pair
                   ("Frequency", (RecurringChargeFrequency.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.frequency
              (fun f -> ("frequency", (RecurringChargeFrequency.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let of_json j =
      {
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json);
        frequency =
          (Util.option_map (Json.lookup j "frequency")
             RecurringChargeFrequency.of_json)
      }
  end
module DnsNameState =
  struct
    type t =
      | PendingVerification 
      | Verified 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("verified", Verified);
      ("pendingVerification", PendingVerification)]
    let t_to_str =
      [(Failed, "failed");
      (Verified, "verified");
      (PendingVerification, "pendingVerification")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceTypeDetail =
  struct
    type t = {
      service_type: ServiceType.t option }
    let make ?service_type  () = { service_type }
    let parse xml =
      Some
        {
          service_type =
            (Util.option_bind (Xml.member "serviceType" xml)
               ServiceType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> Query.Pair ("ServiceType", (ServiceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.service_type
              (fun f -> ("service_type", (ServiceType.to_json f)))])
    let of_json j =
      {
        service_type =
          (Util.option_map (Json.lookup j "service_type") ServiceType.of_json)
      }
  end
module ImportInstanceVolumeDetailSet =
  struct
    type t = ImportInstanceVolumeDetailItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportInstanceVolumeDetailItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportInstanceVolumeDetailItem.to_query v
    let to_json v = `List (List.map ImportInstanceVolumeDetailItem.to_json v)
    let of_json j = Json.to_list ImportInstanceVolumeDetailItem.of_json j
  end
module ApplianceModeSupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Ipv6SupportValue =
  struct
    type t =
      | Enable 
      | Disable 
    let str_to_t = [("disable", Disable); ("enable", Enable)]
    let t_to_str = [(Disable, "disable"); (Enable, "enable")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteAttachment =
  struct
    type t =
      {
      resource_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option }
    let make ?resource_id  ?transit_gateway_attachment_id  ?resource_type  ()
      = { resource_id; transit_gateway_attachment_id; resource_type }
    let parse xml =
      Some
        {
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 Query.Pair
                   ("ResourceType",
                     (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_type
              (fun f ->
                 ("resource_type",
                   (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)))])
    let of_json j =
      {
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json)
      }
  end
module FpgaImageStateCode =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EnableFastSnapshotRestoreStateErrorItem =
  struct
    type t =
      {
      availability_zone: String.t option ;
      error: EnableFastSnapshotRestoreStateError.t option }
    let make ?availability_zone  ?error  () = { availability_zone; error }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               EnableFastSnapshotRestoreStateError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (EnableFastSnapshotRestoreStateError.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error", (EnableFastSnapshotRestoreStateError.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             EnableFastSnapshotRestoreStateError.of_json)
      }
  end
module PropagatingVgw =
  struct
    type t = {
      gateway_id: String.t option }
    let make ?gateway_id  () = { gateway_id }
    let parse xml =
      Some
        {
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)))])
    let of_json j =
      {
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json)
      }
  end
module Route =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      carrier_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      origin: RouteOrigin.t option ;
      state: RouteState.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?egress_only_internet_gateway_id 
      ?gateway_id  ?instance_id  ?instance_owner_id  ?nat_gateway_id 
      ?transit_gateway_id  ?local_gateway_id  ?carrier_gateway_id 
      ?network_interface_id  ?origin  ?state  ?vpc_peering_connection_id  ()
      =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        instance_owner_id;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        carrier_gateway_id;
        network_interface_id;
        origin;
        state;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "destinationPrefixListId" xml)
               String.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          carrier_gateway_id =
            (Util.option_bind (Xml.member "carrierGatewayId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          origin =
            (Util.option_bind (Xml.member "origin" xml) RouteOrigin.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) RouteState.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (RouteState.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (RouteOrigin.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> Query.Pair ("CarrierGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (RouteState.to_json f)));
           Util.option_map v.origin
             (fun f -> ("origin", (RouteOrigin.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> ("carrier_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        carrier_gateway_id =
          (Util.option_map (Json.lookup j "carrier_gateway_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        origin =
          (Util.option_map (Json.lookup j "origin") RouteOrigin.of_json);
        state = (Util.option_map (Json.lookup j "state") RouteState.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module RouteTableAssociation =
  struct
    type t =
      {
      main: Boolean.t option ;
      route_table_association_id: String.t option ;
      route_table_id: String.t option ;
      subnet_id: String.t option ;
      gateway_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?main  ?route_table_association_id  ?route_table_id  ?subnet_id 
      ?gateway_id  ?association_state  () =
      {
        main;
        route_table_association_id;
        route_table_id;
        subnet_id;
        gateway_id;
        association_state
      }
    let parse xml =
      Some
        {
          main = (Util.option_bind (Xml.member "main" xml) Boolean.parse);
          route_table_association_id =
            (Util.option_bind (Xml.member "routeTableAssociationId" xml)
               String.parse);
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Util.option_map v.route_table_association_id
             (fun f ->
                Query.Pair ("RouteTableAssociationId", (String.to_query f)));
           Util.option_map v.main
             (fun f -> Query.Pair ("Main", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Util.option_map v.route_table_association_id
             (fun f -> ("route_table_association_id", (String.to_json f)));
           Util.option_map v.main (fun f -> ("main", (Boolean.to_json f)))])
    let of_json j =
      {
        main = (Util.option_map (Json.lookup j "main") Boolean.of_json);
        route_table_association_id =
          (Util.option_map (Json.lookup j "route_table_association_id")
             String.of_json);
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module CreditSpecification =
  struct
    type t = {
      cpu_credits: String.t option }
    let make ?cpu_credits  () = { cpu_credits }
    let parse xml =
      Some
        {
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)))])
    let of_json j =
      {
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module ElasticGpuSpecificationResponseList =
  struct
    type t = ElasticGpuSpecificationResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecificationResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticGpuSpecificationResponse.to_query v
    let to_json v =
      `List (List.map ElasticGpuSpecificationResponse.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecificationResponse.of_json j
  end
module LaunchTemplateBlockDeviceMappingList =
  struct
    type t = LaunchTemplateBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMapping.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMapping.to_query v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMapping.to_json v)
    let of_json j = Json.to_list LaunchTemplateBlockDeviceMapping.of_json j
  end
module LaunchTemplateCapacityReservationSpecificationResponse =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTargetResponse.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "capacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "capacityReservationTarget" xml)
               CapacityReservationTargetResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTargetResponse.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTargetResponse.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTargetResponse.of_json)
      }
  end
module LaunchTemplateCpuOptions =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "coreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "threadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorResponseList =
  struct
    type t = LaunchTemplateElasticInferenceAcceleratorResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateElasticInferenceAcceleratorResponse.to_query v
    let to_json v =
      `List
        (List.map LaunchTemplateElasticInferenceAcceleratorResponse.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateElasticInferenceAcceleratorResponse.of_json
        j
  end
module LaunchTemplateEnclaveOptions =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module LaunchTemplateHibernationOptions =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module LaunchTemplateIamInstanceProfileSpecification =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module LaunchTemplateInstanceMarketOptions =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: LaunchTemplateSpotMarketOptions.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "marketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               LaunchTemplateSpotMarketOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             LaunchTemplateSpotMarketOptions.of_json)
      }
  end
module LaunchTemplateInstanceMetadataOptions =
  struct
    type t =
      {
      state: LaunchTemplateInstanceMetadataOptionsState.t option ;
      http_tokens: LaunchTemplateHttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: LaunchTemplateInstanceMetadataEndpointState.t option }
    let make ?state  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  () =
      { state; http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               LaunchTemplateInstanceMetadataOptionsState.parse);
          http_tokens =
            (Util.option_bind (Xml.member "httpTokens" xml)
               LaunchTemplateHttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "httpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "httpEndpoint" xml)
               LaunchTemplateInstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (LaunchTemplateInstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair
                  ("HttpTokens", (LaunchTemplateHttpTokensState.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State",
                    (LaunchTemplateInstanceMetadataOptionsState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint",
                   (LaunchTemplateInstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f ->
                ("http_tokens", (LaunchTemplateHttpTokensState.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state",
                  (LaunchTemplateInstanceMetadataOptionsState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             LaunchTemplateInstanceMetadataOptionsState.of_json);
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             LaunchTemplateHttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             LaunchTemplateInstanceMetadataEndpointState.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationList =
  struct
    type t = LaunchTemplateInstanceNetworkInterfaceSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.to_query v
    let to_json v =
      `List
        (List.map LaunchTemplateInstanceNetworkInterfaceSpecification.to_json
           v)
    let of_json j =
      Json.to_list
        LaunchTemplateInstanceNetworkInterfaceSpecification.of_json j
  end
module LaunchTemplateLicenseList =
  struct
    type t = LaunchTemplateLicenseConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfiguration.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfiguration.to_query v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfiguration.to_json v)
    let of_json j = Json.to_list LaunchTemplateLicenseConfiguration.of_json j
  end
module LaunchTemplatePlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option ;
      partition_number: Integer.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  ?partition_number  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn;
        partition_number
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "spreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "hostResourceGroupArn" xml)
               String.parse);
          partition_number =
            (Util.option_bind (Xml.member "partitionNumber" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.partition_number
              (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.host_resource_group_arn
             (fun f ->
                Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.partition_number
              (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.host_resource_group_arn
             (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json)
      }
  end
module LaunchTemplateTagSpecificationList =
  struct
    type t = LaunchTemplateTagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecification.to_query v
    let to_json v = `List (List.map LaunchTemplateTagSpecification.to_json v)
    let of_json j = Json.to_list LaunchTemplateTagSpecification.of_json j
  end
module LaunchTemplatesMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module ShutdownBehavior =
  struct
    type t =
      | Stop 
      | Terminate 
    let str_to_t = [("terminate", Terminate); ("stop", Stop)]
    let t_to_str = [(Terminate, "terminate"); (Stop, "stop")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ValueStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchTemplateEbsBlockDeviceRequest =
  struct
    type t =
      {
      encrypted: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: VolumeType.t option }
    let make ?encrypted  ?delete_on_termination  ?iops  ?kms_key_id 
      ?snapshot_id  ?volume_size  ?volume_type  () =
      {
        encrypted;
        delete_on_termination;
        iops;
        kms_key_id;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)))])
    let of_json j =
      {
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json)
      }
  end
module InstanceIpv6AddressListRequest =
  struct
    type t = InstanceIpv6AddressRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceIpv6AddressRequest.parse
           (Xml.members "InstanceIpv6Address" xml))
    let to_query v =
      Query.to_query_list InstanceIpv6AddressRequest.to_query v
    let to_json v = `List (List.map InstanceIpv6AddressRequest.to_json v)
    let of_json j = Json.to_list InstanceIpv6AddressRequest.of_json j
  end
module PoolCidrBlock =
  struct
    type t = {
      cidr: String.t option }
    let make ?cidr  () = { cidr }
    let parse xml =
      Some
        {
          cidr =
            (Util.option_bind (Xml.member "poolCidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr
              (fun f -> Query.Pair ("PoolCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr (fun f -> ("cidr", (String.to_json f)))])
    let of_json j =
      { cidr = (Util.option_map (Json.lookup j "cidr") String.of_json) }
  end
module LaunchTemplateErrorCode =
  struct
    type t =
      | LaunchTemplateIdDoesNotExist 
      | LaunchTemplateIdMalformed 
      | LaunchTemplateNameDoesNotExist 
      | LaunchTemplateNameMalformed 
      | LaunchTemplateVersionDoesNotExist 
      | UnexpectedError 
    let str_to_t =
      [("unexpectedError", UnexpectedError);
      ("launchTemplateVersionDoesNotExist",
        LaunchTemplateVersionDoesNotExist);
      ("launchTemplateNameMalformed", LaunchTemplateNameMalformed);
      ("launchTemplateNameDoesNotExist", LaunchTemplateNameDoesNotExist);
      ("launchTemplateIdMalformed", LaunchTemplateIdMalformed);
      ("launchTemplateIdDoesNotExist", LaunchTemplateIdDoesNotExist)]
    let t_to_str =
      [(UnexpectedError, "unexpectedError");
      (LaunchTemplateVersionDoesNotExist,
        "launchTemplateVersionDoesNotExist");
      (LaunchTemplateNameMalformed, "launchTemplateNameMalformed");
      (LaunchTemplateNameDoesNotExist, "launchTemplateNameDoesNotExist");
      (LaunchTemplateIdMalformed, "launchTemplateIdMalformed");
      (LaunchTemplateIdDoesNotExist, "launchTemplateIdDoesNotExist")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RunInstancesMonitoringEnabled =
  struct
    type t = {
      enabled: Boolean.t }
    let make ~enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Xml.required "enabled"
               (Util.option_bind (Xml.member "enabled" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Enabled", (Boolean.to_query v.enabled)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("enabled", (Boolean.to_json v.enabled))])
    let of_json j =
      {
        enabled =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "enabled")))
      }
  end
module DeleteQueuedReservedInstancesErrorCode =
  struct
    type t =
      | Reserved_instances_id_invalid 
      | Reserved_instances_not_in_queued_state 
      | Unexpected_error 
    let str_to_t =
      [("unexpected-error", Unexpected_error);
      ("reserved-instances-not-in-queued-state",
        Reserved_instances_not_in_queued_state);
      ("reserved-instances-id-invalid", Reserved_instances_id_invalid)]
    let t_to_str =
      [(Unexpected_error, "unexpected-error");
      (Reserved_instances_not_in_queued_state,
        "reserved-instances-not-in-queued-state");
      (Reserved_instances_id_invalid, "reserved-instances-id-invalid")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ContainerFormat =
  struct
    type t =
      | Ova 
    let str_to_t = [("ova", Ova)]
    let t_to_str = [(Ova, "ova")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportEnvironment =
  struct
    type t =
      | Citrix 
      | Vmware 
      | Microsoft 
    let str_to_t =
      [("microsoft", Microsoft); ("vmware", Vmware); ("citrix", Citrix)]
    let t_to_str =
      [(Microsoft, "microsoft"); (Vmware, "vmware"); (Citrix, "citrix")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IpPermission =
  struct
    type t =
      {
      from_port: Integer.t option ;
      ip_protocol: String.t ;
      ip_ranges: IpRangeList.t ;
      ipv6_ranges: Ipv6RangeList.t ;
      prefix_list_ids: PrefixListIdList.t ;
      to_port: Integer.t option ;
      user_id_group_pairs: UserIdGroupPairList.t }
    let make ?from_port  ~ip_protocol  ?(ip_ranges= [])  ?(ipv6_ranges= []) 
      ?(prefix_list_ids= [])  ?to_port  ?(user_id_group_pairs= [])  () =
      {
        from_port;
        ip_protocol;
        ip_ranges;
        ipv6_ranges;
        prefix_list_ids;
        to_port;
        user_id_group_pairs
      }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Xml.required "ipProtocol"
               (Util.option_bind (Xml.member "ipProtocol" xml) String.parse));
          ip_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipRanges" xml)
                  IpRangeList.parse));
          ipv6_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Ranges" xml)
                  Ipv6RangeList.parse));
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListIds" xml)
                  PrefixListIdList.parse));
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          user_id_group_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "groups" xml)
                  UserIdGroupPairList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Groups",
                   (UserIdGroupPairList.to_query v.user_id_group_pairs)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrefixListIds",
                  (PrefixListIdList.to_query v.prefix_list_ids)));
           Some
             (Query.Pair
                ("Ipv6Ranges", (Ipv6RangeList.to_query v.ipv6_ranges)));
           Some (Query.Pair ("IpRanges", (IpRangeList.to_query v.ip_ranges)));
           Some (Query.Pair ("IpProtocol", (String.to_query v.ip_protocol)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("user_id_group_pairs",
                (UserIdGroupPairList.to_json v.user_id_group_pairs));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Some
             ("prefix_list_ids",
               (PrefixListIdList.to_json v.prefix_list_ids));
           Some ("ipv6_ranges", (Ipv6RangeList.to_json v.ipv6_ranges));
           Some ("ip_ranges", (IpRangeList.to_json v.ip_ranges));
           Some ("ip_protocol", (String.to_json v.ip_protocol));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_protocol")));
        ip_ranges =
          (IpRangeList.of_json
             (Util.of_option_exn (Json.lookup j "ip_ranges")));
        ipv6_ranges =
          (Ipv6RangeList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_ranges")));
        prefix_list_ids =
          (PrefixListIdList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")));
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        user_id_group_pairs =
          (UserIdGroupPairList.of_json
             (Util.of_option_exn (Json.lookup j "user_id_group_pairs")))
      }
  end
module AssociatedTargetNetwork =
  struct
    type t =
      {
      network_id: String.t option ;
      network_type: AssociatedNetworkType.t option }
    let make ?network_id  ?network_type  () = { network_id; network_type }
    let parse xml =
      Some
        {
          network_id =
            (Util.option_bind (Xml.member "networkId" xml) String.parse);
          network_type =
            (Util.option_bind (Xml.member "networkType" xml)
               AssociatedNetworkType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f ->
                 Query.Pair
                   ("NetworkType", (AssociatedNetworkType.to_query f)));
           Util.option_map v.network_id
             (fun f -> Query.Pair ("NetworkId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_type
              (fun f -> ("network_type", (AssociatedNetworkType.to_json f)));
           Util.option_map v.network_id
             (fun f -> ("network_id", (String.to_json f)))])
    let of_json j =
      {
        network_id =
          (Util.option_map (Json.lookup j "network_id") String.of_json);
        network_type =
          (Util.option_map (Json.lookup j "network_type")
             AssociatedNetworkType.of_json)
      }
  end
module ClientVpnEndpointAttributeStatus =
  struct
    type t =
      {
      code: ClientVpnEndpointAttributeStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnEndpointAttributeStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnEndpointAttributeStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (ClientVpnEndpointAttributeStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnEndpointAttributeStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ClientVpnAuthentication =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option ;
      active_directory: DirectoryServiceAuthentication.t option ;
      mutual_authentication: CertificateAuthentication.t option ;
      federated_authentication: FederatedAuthentication.t option }
    let make ?type_  ?active_directory  ?mutual_authentication 
      ?federated_authentication  () =
      {
        type_;
        active_directory;
        mutual_authentication;
        federated_authentication
      }
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "activeDirectory" xml)
               DirectoryServiceAuthentication.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "mutualAuthentication" xml)
               CertificateAuthentication.parse);
          federated_authentication =
            (Util.option_bind (Xml.member "federatedAuthentication" xml)
               FederatedAuthentication.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.federated_authentication
              (fun f ->
                 Query.Pair
                   ("FederatedAuthentication",
                     (FederatedAuthentication.to_query f)));
           Util.option_map v.mutual_authentication
             (fun f ->
                Query.Pair
                  ("MutualAuthentication",
                    (CertificateAuthentication.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthentication.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.federated_authentication
              (fun f ->
                 ("federated_authentication",
                   (FederatedAuthentication.to_json f)));
           Util.option_map v.mutual_authentication
             (fun f ->
                ("mutual_authentication",
                  (CertificateAuthentication.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthentication.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let of_json j =
      {
        type_ =
          (Util.option_map (Json.lookup j "type_")
             ClientVpnAuthenticationType.of_json);
        active_directory =
          (Util.option_map (Json.lookup j "active_directory")
             DirectoryServiceAuthentication.of_json);
        mutual_authentication =
          (Util.option_map (Json.lookup j "mutual_authentication")
             CertificateAuthentication.of_json);
        federated_authentication =
          (Util.option_map (Json.lookup j "federated_authentication")
             FederatedAuthentication.of_json)
      }
  end
module ClientVpnEndpointStatusCode =
  struct
    type t =
      | Pending_associate 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending-associate", Pending_associate)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending_associate, "pending-associate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesRequest =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      max_price: String.t option ;
      subnet_id: String.t option ;
      availability_zone: String.t option ;
      weighted_capacity: Double.t option ;
      priority: Double.t option ;
      placement: Placement.t option }
    let make ?instance_type  ?max_price  ?subnet_id  ?availability_zone 
      ?weighted_capacity  ?priority  ?placement  () =
      {
        instance_type;
        max_price;
        subnet_id;
        availability_zone;
        weighted_capacity;
        priority;
        placement
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          weighted_capacity =
            (Util.option_bind (Xml.member "WeightedCapacity" xml)
               Double.parse);
          priority =
            (Util.option_bind (Xml.member "Priority" xml) Double.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.priority
             (fun f -> Query.Pair ("Priority", (Double.to_query f)));
           Util.option_map v.weighted_capacity
             (fun f -> Query.Pair ("WeightedCapacity", (Double.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement
              (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.priority
             (fun f -> ("priority", (Double.to_json f)));
           Util.option_map v.weighted_capacity
             (fun f -> ("weighted_capacity", (Double.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        weighted_capacity =
          (Util.option_map (Json.lookup j "weighted_capacity") Double.of_json);
        priority =
          (Util.option_map (Json.lookup j "priority") Double.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json)
      }
  end
module InternetGatewayAttachment =
  struct
    type t = {
      state: AttachmentStatus.t ;
      vpc_id: String.t }
    let make ~state  ~vpc_id  () = { state; vpc_id }
    let parse xml =
      Some
        {
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  AttachmentStatus.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (AttachmentStatus.to_query v.state)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (AttachmentStatus.to_json v.state))])
    let of_json j =
      {
        state =
          (AttachmentStatus.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      error_code: String.t option ;
      error_message: String.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        error_code =
          (Util.option_map (Json.lookup j "error_code") String.of_json);
        error_message =
          (Util.option_map (Json.lookup j "error_message") String.of_json)
      }
  end
module DescribeFleetsInstances =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      instance_ids: InstanceIdsSet.t ;
      instance_type: InstanceType.t option ;
      platform: PlatformValues.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        instance_ids =
          (InstanceIdsSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json)
      }
  end
module FleetLaunchTemplateConfig =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecification.t option ;
      overrides: FleetLaunchTemplateOverridesList.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "launchTemplateSpecification" xml)
               FleetLaunchTemplateSpecification.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "overrides" xml)
                  FleetLaunchTemplateOverridesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesList.to_query v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesList.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecification.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecification.of_json);
        overrides =
          (FleetLaunchTemplateOverridesList.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module CapacityReservationOptions =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option }
    let make ?usage_strategy  () = { usage_strategy }
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "usageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let of_json j =
      {
        usage_strategy =
          (Util.option_map (Json.lookup j "usage_strategy")
             FleetCapacityReservationUsageStrategy.of_json)
      }
  end
module FleetOnDemandAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Prioritized, "prioritized"); (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetSpotMaintenanceStrategies =
  struct
    type t = {
      capacity_rebalance: FleetSpotCapacityRebalance.t option }
    let make ?capacity_rebalance  () = { capacity_rebalance }
    let parse xml =
      Some
        {
          capacity_rebalance =
            (Util.option_bind (Xml.member "capacityRebalance" xml)
               FleetSpotCapacityRebalance.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 Query.Pair
                   ("CapacityRebalance",
                     (FleetSpotCapacityRebalance.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 ("capacity_rebalance",
                   (FleetSpotCapacityRebalance.to_json f)))])
    let of_json j =
      {
        capacity_rebalance =
          (Util.option_map (Json.lookup j "capacity_rebalance")
             FleetSpotCapacityRebalance.of_json)
      }
  end
module SpotAllocationStrategy =
  struct
    type t =
      | Lowest_price 
      | Diversified 
      | Capacity_optimized 
    let str_to_t =
      [("capacity-optimized", Capacity_optimized);
      ("diversified", Diversified);
      ("lowest-price", Lowest_price)]
    let t_to_str =
      [(Capacity_optimized, "capacity-optimized");
      (Diversified, "diversified");
      (Lowest_price, "lowest-price")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceInterruptionBehavior =
  struct
    type t =
      | Hibernate 
      | Stop 
      | Terminate 
    let str_to_t =
      [("terminate", Terminate); ("stop", Stop); ("hibernate", Hibernate)]
    let t_to_str =
      [(Terminate, "terminate"); (Stop, "stop"); (Hibernate, "hibernate")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DefaultTargetCapacityType =
  struct
    type t =
      | Spot 
      | On_demand 
    let str_to_t = [("on-demand", On_demand); ("spot", Spot)]
    let t_to_str = [(On_demand, "on-demand"); (Spot, "spot")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Diversified 
      | CapacityOptimized 
    let str_to_t =
      [("capacityOptimized", CapacityOptimized);
      ("diversified", Diversified);
      ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(CapacityOptimized, "capacityOptimized");
      (Diversified, "diversified");
      (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExcessCapacityTerminationPolicy =
  struct
    type t =
      | NoTermination 
      | Default 
    let str_to_t = [("default", Default); ("noTermination", NoTermination)]
    let t_to_str = [(Default, "default"); (NoTermination, "noTermination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetType =
  struct
    type t =
      | Request 
      | Maintain 
      | Instant 
    let str_to_t =
      [("instant", Instant); ("maintain", Maintain); ("request", Request)]
    let t_to_str =
      [(Instant, "instant"); (Maintain, "maintain"); (Request, "request")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LaunchSpecsList =
  struct
    type t = SpotFleetLaunchSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetLaunchSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SpotFleetLaunchSpecification.to_query v
    let to_json v = `List (List.map SpotFleetLaunchSpecification.to_json v)
    let of_json j = Json.to_list SpotFleetLaunchSpecification.of_json j
  end
module LaunchTemplateConfigList =
  struct
    type t = LaunchTemplateConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateConfig.to_query v
    let to_json v = `List (List.map LaunchTemplateConfig.to_json v)
    let of_json j = Json.to_list LaunchTemplateConfig.of_json j
  end
module LoadBalancersConfig =
  struct
    type t =
      {
      classic_load_balancers_config: ClassicLoadBalancersConfig.t option ;
      target_groups_config: TargetGroupsConfig.t option }
    let make ?classic_load_balancers_config  ?target_groups_config  () =
      { classic_load_balancers_config; target_groups_config }
    let parse xml =
      Some
        {
          classic_load_balancers_config =
            (Util.option_bind (Xml.member "classicLoadBalancersConfig" xml)
               ClassicLoadBalancersConfig.parse);
          target_groups_config =
            (Util.option_bind (Xml.member "targetGroupsConfig" xml)
               TargetGroupsConfig.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 Query.Pair
                   ("TargetGroupsConfig", (TargetGroupsConfig.to_query f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                Query.Pair
                  ("ClassicLoadBalancersConfig",
                    (ClassicLoadBalancersConfig.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_groups_config
              (fun f ->
                 ("target_groups_config", (TargetGroupsConfig.to_json f)));
           Util.option_map v.classic_load_balancers_config
             (fun f ->
                ("classic_load_balancers_config",
                  (ClassicLoadBalancersConfig.to_json f)))])
    let of_json j =
      {
        classic_load_balancers_config =
          (Util.option_map (Json.lookup j "classic_load_balancers_config")
             ClassicLoadBalancersConfig.of_json);
        target_groups_config =
          (Util.option_map (Json.lookup j "target_groups_config")
             TargetGroupsConfig.of_json)
      }
  end
module OnDemandAllocationStrategy =
  struct
    type t =
      | LowestPrice 
      | Prioritized 
    let str_to_t =
      [("prioritized", Prioritized); ("lowestPrice", LowestPrice)]
    let t_to_str =
      [(Prioritized, "prioritized"); (LowestPrice, "lowestPrice")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotMaintenanceStrategies =
  struct
    type t = {
      capacity_rebalance: SpotCapacityRebalance.t option }
    let make ?capacity_rebalance  () = { capacity_rebalance }
    let parse xml =
      Some
        {
          capacity_rebalance =
            (Util.option_bind (Xml.member "capacityRebalance" xml)
               SpotCapacityRebalance.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 Query.Pair
                   ("CapacityRebalance", (SpotCapacityRebalance.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 ("capacity_rebalance", (SpotCapacityRebalance.to_json f)))])
    let of_json j =
      {
        capacity_rebalance =
          (Util.option_map (Json.lookup j "capacity_rebalance")
             SpotCapacityRebalance.of_json)
      }
  end
module TagSpecificationList =
  struct
    type t = TagSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TagSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TagSpecification.to_query v
    let to_json v = `List (List.map TagSpecification.to_json v)
    let of_json j = Json.to_list TagSpecification.of_json j
  end
module AvailabilityZoneMessage =
  struct
    type t = {
      message: String.t option }
    let make ?message  () = { message }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      { message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VolumeStatusAction =
  struct
    type t =
      {
      code: String.t option ;
      description: String.t option ;
      event_id: String.t option ;
      event_type: String.t option }
    let make ?code  ?description  ?event_id  ?event_type  () =
      { code; description; event_id; event_type }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event_type
              (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json)
      }
  end
module VolumeStatusAttachmentStatus =
  struct
    type t = {
      io_performance: String.t option ;
      instance_id: String.t option }
    let make ?io_performance  ?instance_id  () =
      { io_performance; instance_id }
    let parse xml =
      Some
        {
          io_performance =
            (Util.option_bind (Xml.member "ioPerformance" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.io_performance
             (fun f -> Query.Pair ("IoPerformance", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.io_performance
             (fun f -> ("io_performance", (String.to_json f)))])
    let of_json j =
      {
        io_performance =
          (Util.option_map (Json.lookup j "io_performance") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module VolumeStatusEvent =
  struct
    type t =
      {
      description: String.t option ;
      event_id: String.t option ;
      event_type: String.t option ;
      not_after: DateTime.t option ;
      not_before: DateTime.t option ;
      instance_id: String.t option }
    let make ?description  ?event_id  ?event_type  ?not_after  ?not_before 
      ?instance_id  () =
      { description; event_id; event_type; not_after; not_before; instance_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          event_id =
            (Util.option_bind (Xml.member "eventId" xml) String.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) String.parse);
          not_after =
            (Util.option_bind (Xml.member "notAfter" xml) DateTime.parse);
          not_before =
            (Util.option_bind (Xml.member "notBefore" xml) DateTime.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.not_before
             (fun f -> Query.Pair ("NotBefore", (DateTime.to_query f)));
           Util.option_map v.not_after
             (fun f -> Query.Pair ("NotAfter", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (String.to_query f)));
           Util.option_map v.event_id
             (fun f -> Query.Pair ("EventId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.not_before
             (fun f -> ("not_before", (DateTime.to_json f)));
           Util.option_map v.not_after
             (fun f -> ("not_after", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (String.to_json f)));
           Util.option_map v.event_id
             (fun f -> ("event_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        event_id =
          (Util.option_map (Json.lookup j "event_id") String.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") String.of_json);
        not_after =
          (Util.option_map (Json.lookup j "not_after") DateTime.of_json);
        not_before =
          (Util.option_map (Json.lookup j "not_before") DateTime.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module VolumeStatusDetailsList =
  struct
    type t = VolumeStatusDetails.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusDetails.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusDetails.to_query v
    let to_json v = `List (List.map VolumeStatusDetails.to_json v)
    let of_json j = Json.to_list VolumeStatusDetails.of_json j
  end
module VolumeStatusInfoStatus =
  struct
    type t =
      | Ok 
      | Impaired 
      | Insufficient_data 
    let str_to_t =
      [("insufficient-data", Insufficient_data);
      ("impaired", Impaired);
      ("ok", Ok)]
    let t_to_str =
      [(Insufficient_data, "insufficient-data");
      (Impaired, "impaired");
      (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ClientVpnAuthorizationRuleStatusCode =
  struct
    type t =
      | Authorizing 
      | Active 
      | Failed 
      | Revoking 
    let str_to_t =
      [("revoking", Revoking);
      ("failed", Failed);
      ("active", Active);
      ("authorizing", Authorizing)]
    let t_to_str =
      [(Revoking, "revoking");
      (Failed, "failed");
      (Active, "active");
      (Authorizing, "authorizing")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module UnsuccessfulInstanceCreditSpecificationErrorCode =
  struct
    type t =
      | InvalidInstanceID_Malformed 
      | InvalidInstanceID_NotFound 
      | IncorrectInstanceState 
      | InstanceCreditSpecification_NotSupported 
    let str_to_t =
      [("InstanceCreditSpecification.NotSupported",
         InstanceCreditSpecification_NotSupported);
      ("IncorrectInstanceState", IncorrectInstanceState);
      ("InvalidInstanceID.NotFound", InvalidInstanceID_NotFound);
      ("InvalidInstanceID.Malformed", InvalidInstanceID_Malformed)]
    let t_to_str =
      [(InstanceCreditSpecification_NotSupported,
         "InstanceCreditSpecification.NotSupported");
      (IncorrectInstanceState, "IncorrectInstanceState");
      (InvalidInstanceID_NotFound, "InvalidInstanceID.NotFound");
      (InvalidInstanceID_Malformed, "InvalidInstanceID.Malformed")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PricingDetail =
  struct
    type t = {
      count: Integer.t option ;
      price: Double.t option }
    let make ?count  ?price  () = { count; price }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.price
              (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json)
      }
  end
module Instance =
  struct
    type t =
      {
      ami_launch_index: Integer.t ;
      image_id: String.t ;
      instance_id: String.t ;
      instance_type: InstanceType.t ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      launch_time: DateTime.t ;
      monitoring: Monitoring.t ;
      placement: Placement.t ;
      platform: PlatformValues.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      product_codes: ProductCodeList.t ;
      public_dns_name: String.t option ;
      public_ip_address: String.t option ;
      ramdisk_id: String.t option ;
      state: InstanceState.t ;
      state_transition_reason: String.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      architecture: ArchitectureValues.t ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      client_token: String.t option ;
      ebs_optimized: Boolean.t option ;
      ena_support: Boolean.t option ;
      hypervisor: HypervisorType.t ;
      iam_instance_profile: IamInstanceProfile.t option ;
      instance_lifecycle: InstanceLifecycleType.t option ;
      elastic_gpu_associations: ElasticGpuAssociationList.t ;
      elastic_inference_accelerator_associations:
        ElasticInferenceAcceleratorAssociationList.t ;
      network_interfaces: InstanceNetworkInterfaceList.t ;
      outpost_arn: String.t option ;
      root_device_name: String.t option ;
      root_device_type: DeviceType.t ;
      security_groups: GroupIdentifierList.t ;
      source_dest_check: Boolean.t option ;
      spot_instance_request_id: String.t option ;
      sriov_net_support: String.t option ;
      state_reason: StateReason.t option ;
      tags: TagList.t ;
      virtualization_type: VirtualizationType.t ;
      cpu_options: CpuOptions.t option ;
      capacity_reservation_id: String.t option ;
      capacity_reservation_specification:
        CapacityReservationSpecificationResponse.t option ;
      hibernation_options: HibernationOptions.t option ;
      licenses: LicenseList.t ;
      metadata_options: InstanceMetadataOptionsResponse.t option ;
      enclave_options: EnclaveOptions.t option }
    let make ~ami_launch_index  ~image_id  ~instance_id  ~instance_type 
      ?kernel_id  ?key_name  ~launch_time  ~monitoring  ~placement  ?platform
       ?private_dns_name  ?private_ip_address  ?(product_codes= []) 
      ?public_dns_name  ?public_ip_address  ?ramdisk_id  ~state 
      ?state_transition_reason  ?subnet_id  ?vpc_id  ~architecture 
      ?(block_device_mappings= [])  ?client_token  ?ebs_optimized 
      ?ena_support  ~hypervisor  ?iam_instance_profile  ?instance_lifecycle 
      ?(elastic_gpu_associations= []) 
      ?(elastic_inference_accelerator_associations= []) 
      ?(network_interfaces= [])  ?outpost_arn  ?root_device_name 
      ~root_device_type  ?(security_groups= [])  ?source_dest_check 
      ?spot_instance_request_id  ?sriov_net_support  ?state_reason  ?(tags=
      [])  ~virtualization_type  ?cpu_options  ?capacity_reservation_id 
      ?capacity_reservation_specification  ?hibernation_options  ?(licenses=
      [])  ?metadata_options  ?enclave_options  () =
      {
        ami_launch_index;
        image_id;
        instance_id;
        instance_type;
        kernel_id;
        key_name;
        launch_time;
        monitoring;
        placement;
        platform;
        private_dns_name;
        private_ip_address;
        product_codes;
        public_dns_name;
        public_ip_address;
        ramdisk_id;
        state;
        state_transition_reason;
        subnet_id;
        vpc_id;
        architecture;
        block_device_mappings;
        client_token;
        ebs_optimized;
        ena_support;
        hypervisor;
        iam_instance_profile;
        instance_lifecycle;
        elastic_gpu_associations;
        elastic_inference_accelerator_associations;
        network_interfaces;
        outpost_arn;
        root_device_name;
        root_device_type;
        security_groups;
        source_dest_check;
        spot_instance_request_id;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type;
        cpu_options;
        capacity_reservation_id;
        capacity_reservation_specification;
        hibernation_options;
        licenses;
        metadata_options;
        enclave_options
      }
    let parse xml =
      Some
        {
          ami_launch_index =
            (Xml.required "amiLaunchIndex"
               (Util.option_bind (Xml.member "amiLaunchIndex" xml)
                  Integer.parse));
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          instance_type =
            (Xml.required "instanceType"
               (Util.option_bind (Xml.member "instanceType" xml)
                  InstanceType.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          launch_time =
            (Xml.required "launchTime"
               (Util.option_bind (Xml.member "launchTime" xml) DateTime.parse));
          monitoring =
            (Xml.required "monitoring"
               (Util.option_bind (Xml.member "monitoring" xml)
                  Monitoring.parse));
          placement =
            (Xml.required "placement"
               (Util.option_bind (Xml.member "placement" xml) Placement.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          public_dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          public_ip_address =
            (Util.option_bind (Xml.member "ipAddress" xml) String.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "instanceState"
               (Util.option_bind (Xml.member "instanceState" xml)
                  InstanceState.parse));
          state_transition_reason =
            (Util.option_bind (Xml.member "reason" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          instance_lifecycle =
            (Util.option_bind (Xml.member "instanceLifecycle" xml)
               InstanceLifecycleType.parse);
          elastic_gpu_associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuAssociationSet" xml)
                  ElasticGpuAssociationList.parse));
          elastic_inference_accelerator_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorAssociationSet" xml)
                  ElasticInferenceAcceleratorAssociationList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceList.parse));
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse));
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml) CpuOptions.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               CapacityReservationSpecificationResponse.parse);
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               HibernationOptions.parse);
          licenses =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LicenseList.parse));
          metadata_options =
            (Util.option_bind (Xml.member "metadataOptions" xml)
               InstanceMetadataOptionsResponse.parse);
          enclave_options =
            (Util.option_bind (Xml.member "enclaveOptions" xml)
               EnclaveOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 Query.Pair ("EnclaveOptions", (EnclaveOptions.to_query f)));
           Util.option_map v.metadata_options
             (fun f ->
                Query.Pair
                  ("MetadataOptions",
                    (InstanceMetadataOptionsResponse.to_query f)));
           Some
             (Query.Pair ("LicenseSet", (LicenseList.to_query v.licenses)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions", (HibernationOptions.to_query f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (CapacityReservationSpecificationResponse.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.cpu_options
             (fun f -> Query.Pair ("CpuOptions", (CpuOptions.to_query f)));
           Some
             (Query.Pair
                ("VirtualizationType",
                  (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceList.to_query v.network_interfaces)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorAssociationSet",
                  (ElasticInferenceAcceleratorAssociationList.to_query
                     v.elastic_inference_accelerator_associations)));
           Some
             (Query.Pair
                ("ElasticGpuAssociationSet",
                  (ElasticGpuAssociationList.to_query
                     v.elastic_gpu_associations)));
           Util.option_map v.instance_lifecycle
             (fun f ->
                Query.Pair
                  ("InstanceLifecycle", (InstanceLifecycleType.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f -> Query.Pair ("Reason", (String.to_query f)));
           Some
             (Query.Pair ("InstanceState", (InstanceState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.public_ip_address
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Util.option_map v.public_dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("Placement", (Placement.to_query v.placement)));
           Some
             (Query.Pair ("Monitoring", (Monitoring.to_query v.monitoring)));
           Some
             (Query.Pair ("LaunchTime", (DateTime.to_query v.launch_time)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceType", (InstanceType.to_query v.instance_type)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("AmiLaunchIndex", (Integer.to_query v.ami_launch_index)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f -> ("enclave_options", (EnclaveOptions.to_json f)));
           Util.option_map v.metadata_options
             (fun f ->
                ("metadata_options",
                  (InstanceMetadataOptionsResponse.to_json f)));
           Some ("licenses", (LicenseList.to_json v.licenses));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options", (HibernationOptions.to_json f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (CapacityReservationSpecificationResponse.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (CpuOptions.to_json f)));
           Some
             ("virtualization_type",
               (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceList.to_json v.network_interfaces));
           Some
             ("elastic_inference_accelerator_associations",
               (ElasticInferenceAcceleratorAssociationList.to_json
                  v.elastic_inference_accelerator_associations));
           Some
             ("elastic_gpu_associations",
               (ElasticGpuAssociationList.to_json v.elastic_gpu_associations));
           Util.option_map v.instance_lifecycle
             (fun f ->
                ("instance_lifecycle", (InstanceLifecycleType.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("architecture", (ArchitectureValues.to_json v.architecture));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Some ("state", (InstanceState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.public_ip_address
             (fun f -> ("public_ip_address", (String.to_json f)));
           Util.option_map v.public_dns_name
             (fun f -> ("public_dns_name", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("placement", (Placement.to_json v.placement));
           Some ("monitoring", (Monitoring.to_json v.monitoring));
           Some ("launch_time", (DateTime.to_json v.launch_time));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("instance_type", (InstanceType.to_json v.instance_type));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("image_id", (String.to_json v.image_id));
           Some ("ami_launch_index", (Integer.to_json v.ami_launch_index))])
    let of_json j =
      {
        ami_launch_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "ami_launch_index")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_type =
          (InstanceType.of_json
             (Util.of_option_exn (Json.lookup j "instance_type")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        launch_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "launch_time")));
        monitoring =
          (Monitoring.of_json
             (Util.of_option_exn (Json.lookup j "monitoring")));
        placement =
          (Placement.of_json (Util.of_option_exn (Json.lookup j "placement")));
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        public_dns_name =
          (Util.option_map (Json.lookup j "public_dns_name") String.of_json);
        public_ip_address =
          (Util.option_map (Json.lookup j "public_ip_address") String.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        state =
          (InstanceState.of_json (Util.of_option_exn (Json.lookup j "state")));
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")));
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfile.of_json);
        instance_lifecycle =
          (Util.option_map (Json.lookup j "instance_lifecycle")
             InstanceLifecycleType.of_json);
        elastic_gpu_associations =
          (ElasticGpuAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_associations")));
        elastic_inference_accelerator_associations =
          (ElasticInferenceAcceleratorAssociationList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerator_associations")));
        network_interfaces =
          (InstanceNetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")));
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options") CpuOptions.of_json);
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             CapacityReservationSpecificationResponse.of_json);
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             HibernationOptions.of_json);
        licenses =
          (LicenseList.of_json
             (Util.of_option_exn (Json.lookup j "licenses")));
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             InstanceMetadataOptionsResponse.of_json);
        enclave_options =
          (Util.option_map (Json.lookup j "enclave_options")
             EnclaveOptions.of_json)
      }
  end
module PublicIpv4PoolRange =
  struct
    type t =
      {
      first_address: String.t option ;
      last_address: String.t option ;
      address_count: Integer.t option ;
      available_address_count: Integer.t option }
    let make ?first_address  ?last_address  ?address_count 
      ?available_address_count  () =
      { first_address; last_address; address_count; available_address_count }
    let parse xml =
      Some
        {
          first_address =
            (Util.option_bind (Xml.member "firstAddress" xml) String.parse);
          last_address =
            (Util.option_bind (Xml.member "lastAddress" xml) String.parse);
          address_count =
            (Util.option_bind (Xml.member "addressCount" xml) Integer.parse);
          available_address_count =
            (Util.option_bind (Xml.member "availableAddressCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f ->
                 Query.Pair ("AvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.address_count
             (fun f -> Query.Pair ("AddressCount", (Integer.to_query f)));
           Util.option_map v.last_address
             (fun f -> Query.Pair ("LastAddress", (String.to_query f)));
           Util.option_map v.first_address
             (fun f -> Query.Pair ("FirstAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_address_count
              (fun f -> ("available_address_count", (Integer.to_json f)));
           Util.option_map v.address_count
             (fun f -> ("address_count", (Integer.to_json f)));
           Util.option_map v.last_address
             (fun f -> ("last_address", (String.to_json f)));
           Util.option_map v.first_address
             (fun f -> ("first_address", (String.to_json f)))])
    let of_json j =
      {
        first_address =
          (Util.option_map (Json.lookup j "first_address") String.of_json);
        last_address =
          (Util.option_map (Json.lookup j "last_address") String.of_json);
        address_count =
          (Util.option_map (Json.lookup j "address_count") Integer.of_json);
        available_address_count =
          (Util.option_map (Json.lookup j "available_address_count")
             Integer.of_json)
      }
  end
module VpcCidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      cidr_block: String.t option ;
      cidr_block_state: VpcCidrBlockState.t option }
    let make ?association_id  ?cidr_block  ?cidr_block_state  () =
      { association_id; cidr_block; cidr_block_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          cidr_block_state =
            (Util.option_bind (Xml.member "cidrBlockState" xml)
               VpcCidrBlockState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f ->
                 Query.Pair
                   ("CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cidr_block_state
              (fun f -> ("cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        cidr_block_state =
          (Util.option_map (Json.lookup j "cidr_block_state")
             VpcCidrBlockState.of_json)
      }
  end
module VpcIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      ipv6_cidr_block: String.t option ;
      ipv6_cidr_block_state: VpcCidrBlockState.t option ;
      network_border_group: String.t option ;
      ipv6_pool: String.t option }
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state 
      ?network_border_group  ?ipv6_pool  () =
      {
        association_id;
        ipv6_cidr_block;
        ipv6_cidr_block_state;
        network_border_group;
        ipv6_pool
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               VpcCidrBlockState.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          ipv6_pool =
            (Util.option_bind (Xml.member "ipv6Pool" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_pool
              (fun f -> Query.Pair ("Ipv6Pool", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockState", (VpcCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_pool
              (fun f -> ("ipv6_pool", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_state
             (fun f ->
                ("ipv6_cidr_block_state", (VpcCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        ipv6_cidr_block_state =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_state")
             VpcCidrBlockState.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        ipv6_pool =
          (Util.option_map (Json.lookup j "ipv6_pool") String.of_json)
      }
  end
module SubnetIpv6CidrBlockAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      ipv6_cidr_block: String.t option ;
      ipv6_cidr_block_state: SubnetCidrBlockState.t option }
    let make ?association_id  ?ipv6_cidr_block  ?ipv6_cidr_block_state  () =
      { association_id; ipv6_cidr_block; ipv6_cidr_block_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          ipv6_cidr_block_state =
            (Util.option_bind (Xml.member "ipv6CidrBlockState" xml)
               SubnetCidrBlockState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 Query.Pair
                   ("Ipv6CidrBlockState", (SubnetCidrBlockState.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block_state
              (fun f ->
                 ("ipv6_cidr_block_state", (SubnetCidrBlockState.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        ipv6_cidr_block_state =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_state")
             SubnetCidrBlockState.of_json)
      }
  end
module ElasticGpuStatus =
  struct
    type t =
      | OK 
      | IMPAIRED 
    let str_to_t = [("IMPAIRED", IMPAIRED); ("OK", OK)]
    let t_to_str = [(IMPAIRED, "IMPAIRED"); (OK, "OK")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportImageLicenseConfigurationResponse =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "licenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module SnapshotDetail =
  struct
    type t =
      {
      description: String.t option ;
      device_name: String.t option ;
      disk_image_size: Double.t option ;
      format: String.t option ;
      progress: String.t option ;
      snapshot_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option }
    let make ?description  ?device_name  ?disk_image_size  ?format  ?progress
       ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket  () =
      {
        description;
        device_name;
        disk_image_size;
        format;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json)
      }
  end
module ScheduledInstancesEbs =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      encrypted: Boolean.t option ;
      iops: Integer.t option ;
      snapshot_id: String.t option ;
      volume_size: Integer.t option ;
      volume_type: String.t option }
    let make ?delete_on_termination  ?encrypted  ?iops  ?snapshot_id 
      ?volume_size  ?volume_type  () =
      {
        delete_on_termination;
        encrypted;
        iops;
        snapshot_id;
        volume_size;
        volume_type
      }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_size =
            (Util.option_bind (Xml.member "VolumeSize" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> Query.Pair ("VolumeType", (String.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_type
              (fun f -> ("volume_type", (String.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") String.of_json)
      }
  end
module PrivateIpAddressConfigSet =
  struct
    type t = ScheduledInstancesPrivateIpAddressConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesPrivateIpAddressConfig.parse
           (Xml.members "PrivateIpAddressConfigSet" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesPrivateIpAddressConfig.to_query v
    let to_json v =
      `List (List.map ScheduledInstancesPrivateIpAddressConfig.to_json v)
    let of_json j =
      Json.to_list ScheduledInstancesPrivateIpAddressConfig.of_json j
  end
module ScheduledInstancesIpv6AddressList =
  struct
    type t = ScheduledInstancesIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesIpv6Address.parse
           (Xml.members "Ipv6Address" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesIpv6Address.to_query v
    let to_json v = `List (List.map ScheduledInstancesIpv6Address.to_json v)
    let of_json j = Json.to_list ScheduledInstancesIpv6Address.of_json j
  end
module ScheduledInstancesSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NatGatewayAddress =
  struct
    type t =
      {
      allocation_id: String.t option ;
      network_interface_id: String.t option ;
      private_ip: String.t option ;
      public_ip: String.t option }
    let make ?allocation_id  ?network_interface_id  ?private_ip  ?public_ip 
      () = { allocation_id; network_interface_id; private_ip; public_ip }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip =
            (Util.option_bind (Xml.member "privateIp" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.private_ip
             (fun f -> Query.Pair ("PrivateIp", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.private_ip
             (fun f -> ("private_ip", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip =
          (Util.option_map (Json.lookup j "private_ip") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module DhcpConfigurationList =
  struct
    type t = DhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpConfiguration.to_query v
    let to_json v = `List (List.map DhcpConfiguration.to_json v)
    let of_json j = Json.to_list DhcpConfiguration.of_json j
  end
module GatewayType =
  struct
    type t =
      | Ipsec_1 
    let str_to_t = [("ipsec.1", Ipsec_1)]
    let t_to_str = [(Ipsec_1, "ipsec.1")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcAttachmentList =
  struct
    type t = VpcAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcAttachment.to_query v
    let to_json v = `List (List.map VpcAttachment.to_json v)
    let of_json j = Json.to_list VpcAttachment.of_json j
  end
module TransitGatewayPropagationState =
  struct
    type t =
      | Enabling 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationInstancePlatform =
  struct
    type t =
      | Linux_UNIX 
      | Red_Hat_Enterprise_Linux 
      | SUSE_Linux 
      | Windows 
      | Windows_with_SQL_Server 
      | Windows_with_SQL_Server_Enterprise 
      | Windows_with_SQL_Server_Standard 
      | Windows_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Standard 
      | Linux_with_SQL_Server_Web 
      | Linux_with_SQL_Server_Enterprise 
    let str_to_t =
      [("Linux with SQL Server Enterprise", Linux_with_SQL_Server_Enterprise);
      ("Linux with SQL Server Web", Linux_with_SQL_Server_Web);
      ("Linux with SQL Server Standard", Linux_with_SQL_Server_Standard);
      ("Windows with SQL Server Web", Windows_with_SQL_Server_Web);
      ("Windows with SQL Server Standard", Windows_with_SQL_Server_Standard);
      ("Windows with SQL Server Enterprise",
        Windows_with_SQL_Server_Enterprise);
      ("Windows with SQL Server", Windows_with_SQL_Server);
      ("Windows", Windows);
      ("SUSE Linux", SUSE_Linux);
      ("Red Hat Enterprise Linux", Red_Hat_Enterprise_Linux);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Linux_with_SQL_Server_Enterprise, "Linux with SQL Server Enterprise");
      (Linux_with_SQL_Server_Web, "Linux with SQL Server Web");
      (Linux_with_SQL_Server_Standard, "Linux with SQL Server Standard");
      (Windows_with_SQL_Server_Web, "Windows with SQL Server Web");
      (Windows_with_SQL_Server_Standard, "Windows with SQL Server Standard");
      (Windows_with_SQL_Server_Enterprise,
        "Windows with SQL Server Enterprise");
      (Windows_with_SQL_Server, "Windows with SQL Server");
      (Windows, "Windows");
      (SUSE_Linux, "SUSE Linux");
      (Red_Hat_Enterprise_Linux, "Red Hat Enterprise Linux");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationState =
  struct
    type t =
      | Active 
      | Expired 
      | Cancelled 
      | Pending 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("pending", Pending);
      ("cancelled", Cancelled);
      ("expired", Expired);
      ("active", Active)]
    let t_to_str =
      [(Failed, "failed");
      (Pending, "pending");
      (Cancelled, "cancelled");
      (Expired, "expired");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CapacityReservationTenancy =
  struct
    type t =
      | Default 
      | Dedicated 
    let str_to_t = [("dedicated", Dedicated); ("default", Default)]
    let t_to_str = [(Dedicated, "dedicated"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EndDateType =
  struct
    type t =
      | Unlimited 
      | Limited 
    let str_to_t = [("limited", Limited); ("unlimited", Unlimited)]
    let t_to_str = [(Limited, "limited"); (Unlimited, "unlimited")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceMatchCriteria =
  struct
    type t =
      | Open 
      | Targeted 
    let str_to_t = [("targeted", Targeted); ("open", Open)]
    let t_to_str = [(Targeted, "targeted"); (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservedInstancesModificationResultList =
  struct
    type t = ReservedInstancesModificationResult.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModificationResult.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModificationResult.to_query v
    let to_json v =
      `List (List.map ReservedInstancesModificationResult.to_json v)
    let of_json j =
      Json.to_list ReservedInstancesModificationResult.of_json j
  end
module ReservedIntancesIds =
  struct
    type t = ReservedInstancesId.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesId.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesId.to_query v
    let to_json v = `List (List.map ReservedInstancesId.to_json v)
    let of_json j = Json.to_list ReservedInstancesId.of_json j
  end
module PlacementGroupState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PlacementStrategy =
  struct
    type t =
      | Cluster 
      | Spread 
      | Partition 
    let str_to_t =
      [("partition", Partition); ("spread", Spread); ("cluster", Cluster)]
    let t_to_str =
      [(Partition, "partition"); (Spread, "spread"); (Cluster, "cluster")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ValidationError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module EventInformation =
  struct
    type t =
      {
      event_description: String.t option ;
      event_sub_type: String.t option ;
      instance_id: String.t option }
    let make ?event_description  ?event_sub_type  ?instance_id  () =
      { event_description; event_sub_type; instance_id }
    let parse xml =
      Some
        {
          event_description =
            (Util.option_bind (Xml.member "eventDescription" xml)
               String.parse);
          event_sub_type =
            (Util.option_bind (Xml.member "eventSubType" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.event_sub_type
             (fun f -> Query.Pair ("EventSubType", (String.to_query f)));
           Util.option_map v.event_description
             (fun f -> Query.Pair ("EventDescription", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.event_sub_type
             (fun f -> ("event_sub_type", (String.to_json f)));
           Util.option_map v.event_description
             (fun f -> ("event_description", (String.to_json f)))])
    let of_json j =
      {
        event_description =
          (Util.option_map (Json.lookup j "event_description") String.of_json);
        event_sub_type =
          (Util.option_map (Json.lookup j "event_sub_type") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module FleetEventType =
  struct
    type t =
      | Instance_change 
      | Fleet_change 
      | Service_error 
    let str_to_t =
      [("service-error", Service_error);
      ("fleet-change", Fleet_change);
      ("instance-change", Instance_change)]
    let t_to_str =
      [(Service_error, "service-error");
      (Fleet_change, "fleet-change");
      (Instance_change, "instance-change")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PaymentOption =
  struct
    type t =
      | AllUpfront 
      | PartialUpfront 
      | NoUpfront 
    let str_to_t =
      [("NoUpfront", NoUpfront);
      ("PartialUpfront", PartialUpfront);
      ("AllUpfront", AllUpfront)]
    let t_to_str =
      [(NoUpfront, "NoUpfront");
      (PartialUpfront, "PartialUpfront");
      (AllUpfront, "AllUpfront")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservationState =
  struct
    type t =
      | Payment_pending 
      | Payment_failed 
      | Active 
      | Retired 
    let str_to_t =
      [("retired", Retired);
      ("active", Active);
      ("payment-failed", Payment_failed);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Retired, "retired");
      (Active, "active");
      (Payment_failed, "payment-failed");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResponseHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchPermission =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module DnsEntrySet =
  struct
    type t = DnsEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DnsEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DnsEntry.to_query v
    let to_json v = `List (List.map DnsEntry.to_json v)
    let of_json j = Json.to_list DnsEntry.of_json j
  end
module State =
  struct
    type t =
      | PendingAcceptance 
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Rejected 
      | Failed 
      | Expired 
    let str_to_t =
      [("Expired", Expired);
      ("Failed", Failed);
      ("Rejected", Rejected);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending);
      ("PendingAcceptance", PendingAcceptance)]
    let t_to_str =
      [(Expired, "Expired");
      (Failed, "Failed");
      (Rejected, "Rejected");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending");
      (PendingAcceptance, "PendingAcceptance")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportTaskS3Location =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_prefix: String.t option }
    let make ?s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module UnsuccessfulItemError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TrafficMirrorFilterRuleList =
  struct
    type t = TrafficMirrorFilterRule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorFilterRule.to_query v
    let to_json v = `List (List.map TrafficMirrorFilterRule.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilterRule.of_json j
  end
module TrafficMirrorNetworkServiceList =
  struct
    type t = TrafficMirrorNetworkService.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorNetworkService.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TrafficMirrorNetworkService.to_query v
    let to_json v = `List (List.map TrafficMirrorNetworkService.to_json v)
    let of_json j = Json.to_list TrafficMirrorNetworkService.of_json j
  end
module TransitGatewayOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option ;
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option ;
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option ;
      association_default_route_table_id: String.t option ;
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option ;
      propagation_default_route_table_id: String.t option ;
      vpn_ecmp_support: VpnEcmpSupportValue.t option ;
      dns_support: DnsSupportValue.t option ;
      multicast_support: MulticastSupportValue.t option }
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?association_default_route_table_id 
      ?default_route_table_propagation  ?propagation_default_route_table_id 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        association_default_route_table_id;
        default_route_table_propagation;
        propagation_default_route_table_id;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "autoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "defaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          association_default_route_table_id =
            (Util.option_bind
               (Xml.member "associationDefaultRouteTableId" xml) String.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "defaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          propagation_default_route_table_id =
            (Util.option_bind
               (Xml.member "propagationDefaultRouteTableId" xml) String.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "vpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "multicastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                Query.Pair
                  ("PropagationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                Query.Pair
                  ("AssociationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.propagation_default_route_table_id
             (fun f ->
                ("propagation_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                ("association_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let of_json j =
      {
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        auto_accept_shared_attachments =
          (Util.option_map (Json.lookup j "auto_accept_shared_attachments")
             AutoAcceptSharedAttachmentsValue.of_json);
        default_route_table_association =
          (Util.option_map (Json.lookup j "default_route_table_association")
             DefaultRouteTableAssociationValue.of_json);
        association_default_route_table_id =
          (Util.option_map
             (Json.lookup j "association_default_route_table_id")
             String.of_json);
        default_route_table_propagation =
          (Util.option_map (Json.lookup j "default_route_table_propagation")
             DefaultRouteTablePropagationValue.of_json);
        propagation_default_route_table_id =
          (Util.option_map
             (Json.lookup j "propagation_default_route_table_id")
             String.of_json);
        vpn_ecmp_support =
          (Util.option_map (Json.lookup j "vpn_ecmp_support")
             VpnEcmpSupportValue.of_json);
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        multicast_support =
          (Util.option_map (Json.lookup j "multicast_support")
             MulticastSupportValue.of_json)
      }
  end
module TransitGatewayState =
  struct
    type t =
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module CertificateAuthenticationRequest =
  struct
    type t = {
      client_root_certificate_chain_arn: String.t option }
    let make ?client_root_certificate_chain_arn  () =
      { client_root_certificate_chain_arn }
    let parse xml =
      Some
        {
          client_root_certificate_chain_arn =
            (Util.option_bind
               (Xml.member "ClientRootCertificateChainArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 Query.Pair
                   ("ClientRootCertificateChainArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_root_certificate_chain_arn
              (fun f ->
                 ("client_root_certificate_chain_arn", (String.to_json f)))])
    let of_json j =
      {
        client_root_certificate_chain_arn =
          (Util.option_map
             (Json.lookup j "client_root_certificate_chain_arn")
             String.of_json)
      }
  end
module DirectoryServiceAuthenticationRequest =
  struct
    type t = {
      directory_id: String.t option }
    let make ?directory_id  () = { directory_id }
    let parse xml =
      Some
        {
          directory_id =
            (Util.option_bind (Xml.member "DirectoryId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> Query.Pair ("DirectoryId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.directory_id
              (fun f -> ("directory_id", (String.to_json f)))])
    let of_json j =
      {
        directory_id =
          (Util.option_map (Json.lookup j "directory_id") String.of_json)
      }
  end
module FederatedAuthenticationRequest =
  struct
    type t =
      {
      s_a_m_l_provider_arn: String.t option ;
      self_service_s_a_m_l_provider_arn: String.t option }
    let make ?s_a_m_l_provider_arn  ?self_service_s_a_m_l_provider_arn  () =
      { s_a_m_l_provider_arn; self_service_s_a_m_l_provider_arn }
    let parse xml =
      Some
        {
          s_a_m_l_provider_arn =
            (Util.option_bind (Xml.member "SAMLProviderArn" xml) String.parse);
          self_service_s_a_m_l_provider_arn =
            (Util.option_bind (Xml.member "SelfServiceSAMLProviderArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.self_service_s_a_m_l_provider_arn
              (fun f ->
                 Query.Pair
                   ("SelfServiceSAMLProviderArn", (String.to_query f)));
           Util.option_map v.s_a_m_l_provider_arn
             (fun f -> Query.Pair ("SAMLProviderArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.self_service_s_a_m_l_provider_arn
              (fun f ->
                 ("self_service_s_a_m_l_provider_arn", (String.to_json f)));
           Util.option_map v.s_a_m_l_provider_arn
             (fun f -> ("s_a_m_l_provider_arn", (String.to_json f)))])
    let of_json j =
      {
        s_a_m_l_provider_arn =
          (Util.option_map (Json.lookup j "s_a_m_l_provider_arn")
             String.of_json);
        self_service_s_a_m_l_provider_arn =
          (Util.option_map
             (Json.lookup j "self_service_s_a_m_l_provider_arn")
             String.of_json)
      }
  end
module PrefixListState =
  struct
    type t =
      | Create_in_progress 
      | Create_complete 
      | Create_failed 
      | Modify_in_progress 
      | Modify_complete 
      | Modify_failed 
      | Restore_in_progress 
      | Restore_complete 
      | Restore_failed 
      | Delete_in_progress 
      | Delete_complete 
      | Delete_failed 
    let str_to_t =
      [("delete-failed", Delete_failed);
      ("delete-complete", Delete_complete);
      ("delete-in-progress", Delete_in_progress);
      ("restore-failed", Restore_failed);
      ("restore-complete", Restore_complete);
      ("restore-in-progress", Restore_in_progress);
      ("modify-failed", Modify_failed);
      ("modify-complete", Modify_complete);
      ("modify-in-progress", Modify_in_progress);
      ("create-failed", Create_failed);
      ("create-complete", Create_complete);
      ("create-in-progress", Create_in_progress)]
    let t_to_str =
      [(Delete_failed, "delete-failed");
      (Delete_complete, "delete-complete");
      (Delete_in_progress, "delete-in-progress");
      (Restore_failed, "restore-failed");
      (Restore_complete, "restore-complete");
      (Restore_in_progress, "restore-in-progress");
      (Modify_failed, "modify-failed");
      (Modify_complete, "modify-complete");
      (Modify_in_progress, "modify-in-progress");
      (Create_failed, "create-failed");
      (Create_complete, "create-complete");
      (Create_in_progress, "create-in-progress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCountList =
  struct
    type t = InstanceCount.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map InstanceCount.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceCount.to_query v
    let to_json v = `List (List.map InstanceCount.to_json v)
    let of_json j = Json.to_list InstanceCount.of_json j
  end
module ListingStatus =
  struct
    type t =
      | Active 
      | Pending 
      | Cancelled 
      | Closed 
    let str_to_t =
      [("closed", Closed);
      ("cancelled", Cancelled);
      ("pending", Pending);
      ("active", Active)]
    let t_to_str =
      [(Closed, "closed");
      (Cancelled, "cancelled");
      (Pending, "pending");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PriceScheduleList =
  struct
    type t = PriceSchedule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PriceSchedule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PriceSchedule.to_query v
    let to_json v = `List (List.map PriceSchedule.to_json v)
    let of_json j = Json.to_list PriceSchedule.of_json j
  end
module ClientVpnConnectionStatus =
  struct
    type t =
      {
      code: ClientVpnConnectionStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnConnectionStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnConnectionStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnConnectionStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnConnectionStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module LocationType =
  struct
    type t =
      | Region 
      | Availability_zone 
      | Availability_zone_id 
    let str_to_t =
      [("availability-zone-id", Availability_zone_id);
      ("availability-zone", Availability_zone);
      ("region", Region)]
    let t_to_str =
      [(Availability_zone_id, "availability-zone-id");
      (Availability_zone, "availability-zone");
      (Region, "region")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceStatusEventList =
  struct
    type t = InstanceStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatusEvent.to_query v
    let to_json v = `List (List.map InstanceStatusEvent.to_json v)
    let of_json j = Json.to_list InstanceStatusEvent.of_json j
  end
module InstanceStatusSummary =
  struct
    type t = {
      details: InstanceStatusDetailsList.t ;
      status: SummaryStatus.t }
    let make ?(details= [])  ~status  () = { details; status }
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  InstanceStatusDetailsList.parse));
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SummaryStatus.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Status", (SummaryStatus.to_query v.status)));
           Some
             (Query.Pair
                ("Details", (InstanceStatusDetailsList.to_query v.details)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("status", (SummaryStatus.to_json v.status));
           Some ("details", (InstanceStatusDetailsList.to_json v.details))])
    let of_json j =
      {
        details =
          (InstanceStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")));
        status =
          (SummaryStatus.of_json
             (Util.of_option_exn (Json.lookup j "status")))
      }
  end
module TransitGatewayPrefixListAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      resource_id: String.t option }
    let make ?transit_gateway_attachment_id  ?resource_type  ?resource_id  ()
      = { transit_gateway_attachment_id; resource_type; resource_id }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json)
      }
  end
module TransitGatewayPrefixListReferenceState =
  struct
    type t =
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
    let str_to_t =
      [("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImageState =
  struct
    type t =
      | Pending 
      | Available 
      | Invalid 
      | Deregistered 
      | Transient 
      | Failed 
      | Error 
    let str_to_t =
      [("error", Error);
      ("failed", Failed);
      ("transient", Transient);
      ("deregistered", Deregistered);
      ("invalid", Invalid);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Error, "error");
      (Failed, "failed");
      (Transient, "transient");
      (Deregistered, "deregistered");
      (Invalid, "invalid");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImageTypeValues =
  struct
    type t =
      | Machine 
      | Kernel 
      | Ramdisk 
    let str_to_t =
      [("ramdisk", Ramdisk); ("kernel", Kernel); ("machine", Machine)]
    let t_to_str =
      [(Ramdisk, "ramdisk"); (Kernel, "kernel"); (Machine, "machine")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotTaskDetail =
  struct
    type t =
      {
      description: String.t option ;
      disk_image_size: Double.t option ;
      encrypted: Boolean.t option ;
      format: String.t option ;
      kms_key_id: String.t option ;
      progress: String.t option ;
      snapshot_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      url: String.t option ;
      user_bucket: UserBucketDetails.t option }
    let make ?description  ?disk_image_size  ?encrypted  ?format  ?kms_key_id
       ?progress  ?snapshot_id  ?status  ?status_message  ?url  ?user_bucket 
      () =
      {
        description;
        disk_image_size;
        encrypted;
        format;
        kms_key_id;
        progress;
        snapshot_id;
        status;
        status_message;
        url;
        user_bucket
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_size =
            (Util.option_bind (Xml.member "diskImageSize" xml) Double.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          format = (Util.option_bind (Xml.member "format" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          url = (Util.option_bind (Xml.member "url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "userBucket" xml)
               UserBucketDetails.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f ->
                 Query.Pair ("UserBucket", (UserBucketDetails.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.disk_image_size
             (fun f -> Query.Pair ("DiskImageSize", (Double.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucketDetails.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.disk_image_size
             (fun f -> ("disk_image_size", (Double.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_size =
          (Util.option_map (Json.lookup j "disk_image_size") Double.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket")
             UserBucketDetails.of_json)
      }
  end
module InterfacePermissionType =
  struct
    type t =
      | INSTANCE_ATTACH 
      | EIP_ASSOCIATE 
    let str_to_t =
      [("EIP-ASSOCIATE", EIP_ASSOCIATE);
      ("INSTANCE-ATTACH", INSTANCE_ATTACH)]
    let t_to_str =
      [(EIP_ASSOCIATE, "EIP-ASSOCIATE");
      (INSTANCE_ATTACH, "INSTANCE-ATTACH")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfacePermissionState =
  struct
    type t =
      {
      state: NetworkInterfacePermissionStateCode.t option ;
      status_message: String.t option }
    let make ?state  ?status_message  () = { state; status_message }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml)
               NetworkInterfacePermissionStateCode.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (NetworkInterfacePermissionStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status_message
              (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (NetworkInterfacePermissionStateCode.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             NetworkInterfacePermissionStateCode.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json)
      }
  end
module AllocationState =
  struct
    type t =
      | Available 
      | Under_assessment 
      | Permanent_failure 
      | Released 
      | Released_permanent_failure 
      | Pending 
    let str_to_t =
      [("pending", Pending);
      ("released-permanent-failure", Released_permanent_failure);
      ("released", Released);
      ("permanent-failure", Permanent_failure);
      ("under-assessment", Under_assessment);
      ("available", Available)]
    let t_to_str =
      [(Pending, "pending");
      (Released_permanent_failure, "released-permanent-failure");
      (Released, "released");
      (Permanent_failure, "permanent-failure");
      (Under_assessment, "under-assessment");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AllowsMultipleInstanceTypes =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AutoPlacement =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailableCapacity =
  struct
    type t =
      {
      available_instance_capacity: AvailableInstanceCapacityList.t ;
      available_v_cpus: Integer.t option }
    let make ?(available_instance_capacity= [])  ?available_v_cpus  () =
      { available_instance_capacity; available_v_cpus }
    let parse xml =
      Some
        {
          available_instance_capacity =
            (Util.of_option []
               (Util.option_bind (Xml.member "availableInstanceCapacity" xml)
                  AvailableInstanceCapacityList.parse));
          available_v_cpus =
            (Util.option_bind (Xml.member "availableVCpus" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> Query.Pair ("AvailableVCpus", (Integer.to_query f)));
           Some
             (Query.Pair
                ("AvailableInstanceCapacity",
                  (AvailableInstanceCapacityList.to_query
                     v.available_instance_capacity)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.available_v_cpus
              (fun f -> ("available_v_cpus", (Integer.to_json f)));
           Some
             ("available_instance_capacity",
               (AvailableInstanceCapacityList.to_json
                  v.available_instance_capacity))])
    let of_json j =
      {
        available_instance_capacity =
          (AvailableInstanceCapacityList.of_json
             (Util.of_option_exn
                (Json.lookup j "available_instance_capacity")));
        available_v_cpus =
          (Util.option_map (Json.lookup j "available_v_cpus") Integer.of_json)
      }
  end
module HostInstanceList =
  struct
    type t = HostInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HostInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostInstance.to_query v
    let to_json v = `List (List.map HostInstance.to_json v)
    let of_json j = Json.to_list HostInstance.of_json j
  end
module HostProperties =
  struct
    type t =
      {
      cores: Integer.t option ;
      instance_type: String.t option ;
      instance_family: String.t option ;
      sockets: Integer.t option ;
      total_v_cpus: Integer.t option }
    let make ?cores  ?instance_type  ?instance_family  ?sockets 
      ?total_v_cpus  () =
      { cores; instance_type; instance_family; sockets; total_v_cpus }
    let parse xml =
      Some
        {
          cores = (Util.option_bind (Xml.member "cores" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          sockets =
            (Util.option_bind (Xml.member "sockets" xml) Integer.parse);
          total_v_cpus =
            (Util.option_bind (Xml.member "totalVCpus" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> Query.Pair ("TotalVCpus", (Integer.to_query f)));
           Util.option_map v.sockets
             (fun f -> Query.Pair ("Sockets", (Integer.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.cores
             (fun f -> Query.Pair ("Cores", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_v_cpus
              (fun f -> ("total_v_cpus", (Integer.to_json f)));
           Util.option_map v.sockets
             (fun f -> ("sockets", (Integer.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.cores (fun f -> ("cores", (Integer.to_json f)))])
    let of_json j =
      {
        cores = (Util.option_map (Json.lookup j "cores") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        sockets = (Util.option_map (Json.lookup j "sockets") Integer.of_json);
        total_v_cpus =
          (Util.option_map (Json.lookup j "total_v_cpus") Integer.of_json)
      }
  end
module HostRecovery =
  struct
    type t =
      | On 
      | Off 
    let str_to_t = [("off", Off); ("on", On)]
    let t_to_str = [(Off, "off"); (On, "on")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetAssociation =
  struct
    type t =
      {
      subnet_id: String.t option ;
      state: TransitGatewayMulitcastDomainAssociationState.t option }
    let make ?subnet_id  ?state  () = { subnet_id; state }
    let parse xml =
      Some
        {
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulitcastDomainAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State",
                     (TransitGatewayMulitcastDomainAssociationState.to_query
                        f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 ("state",
                   (TransitGatewayMulitcastDomainAssociationState.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)))])
    let of_json j =
      {
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayMulitcastDomainAssociationState.of_json)
      }
  end
module InstanceHealthStatus =
  struct
    type t =
      | Healthy 
      | Unhealthy 
    let str_to_t = [("unhealthy", Unhealthy); ("healthy", Healthy)]
    let t_to_str = [(Unhealthy, "unhealthy"); (Healthy, "healthy")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsInstanceBlockDeviceSpecification =
  struct
    type t =
      {
      delete_on_termination: Boolean.t option ;
      volume_id: String.t option }
    let make ?delete_on_termination  ?volume_id  () =
      { delete_on_termination; volume_id }
    let parse xml =
      Some
        {
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)))])
    let of_json j =
      {
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module LoadPermission =
  struct
    type t = {
      user_id: String.t option ;
      group: PermissionGroup.t option }
    let make ?user_id  ?group  () = { user_id; group }
    let parse xml =
      Some
        {
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse);
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)));
           Util.option_map v.user_id
             (fun f -> Query.Pair ("UserId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group
              (fun f -> ("group", (PermissionGroup.to_json f)));
           Util.option_map v.user_id
             (fun f -> ("user_id", (String.to_json f)))])
    let of_json j =
      {
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json);
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json)
      }
  end
module TransitGatewayMulticastDomainState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module IdFormatList =
  struct
    type t = IdFormat.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IdFormat.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IdFormat.to_query v
    let to_json v = `List (List.map IdFormat.to_json v)
    let of_json j = Json.to_list IdFormat.of_json j
  end
module PrincipalType =
  struct
    type t =
      | All 
      | Service 
      | OrganizationUnit 
      | Account 
      | User 
      | Role 
    let str_to_t =
      [("Role", Role);
      ("User", User);
      ("Account", Account);
      ("OrganizationUnit", OrganizationUnit);
      ("Service", Service);
      ("All", All)]
    let t_to_str =
      [(Role, "Role");
      (User, "User");
      (Account, "Account");
      (OrganizationUnit, "OrganizationUnit");
      (Service, "Service");
      (All, "All")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ByoipCidrState =
  struct
    type t =
      | Advertised 
      | Deprovisioned 
      | Failed_deprovision 
      | Failed_provision 
      | Pending_deprovision 
      | Pending_provision 
      | Provisioned 
      | Provisioned_not_publicly_advertisable 
    let str_to_t =
      [("provisioned-not-publicly-advertisable",
         Provisioned_not_publicly_advertisable);
      ("provisioned", Provisioned);
      ("pending-provision", Pending_provision);
      ("pending-deprovision", Pending_deprovision);
      ("failed-provision", Failed_provision);
      ("failed-deprovision", Failed_deprovision);
      ("deprovisioned", Deprovisioned);
      ("advertised", Advertised)]
    let t_to_str =
      [(Provisioned_not_publicly_advertisable,
         "provisioned-not-publicly-advertisable");
      (Provisioned, "provisioned");
      (Pending_provision, "pending-provision");
      (Pending_deprovision, "pending-deprovision");
      (Failed_provision, "failed-provision");
      (Failed_deprovision, "failed-deprovision");
      (Deprovisioned, "deprovisioned");
      (Advertised, "advertised")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DeleteFleetError =
  struct
    type t = {
      code: DeleteFleetErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteFleetErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (DeleteFleetErrorCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (DeleteFleetErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             DeleteFleetErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module FleetStateCode =
  struct
    type t =
      | Submitted 
      | Active 
      | Deleted 
      | Failed 
      | Deleted_running 
      | Deleted_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("deleted_terminating", Deleted_terminating);
      ("deleted_running", Deleted_running);
      ("failed", Failed);
      ("deleted", Deleted);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Deleted_terminating, "deleted_terminating");
      (Deleted_running, "deleted_running");
      (Failed, "failed");
      (Deleted, "deleted");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DisableFastSnapshotRestoreStateErrorSet =
  struct
    type t = DisableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreStateErrorItem.to_query v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreStateErrorItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreStateErrorItem.of_json j
  end
module FastSnapshotRestoreStateCode =
  struct
    type t =
      | Enabling 
      | Optimizing 
      | Enabled 
      | Disabling 
      | Disabled 
    let str_to_t =
      [("disabled", Disabled);
      ("disabling", Disabling);
      ("enabled", Enabled);
      ("optimizing", Optimizing);
      ("enabling", Enabling)]
    let t_to_str =
      [(Disabled, "disabled");
      (Disabling, "disabling");
      (Enabled, "enabled");
      (Optimizing, "optimizing");
      (Enabling, "enabling")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ScheduledInstanceRecurrence =
  struct
    type t =
      {
      frequency: String.t option ;
      interval: Integer.t option ;
      occurrence_day_set: OccurrenceDaySet.t ;
      occurrence_relative_to_end: Boolean.t option ;
      occurrence_unit: String.t option }
    let make ?frequency  ?interval  ?(occurrence_day_set= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_day_set;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "interval" xml) Integer.parse);
          occurrence_day_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "occurrenceDaySet" xml)
                  OccurrenceDaySet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "occurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "occurrenceUnit" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDaySet",
                  (OccurrenceDaySet.to_query v.occurrence_day_set)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_day_set",
               (OccurrenceDaySet.to_json v.occurrence_day_set));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let of_json j =
      {
        frequency =
          (Util.option_map (Json.lookup j "frequency") String.of_json);
        interval =
          (Util.option_map (Json.lookup j "interval") Integer.of_json);
        occurrence_day_set =
          (OccurrenceDaySet.of_json
             (Util.of_option_exn (Json.lookup j "occurrence_day_set")));
        occurrence_relative_to_end =
          (Util.option_map (Json.lookup j "occurrence_relative_to_end")
             Boolean.of_json);
        occurrence_unit =
          (Util.option_map (Json.lookup j "occurrence_unit") String.of_json)
      }
  end
module LogDestinationType =
  struct
    type t =
      | Cloud_watch_logs 
      | S3 
    let str_to_t = [("s3", S3); ("cloud-watch-logs", Cloud_watch_logs)]
    let t_to_str = [(S3, "s3"); (Cloud_watch_logs, "cloud-watch-logs")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficType =
  struct
    type t =
      | ACCEPT 
      | REJECT 
      | ALL 
    let str_to_t = [("ALL", ALL); ("REJECT", REJECT); ("ACCEPT", ACCEPT)]
    let t_to_str = [(ALL, "ALL"); (REJECT, "REJECT"); (ACCEPT, "ACCEPT")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module BundleTaskError =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module BundleTaskState =
  struct
    type t =
      | Pending 
      | Waiting_for_shutdown 
      | Bundling 
      | Storing 
      | Cancelling 
      | Complete 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("complete", Complete);
      ("cancelling", Cancelling);
      ("storing", Storing);
      ("bundling", Bundling);
      ("waiting-for-shutdown", Waiting_for_shutdown);
      ("pending", Pending)]
    let t_to_str =
      [(Failed, "failed");
      (Complete, "complete");
      (Cancelling, "cancelling");
      (Storing, "storing");
      (Bundling, "bundling");
      (Waiting_for_shutdown, "waiting-for-shutdown");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module Storage =
  struct
    type t = {
      s3: S3Storage.t option }
    let make ?s3  () = { s3 }
    let parse xml =
      Some { s3 = (Util.option_bind (Xml.member "S3" xml) S3Storage.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3
              (fun f -> Query.Pair ("S3", (S3Storage.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3 (fun f -> ("s3", (S3Storage.to_json f)))])
    let of_json j =
      { s3 = (Util.option_map (Json.lookup j "s3") S3Storage.of_json) }
  end
module StaleIpPermissionSet =
  struct
    type t = StaleIpPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StaleIpPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list StaleIpPermission.to_query v
    let to_json v = `List (List.map StaleIpPermission.to_json v)
    let of_json j = Json.to_list StaleIpPermission.of_json j
  end
module CreateVolumePermission =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "userId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module VolumeAttachmentList =
  struct
    type t = VolumeAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeAttachment.to_query v
    let to_json v = `List (List.map VolumeAttachment.to_json v)
    let of_json j = Json.to_list VolumeAttachment.of_json j
  end
module VolumeState =
  struct
    type t =
      | Creating 
      | Available 
      | In_use 
      | Deleting 
      | Deleted 
      | Error 
    let str_to_t =
      [("error", Error);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("in-use", In_use);
      ("available", Available);
      ("creating", Creating)]
    let t_to_str =
      [(Error, "error");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (In_use, "in-use");
      (Available, "available");
      (Creating, "creating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option ;
      tunnel_inside_ipv6_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      d_p_d_timeout_seconds: Integer.t option ;
      d_p_d_timeout_action: String.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t ;
      i_k_e_versions: IKEVersionsRequestList.t ;
      startup_action: String.t option }
    let make ?tunnel_inside_cidr  ?tunnel_inside_ipv6_cidr  ?pre_shared_key 
      ?phase1_lifetime_seconds  ?phase2_lifetime_seconds 
      ?rekey_margin_time_seconds  ?rekey_fuzz_percentage  ?replay_window_size
       ?d_p_d_timeout_seconds  ?d_p_d_timeout_action 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  ?startup_action  () =
      {
        tunnel_inside_cidr;
        tunnel_inside_ipv6_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        d_p_d_timeout_action;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions;
        startup_action
      }
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          tunnel_inside_ipv6_cidr =
            (Util.option_bind (Xml.member "TunnelInsideIpv6Cidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          d_p_d_timeout_action =
            (Util.option_bind (Xml.member "DPDTimeoutAction" xml)
               String.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse));
          startup_action =
            (Util.option_bind (Xml.member "StartupAction" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> Query.Pair ("StartupAction", (String.to_query f)));
           Some
             (Query.Pair
                ("IKEVersion",
                  (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_action
             (fun f -> Query.Pair ("DPDTimeoutAction", (String.to_query f)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f ->
                Query.Pair ("TunnelInsideIpv6Cidr", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> ("startup_action", (String.to_json f)));
           Some
             ("i_k_e_versions",
               (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_action
             (fun f -> ("d_p_d_timeout_action", (String.to_json f)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f -> ("tunnel_inside_ipv6_cidr", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let of_json j =
      {
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        tunnel_inside_ipv6_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_ipv6_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        d_p_d_timeout_seconds =
          (Util.option_map (Json.lookup j "d_p_d_timeout_seconds")
             Integer.of_json);
        d_p_d_timeout_action =
          (Util.option_map (Json.lookup j "d_p_d_timeout_action")
             String.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        i_k_e_versions =
          (IKEVersionsRequestList.of_json
             (Util.of_option_exn (Json.lookup j "i_k_e_versions")));
        startup_action =
          (Util.option_map (Json.lookup j "startup_action") String.of_json)
      }
  end
module DomainType =
  struct
    type t =
      | Vpc 
      | Standard 
    let str_to_t = [("standard", Standard); ("vpc", Vpc)]
    let t_to_str = [(Standard, "standard"); (Vpc, "vpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EbsInfo =
  struct
    type t =
      {
      ebs_optimized_support: EbsOptimizedSupport.t option ;
      encryption_support: EbsEncryptionSupport.t option ;
      ebs_optimized_info: EbsOptimizedInfo.t option ;
      nvme_support: EbsNvmeSupport.t option }
    let make ?ebs_optimized_support  ?encryption_support  ?ebs_optimized_info
       ?nvme_support  () =
      {
        ebs_optimized_support;
        encryption_support;
        ebs_optimized_info;
        nvme_support
      }
    let parse xml =
      Some
        {
          ebs_optimized_support =
            (Util.option_bind (Xml.member "ebsOptimizedSupport" xml)
               EbsOptimizedSupport.parse);
          encryption_support =
            (Util.option_bind (Xml.member "encryptionSupport" xml)
               EbsEncryptionSupport.parse);
          ebs_optimized_info =
            (Util.option_bind (Xml.member "ebsOptimizedInfo" xml)
               EbsOptimizedInfo.parse);
          nvme_support =
            (Util.option_bind (Xml.member "nvmeSupport" xml)
               EbsNvmeSupport.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nvme_support
              (fun f ->
                 Query.Pair ("NvmeSupport", (EbsNvmeSupport.to_query f)));
           Util.option_map v.ebs_optimized_info
             (fun f ->
                Query.Pair
                  ("EbsOptimizedInfo", (EbsOptimizedInfo.to_query f)));
           Util.option_map v.encryption_support
             (fun f ->
                Query.Pair
                  ("EncryptionSupport", (EbsEncryptionSupport.to_query f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                Query.Pair
                  ("EbsOptimizedSupport", (EbsOptimizedSupport.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nvme_support
              (fun f -> ("nvme_support", (EbsNvmeSupport.to_json f)));
           Util.option_map v.ebs_optimized_info
             (fun f -> ("ebs_optimized_info", (EbsOptimizedInfo.to_json f)));
           Util.option_map v.encryption_support
             (fun f ->
                ("encryption_support", (EbsEncryptionSupport.to_json f)));
           Util.option_map v.ebs_optimized_support
             (fun f ->
                ("ebs_optimized_support", (EbsOptimizedSupport.to_json f)))])
    let of_json j =
      {
        ebs_optimized_support =
          (Util.option_map (Json.lookup j "ebs_optimized_support")
             EbsOptimizedSupport.of_json);
        encryption_support =
          (Util.option_map (Json.lookup j "encryption_support")
             EbsEncryptionSupport.of_json);
        ebs_optimized_info =
          (Util.option_map (Json.lookup j "ebs_optimized_info")
             EbsOptimizedInfo.of_json);
        nvme_support =
          (Util.option_map (Json.lookup j "nvme_support")
             EbsNvmeSupport.of_json)
      }
  end
module FpgaInfo =
  struct
    type t =
      {
      fpgas: FpgaDeviceInfoList.t ;
      total_fpga_memory_in_mi_b: Integer.t option }
    let make ?(fpgas= [])  ?total_fpga_memory_in_mi_b  () =
      { fpgas; total_fpga_memory_in_mi_b }
    let parse xml =
      Some
        {
          fpgas =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgas" xml)
                  FpgaDeviceInfoList.parse));
          total_fpga_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalFpgaMemoryInMiB" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalFpgaMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Fpgas", (FpgaDeviceInfoList.to_query v.fpgas)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_fpga_memory_in_mi_b
              (fun f -> ("total_fpga_memory_in_mi_b", (Integer.to_json f)));
           Some ("fpgas", (FpgaDeviceInfoList.to_json v.fpgas))])
    let of_json j =
      {
        fpgas =
          (FpgaDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "fpgas")));
        total_fpga_memory_in_mi_b =
          (Util.option_map (Json.lookup j "total_fpga_memory_in_mi_b")
             Integer.of_json)
      }
  end
module GpuInfo =
  struct
    type t =
      {
      gpus: GpuDeviceInfoList.t ;
      total_gpu_memory_in_mi_b: Integer.t option }
    let make ?(gpus= [])  ?total_gpu_memory_in_mi_b  () =
      { gpus; total_gpu_memory_in_mi_b }
    let parse xml =
      Some
        {
          gpus =
            (Util.of_option []
               (Util.option_bind (Xml.member "gpus" xml)
                  GpuDeviceInfoList.parse));
          total_gpu_memory_in_mi_b =
            (Util.option_bind (Xml.member "totalGpuMemoryInMiB" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f ->
                 Query.Pair ("TotalGpuMemoryInMiB", (Integer.to_query f)));
           Some (Query.Pair ("Gpus", (GpuDeviceInfoList.to_query v.gpus)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_gpu_memory_in_mi_b
              (fun f -> ("total_gpu_memory_in_mi_b", (Integer.to_json f)));
           Some ("gpus", (GpuDeviceInfoList.to_json v.gpus))])
    let of_json j =
      {
        gpus =
          (GpuDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "gpus")));
        total_gpu_memory_in_mi_b =
          (Util.option_map (Json.lookup j "total_gpu_memory_in_mi_b")
             Integer.of_json)
      }
  end
module InferenceAcceleratorInfo =
  struct
    type t = {
      accelerators: InferenceDeviceInfoList.t }
    let make ?(accelerators= [])  () = { accelerators }
    let parse xml =
      Some
        {
          accelerators =
            (Util.of_option []
               (Util.option_bind (Xml.member "accelerators" xml)
                  InferenceDeviceInfoList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Accelerators",
                   (InferenceDeviceInfoList.to_query v.accelerators)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("accelerators",
                (InferenceDeviceInfoList.to_json v.accelerators))])
    let of_json j =
      {
        accelerators =
          (InferenceDeviceInfoList.of_json
             (Util.of_option_exn (Json.lookup j "accelerators")))
      }
  end
module InstanceStorageInfo =
  struct
    type t =
      {
      total_size_in_g_b: Long.t option ;
      disks: DiskInfoList.t ;
      nvme_support: EphemeralNvmeSupport.t option }
    let make ?total_size_in_g_b  ?(disks= [])  ?nvme_support  () =
      { total_size_in_g_b; disks; nvme_support }
    let parse xml =
      Some
        {
          total_size_in_g_b =
            (Util.option_bind (Xml.member "totalSizeInGB" xml) Long.parse);
          disks =
            (Util.of_option []
               (Util.option_bind (Xml.member "disks" xml) DiskInfoList.parse));
          nvme_support =
            (Util.option_bind (Xml.member "nvmeSupport" xml)
               EphemeralNvmeSupport.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nvme_support
              (fun f ->
                 Query.Pair
                   ("NvmeSupport", (EphemeralNvmeSupport.to_query f)));
           Some (Query.Pair ("Disks", (DiskInfoList.to_query v.disks)));
           Util.option_map v.total_size_in_g_b
             (fun f -> Query.Pair ("TotalSizeInGB", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nvme_support
              (fun f -> ("nvme_support", (EphemeralNvmeSupport.to_json f)));
           Some ("disks", (DiskInfoList.to_json v.disks));
           Util.option_map v.total_size_in_g_b
             (fun f -> ("total_size_in_g_b", (Long.to_json f)))])
    let of_json j =
      {
        total_size_in_g_b =
          (Util.option_map (Json.lookup j "total_size_in_g_b") Long.of_json);
        disks =
          (DiskInfoList.of_json (Util.of_option_exn (Json.lookup j "disks")));
        nvme_support =
          (Util.option_map (Json.lookup j "nvme_support")
             EphemeralNvmeSupport.of_json)
      }
  end
module InstanceTypeHypervisor =
  struct
    type t =
      | Nitro 
      | Xen 
    let str_to_t = [("xen", Xen); ("nitro", Nitro)]
    let t_to_str = [(Xen, "xen"); (Nitro, "nitro")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MemoryInfo =
  struct
    type t = {
      size_in_mi_b: Long.t option }
    let make ?size_in_mi_b  () = { size_in_mi_b }
    let parse xml =
      Some
        {
          size_in_mi_b =
            (Util.option_bind (Xml.member "sizeInMiB" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> Query.Pair ("SizeInMiB", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.size_in_mi_b
              (fun f -> ("size_in_mi_b", (Long.to_json f)))])
    let of_json j =
      {
        size_in_mi_b =
          (Util.option_map (Json.lookup j "size_in_mi_b") Long.of_json)
      }
  end
module NetworkInfo =
  struct
    type t =
      {
      network_performance: String.t option ;
      maximum_network_interfaces: Integer.t option ;
      maximum_network_cards: Integer.t option ;
      default_network_card_index: Integer.t option ;
      network_cards: NetworkCardInfoList.t ;
      ipv4_addresses_per_interface: Integer.t option ;
      ipv6_addresses_per_interface: Integer.t option ;
      ipv6_supported: Boolean.t option ;
      ena_support: EnaSupport.t option ;
      efa_supported: Boolean.t option }
    let make ?network_performance  ?maximum_network_interfaces 
      ?maximum_network_cards  ?default_network_card_index  ?(network_cards=
      [])  ?ipv4_addresses_per_interface  ?ipv6_addresses_per_interface 
      ?ipv6_supported  ?ena_support  ?efa_supported  () =
      {
        network_performance;
        maximum_network_interfaces;
        maximum_network_cards;
        default_network_card_index;
        network_cards;
        ipv4_addresses_per_interface;
        ipv6_addresses_per_interface;
        ipv6_supported;
        ena_support;
        efa_supported
      }
    let parse xml =
      Some
        {
          network_performance =
            (Util.option_bind (Xml.member "networkPerformance" xml)
               String.parse);
          maximum_network_interfaces =
            (Util.option_bind (Xml.member "maximumNetworkInterfaces" xml)
               Integer.parse);
          maximum_network_cards =
            (Util.option_bind (Xml.member "maximumNetworkCards" xml)
               Integer.parse);
          default_network_card_index =
            (Util.option_bind (Xml.member "defaultNetworkCardIndex" xml)
               Integer.parse);
          network_cards =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkCards" xml)
                  NetworkCardInfoList.parse));
          ipv4_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv4AddressesPerInterface" xml)
               Integer.parse);
          ipv6_addresses_per_interface =
            (Util.option_bind (Xml.member "ipv6AddressesPerInterface" xml)
               Integer.parse);
          ipv6_supported =
            (Util.option_bind (Xml.member "ipv6Supported" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) EnaSupport.parse);
          efa_supported =
            (Util.option_bind (Xml.member "efaSupported" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.efa_supported
              (fun f -> Query.Pair ("EfaSupported", (Boolean.to_query f)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (EnaSupport.to_query f)));
           Util.option_map v.ipv6_supported
             (fun f -> Query.Pair ("Ipv6Supported", (Boolean.to_query f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv6AddressesPerInterface", (Integer.to_query f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f ->
                Query.Pair
                  ("Ipv4AddressesPerInterface", (Integer.to_query f)));
           Some
             (Query.Pair
                ("NetworkCards",
                  (NetworkCardInfoList.to_query v.network_cards)));
           Util.option_map v.default_network_card_index
             (fun f ->
                Query.Pair ("DefaultNetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.maximum_network_cards
             (fun f ->
                Query.Pair ("MaximumNetworkCards", (Integer.to_query f)));
           Util.option_map v.maximum_network_interfaces
             (fun f ->
                Query.Pair ("MaximumNetworkInterfaces", (Integer.to_query f)));
           Util.option_map v.network_performance
             (fun f -> Query.Pair ("NetworkPerformance", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.efa_supported
              (fun f -> ("efa_supported", (Boolean.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (EnaSupport.to_json f)));
           Util.option_map v.ipv6_supported
             (fun f -> ("ipv6_supported", (Boolean.to_json f)));
           Util.option_map v.ipv6_addresses_per_interface
             (fun f -> ("ipv6_addresses_per_interface", (Integer.to_json f)));
           Util.option_map v.ipv4_addresses_per_interface
             (fun f -> ("ipv4_addresses_per_interface", (Integer.to_json f)));
           Some
             ("network_cards", (NetworkCardInfoList.to_json v.network_cards));
           Util.option_map v.default_network_card_index
             (fun f -> ("default_network_card_index", (Integer.to_json f)));
           Util.option_map v.maximum_network_cards
             (fun f -> ("maximum_network_cards", (Integer.to_json f)));
           Util.option_map v.maximum_network_interfaces
             (fun f -> ("maximum_network_interfaces", (Integer.to_json f)));
           Util.option_map v.network_performance
             (fun f -> ("network_performance", (String.to_json f)))])
    let of_json j =
      {
        network_performance =
          (Util.option_map (Json.lookup j "network_performance")
             String.of_json);
        maximum_network_interfaces =
          (Util.option_map (Json.lookup j "maximum_network_interfaces")
             Integer.of_json);
        maximum_network_cards =
          (Util.option_map (Json.lookup j "maximum_network_cards")
             Integer.of_json);
        default_network_card_index =
          (Util.option_map (Json.lookup j "default_network_card_index")
             Integer.of_json);
        network_cards =
          (NetworkCardInfoList.of_json
             (Util.of_option_exn (Json.lookup j "network_cards")));
        ipv4_addresses_per_interface =
          (Util.option_map (Json.lookup j "ipv4_addresses_per_interface")
             Integer.of_json);
        ipv6_addresses_per_interface =
          (Util.option_map (Json.lookup j "ipv6_addresses_per_interface")
             Integer.of_json);
        ipv6_supported =
          (Util.option_map (Json.lookup j "ipv6_supported") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") EnaSupport.of_json);
        efa_supported =
          (Util.option_map (Json.lookup j "efa_supported") Boolean.of_json)
      }
  end
module PlacementGroupInfo =
  struct
    type t = {
      supported_strategies: PlacementGroupStrategyList.t }
    let make ?(supported_strategies= [])  () = { supported_strategies }
    let parse xml =
      Some
        {
          supported_strategies =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedStrategies" xml)
                  PlacementGroupStrategyList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SupportedStrategies",
                   (PlacementGroupStrategyList.to_query
                      v.supported_strategies)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("supported_strategies",
                (PlacementGroupStrategyList.to_json v.supported_strategies))])
    let of_json j =
      {
        supported_strategies =
          (PlacementGroupStrategyList.of_json
             (Util.of_option_exn (Json.lookup j "supported_strategies")))
      }
  end
module ProcessorInfo =
  struct
    type t =
      {
      supported_architectures: ArchitectureTypeList.t ;
      sustained_clock_speed_in_ghz: Double.t option }
    let make ?(supported_architectures= [])  ?sustained_clock_speed_in_ghz 
      () = { supported_architectures; sustained_clock_speed_in_ghz }
    let parse xml =
      Some
        {
          supported_architectures =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedArchitectures" xml)
                  ArchitectureTypeList.parse));
          sustained_clock_speed_in_ghz =
            (Util.option_bind (Xml.member "sustainedClockSpeedInGhz" xml)
               Double.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f ->
                 Query.Pair ("SustainedClockSpeedInGhz", (Double.to_query f)));
           Some
             (Query.Pair
                ("SupportedArchitectures",
                  (ArchitectureTypeList.to_query v.supported_architectures)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sustained_clock_speed_in_ghz
              (fun f -> ("sustained_clock_speed_in_ghz", (Double.to_json f)));
           Some
             ("supported_architectures",
               (ArchitectureTypeList.to_json v.supported_architectures))])
    let of_json j =
      {
        supported_architectures =
          (ArchitectureTypeList.of_json
             (Util.of_option_exn (Json.lookup j "supported_architectures")));
        sustained_clock_speed_in_ghz =
          (Util.option_map (Json.lookup j "sustained_clock_speed_in_ghz")
             Double.of_json)
      }
  end
module RootDeviceTypeList =
  struct
    type t = RootDeviceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RootDeviceType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RootDeviceType.to_query v
    let to_json v = `List (List.map RootDeviceType.to_json v)
    let of_json j = Json.to_list RootDeviceType.of_json j
  end
module UsageClassTypeList =
  struct
    type t = UsageClassType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UsageClassType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UsageClassType.to_query v
    let to_json v = `List (List.map UsageClassType.to_json v)
    let of_json j = Json.to_list UsageClassType.of_json j
  end
module VCpuInfo =
  struct
    type t =
      {
      default_v_cpus: Integer.t option ;
      default_cores: Integer.t option ;
      default_threads_per_core: Integer.t option ;
      valid_cores: CoreCountList.t ;
      valid_threads_per_core: ThreadsPerCoreList.t }
    let make ?default_v_cpus  ?default_cores  ?default_threads_per_core 
      ?(valid_cores= [])  ?(valid_threads_per_core= [])  () =
      {
        default_v_cpus;
        default_cores;
        default_threads_per_core;
        valid_cores;
        valid_threads_per_core
      }
    let parse xml =
      Some
        {
          default_v_cpus =
            (Util.option_bind (Xml.member "defaultVCpus" xml) Integer.parse);
          default_cores =
            (Util.option_bind (Xml.member "defaultCores" xml) Integer.parse);
          default_threads_per_core =
            (Util.option_bind (Xml.member "defaultThreadsPerCore" xml)
               Integer.parse);
          valid_cores =
            (Util.of_option []
               (Util.option_bind (Xml.member "validCores" xml)
                  CoreCountList.parse));
          valid_threads_per_core =
            (Util.of_option []
               (Util.option_bind (Xml.member "validThreadsPerCore" xml)
                  ThreadsPerCoreList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ValidThreadsPerCore",
                   (ThreadsPerCoreList.to_query v.valid_threads_per_core)));
           Some
             (Query.Pair
                ("ValidCores", (CoreCountList.to_query v.valid_cores)));
           Util.option_map v.default_threads_per_core
             (fun f ->
                Query.Pair ("DefaultThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.default_cores
             (fun f -> Query.Pair ("DefaultCores", (Integer.to_query f)));
           Util.option_map v.default_v_cpus
             (fun f -> Query.Pair ("DefaultVCpus", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("valid_threads_per_core",
                (ThreadsPerCoreList.to_json v.valid_threads_per_core));
           Some ("valid_cores", (CoreCountList.to_json v.valid_cores));
           Util.option_map v.default_threads_per_core
             (fun f -> ("default_threads_per_core", (Integer.to_json f)));
           Util.option_map v.default_cores
             (fun f -> ("default_cores", (Integer.to_json f)));
           Util.option_map v.default_v_cpus
             (fun f -> ("default_v_cpus", (Integer.to_json f)))])
    let of_json j =
      {
        default_v_cpus =
          (Util.option_map (Json.lookup j "default_v_cpus") Integer.of_json);
        default_cores =
          (Util.option_map (Json.lookup j "default_cores") Integer.of_json);
        default_threads_per_core =
          (Util.option_map (Json.lookup j "default_threads_per_core")
             Integer.of_json);
        valid_cores =
          (CoreCountList.of_json
             (Util.of_option_exn (Json.lookup j "valid_cores")));
        valid_threads_per_core =
          (ThreadsPerCoreList.of_json
             (Util.of_option_exn (Json.lookup j "valid_threads_per_core")))
      }
  end
module VirtualizationTypeList =
  struct
    type t = VirtualizationType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VirtualizationType.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VirtualizationType.to_query v
    let to_json v = `List (List.map VirtualizationType.to_json v)
    let of_json j = Json.to_list VirtualizationType.of_json j
  end
module ClientVpnRouteStatus =
  struct
    type t =
      {
      code: ClientVpnRouteStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnRouteStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnRouteStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnRouteStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnRouteStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VgwTelemetryList =
  struct
    type t = VgwTelemetry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VgwTelemetry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VgwTelemetry.to_query v
    let to_json v = `List (List.map VgwTelemetry.to_json v)
    let of_json j = Json.to_list VgwTelemetry.of_json j
  end
module VpnConnectionOptions =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option ;
      static_routes_only: Boolean.t option ;
      local_ipv4_network_cidr: String.t option ;
      remote_ipv4_network_cidr: String.t option ;
      local_ipv6_network_cidr: String.t option ;
      remote_ipv6_network_cidr: String.t option ;
      tunnel_inside_ip_version: TunnelInsideIpVersion.t option ;
      tunnel_options: TunnelOptionsList.t }
    let make ?enable_acceleration  ?static_routes_only 
      ?local_ipv4_network_cidr  ?remote_ipv4_network_cidr 
      ?local_ipv6_network_cidr  ?remote_ipv6_network_cidr 
      ?tunnel_inside_ip_version  ?(tunnel_options= [])  () =
      {
        enable_acceleration;
        static_routes_only;
        local_ipv4_network_cidr;
        remote_ipv4_network_cidr;
        local_ipv6_network_cidr;
        remote_ipv6_network_cidr;
        tunnel_inside_ip_version;
        tunnel_options
      }
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "enableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          local_ipv4_network_cidr =
            (Util.option_bind (Xml.member "localIpv4NetworkCidr" xml)
               String.parse);
          remote_ipv4_network_cidr =
            (Util.option_bind (Xml.member "remoteIpv4NetworkCidr" xml)
               String.parse);
          local_ipv6_network_cidr =
            (Util.option_bind (Xml.member "localIpv6NetworkCidr" xml)
               String.parse);
          remote_ipv6_network_cidr =
            (Util.option_bind (Xml.member "remoteIpv6NetworkCidr" xml)
               String.parse);
          tunnel_inside_ip_version =
            (Util.option_bind (Xml.member "tunnelInsideIpVersion" xml)
               TunnelInsideIpVersion.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "tunnelOptionSet" xml)
                  TunnelOptionsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TunnelOptionSet",
                   (TunnelOptionsList.to_query v.tunnel_options)));
           Util.option_map v.tunnel_inside_ip_version
             (fun f ->
                Query.Pair
                  ("TunnelInsideIpVersion",
                    (TunnelInsideIpVersion.to_query f)));
           Util.option_map v.remote_ipv6_network_cidr
             (fun f ->
                Query.Pair ("RemoteIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f ->
                Query.Pair ("RemoteIpv4NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv4NetworkCidr", (String.to_query f)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tunnel_options",
                (TunnelOptionsList.to_json v.tunnel_options));
           Util.option_map v.tunnel_inside_ip_version
             (fun f ->
                ("tunnel_inside_ip_version",
                  (TunnelInsideIpVersion.to_json f)));
           Util.option_map v.remote_ipv6_network_cidr
             (fun f -> ("remote_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f -> ("local_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f -> ("remote_ipv4_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f -> ("local_ipv4_network_cidr", (String.to_json f)));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let of_json j =
      {
        enable_acceleration =
          (Util.option_map (Json.lookup j "enable_acceleration")
             Boolean.of_json);
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json);
        local_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv4_network_cidr")
             String.of_json);
        remote_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv4_network_cidr")
             String.of_json);
        local_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv6_network_cidr")
             String.of_json);
        remote_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv6_network_cidr")
             String.of_json);
        tunnel_inside_ip_version =
          (Util.option_map (Json.lookup j "tunnel_inside_ip_version")
             TunnelInsideIpVersion.of_json);
        tunnel_options =
          (TunnelOptionsList.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")))
      }
  end
module VpnStaticRouteList =
  struct
    type t = VpnStaticRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpnStaticRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnStaticRoute.to_query v
    let to_json v = `List (List.map VpnStaticRoute.to_json v)
    let of_json j = Json.to_list VpnStaticRoute.of_json j
  end
module AssociationStatus =
  struct
    type t =
      {
      code: AssociationStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               AssociationStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (AssociationStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (AssociationStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             AssociationStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VpcPeeringConnectionStateReason =
  struct
    type t =
      {
      code: VpcPeeringConnectionStateReasonCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               VpcPeeringConnectionStateReasonCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (VpcPeeringConnectionStateReasonCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (VpcPeeringConnectionStateReasonCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             VpcPeeringConnectionStateReasonCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module VpcPeeringConnectionVpcInfo =
  struct
    type t =
      {
      cidr_block: String.t option ;
      ipv6_cidr_block_set: Ipv6CidrBlockSet.t ;
      cidr_block_set: CidrBlockSet.t ;
      owner_id: String.t option ;
      peering_options: VpcPeeringConnectionOptionsDescription.t option ;
      vpc_id: String.t option ;
      region: String.t option }
    let make ?cidr_block  ?(ipv6_cidr_block_set= [])  ?(cidr_block_set= []) 
      ?owner_id  ?peering_options  ?vpc_id  ?region  () =
      {
        cidr_block;
        ipv6_cidr_block_set;
        cidr_block_set;
        owner_id;
        peering_options;
        vpc_id;
        region
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          ipv6_cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6CidrBlockSet" xml)
                  Ipv6CidrBlockSet.parse));
          cidr_block_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockSet" xml)
                  CidrBlockSet.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          peering_options =
            (Util.option_bind (Xml.member "peeringOptions" xml)
               VpcPeeringConnectionOptionsDescription.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.peering_options
             (fun f ->
                Query.Pair
                  ("PeeringOptions",
                    (VpcPeeringConnectionOptionsDescription.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("CidrBlockSet", (CidrBlockSet.to_query v.cidr_block_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockSet",
                  (Ipv6CidrBlockSet.to_query v.ipv6_cidr_block_set)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.peering_options
             (fun f ->
                ("peering_options",
                  (VpcPeeringConnectionOptionsDescription.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("cidr_block_set", (CidrBlockSet.to_json v.cidr_block_set));
           Some
             ("ipv6_cidr_block_set",
               (Ipv6CidrBlockSet.to_json v.ipv6_cidr_block_set));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        ipv6_cidr_block_set =
          (Ipv6CidrBlockSet.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_cidr_block_set")));
        cidr_block_set =
          (CidrBlockSet.of_json
             (Util.of_option_exn (Json.lookup j "cidr_block_set")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        peering_options =
          (Util.option_map (Json.lookup j "peering_options")
             VpcPeeringConnectionOptionsDescription.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        region = (Util.option_map (Json.lookup j "region") String.of_json)
      }
  end
module NetworkAclAssociationList =
  struct
    type t = NetworkAclAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclAssociation.to_query v
    let to_json v = `List (List.map NetworkAclAssociation.to_json v)
    let of_json j = Json.to_list NetworkAclAssociation.of_json j
  end
module NetworkAclEntryList =
  struct
    type t = NetworkAclEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkAclEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAclEntry.to_query v
    let to_json v = `List (List.map NetworkAclEntry.to_json v)
    let of_json j = Json.to_list NetworkAclEntry.of_json j
  end
module CancelSpotFleetRequestsError =
  struct
    type t = {
      code: CancelBatchErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               CancelBatchErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (CancelBatchErrorCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (CancelBatchErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             CancelBatchErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module BatchState =
  struct
    type t =
      | Submitted 
      | Active 
      | Cancelled 
      | Failed 
      | Cancelled_running 
      | Cancelled_terminating 
      | Modifying 
    let str_to_t =
      [("modifying", Modifying);
      ("cancelled_terminating", Cancelled_terminating);
      ("cancelled_running", Cancelled_running);
      ("failed", Failed);
      ("cancelled", Cancelled);
      ("active", Active);
      ("submitted", Submitted)]
    let t_to_str =
      [(Modifying, "modifying");
      (Cancelled_terminating, "cancelled_terminating");
      (Cancelled_running, "cancelled_running");
      (Failed, "failed");
      (Cancelled, "cancelled");
      (Active, "active");
      (Submitted, "submitted")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AccountAttributeValueList =
  struct
    type t = AccountAttributeValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttributeValue.to_query v
    let to_json v = `List (List.map AccountAttributeValue.to_json v)
    let of_json j = Json.to_list AccountAttributeValue.of_json j
  end
module DiskImageDetail =
  struct
    type t =
      {
      bytes: Long.t ;
      format: DiskImageFormat.t ;
      import_manifest_url: String.t }
    let make ~bytes  ~format  ~import_manifest_url  () =
      { bytes; format; import_manifest_url }
    let parse xml =
      Some
        {
          bytes =
            (Xml.required "bytes"
               (Util.option_bind (Xml.member "bytes" xml) Long.parse));
          format =
            (Xml.required "format"
               (Util.option_bind (Xml.member "format" xml)
                  DiskImageFormat.parse));
          import_manifest_url =
            (Xml.required "importManifestUrl"
               (Util.option_bind (Xml.member "importManifestUrl" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ImportManifestUrl",
                   (String.to_query v.import_manifest_url)));
           Some (Query.Pair ("Format", (DiskImageFormat.to_query v.format)));
           Some (Query.Pair ("Bytes", (Long.to_query v.bytes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("import_manifest_url", (String.to_json v.import_manifest_url));
           Some ("format", (DiskImageFormat.to_json v.format));
           Some ("bytes", (Long.to_json v.bytes))])
    let of_json j =
      {
        bytes = (Long.of_json (Util.of_option_exn (Json.lookup j "bytes")));
        format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "format")));
        import_manifest_url =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "import_manifest_url")))
      }
  end
module VolumeDetail =
  struct
    type t = {
      size: Long.t }
    let make ~size  () = { size }
    let parse xml =
      Some
        {
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Long.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Size", (Long.to_query v.size)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("size", (Long.to_json v.size))])
    let of_json j =
      { size = (Long.of_json (Util.of_option_exn (Json.lookup j "size"))) }
  end
module GroupIdentifierSet =
  struct
    type t = SecurityGroupIdentifier.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SecurityGroupIdentifier.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroupIdentifier.to_query v
    let to_json v = `List (List.map SecurityGroupIdentifier.to_json v)
    let of_json j = Json.to_list SecurityGroupIdentifier.of_json j
  end
module LastError =
  struct
    type t = {
      message: String.t option ;
      code: String.t option }
    let make ?message  ?code  () = { message; code }
    let parse xml =
      Some
        {
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse);
          code = (Util.option_bind (Xml.member "code" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.code
              (fun f -> Query.Pair ("Code", (String.to_query f)));
           Util.option_map v.message
             (fun f -> Query.Pair ("Message", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.code (fun f -> ("code", (String.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)))])
    let of_json j =
      {
        message = (Util.option_map (Json.lookup j "message") String.of_json);
        code = (Util.option_map (Json.lookup j "code") String.of_json)
      }
  end
module VpcEndpointType =
  struct
    type t =
      | Interface 
      | Gateway 
      | GatewayLoadBalancer 
    let str_to_t =
      [("GatewayLoadBalancer", GatewayLoadBalancer);
      ("Gateway", Gateway);
      ("Interface", Interface)]
    let t_to_str =
      [(GatewayLoadBalancer, "GatewayLoadBalancer");
      (Gateway, "Gateway");
      (Interface, "Interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayAttachmentAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module TransitGatewayAttachmentState =
  struct
    type t =
      | Initiating 
      | InitiatingRequest 
      | PendingAcceptance 
      | RollingBack 
      | Pending 
      | Available 
      | Modifying 
      | Deleting 
      | Deleted 
      | Failed 
      | Rejected 
      | Rejecting 
      | Failing 
    let str_to_t =
      [("failing", Failing);
      ("rejecting", Rejecting);
      ("rejected", Rejected);
      ("failed", Failed);
      ("deleted", Deleted);
      ("deleting", Deleting);
      ("modifying", Modifying);
      ("available", Available);
      ("pending", Pending);
      ("rollingBack", RollingBack);
      ("pendingAcceptance", PendingAcceptance);
      ("initiatingRequest", InitiatingRequest);
      ("initiating", Initiating)]
    let t_to_str =
      [(Failing, "failing");
      (Rejecting, "rejecting");
      (Rejected, "rejected");
      (Failed, "failed");
      (Deleted, "deleted");
      (Deleting, "deleting");
      (Modifying, "modifying");
      (Available, "available");
      (Pending, "pending");
      (RollingBack, "rollingBack");
      (PendingAcceptance, "pendingAcceptance");
      (InitiatingRequest, "initiatingRequest");
      (Initiating, "initiating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotState =
  struct
    type t =
      | Pending 
      | Completed 
      | Error 
    let str_to_t =
      [("error", Error); ("completed", Completed); ("pending", Pending)]
    let t_to_str =
      [(Error, "error"); (Completed, "completed"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorTargetType =
  struct
    type t =
      | Network_interface 
      | Network_load_balancer 
    let str_to_t =
      [("network-load-balancer", Network_load_balancer);
      ("network-interface", Network_interface)]
    let t_to_str =
      [(Network_load_balancer, "network-load-balancer");
      (Network_interface, "network-interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeModificationState =
  struct
    type t =
      | Modifying 
      | Optimizing 
      | Completed 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("completed", Completed);
      ("optimizing", Optimizing);
      ("modifying", Modifying)]
    let t_to_str =
      [(Failed, "failed");
      (Completed, "completed");
      (Optimizing, "optimizing");
      (Modifying, "modifying")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceAttachment =
  struct
    type t =
      {
      attach_time: DateTime.t option ;
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option ;
      device_index: Integer.t option ;
      network_card_index: Integer.t option ;
      instance_id: String.t option ;
      instance_owner_id: String.t option ;
      status: AttachmentStatus.t option }
    let make ?attach_time  ?attachment_id  ?delete_on_termination 
      ?device_index  ?network_card_index  ?instance_id  ?instance_owner_id 
      ?status  () =
      {
        attach_time;
        attachment_id;
        delete_on_termination;
        device_index;
        network_card_index;
        instance_id;
        instance_owner_id;
        status
      }
    let parse xml =
      Some
        {
          attach_time =
            (Util.option_bind (Xml.member "attachTime" xml) DateTime.parse);
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse);
          device_index =
            (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse);
          network_card_index =
            (Util.option_bind (Xml.member "networkCardIndex" xml)
               Integer.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_owner_id =
            (Util.option_bind (Xml.member "instanceOwnerId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AttachmentStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AttachmentStatus.to_query f)));
           Util.option_map v.instance_owner_id
             (fun f -> Query.Pair ("InstanceOwnerId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.network_card_index
             (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)));
           Util.option_map v.attach_time
             (fun f -> Query.Pair ("AttachTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AttachmentStatus.to_json f)));
           Util.option_map v.instance_owner_id
             (fun f -> ("instance_owner_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.network_card_index
             (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)));
           Util.option_map v.attach_time
             (fun f -> ("attach_time", (DateTime.to_json f)))])
    let of_json j =
      {
        attach_time =
          (Util.option_map (Json.lookup j "attach_time") DateTime.of_json);
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_owner_id =
          (Util.option_map (Json.lookup j "instance_owner_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AttachmentStatus.of_json)
      }
  end
module NetworkInterfaceIpv6AddressesList =
  struct
    type t = NetworkInterfaceIpv6Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfaceIpv6Address.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfaceIpv6Address.to_query v
    let to_json v = `List (List.map NetworkInterfaceIpv6Address.to_json v)
    let of_json j = Json.to_list NetworkInterfaceIpv6Address.of_json j
  end
module NetworkInterfacePrivateIpAddressList =
  struct
    type t = NetworkInterfacePrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePrivateIpAddress.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfacePrivateIpAddress.to_query v
    let to_json v =
      `List (List.map NetworkInterfacePrivateIpAddress.to_json v)
    let of_json j = Json.to_list NetworkInterfacePrivateIpAddress.of_json j
  end
module NetworkInterfaceType =
  struct
    type t =
      | Interface 
      | NatGateway 
      | Efa 
    let str_to_t =
      [("efa", Efa); ("natGateway", NatGateway); ("interface", Interface)]
    let t_to_str =
      [(Efa, "efa"); (NatGateway, "natGateway"); (Interface, "interface")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ConnectionNotificationState =
  struct
    type t =
      | Enabled 
      | Disabled 
    let str_to_t = [("Disabled", Disabled); ("Enabled", Enabled)]
    let t_to_str = [(Disabled, "Disabled"); (Enabled, "Enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ConnectionNotificationType =
  struct
    type t =
      | Topic 
    let str_to_t = [("Topic", Topic)]
    let t_to_str = [(Topic, "Topic")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OfferingClassType =
  struct
    type t =
      | Standard 
      | Convertible 
    let str_to_t = [("convertible", Convertible); ("standard", Standard)]
    let t_to_str = [(Convertible, "convertible"); (Standard, "standard")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module OfferingTypeValues =
  struct
    type t =
      | Heavy_Utilization 
      | Medium_Utilization 
      | Light_Utilization 
      | No_Upfront 
      | Partial_Upfront 
      | All_Upfront 
    let str_to_t =
      [("All Upfront", All_Upfront);
      ("Partial Upfront", Partial_Upfront);
      ("No Upfront", No_Upfront);
      ("Light Utilization", Light_Utilization);
      ("Medium Utilization", Medium_Utilization);
      ("Heavy Utilization", Heavy_Utilization)]
    let t_to_str =
      [(All_Upfront, "All Upfront");
      (Partial_Upfront, "Partial Upfront");
      (No_Upfront, "No Upfront");
      (Light_Utilization, "Light Utilization");
      (Medium_Utilization, "Medium Utilization");
      (Heavy_Utilization, "Heavy Utilization")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RIProductDescription =
  struct
    type t =
      | Linux_UNIX 
      | Linux_UNIX__Amazon_VPC_ 
      | Windows 
      | Windows__Amazon_VPC_ 
    let str_to_t =
      [("Windows (Amazon VPC)", Windows__Amazon_VPC_);
      ("Windows", Windows);
      ("Linux/UNIX (Amazon VPC)", Linux_UNIX__Amazon_VPC_);
      ("Linux/UNIX", Linux_UNIX)]
    let t_to_str =
      [(Windows__Amazon_VPC_, "Windows (Amazon VPC)");
      (Windows, "Windows");
      (Linux_UNIX__Amazon_VPC_, "Linux/UNIX (Amazon VPC)");
      (Linux_UNIX, "Linux/UNIX")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RecurringChargesList =
  struct
    type t = RecurringCharge.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RecurringCharge.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RecurringCharge.to_query v
    let to_json v = `List (List.map RecurringCharge.to_json v)
    let of_json j = Json.to_list RecurringCharge.of_json j
  end
module ReservedInstanceState =
  struct
    type t =
      | Payment_pending 
      | Active 
      | Payment_failed 
      | Retired 
      | Queued 
      | Queued_deleted 
    let str_to_t =
      [("queued-deleted", Queued_deleted);
      ("queued", Queued);
      ("retired", Retired);
      ("payment-failed", Payment_failed);
      ("active", Active);
      ("payment-pending", Payment_pending)]
    let t_to_str =
      [(Queued_deleted, "queued-deleted");
      (Queued, "queued");
      (Retired, "retired");
      (Payment_failed, "payment-failed");
      (Active, "active");
      (Payment_pending, "payment-pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PeeringAttachmentStatus =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PeeringTgwInfo =
  struct
    type t =
      {
      transit_gateway_id: String.t option ;
      owner_id: String.t option ;
      region: String.t option }
    let make ?transit_gateway_id  ?owner_id  ?region  () =
      { transit_gateway_id; owner_id; region }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          region = (Util.option_bind (Xml.member "region" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> Query.Pair ("Region", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.region
              (fun f -> ("region", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        region = (Util.option_map (Json.lookup j "region") String.of_json)
      }
  end
module CancelSpotInstanceRequestState =
  struct
    type t =
      | Active 
      | Open 
      | Closed 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("open", Open);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Open, "open");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PrivateDnsNameConfiguration =
  struct
    type t =
      {
      state: DnsNameState.t option ;
      type_: String.t option ;
      value: String.t option ;
      name: String.t option }
    let make ?state  ?type_  ?value  ?name  () =
      { state; type_; value; name }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "state" xml) DnsNameState.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          value = (Util.option_bind (Xml.member "value" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.value
             (fun f -> Query.Pair ("Value", (String.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (DnsNameState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (DnsNameState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state") DnsNameState.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") String.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ServiceState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
      | Failed 
    let str_to_t =
      [("Failed", Failed);
      ("Deleted", Deleted);
      ("Deleting", Deleting);
      ("Available", Available);
      ("Pending", Pending)]
    let t_to_str =
      [(Failed, "Failed");
      (Deleted, "Deleted");
      (Deleting, "Deleting");
      (Available, "Available");
      (Pending, "Pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ServiceTypeDetailSet =
  struct
    type t = ServiceTypeDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ServiceTypeDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceTypeDetail.to_query v
    let to_json v = `List (List.map ServiceTypeDetail.to_json v)
    let of_json j = Json.to_list ServiceTypeDetail.of_json j
  end
module ConversionTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportInstanceTaskDetails =
  struct
    type t =
      {
      description: String.t option ;
      instance_id: String.t option ;
      platform: PlatformValues.t option ;
      volumes: ImportInstanceVolumeDetailSet.t }
    let make ?description  ?instance_id  ?platform  ?(volumes= [])  () =
      { description; instance_id; platform; volumes }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumes" xml)
                  ImportInstanceVolumeDetailSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Volumes",
                   (ImportInstanceVolumeDetailSet.to_query v.volumes)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volumes", (ImportInstanceVolumeDetailSet.to_json v.volumes));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        volumes =
          (ImportInstanceVolumeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "volumes")))
      }
  end
module ImportVolumeTaskDetails =
  struct
    type t =
      {
      availability_zone: String.t option ;
      bytes_converted: Long.t option ;
      description: String.t option ;
      image: DiskImageDescription.t option ;
      volume: DiskImageVolumeDescription.t option }
    let make ?availability_zone  ?bytes_converted  ?description  ?image 
      ?volume  () =
      { availability_zone; bytes_converted; description; image; volume }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          bytes_converted =
            (Util.option_bind (Xml.member "bytesConverted" xml) Long.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "image" xml)
               DiskImageDescription.parse);
          volume =
            (Util.option_bind (Xml.member "volume" xml)
               DiskImageVolumeDescription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f ->
                 Query.Pair
                   ("Volume", (DiskImageVolumeDescription.to_query f)));
           Util.option_map v.image
             (fun f ->
                Query.Pair ("Image", (DiskImageDescription.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.bytes_converted
             (fun f -> Query.Pair ("BytesConverted", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (DiskImageVolumeDescription.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDescription.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.bytes_converted
             (fun f -> ("bytes_converted", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        bytes_converted =
          (Util.option_map (Json.lookup j "bytes_converted") Long.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image")
             DiskImageDescription.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume")
             DiskImageVolumeDescription.of_json)
      }
  end
module TransitGatewayVpcAttachmentOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option ;
      appliance_mode_support: ApplianceModeSupportValue.t option }
    let make ?dns_support  ?ipv6_support  ?appliance_mode_support  () =
      { dns_support; ipv6_support; appliance_mode_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "dnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "ipv6Support" xml)
               Ipv6SupportValue.parse);
          appliance_mode_support =
            (Util.option_bind (Xml.member "applianceModeSupport" xml)
               ApplianceModeSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 Query.Pair
                   ("ApplianceModeSupport",
                     (ApplianceModeSupportValue.to_query f)));
           Util.option_map v.ipv6_support
             (fun f ->
                Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 ("appliance_mode_support",
                   (ApplianceModeSupportValue.to_json f)));
           Util.option_map v.ipv6_support
             (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json);
        appliance_mode_support =
          (Util.option_map (Json.lookup j "appliance_mode_support")
             ApplianceModeSupportValue.of_json)
      }
  end
module ReservationValue =
  struct
    type t =
      {
      hourly_price: String.t option ;
      remaining_total_value: String.t option ;
      remaining_upfront_value: String.t option }
    let make ?hourly_price  ?remaining_total_value  ?remaining_upfront_value 
      () = { hourly_price; remaining_total_value; remaining_upfront_value }
    let parse xml =
      Some
        {
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          remaining_total_value =
            (Util.option_bind (Xml.member "remainingTotalValue" xml)
               String.parse);
          remaining_upfront_value =
            (Util.option_bind (Xml.member "remainingUpfrontValue" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f ->
                 Query.Pair ("RemainingUpfrontValue", (String.to_query f)));
           Util.option_map v.remaining_total_value
             (fun f ->
                Query.Pair ("RemainingTotalValue", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.remaining_upfront_value
              (fun f -> ("remaining_upfront_value", (String.to_json f)));
           Util.option_map v.remaining_total_value
             (fun f -> ("remaining_total_value", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)))])
    let of_json j =
      {
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        remaining_total_value =
          (Util.option_map (Json.lookup j "remaining_total_value")
             String.of_json);
        remaining_upfront_value =
          (Util.option_map (Json.lookup j "remaining_upfront_value")
             String.of_json)
      }
  end
module TargetConfiguration =
  struct
    type t =
      {
      instance_count: Integer.t option ;
      offering_id: String.t option }
    let make ?instance_count  ?offering_id  () =
      { instance_count; offering_id }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json)
      }
  end
module TransitGatewayRouteAttachmentList =
  struct
    type t = TransitGatewayRouteAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteAttachment.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteAttachment.to_query v
    let to_json v = `List (List.map TransitGatewayRouteAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayRouteAttachment.of_json j
  end
module TransitGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module EventType =
  struct
    type t =
      | InstanceChange 
      | FleetRequestChange 
      | Error 
      | Information 
    let str_to_t =
      [("information", Information);
      ("error", Error);
      ("fleetRequestChange", FleetRequestChange);
      ("instanceChange", InstanceChange)]
    let t_to_str =
      [(Information, "information");
      (Error, "error");
      (FleetRequestChange, "fleetRequestChange");
      (InstanceChange, "instanceChange")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaImageState =
  struct
    type t = {
      code: FpgaImageStateCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               FpgaImageStateCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (FpgaImageStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (FpgaImageStateCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code") FpgaImageStateCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PciId =
  struct
    type t =
      {
      device_id: String.t option ;
      vendor_id: String.t option ;
      subsystem_id: String.t option ;
      subsystem_vendor_id: String.t option }
    let make ?device_id  ?vendor_id  ?subsystem_id  ?subsystem_vendor_id  ()
      = { device_id; vendor_id; subsystem_id; subsystem_vendor_id }
    let parse xml =
      Some
        {
          device_id =
            (Util.option_bind (Xml.member "DeviceId" xml) String.parse);
          vendor_id =
            (Util.option_bind (Xml.member "VendorId" xml) String.parse);
          subsystem_id =
            (Util.option_bind (Xml.member "SubsystemId" xml) String.parse);
          subsystem_vendor_id =
            (Util.option_bind (Xml.member "SubsystemVendorId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> Query.Pair ("SubsystemVendorId", (String.to_query f)));
           Util.option_map v.subsystem_id
             (fun f -> Query.Pair ("SubsystemId", (String.to_query f)));
           Util.option_map v.vendor_id
             (fun f -> Query.Pair ("VendorId", (String.to_query f)));
           Util.option_map v.device_id
             (fun f -> Query.Pair ("DeviceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subsystem_vendor_id
              (fun f -> ("subsystem_vendor_id", (String.to_json f)));
           Util.option_map v.subsystem_id
             (fun f -> ("subsystem_id", (String.to_json f)));
           Util.option_map v.vendor_id
             (fun f -> ("vendor_id", (String.to_json f)));
           Util.option_map v.device_id
             (fun f -> ("device_id", (String.to_json f)))])
    let of_json j =
      {
        device_id =
          (Util.option_map (Json.lookup j "device_id") String.of_json);
        vendor_id =
          (Util.option_map (Json.lookup j "vendor_id") String.of_json);
        subsystem_id =
          (Util.option_map (Json.lookup j "subsystem_id") String.of_json);
        subsystem_vendor_id =
          (Util.option_map (Json.lookup j "subsystem_vendor_id")
             String.of_json)
      }
  end
module EnableFastSnapshotRestoreStateErrorSet =
  struct
    type t = EnableFastSnapshotRestoreStateErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreStateErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreStateErrorItem.to_query v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreStateErrorItem.to_json v)
    let of_json j =
      Json.to_list EnableFastSnapshotRestoreStateErrorItem.of_json j
  end
module PropagatingVgwList =
  struct
    type t = PropagatingVgw.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PropagatingVgw.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PropagatingVgw.to_query v
    let to_json v = `List (List.map PropagatingVgw.to_json v)
    let of_json j = Json.to_list PropagatingVgw.of_json j
  end
module RouteList =
  struct
    type t = Route.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Route.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Route.to_query v
    let to_json v = `List (List.map Route.to_json v)
    let of_json j = Json.to_list Route.of_json j
  end
module RouteTableAssociationList =
  struct
    type t = RouteTableAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RouteTableAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTableAssociation.to_query v
    let to_json v = `List (List.map RouteTableAssociation.to_json v)
    let of_json j = Json.to_list RouteTableAssociation.of_json j
  end
module IamInstanceProfileAssociationState =
  struct
    type t =
      | Associating 
      | Associated 
      | Disassociating 
      | Disassociated 
    let str_to_t =
      [("disassociated", Disassociated);
      ("disassociating", Disassociating);
      ("associated", Associated);
      ("associating", Associating)]
    let t_to_str =
      [(Disassociated, "disassociated");
      (Disassociating, "disassociating");
      (Associated, "associated");
      (Associating, "associating")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ResponseLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecification.t option ;
      block_device_mappings: LaunchTemplateBlockDeviceMappingList.t ;
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      key_name: String.t option ;
      monitoring: LaunchTemplatesMonitoring.t option ;
      placement: LaunchTemplatePlacement.t option ;
      ram_disk_id: String.t option ;
      disable_api_termination: Boolean.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      user_data: String.t option ;
      tag_specifications: LaunchTemplateTagSpecificationList.t ;
      elastic_gpu_specifications: ElasticGpuSpecificationResponseList.t ;
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorResponseList.t ;
      security_group_ids: ValueStringList.t ;
      security_groups: ValueStringList.t ;
      instance_market_options: LaunchTemplateInstanceMarketOptions.t option ;
      credit_specification: CreditSpecification.t option ;
      cpu_options: LaunchTemplateCpuOptions.t option ;
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationResponse.t option ;
      license_specifications: LaunchTemplateLicenseList.t ;
      hibernation_options: LaunchTemplateHibernationOptions.t option ;
      metadata_options: LaunchTemplateInstanceMetadataOptions.t option ;
      enclave_options: LaunchTemplateEnclaveOptions.t option }
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  ?metadata_options 
      ?enclave_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options;
        metadata_options;
        enclave_options
      }
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecification.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMappingSet" xml)
                  LaunchTemplateBlockDeviceMappingList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               LaunchTemplatesMonitoring.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               LaunchTemplatePlacement.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "ramDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSpecificationSet" xml)
                  LaunchTemplateTagSpecificationList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticGpuSpecificationSet" xml)
                  ElasticGpuSpecificationResponseList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "elasticInferenceAcceleratorSet" xml)
                  LaunchTemplateElasticInferenceAcceleratorResponseList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIdSet" xml)
                  ValueStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupSet" xml)
                  ValueStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "instanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptions.parse);
          credit_specification =
            (Util.option_bind (Xml.member "creditSpecification" xml)
               CreditSpecification.parse);
          cpu_options =
            (Util.option_bind (Xml.member "cpuOptions" xml)
               LaunchTemplateCpuOptions.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "capacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationResponse.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSet" xml)
                  LaunchTemplateLicenseList.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "hibernationOptions" xml)
               LaunchTemplateHibernationOptions.parse);
          metadata_options =
            (Util.option_bind (Xml.member "metadataOptions" xml)
               LaunchTemplateInstanceMetadataOptions.parse);
          enclave_options =
            (Util.option_bind (Xml.member "enclaveOptions" xml)
               LaunchTemplateEnclaveOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 Query.Pair
                   ("EnclaveOptions",
                     (LaunchTemplateEnclaveOptions.to_query f)));
           Util.option_map v.metadata_options
             (fun f ->
                Query.Pair
                  ("MetadataOptions",
                    (LaunchTemplateInstanceMetadataOptions.to_query f)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions",
                    (LaunchTemplateHibernationOptions.to_query f)));
           Some
             (Query.Pair
                ("LicenseSet",
                  (LaunchTemplateLicenseList.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationResponse.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions", (LaunchTemplateCpuOptions.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification", (CreditSpecification.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptions.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupSet",
                  (ValueStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupIdSet",
                  (ValueStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAcceleratorSet",
                  (LaunchTemplateElasticInferenceAcceleratorResponseList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecificationSet",
                  (ElasticGpuSpecificationResponseList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecificationSet",
                  (LaunchTemplateTagSpecificationList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacement.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (LaunchTemplatesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMappingSet",
                  (LaunchTemplateBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 ("enclave_options",
                   (LaunchTemplateEnclaveOptions.to_json f)));
           Util.option_map v.metadata_options
             (fun f ->
                ("metadata_options",
                  (LaunchTemplateInstanceMetadataOptions.to_json f)));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options",
                  (LaunchTemplateHibernationOptions.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseList.to_json v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationResponse.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (LaunchTemplateCpuOptions.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification", (CreditSpecification.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptions.to_json f)));
           Some
             ("security_groups", (ValueStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (ValueStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorResponseList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationResponseList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (LaunchTemplatePlacement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (LaunchTemplatesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let of_json j =
      {
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             LaunchTemplateIamInstanceProfileSpecification.of_json);
        block_device_mappings =
          (LaunchTemplateBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        network_interfaces =
          (LaunchTemplateInstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             LaunchTemplatesMonitoring.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             LaunchTemplatePlacement.of_json);
        ram_disk_id =
          (Util.option_map (Json.lookup j "ram_disk_id") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        tag_specifications =
          (LaunchTemplateTagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        elastic_gpu_specifications =
          (ElasticGpuSpecificationResponseList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specifications")));
        elastic_inference_accelerators =
          (LaunchTemplateElasticInferenceAcceleratorResponseList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        security_group_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             LaunchTemplateInstanceMarketOptions.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecification.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             LaunchTemplateCpuOptions.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             LaunchTemplateCapacityReservationSpecificationResponse.of_json);
        license_specifications =
          (LaunchTemplateLicenseList.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             LaunchTemplateHibernationOptions.of_json);
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             LaunchTemplateInstanceMetadataOptions.of_json);
        enclave_options =
          (Util.option_map (Json.lookup j "enclave_options")
             LaunchTemplateEnclaveOptions.of_json)
      }
  end
module CarrierGatewayState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module MembershipType =
  struct
    type t =
      | Static 
      | Igmp 
    let str_to_t = [("igmp", Igmp); ("static", Static)]
    let t_to_str = [(Igmp, "igmp"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LocalGatewayVirtualInterfaceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MoveStatus =
  struct
    type t =
      | MovingToVpc 
      | RestoringToClassic 
    let str_to_t =
      [("restoringToClassic", RestoringToClassic);
      ("movingToVpc", MovingToVpc)]
    let t_to_str =
      [(RestoringToClassic, "restoringToClassic");
      (MovingToVpc, "movingToVpc")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuSpecification =
  struct
    type t = {
      type_: String.t }
    let make ~type_  () = { type_ }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("type_", (String.to_json v.type_))])
    let of_json j =
      { type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")))
      }
  end
module LaunchTemplateBlockDeviceMappingRequest =
  struct
    type t =
      {
      device_name: String.t option ;
      virtual_name: String.t option ;
      ebs: LaunchTemplateEbsBlockDeviceRequest.t option ;
      no_device: String.t option }
    let make ?device_name  ?virtual_name  ?ebs  ?no_device  () =
      { device_name; virtual_name; ebs; no_device }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               LaunchTemplateEbsBlockDeviceRequest.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (LaunchTemplateEbsBlockDeviceRequest.to_query f)));
           Util.option_map v.virtual_name
             (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_device
              (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (LaunchTemplateEbsBlockDeviceRequest.to_json f)));
           Util.option_map v.virtual_name
             (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             LaunchTemplateEbsBlockDeviceRequest.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json)
      }
  end
module CapacityReservationTarget =
  struct
    type t =
      {
      capacity_reservation_id: String.t option ;
      capacity_reservation_resource_group_arn: String.t option }
    let make ?capacity_reservation_id 
      ?capacity_reservation_resource_group_arn  () =
      { capacity_reservation_id; capacity_reservation_resource_group_arn }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "CapacityReservationId" xml)
               String.parse);
          capacity_reservation_resource_group_arn =
            (Util.option_bind
               (Xml.member "CapacityReservationResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_resource_group_arn
              (fun f ->
                 Query.Pair
                   ("CapacityReservationResourceGroupArn",
                     (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_resource_group_arn
              (fun f ->
                 ("capacity_reservation_resource_group_arn",
                   (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        capacity_reservation_resource_group_arn =
          (Util.option_map
             (Json.lookup j "capacity_reservation_resource_group_arn")
             String.of_json)
      }
  end
module LaunchTemplateElasticInferenceAccelerator =
  struct
    type t = {
      type_: String.t ;
      count: Integer.t option }
    let make ~type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let of_json j =
      {
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module LaunchTemplateSpotMarketOptionsRequest =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequest =
  struct
    type t =
      {
      associate_carrier_ip_address: Boolean.t option ;
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: SecurityGroupIdStringList.t ;
      interface_type: String.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressListRequest.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option ;
      network_card_index: Integer.t option }
    let make ?associate_carrier_ip_address  ?associate_public_ip_address 
      ?delete_on_termination  ?description  ?device_index  ?(groups= []) 
      ?interface_type  ?ipv6_address_count  ?(ipv6_addresses= []) 
      ?network_interface_id  ?private_ip_address  ?(private_ip_addresses= [])
       ?secondary_private_ip_address_count  ?subnet_id  ?network_card_index 
      () =
      {
        associate_carrier_ip_address;
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        interface_type;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        subnet_id;
        network_card_index
      }
    let parse xml =
      Some
        {
          associate_carrier_ip_address =
            (Util.option_bind (Xml.member "AssociateCarrierIpAddress" xml)
               Boolean.parse);
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml) String.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Addresses" xml)
                  InstanceIpv6AddressListRequest.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          network_card_index =
            (Util.option_bind (Xml.member "NetworkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (InstanceIpv6AddressListRequest.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.interface_type
             (fun f -> Query.Pair ("InterfaceType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f ->
                Query.Pair
                  ("AssociateCarrierIpAddress", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressListRequest.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (String.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)));
           Util.option_map v.associate_carrier_ip_address
             (fun f -> ("associate_carrier_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_carrier_ip_address =
          (Util.option_map (Json.lookup j "associate_carrier_ip_address")
             Boolean.of_json);
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type") String.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressListRequest.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module LaunchTemplateLicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LaunchTemplateTagSpecificationRequest =
  struct
    type t = {
      resource_type: ResourceType.t option ;
      tags: TagList.t }
    let make ?resource_type  ?(tags= [])  () = { resource_type; tags }
    let parse xml =
      Some
        {
          resource_type =
            (Util.option_bind (Xml.member "ResourceType" xml)
               ResourceType.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Util.option_map v.resource_type
             (fun f -> Query.Pair ("ResourceType", (ResourceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.resource_type
             (fun f -> ("resource_type", (ResourceType.to_json f)))])
    let of_json j =
      {
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             ResourceType.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PoolCidrBlocksSet =
  struct
    type t = PoolCidrBlock.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PoolCidrBlock.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PoolCidrBlock.to_query v
    let to_json v = `List (List.map PoolCidrBlock.to_json v)
    let of_json j = Json.to_list PoolCidrBlock.of_json j
  end
module ResponseError =
  struct
    type t =
      {
      code: LaunchTemplateErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               LaunchTemplateErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (LaunchTemplateErrorCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (LaunchTemplateErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             LaunchTemplateErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module LaunchSpecification =
  struct
    type t =
      {
      user_data: String.t option ;
      security_groups: GroupIdentifierList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      subnet_id: String.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option }
    let make ?user_data  ?(security_groups= [])  ?addressing_type 
      ?(block_device_mappings= [])  ?ebs_optimized  ?iam_instance_profile 
      ?image_id  ?instance_type  ?kernel_id  ?key_name  ?(network_interfaces=
      [])  ?placement  ?ramdisk_id  ?subnet_id  ?monitoring  () =
      {
        user_data;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        monitoring
      }
    let parse xml =
      Some
        {
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 Query.Pair
                   ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet",
                  (GroupIdentifierList.to_query v.security_groups)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f ->
                 ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (GroupIdentifierList.to_json v.security_groups));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)))])
    let of_json j =
      {
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        security_groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json)
      }
  end
module SpotInstanceState =
  struct
    type t =
      | Open 
      | Active 
      | Closed 
      | Cancelled 
      | Failed 
    let str_to_t =
      [("failed", Failed);
      ("cancelled", Cancelled);
      ("closed", Closed);
      ("active", Active);
      ("open", Open)]
    let t_to_str =
      [(Failed, "failed");
      (Cancelled, "cancelled");
      (Closed, "closed");
      (Active, "active");
      (Open, "open")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotInstanceStateFault =
  struct
    type t = {
      code: String.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module SpotInstanceStatus =
  struct
    type t =
      {
      code: String.t option ;
      message: String.t option ;
      update_time: DateTime.t option }
    let make ?code  ?message  ?update_time  () =
      { code; message; update_time }
    let parse xml =
      Some
        {
          code = (Util.option_bind (Xml.member "code" xml) String.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.message
             (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f -> Query.Pair ("Code", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_time
              (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.message
             (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code (fun f -> ("code", (String.to_json f)))])
    let of_json j =
      {
        code = (Util.option_map (Json.lookup j "code") String.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json);
        update_time =
          (Util.option_map (Json.lookup j "update_time") DateTime.of_json)
      }
  end
module DeleteQueuedReservedInstancesError =
  struct
    type t =
      {
      code: DeleteQueuedReservedInstancesErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               DeleteQueuedReservedInstancesErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (DeleteQueuedReservedInstancesErrorCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (DeleteQueuedReservedInstancesErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             DeleteQueuedReservedInstancesErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ExportTaskState =
  struct
    type t =
      | Active 
      | Cancelling 
      | Cancelled 
      | Completed 
    let str_to_t =
      [("completed", Completed);
      ("cancelled", Cancelled);
      ("cancelling", Cancelling);
      ("active", Active)]
    let t_to_str =
      [(Completed, "completed");
      (Cancelled, "cancelled");
      (Cancelling, "cancelling");
      (Active, "active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ExportToS3Task =
  struct
    type t =
      {
      container_format: ContainerFormat.t option ;
      disk_image_format: DiskImageFormat.t option ;
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_key  () =
      { container_format; disk_image_format; s3_bucket; s3_key }
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "s3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let of_json j =
      {
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module InstanceExportDetails =
  struct
    type t =
      {
      instance_id: String.t option ;
      target_environment: ExportEnvironment.t option }
    let make ?instance_id  ?target_environment  () =
      { instance_id; target_environment }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          target_environment =
            (Util.option_bind (Xml.member "targetEnvironment" xml)
               ExportEnvironment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f ->
                 Query.Pair
                   ("TargetEnvironment", (ExportEnvironment.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_environment
              (fun f -> ("target_environment", (ExportEnvironment.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        target_environment =
          (Util.option_map (Json.lookup j "target_environment")
             ExportEnvironment.of_json)
      }
  end
module IpPermissionList =
  struct
    type t = IpPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map IpPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list IpPermission.to_query v
    let to_json v = `List (List.map IpPermission.to_json v)
    let of_json j = Json.to_list IpPermission.of_json j
  end
module AssociatedTargetNetworkSet =
  struct
    type t = AssociatedTargetNetwork.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociatedTargetNetwork.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AssociatedTargetNetwork.to_query v
    let to_json v = `List (List.map AssociatedTargetNetwork.to_json v)
    let of_json j = Json.to_list AssociatedTargetNetwork.of_json j
  end
module ClientConnectResponseOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      lambda_function_arn: String.t option ;
      status: ClientVpnEndpointAttributeStatus.t option }
    let make ?enabled  ?lambda_function_arn  ?status  () =
      { enabled; lambda_function_arn; status }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "enabled" xml) Boolean.parse);
          lambda_function_arn =
            (Util.option_bind (Xml.member "lambdaFunctionArn" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointAttributeStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnEndpointAttributeStatus.to_query f)));
           Util.option_map v.lambda_function_arn
             (fun f -> Query.Pair ("LambdaFunctionArn", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnEndpointAttributeStatus.to_json f)));
           Util.option_map v.lambda_function_arn
             (fun f -> ("lambda_function_arn", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        lambda_function_arn =
          (Util.option_map (Json.lookup j "lambda_function_arn")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointAttributeStatus.of_json)
      }
  end
module ClientVpnAuthenticationList =
  struct
    type t = ClientVpnAuthentication.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthentication.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnAuthentication.to_query v
    let to_json v = `List (List.map ClientVpnAuthentication.to_json v)
    let of_json j = Json.to_list ClientVpnAuthentication.of_json j
  end
module ClientVpnEndpointStatus =
  struct
    type t =
      {
      code: ClientVpnEndpointStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnEndpointStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair ("Code", (ClientVpnEndpointStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f -> ("code", (ClientVpnEndpointStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnEndpointStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module ClientVpnSecurityGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ConnectionLogResponseOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      cloudwatch_log_group: String.t option ;
      cloudwatch_log_stream: String.t option }
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        cloudwatch_log_group =
          (Util.option_map (Json.lookup j "cloudwatch_log_group")
             String.of_json);
        cloudwatch_log_stream =
          (Util.option_map (Json.lookup j "cloudwatch_log_stream")
             String.of_json)
      }
  end
module TransportProtocol =
  struct
    type t =
      | Tcp 
      | Udp 
    let str_to_t = [("udp", Udp); ("tcp", Tcp)]
    let t_to_str = [(Udp, "udp"); (Tcp, "tcp")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpnProtocol =
  struct
    type t =
      | Openvpn 
    let str_to_t = [("openvpn", Openvpn)]
    let t_to_str = [(Openvpn, "openvpn")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateOverridesListRequest =
  struct
    type t = FleetLaunchTemplateOverridesRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateOverridesRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateOverridesRequest.to_query v
    let to_json v =
      `List (List.map FleetLaunchTemplateOverridesRequest.to_json v)
    let of_json j =
      Json.to_list FleetLaunchTemplateOverridesRequest.of_json j
  end
module FleetLaunchTemplateSpecificationRequest =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module FleetSpotCapacityRebalanceRequest =
  struct
    type t = {
      replacement_strategy: FleetReplacementStrategy.t option }
    let make ?replacement_strategy  () = { replacement_strategy }
    let parse xml =
      Some
        {
          replacement_strategy =
            (Util.option_bind (Xml.member "ReplacementStrategy" xml)
               FleetReplacementStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 Query.Pair
                   ("ReplacementStrategy",
                     (FleetReplacementStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.replacement_strategy
              (fun f ->
                 ("replacement_strategy",
                   (FleetReplacementStrategy.to_json f)))])
    let of_json j =
      {
        replacement_strategy =
          (Util.option_map (Json.lookup j "replacement_strategy")
             FleetReplacementStrategy.of_json)
      }
  end
module InternetGatewayAttachmentList =
  struct
    type t = InternetGatewayAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGatewayAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGatewayAttachment.to_query v
    let to_json v = `List (List.map InternetGatewayAttachment.to_json v)
    let of_json j = Json.to_list InternetGatewayAttachment.of_json j
  end
module DescribeFleetsErrorSet =
  struct
    type t = DescribeFleetError.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFleetError.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DescribeFleetError.to_query v
    let to_json v = `List (List.map DescribeFleetError.to_json v)
    let of_json j = Json.to_list DescribeFleetError.of_json j
  end
module DescribeFleetsInstancesSet =
  struct
    type t = DescribeFleetsInstances.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFleetsInstances.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DescribeFleetsInstances.to_query v
    let to_json v = `List (List.map DescribeFleetsInstances.to_json v)
    let of_json j = Json.to_list DescribeFleetsInstances.of_json j
  end
module FleetActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetExcessCapacityTerminationPolicy =
  struct
    type t =
      | No_termination 
      | Termination 
    let str_to_t =
      [("termination", Termination); ("no-termination", No_termination)]
    let t_to_str =
      [(Termination, "termination"); (No_termination, "no-termination")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetLaunchTemplateConfigList =
  struct
    type t = FleetLaunchTemplateConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FleetLaunchTemplateConfig.to_query v
    let to_json v = `List (List.map FleetLaunchTemplateConfig.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateConfig.of_json j
  end
module OnDemandOptions =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option ;
      capacity_reservation_options: CapacityReservationOptions.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "capacityReservationOptions" xml)
               CapacityReservationOptions.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptions.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptions.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             FleetOnDemandAllocationStrategy.of_json);
        capacity_reservation_options =
          (Util.option_map (Json.lookup j "capacity_reservation_options")
             CapacityReservationOptions.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module SpotOptions =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option ;
      maintenance_strategies: FleetSpotMaintenanceStrategies.t option ;
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option ;
      instance_pools_to_use_count: Integer.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?maintenance_strategies 
      ?instance_interruption_behavior  ?instance_pools_to_use_count 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        maintenance_strategies;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               SpotAllocationStrategy.parse);
          maintenance_strategies =
            (Util.option_bind (Xml.member "maintenanceStrategies" xml)
               FleetSpotMaintenanceStrategies.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "singleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "singleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "minTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "maxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.maintenance_strategies
             (fun f ->
                Query.Pair
                  ("MaintenanceStrategies",
                    (FleetSpotMaintenanceStrategies.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.maintenance_strategies
             (fun f ->
                ("maintenance_strategies",
                  (FleetSpotMaintenanceStrategies.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             SpotAllocationStrategy.of_json);
        maintenance_strategies =
          (Util.option_map (Json.lookup j "maintenance_strategies")
             FleetSpotMaintenanceStrategies.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             SpotInstanceInterruptionBehavior.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module TargetCapacitySpecification =
  struct
    type t =
      {
      total_target_capacity: Integer.t option ;
      on_demand_target_capacity: Integer.t option ;
      spot_target_capacity: Integer.t option ;
      default_target_capacity_type: DefaultTargetCapacityType.t option }
    let make ?total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let parse xml =
      Some
        {
          total_target_capacity =
            (Util.option_bind (Xml.member "totalTargetCapacity" xml)
               Integer.parse);
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "spotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "defaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Util.option_map v.total_target_capacity
             (fun f ->
                Query.Pair ("TotalTargetCapacity", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Util.option_map v.total_target_capacity
             (fun f -> ("total_target_capacity", (Integer.to_json f)))])
    let of_json j =
      {
        total_target_capacity =
          (Util.option_map (Json.lookup j "total_target_capacity")
             Integer.of_json);
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        spot_target_capacity =
          (Util.option_map (Json.lookup j "spot_target_capacity")
             Integer.of_json);
        default_target_capacity_type =
          (Util.option_map (Json.lookup j "default_target_capacity_type")
             DefaultTargetCapacityType.of_json)
      }
  end
module ActivityStatus =
  struct
    type t =
      | Error 
      | Pending_fulfillment 
      | Pending_termination 
      | Fulfilled 
    let str_to_t =
      [("fulfilled", Fulfilled);
      ("pending_termination", Pending_termination);
      ("pending_fulfillment", Pending_fulfillment);
      ("error", Error)]
    let t_to_str =
      [(Fulfilled, "fulfilled");
      (Pending_termination, "pending_termination");
      (Pending_fulfillment, "pending_fulfillment");
      (Error, "error")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SpotFleetRequestConfigData =
  struct
    type t =
      {
      allocation_strategy: AllocationStrategy.t option ;
      on_demand_allocation_strategy: OnDemandAllocationStrategy.t option ;
      spot_maintenance_strategies: SpotMaintenanceStrategies.t option ;
      client_token: String.t option ;
      excess_capacity_termination_policy:
        ExcessCapacityTerminationPolicy.t option ;
      fulfilled_capacity: Double.t option ;
      on_demand_fulfilled_capacity: Double.t option ;
      iam_fleet_role: String.t ;
      launch_specifications: LaunchSpecsList.t ;
      launch_template_configs: LaunchTemplateConfigList.t ;
      spot_price: String.t option ;
      target_capacity: Integer.t ;
      on_demand_target_capacity: Integer.t option ;
      on_demand_max_total_price: String.t option ;
      spot_max_total_price: String.t option ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option ;
      load_balancers_config: LoadBalancersConfig.t option ;
      instance_pools_to_use_count: Integer.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?allocation_strategy  ?on_demand_allocation_strategy 
      ?spot_maintenance_strategies  ?client_token 
      ?excess_capacity_termination_policy  ?fulfilled_capacity 
      ?on_demand_fulfilled_capacity  ~iam_fleet_role 
      ?(launch_specifications= [])  ?(launch_template_configs= []) 
      ?spot_price  ~target_capacity  ?on_demand_target_capacity 
      ?on_demand_max_total_price  ?spot_max_total_price 
      ?terminate_instances_with_expiration  ?type_  ?valid_from  ?valid_until
       ?replace_unhealthy_instances  ?instance_interruption_behavior 
      ?load_balancers_config  ?instance_pools_to_use_count 
      ?(tag_specifications= [])  () =
      {
        allocation_strategy;
        on_demand_allocation_strategy;
        spot_maintenance_strategies;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        on_demand_fulfilled_capacity;
        iam_fleet_role;
        launch_specifications;
        launch_template_configs;
        spot_price;
        target_capacity;
        on_demand_target_capacity;
        on_demand_max_total_price;
        spot_max_total_price;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        instance_interruption_behavior;
        load_balancers_config;
        instance_pools_to_use_count;
        tag_specifications
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "allocationStrategy" xml)
               AllocationStrategy.parse);
          on_demand_allocation_strategy =
            (Util.option_bind (Xml.member "onDemandAllocationStrategy" xml)
               OnDemandAllocationStrategy.parse);
          spot_maintenance_strategies =
            (Util.option_bind (Xml.member "spotMaintenanceStrategies" xml)
               SpotMaintenanceStrategies.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               ExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          on_demand_fulfilled_capacity =
            (Util.option_bind (Xml.member "onDemandFulfilledCapacity" xml)
               Double.parse);
          iam_fleet_role =
            (Xml.required "iamFleetRole"
               (Util.option_bind (Xml.member "iamFleetRole" xml) String.parse));
          launch_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchSpecifications" xml)
                  LaunchSpecsList.parse));
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  LaunchTemplateConfigList.parse));
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          target_capacity =
            (Xml.required "targetCapacity"
               (Util.option_bind (Xml.member "targetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "onDemandTargetCapacity" xml)
               Integer.parse);
          on_demand_max_total_price =
            (Util.option_bind (Xml.member "onDemandMaxTotalPrice" xml)
               String.parse);
          spot_max_total_price =
            (Util.option_bind (Xml.member "spotMaxTotalPrice" xml)
               String.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse);
          load_balancers_config =
            (Util.option_bind (Xml.member "loadBalancersConfig" xml)
               LoadBalancersConfig.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "instancePoolsToUseCount" xml)
               Integer.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                Query.Pair
                  ("LoadBalancersConfig", (LoadBalancersConfig.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.spot_max_total_price
             (fun f -> Query.Pair ("SpotMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_max_total_price
             (fun f ->
                Query.Pair ("OnDemandMaxTotalPrice", (String.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacity", (Integer.to_query v.target_capacity)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (LaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Some
             (Query.Pair
                ("LaunchSpecifications",
                  (LaunchSpecsList.to_query v.launch_specifications)));
           Some
             (Query.Pair ("IamFleetRole", (String.to_query v.iam_fleet_role)));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f ->
                Query.Pair ("OnDemandFulfilledCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (ExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.spot_maintenance_strategies
             (fun f ->
                Query.Pair
                  ("SpotMaintenanceStrategies",
                    (SpotMaintenanceStrategies.to_query f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                Query.Pair
                  ("OnDemandAllocationStrategy",
                    (OnDemandAllocationStrategy.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (AllocationStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.load_balancers_config
             (fun f ->
                ("load_balancers_config", (LoadBalancersConfig.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.spot_max_total_price
             (fun f -> ("spot_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_max_total_price
             (fun f -> ("on_demand_max_total_price", (String.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some ("target_capacity", (Integer.to_json v.target_capacity));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Some
             ("launch_template_configs",
               (LaunchTemplateConfigList.to_json v.launch_template_configs));
           Some
             ("launch_specifications",
               (LaunchSpecsList.to_json v.launch_specifications));
           Some ("iam_fleet_role", (String.to_json v.iam_fleet_role));
           Util.option_map v.on_demand_fulfilled_capacity
             (fun f -> ("on_demand_fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (ExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.spot_maintenance_strategies
             (fun f ->
                ("spot_maintenance_strategies",
                  (SpotMaintenanceStrategies.to_json f)));
           Util.option_map v.on_demand_allocation_strategy
             (fun f ->
                ("on_demand_allocation_strategy",
                  (OnDemandAllocationStrategy.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (AllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             AllocationStrategy.of_json);
        on_demand_allocation_strategy =
          (Util.option_map (Json.lookup j "on_demand_allocation_strategy")
             OnDemandAllocationStrategy.of_json);
        spot_maintenance_strategies =
          (Util.option_map (Json.lookup j "spot_maintenance_strategies")
             SpotMaintenanceStrategies.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             ExcessCapacityTerminationPolicy.of_json);
        fulfilled_capacity =
          (Util.option_map (Json.lookup j "fulfilled_capacity")
             Double.of_json);
        on_demand_fulfilled_capacity =
          (Util.option_map (Json.lookup j "on_demand_fulfilled_capacity")
             Double.of_json);
        iam_fleet_role =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "iam_fleet_role")));
        launch_specifications =
          (LaunchSpecsList.of_json
             (Util.of_option_exn (Json.lookup j "launch_specifications")));
        launch_template_configs =
          (LaunchTemplateConfigList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        target_capacity =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "target_capacity")));
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        on_demand_max_total_price =
          (Util.option_map (Json.lookup j "on_demand_max_total_price")
             String.of_json);
        spot_max_total_price =
          (Util.option_map (Json.lookup j "spot_max_total_price")
             String.of_json);
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json);
        load_balancers_config =
          (Util.option_map (Json.lookup j "load_balancers_config")
             LoadBalancersConfig.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module AvailabilityZoneMessageList =
  struct
    type t = AvailabilityZoneMessage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZoneMessage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZoneMessage.to_query v
    let to_json v = `List (List.map AvailabilityZoneMessage.to_json v)
    let of_json j = Json.to_list AvailabilityZoneMessage.of_json j
  end
module AvailabilityZoneOptInStatus =
  struct
    type t =
      | Opt_in_not_required 
      | Opted_in 
      | Not_opted_in 
    let str_to_t =
      [("not-opted-in", Not_opted_in);
      ("opted-in", Opted_in);
      ("opt-in-not-required", Opt_in_not_required)]
    let t_to_str =
      [(Not_opted_in, "not-opted-in");
      (Opted_in, "opted-in");
      (Opt_in_not_required, "opt-in-not-required")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AvailabilityZoneState =
  struct
    type t =
      | Available 
      | Information 
      | Impaired 
      | Unavailable 
    let str_to_t =
      [("unavailable", Unavailable);
      ("impaired", Impaired);
      ("information", Information);
      ("available", Available)]
    let t_to_str =
      [(Unavailable, "unavailable");
      (Impaired, "impaired");
      (Information, "information");
      (Available, "available")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeStatusActionsList =
  struct
    type t = VolumeStatusAction.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusAction.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusAction.to_query v
    let to_json v = `List (List.map VolumeStatusAction.to_json v)
    let of_json j = Json.to_list VolumeStatusAction.of_json j
  end
module VolumeStatusAttachmentStatusList =
  struct
    type t = VolumeStatusAttachmentStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusAttachmentStatus.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list VolumeStatusAttachmentStatus.to_query v
    let to_json v = `List (List.map VolumeStatusAttachmentStatus.to_json v)
    let of_json j = Json.to_list VolumeStatusAttachmentStatus.of_json j
  end
module VolumeStatusEventsList =
  struct
    type t = VolumeStatusEvent.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusEvent.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusEvent.to_query v
    let to_json v = `List (List.map VolumeStatusEvent.to_json v)
    let of_json j = Json.to_list VolumeStatusEvent.of_json j
  end
module VolumeStatusInfo =
  struct
    type t =
      {
      details: VolumeStatusDetailsList.t ;
      status: VolumeStatusInfoStatus.t option }
    let make ?(details= [])  ?status  () = { details; status }
    let parse xml =
      Some
        {
          details =
            (Util.of_option []
               (Util.option_bind (Xml.member "details" xml)
                  VolumeStatusDetailsList.parse));
          status =
            (Util.option_bind (Xml.member "status" xml)
               VolumeStatusInfoStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (VolumeStatusInfoStatus.to_query f)));
           Some
             (Query.Pair
                ("Details", (VolumeStatusDetailsList.to_query v.details)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (VolumeStatusInfoStatus.to_json f)));
           Some ("details", (VolumeStatusDetailsList.to_json v.details))])
    let of_json j =
      {
        details =
          (VolumeStatusDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "details")));
        status =
          (Util.option_map (Json.lookup j "status")
             VolumeStatusInfoStatus.of_json)
      }
  end
module TransitGatewayRouteTableState =
  struct
    type t =
      | Pending 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ClientVpnAuthorizationRuleStatus =
  struct
    type t =
      {
      code: ClientVpnAuthorizationRuleStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientVpnAuthorizationRuleStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code", (ClientVpnAuthorizationRuleStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code", (ClientVpnAuthorizationRuleStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientVpnAuthorizationRuleStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module UnsuccessfulInstanceCreditSpecificationItemError =
  struct
    type t =
      {
      code: UnsuccessfulInstanceCreditSpecificationErrorCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               UnsuccessfulInstanceCreditSpecificationErrorCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (UnsuccessfulInstanceCreditSpecificationErrorCode.to_query
                       f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (UnsuccessfulInstanceCreditSpecificationErrorCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             UnsuccessfulInstanceCreditSpecificationErrorCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module PricingDetailsList =
  struct
    type t = PricingDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PricingDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PricingDetail.to_query v
    let to_json v = `List (List.map PricingDetail.to_json v)
    let of_json j = Json.to_list PricingDetail.of_json j
  end
module InstanceList =
  struct
    type t = Instance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Instance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Instance.to_query v
    let to_json v = `List (List.map Instance.to_json v)
    let of_json j = Json.to_list Instance.of_json j
  end
module PublicIpv4PoolRangeSet =
  struct
    type t = PublicIpv4PoolRange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PublicIpv4PoolRange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PublicIpv4PoolRange.to_query v
    let to_json v = `List (List.map PublicIpv4PoolRange.to_json v)
    let of_json j = Json.to_list PublicIpv4PoolRange.of_json j
  end
module VpcCidrBlockAssociationSet =
  struct
    type t = VpcCidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcCidrBlockAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcCidrBlockAssociation.to_query v
    let to_json v = `List (List.map VpcCidrBlockAssociation.to_json v)
    let of_json j = Json.to_list VpcCidrBlockAssociation.of_json j
  end
module VpcIpv6CidrBlockAssociationSet =
  struct
    type t = VpcIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcIpv6CidrBlockAssociation.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list VpcIpv6CidrBlockAssociation.to_query v
    let to_json v = `List (List.map VpcIpv6CidrBlockAssociation.to_json v)
    let of_json j = Json.to_list VpcIpv6CidrBlockAssociation.of_json j
  end
module VpcState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SubnetIpv6CidrBlockAssociationSet =
  struct
    type t = SubnetIpv6CidrBlockAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SubnetIpv6CidrBlockAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SubnetIpv6CidrBlockAssociation.to_query v
    let to_json v = `List (List.map SubnetIpv6CidrBlockAssociation.to_json v)
    let of_json j = Json.to_list SubnetIpv6CidrBlockAssociation.of_json j
  end
module SubnetState =
  struct
    type t =
      | Pending 
      | Available 
    let str_to_t = [("available", Available); ("pending", Pending)]
    let t_to_str = [(Available, "available"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ElasticGpuHealth =
  struct
    type t = {
      status: ElasticGpuStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ElasticGpuStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (ElasticGpuStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ElasticGpuStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status") ElasticGpuStatus.of_json)
      }
  end
module ElasticGpuState =
  struct
    type t =
      | ATTACHED 
    let str_to_t = [("ATTACHED", ATTACHED)]
    let t_to_str = [(ATTACHED, "ATTACHED")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ImportImageLicenseSpecificationListResponse =
  struct
    type t = ImportImageLicenseConfigurationResponse.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationResponse.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationResponse.to_query v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationResponse.to_json v)
    let of_json j =
      Json.to_list ImportImageLicenseConfigurationResponse.of_json j
  end
module SnapshotDetailList =
  struct
    type t = SnapshotDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SnapshotDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SnapshotDetail.to_query v
    let to_json v = `List (List.map SnapshotDetail.to_json v)
    let of_json j = Json.to_list SnapshotDetail.of_json j
  end
module UserBucket =
  struct
    type t = {
      s3_bucket: String.t option ;
      s3_key: String.t option }
    let make ?s3_bucket  ?s3_key  () = { s3_bucket; s3_key }
    let parse xml =
      Some
        {
          s3_bucket =
            (Util.option_bind (Xml.member "S3Bucket" xml) String.parse);
          s3_key = (Util.option_bind (Xml.member "S3Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> Query.Pair ("S3Key", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_key
              (fun f -> ("s3_key", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)))])
    let of_json j =
      {
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_key = (Util.option_map (Json.lookup j "s3_key") String.of_json)
      }
  end
module LocalGatewayRouteState =
  struct
    type t =
      | Pending 
      | Active 
      | Blackhole 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("blackhole", Blackhole);
      ("active", Active);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Blackhole, "blackhole");
      (Active, "active");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module LocalGatewayRouteType =
  struct
    type t =
      | Static 
      | Propagated 
    let str_to_t = [("propagated", Propagated); ("static", Static)]
    let t_to_str = [(Propagated, "propagated"); (Static, "static")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ScheduledInstancesBlockDeviceMapping =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: ScheduledInstancesEbs.t option ;
      no_device: String.t option ;
      virtual_name: String.t option }
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "Ebs" xml)
               ScheduledInstancesEbs.parse);
          no_device =
            (Util.option_bind (Xml.member "NoDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "VirtualName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f -> Query.Pair ("Ebs", (ScheduledInstancesEbs.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f -> ("ebs", (ScheduledInstancesEbs.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             ScheduledInstancesEbs.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json)
      }
  end
module ScheduledInstancesNetworkInterface =
  struct
    type t =
      {
      associate_public_ip_address: Boolean.t option ;
      delete_on_termination: Boolean.t option ;
      description: String.t option ;
      device_index: Integer.t option ;
      groups: ScheduledInstancesSecurityGroupIdSet.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: ScheduledInstancesIpv6AddressList.t ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option ;
      private_ip_address_configs: PrivateIpAddressConfigSet.t ;
      secondary_private_ip_address_count: Integer.t option ;
      subnet_id: String.t option }
    let make ?associate_public_ip_address  ?delete_on_termination 
      ?description  ?device_index  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?network_interface_id  ?private_ip_address 
      ?(private_ip_address_configs= [])  ?secondary_private_ip_address_count 
      ?subnet_id  () =
      {
        associate_public_ip_address;
        delete_on_termination;
        description;
        device_index;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        network_interface_id;
        private_ip_address;
        private_ip_address_configs;
        secondary_private_ip_address_count;
        subnet_id
      }
    let parse xml =
      Some
        {
          associate_public_ip_address =
            (Util.option_bind (Xml.member "AssociatePublicIpAddress" xml)
               Boolean.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "DeleteOnTermination" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_index =
            (Util.option_bind (Xml.member "DeviceIndex" xml) Integer.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "Group" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Address" xml)
                  ScheduledInstancesIpv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "PrivateIpAddress" xml)
               String.parse);
          private_ip_address_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrivateIpAddressConfig" xml)
                  PrivateIpAddressConfigSet.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "SecondaryPrivateIpAddressCount" xml)
               Integer.parse);
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressConfig",
                  (PrivateIpAddressConfigSet.to_query
                     v.private_ip_address_configs)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Address",
                  (ScheduledInstancesIpv6AddressList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("Group",
                  (ScheduledInstancesSecurityGroupIdSet.to_query v.groups)));
           Util.option_map v.device_index
             (fun f -> Query.Pair ("DeviceIndex", (Integer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.delete_on_termination
             (fun f ->
                Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.associate_public_ip_address
             (fun f ->
                Query.Pair ("AssociatePublicIpAddress", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_address_configs",
               (PrivateIpAddressConfigSet.to_json
                  v.private_ip_address_configs));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (ScheduledInstancesIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some
             ("groups",
               (ScheduledInstancesSecurityGroupIdSet.to_json v.groups));
           Util.option_map v.device_index
             (fun f -> ("device_index", (Integer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.delete_on_termination
             (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.associate_public_ip_address
             (fun f -> ("associate_public_ip_address", (Boolean.to_json f)))])
    let of_json j =
      {
        associate_public_ip_address =
          (Util.option_map (Json.lookup j "associate_public_ip_address")
             Boolean.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_index =
          (Util.option_map (Json.lookup j "device_index") Integer.of_json);
        groups =
          (ScheduledInstancesSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (ScheduledInstancesIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_address_configs =
          (PrivateIpAddressConfigSet.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_address_configs")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module NatGatewayAddressList =
  struct
    type t = NatGatewayAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NatGatewayAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NatGatewayAddress.to_query v
    let to_json v = `List (List.map NatGatewayAddress.to_json v)
    let of_json j = Json.to_list NatGatewayAddress.of_json j
  end
module NatGatewayState =
  struct
    type t =
      | Pending 
      | Failed 
      | Available 
      | Deleting 
      | Deleted 
    let str_to_t =
      [("deleted", Deleted);
      ("deleting", Deleting);
      ("available", Available);
      ("failed", Failed);
      ("pending", Pending)]
    let t_to_str =
      [(Deleted, "deleted");
      (Deleting, "deleting");
      (Available, "available");
      (Failed, "failed");
      (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProvisionedBandwidth =
  struct
    type t =
      {
      provision_time: DateTime.t option ;
      provisioned: String.t option ;
      request_time: DateTime.t option ;
      requested: String.t option ;
      status: String.t option }
    let make ?provision_time  ?provisioned  ?request_time  ?requested 
      ?status  () =
      { provision_time; provisioned; request_time; requested; status }
    let parse xml =
      Some
        {
          provision_time =
            (Util.option_bind (Xml.member "provisionTime" xml) DateTime.parse);
          provisioned =
            (Util.option_bind (Xml.member "provisioned" xml) String.parse);
          request_time =
            (Util.option_bind (Xml.member "requestTime" xml) DateTime.parse);
          requested =
            (Util.option_bind (Xml.member "requested" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.requested
             (fun f -> Query.Pair ("Requested", (String.to_query f)));
           Util.option_map v.request_time
             (fun f -> Query.Pair ("RequestTime", (DateTime.to_query f)));
           Util.option_map v.provisioned
             (fun f -> Query.Pair ("Provisioned", (String.to_query f)));
           Util.option_map v.provision_time
             (fun f -> Query.Pair ("ProvisionTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (String.to_json f)));
           Util.option_map v.requested
             (fun f -> ("requested", (String.to_json f)));
           Util.option_map v.request_time
             (fun f -> ("request_time", (DateTime.to_json f)));
           Util.option_map v.provisioned
             (fun f -> ("provisioned", (String.to_json f)));
           Util.option_map v.provision_time
             (fun f -> ("provision_time", (DateTime.to_json f)))])
    let of_json j =
      {
        provision_time =
          (Util.option_map (Json.lookup j "provision_time") DateTime.of_json);
        provisioned =
          (Util.option_map (Json.lookup j "provisioned") String.of_json);
        request_time =
          (Util.option_map (Json.lookup j "request_time") DateTime.of_json);
        requested =
          (Util.option_map (Json.lookup j "requested") String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json)
      }
  end
module LoadPermissionRequest =
  struct
    type t = {
      group: PermissionGroup.t option ;
      user_id: String.t option }
    let make ?group  ?user_id  () = { group; user_id }
    let parse xml =
      Some
        {
          group =
            (Util.option_bind (Xml.member "Group" xml) PermissionGroup.parse);
          user_id = (Util.option_bind (Xml.member "UserId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> Query.Pair ("UserId", (String.to_query f)));
           Util.option_map v.group
             (fun f -> Query.Pair ("Group", (PermissionGroup.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_id
              (fun f -> ("user_id", (String.to_json f)));
           Util.option_map v.group
             (fun f -> ("group", (PermissionGroup.to_json f)))])
    let of_json j =
      {
        group =
          (Util.option_map (Json.lookup j "group") PermissionGroup.of_json);
        user_id = (Util.option_map (Json.lookup j "user_id") String.of_json)
      }
  end
module Filter =
  struct
    type t = {
      name: String.t ;
      values: ValueStringList.t }
    let make ~name  ?(values= [])  () = { name; values }
    let parse xml =
      Some
        {
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Some (Query.Pair ("Name", (String.to_query v.name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Some ("name", (String.to_json v.name))])
    let of_json j =
      {
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module TagDescription =
  struct
    type t =
      {
      key: String.t ;
      resource_id: String.t ;
      resource_type: ResourceType.t ;
      value: String.t }
    let make ~key  ~resource_id  ~resource_type  ~value  () =
      { key; resource_id; resource_type; value }
    let parse xml =
      Some
        {
          key =
            (Xml.required "key"
               (Util.option_bind (Xml.member "key" xml) String.parse));
          resource_id =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml) String.parse));
          resource_type =
            (Xml.required "resourceType"
               (Util.option_bind (Xml.member "resourceType" xml)
                  ResourceType.parse));
          value =
            (Xml.required "value"
               (Util.option_bind (Xml.member "value" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (String.to_query v.value)));
           Some
             (Query.Pair
                ("ResourceType", (ResourceType.to_query v.resource_type)));
           Some (Query.Pair ("ResourceId", (String.to_query v.resource_id)));
           Some (Query.Pair ("Key", (String.to_query v.key)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("value", (String.to_json v.value));
           Some ("resource_type", (ResourceType.to_json v.resource_type));
           Some ("resource_id", (String.to_json v.resource_id));
           Some ("key", (String.to_json v.key))])
    let of_json j =
      {
        key = (String.of_json (Util.of_option_exn (Json.lookup j "key")));
        resource_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource_id")));
        resource_type =
          (ResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        value = (String.of_json (Util.of_option_exn (Json.lookup j "value")))
      }
  end
module DhcpOptions =
  struct
    type t =
      {
      dhcp_configurations: DhcpConfigurationList.t ;
      dhcp_options_id: String.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?(dhcp_configurations= [])  ?dhcp_options_id  ?owner_id  ?(tags=
      [])  () = { dhcp_configurations; dhcp_options_id; owner_id; tags }
    let parse xml =
      Some
        {
          dhcp_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpConfigurationSet" xml)
                  DhcpConfigurationList.parse));
          dhcp_options_id =
            (Util.option_bind (Xml.member "dhcpOptionsId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.dhcp_options_id
             (fun f -> Query.Pair ("DhcpOptionsId", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpConfigurationSet",
                  (DhcpConfigurationList.to_query v.dhcp_configurations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.dhcp_options_id
             (fun f -> ("dhcp_options_id", (String.to_json f)));
           Some
             ("dhcp_configurations",
               (DhcpConfigurationList.to_json v.dhcp_configurations))])
    let of_json j =
      {
        dhcp_configurations =
          (DhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")));
        dhcp_options_id =
          (Util.option_map (Json.lookup j "dhcp_options_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpnGateway =
  struct
    type t =
      {
      availability_zone: String.t option ;
      state: VpnState.t option ;
      type_: GatewayType.t option ;
      vpc_attachments: VpcAttachmentList.t ;
      vpn_gateway_id: String.t option ;
      amazon_side_asn: Long.t option ;
      tags: TagList.t }
    let make ?availability_zone  ?state  ?type_  ?(vpc_attachments= []) 
      ?vpn_gateway_id  ?amazon_side_asn  ?(tags= [])  () =
      {
        availability_zone;
        state;
        type_;
        vpc_attachments;
        vpn_gateway_id;
        amazon_side_asn;
        tags
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state = (Util.option_bind (Xml.member "state" xml) VpnState.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) GatewayType.parse);
          vpc_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachments" xml)
                  VpcAttachmentList.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          amazon_side_asn =
            (Util.option_bind (Xml.member "amazonSideAsn" xml) Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("Attachments",
                  (VpcAttachmentList.to_query v.vpc_attachments)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (GatewayType.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (VpnState.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some
             ("vpc_attachments",
               (VpcAttachmentList.to_json v.vpc_attachments));
           Util.option_map v.type_
             (fun f -> ("type_", (GatewayType.to_json f)));
           Util.option_map v.state (fun f -> ("state", (VpnState.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state = (Util.option_map (Json.lookup j "state") VpnState.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") GatewayType.of_json);
        vpc_attachments =
          (VpcAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_attachments")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayAttachmentPropagation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_route_table_id  ?state  () =
      { transit_gateway_route_table_id; state }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module CapacityReservation =
  struct
    type t =
      {
      capacity_reservation_id: String.t option ;
      owner_id: String.t option ;
      capacity_reservation_arn: String.t option ;
      availability_zone_id: String.t option ;
      instance_type: String.t option ;
      instance_platform: CapacityReservationInstancePlatform.t option ;
      availability_zone: String.t option ;
      tenancy: CapacityReservationTenancy.t option ;
      total_instance_count: Integer.t option ;
      available_instance_count: Integer.t option ;
      ebs_optimized: Boolean.t option ;
      ephemeral_storage: Boolean.t option ;
      state: CapacityReservationState.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      instance_match_criteria: InstanceMatchCriteria.t option ;
      create_date: DateTime.t option ;
      tags: TagList.t }
    let make ?capacity_reservation_id  ?owner_id  ?capacity_reservation_arn 
      ?availability_zone_id  ?instance_type  ?instance_platform 
      ?availability_zone  ?tenancy  ?total_instance_count 
      ?available_instance_count  ?ebs_optimized  ?ephemeral_storage  ?state 
      ?end_date  ?end_date_type  ?instance_match_criteria  ?create_date 
      ?(tags= [])  () =
      {
        capacity_reservation_id;
        owner_id;
        capacity_reservation_arn;
        availability_zone_id;
        instance_type;
        instance_platform;
        availability_zone;
        tenancy;
        total_instance_count;
        available_instance_count;
        ebs_optimized;
        ephemeral_storage;
        state;
        end_date;
        end_date_type;
        instance_match_criteria;
        create_date;
        tags
      }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          capacity_reservation_arn =
            (Util.option_bind (Xml.member "capacityReservationArn" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_platform =
            (Util.option_bind (Xml.member "instancePlatform" xml)
               CapacityReservationInstancePlatform.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml)
               CapacityReservationTenancy.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          ephemeral_storage =
            (Util.option_bind (Xml.member "ephemeralStorage" xml)
               Boolean.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          end_date =
            (Util.option_bind (Xml.member "endDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "endDateType" xml)
               EndDateType.parse);
          instance_match_criteria =
            (Util.option_bind (Xml.member "instanceMatchCriteria" xml)
               InstanceMatchCriteria.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                Query.Pair
                  ("InstanceMatchCriteria",
                    (InstanceMatchCriteria.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.ephemeral_storage
             (fun f -> Query.Pair ("EphemeralStorage", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.tenancy
             (fun f ->
                Query.Pair
                  ("Tenancy", (CapacityReservationTenancy.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.instance_platform
             (fun f ->
                Query.Pair
                  ("InstancePlatform",
                    (CapacityReservationInstancePlatform.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.capacity_reservation_arn
             (fun f ->
                Query.Pair ("CapacityReservationArn", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                ("instance_match_criteria",
                  (InstanceMatchCriteria.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.ephemeral_storage
             (fun f -> ("ephemeral_storage", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (CapacityReservationTenancy.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.instance_platform
             (fun f ->
                ("instance_platform",
                  (CapacityReservationInstancePlatform.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_arn
             (fun f -> ("capacity_reservation_arn", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)))])
    let of_json j =
      {
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        capacity_reservation_arn =
          (Util.option_map (Json.lookup j "capacity_reservation_arn")
             String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_platform =
          (Util.option_map (Json.lookup j "instance_platform")
             CapacityReservationInstancePlatform.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        tenancy =
          (Util.option_map (Json.lookup j "tenancy")
             CapacityReservationTenancy.of_json);
        total_instance_count =
          (Util.option_map (Json.lookup j "total_instance_count")
             Integer.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ephemeral_storage =
          (Util.option_map (Json.lookup j "ephemeral_storage")
             Boolean.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CapacityReservationState.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        instance_match_criteria =
          (Util.option_map (Json.lookup j "instance_match_criteria")
             InstanceMatchCriteria.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReservedInstancesModification =
  struct
    type t =
      {
      client_token: String.t option ;
      create_date: DateTime.t option ;
      effective_date: DateTime.t option ;
      modification_results: ReservedInstancesModificationResultList.t ;
      reserved_instances_ids: ReservedIntancesIds.t ;
      reserved_instances_modification_id: String.t option ;
      status: String.t option ;
      status_message: String.t option ;
      update_date: DateTime.t option }
    let make ?client_token  ?create_date  ?effective_date 
      ?(modification_results= [])  ?(reserved_instances_ids= []) 
      ?reserved_instances_modification_id  ?status  ?status_message 
      ?update_date  () =
      {
        client_token;
        create_date;
        effective_date;
        modification_results;
        reserved_instances_ids;
        reserved_instances_modification_id;
        status;
        status_message;
        update_date
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          effective_date =
            (Util.option_bind (Xml.member "effectiveDate" xml) DateTime.parse);
          modification_results =
            (Util.of_option []
               (Util.option_bind (Xml.member "modificationResultSet" xml)
                  ReservedInstancesModificationResultList.parse));
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedIntancesIds.parse));
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesModificationId", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesSet",
                  (ReservedIntancesIds.to_query v.reserved_instances_ids)));
           Some
             (Query.Pair
                ("ModificationResultSet",
                  (ReservedInstancesModificationResultList.to_query
                     v.modification_results)));
           Util.option_map v.effective_date
             (fun f -> Query.Pair ("EffectiveDate", (DateTime.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.reserved_instances_modification_id
             (fun f ->
                ("reserved_instances_modification_id", (String.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedIntancesIds.to_json v.reserved_instances_ids));
           Some
             ("modification_results",
               (ReservedInstancesModificationResultList.to_json
                  v.modification_results));
           Util.option_map v.effective_date
             (fun f -> ("effective_date", (DateTime.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        effective_date =
          (Util.option_map (Json.lookup j "effective_date") DateTime.of_json);
        modification_results =
          (ReservedInstancesModificationResultList.of_json
             (Util.of_option_exn (Json.lookup j "modification_results")));
        reserved_instances_ids =
          (ReservedIntancesIds.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json)
      }
  end
module PlacementGroup =
  struct
    type t =
      {
      group_name: String.t option ;
      state: PlacementGroupState.t option ;
      strategy: PlacementStrategy.t option ;
      partition_count: Integer.t option ;
      group_id: String.t option ;
      tags: TagList.t }
    let make ?group_name  ?state  ?strategy  ?partition_count  ?group_id 
      ?(tags= [])  () =
      { group_name; state; strategy; partition_count; group_id; tags }
    let parse xml =
      Some
        {
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               PlacementGroupState.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          partition_count =
            (Util.option_bind (Xml.member "partitionCount" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.partition_count
             (fun f -> Query.Pair ("PartitionCount", (Integer.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (PlacementGroupState.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.partition_count
             (fun f -> ("partition_count", (Integer.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (PlacementGroupState.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)))])
    let of_json j =
      {
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             PlacementGroupState.of_json);
        strategy =
          (Util.option_map (Json.lookup j "strategy")
             PlacementStrategy.of_json);
        partition_count =
          (Util.option_map (Json.lookup j "partition_count") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayRouteTablePropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module KeyPairInfo =
  struct
    type t =
      {
      key_pair_id: String.t option ;
      key_fingerprint: String.t option ;
      key_name: String.t option ;
      tags: TagList.t }
    let make ?key_pair_id  ?key_fingerprint  ?key_name  ?(tags= [])  () =
      { key_pair_id; key_fingerprint; key_name; tags }
    let parse xml =
      Some
        {
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse);
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)))])
    let of_json j =
      {
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json);
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ErrorSet =
  struct
    type t = ValidationError.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ValidationError.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ValidationError.to_query v
    let to_json v = `List (List.map ValidationError.to_json v)
    let of_json j = Json.to_list ValidationError.of_json j
  end
module HistoryRecordEntry =
  struct
    type t =
      {
      event_information: EventInformation.t option ;
      event_type: FleetEventType.t option ;
      timestamp: DateTime.t option }
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml)
               FleetEventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (FleetEventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (FleetEventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let of_json j =
      {
        event_information =
          (Util.option_map (Json.lookup j "event_information")
             EventInformation.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type")
             FleetEventType.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module HostReservation =
  struct
    type t =
      {
      count: Integer.t option ;
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      end_: DateTime.t option ;
      host_id_set: ResponseHostIdSet.t ;
      host_reservation_id: String.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      offering_id: String.t option ;
      payment_option: PaymentOption.t option ;
      start: DateTime.t option ;
      state: ReservationState.t option ;
      upfront_price: String.t option ;
      tags: TagList.t }
    let make ?count  ?currency_code  ?duration  ?end_  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?offering_id 
      ?payment_option  ?start  ?state  ?upfront_price  ?(tags= [])  () =
      {
        count;
        currency_code;
        duration;
        end_;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        start;
        state;
        upfront_price;
        tags
      }
    let parse xml =
      Some
        {
          count = (Util.option_bind (Xml.member "count" xml) Integer.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ReservationState.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.upfront_price
             (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ReservationState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.count
             (fun f -> Query.Pair ("Count", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.upfront_price
             (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservationState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.count (fun f -> ("count", (Integer.to_json f)))])
    let of_json j =
      {
        count = (Util.option_map (Json.lookup j "count") Integer.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        end_ = (Util.option_map (Json.lookup j "end_") DateTime.of_json);
        host_id_set =
          (ResponseHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        start = (Util.option_map (Json.lookup j "start") DateTime.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ReservationState.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module LaunchPermissionList =
  struct
    type t = LaunchPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchPermission.to_query v
    let to_json v = `List (List.map LaunchPermission.to_json v)
    let of_json j = Json.to_list LaunchPermission.of_json j
  end
module VpcEndpointConnection =
  struct
    type t =
      {
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      vpc_endpoint_owner: String.t option ;
      vpc_endpoint_state: State.t option ;
      creation_timestamp: DateTime.t option ;
      dns_entries: DnsEntrySet.t ;
      network_load_balancer_arns: ValueStringList.t ;
      gateway_load_balancer_arns: ValueStringList.t }
    let make ?service_id  ?vpc_endpoint_id  ?vpc_endpoint_owner 
      ?vpc_endpoint_state  ?creation_timestamp  ?(dns_entries= []) 
      ?(network_load_balancer_arns= [])  ?(gateway_load_balancer_arns= []) 
      () =
      {
        service_id;
        vpc_endpoint_id;
        vpc_endpoint_owner;
        vpc_endpoint_state;
        creation_timestamp;
        dns_entries;
        network_load_balancer_arns;
        gateway_load_balancer_arns
      }
    let parse xml =
      Some
        {
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_owner =
            (Util.option_bind (Xml.member "vpcEndpointOwner" xml)
               String.parse);
          vpc_endpoint_state =
            (Util.option_bind (Xml.member "vpcEndpointState" xml) State.parse);
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse));
          gateway_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "gatewayLoadBalancerArnSet" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("GatewayLoadBalancerArnSet",
                   (ValueStringList.to_query v.gateway_load_balancer_arns)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArnSet",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> Query.Pair ("VpcEndpointState", (State.to_query f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> Query.Pair ("VpcEndpointOwner", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("gateway_load_balancer_arns",
                (ValueStringList.to_json v.gateway_load_balancer_arns));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Util.option_map v.vpc_endpoint_state
             (fun f -> ("vpc_endpoint_state", (State.to_json f)));
           Util.option_map v.vpc_endpoint_owner
             (fun f -> ("vpc_endpoint_owner", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)))])
    let of_json j =
      {
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        vpc_endpoint_owner =
          (Util.option_map (Json.lookup j "vpc_endpoint_owner")
             String.of_json);
        vpc_endpoint_state =
          (Util.option_map (Json.lookup j "vpc_endpoint_state") State.of_json);
        creation_timestamp =
          (Util.option_map (Json.lookup j "creation_timestamp")
             DateTime.of_json);
        dns_entries =
          (DnsEntrySet.of_json
             (Util.of_option_exn (Json.lookup j "dns_entries")));
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")));
        gateway_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "gateway_load_balancer_arns")))
      }
  end
module ExportImageTask =
  struct
    type t =
      {
      description: String.t option ;
      export_image_task_id: String.t option ;
      image_id: String.t option ;
      progress: String.t option ;
      s3_export_location: ExportTaskS3Location.t option ;
      status: String.t option ;
      status_message: String.t option ;
      tags: TagList.t }
    let make ?description  ?export_image_task_id  ?image_id  ?progress 
      ?s3_export_location  ?status  ?status_message  ?(tags= [])  () =
      {
        description;
        export_image_task_id;
        image_id;
        progress;
        s3_export_location;
        status;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        export_image_task_id =
          (Util.option_map (Json.lookup j "export_image_task_id")
             String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        s3_export_location =
          (Util.option_map (Json.lookup j "s3_export_location")
             ExportTaskS3Location.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module RequestSpotLaunchSpecificationSecurityGroupIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestSpotLaunchSpecificationSecurityGroupList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AssociatedRole =
  struct
    type t =
      {
      associated_role_arn: String.t option ;
      certificate_s3_bucket_name: String.t option ;
      certificate_s3_object_key: String.t option ;
      encryption_kms_key_id: String.t option }
    let make ?associated_role_arn  ?certificate_s3_bucket_name 
      ?certificate_s3_object_key  ?encryption_kms_key_id  () =
      {
        associated_role_arn;
        certificate_s3_bucket_name;
        certificate_s3_object_key;
        encryption_kms_key_id
      }
    let parse xml =
      Some
        {
          associated_role_arn =
            (Util.option_bind (Xml.member "associatedRoleArn" xml)
               String.parse);
          certificate_s3_bucket_name =
            (Util.option_bind (Xml.member "certificateS3BucketName" xml)
               String.parse);
          certificate_s3_object_key =
            (Util.option_bind (Xml.member "certificateS3ObjectKey" xml)
               String.parse);
          encryption_kms_key_id =
            (Util.option_bind (Xml.member "encryptionKmsKeyId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encryption_kms_key_id
              (fun f ->
                 Query.Pair ("EncryptionKmsKeyId", (String.to_query f)));
           Util.option_map v.certificate_s3_object_key
             (fun f ->
                Query.Pair ("CertificateS3ObjectKey", (String.to_query f)));
           Util.option_map v.certificate_s3_bucket_name
             (fun f ->
                Query.Pair ("CertificateS3BucketName", (String.to_query f)));
           Util.option_map v.associated_role_arn
             (fun f -> Query.Pair ("AssociatedRoleArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encryption_kms_key_id
              (fun f -> ("encryption_kms_key_id", (String.to_json f)));
           Util.option_map v.certificate_s3_object_key
             (fun f -> ("certificate_s3_object_key", (String.to_json f)));
           Util.option_map v.certificate_s3_bucket_name
             (fun f -> ("certificate_s3_bucket_name", (String.to_json f)));
           Util.option_map v.associated_role_arn
             (fun f -> ("associated_role_arn", (String.to_json f)))])
    let of_json j =
      {
        associated_role_arn =
          (Util.option_map (Json.lookup j "associated_role_arn")
             String.of_json);
        certificate_s3_bucket_name =
          (Util.option_map (Json.lookup j "certificate_s3_bucket_name")
             String.of_json);
        certificate_s3_object_key =
          (Util.option_map (Json.lookup j "certificate_s3_object_key")
             String.of_json);
        encryption_kms_key_id =
          (Util.option_map (Json.lookup j "encryption_kms_key_id")
             String.of_json)
      }
  end
module UnsuccessfulItem =
  struct
    type t =
      {
      error: UnsuccessfulItemError.t option ;
      resource_id: String.t option }
    let make ?error  ?resource_id  () = { error; resource_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulItemError.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair ("Error", (UnsuccessfulItemError.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_id
              (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (UnsuccessfulItemError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             UnsuccessfulItemError.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json)
      }
  end
module TrafficMirrorFilter =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t option ;
      ingress_filter_rules: TrafficMirrorFilterRuleList.t ;
      egress_filter_rules: TrafficMirrorFilterRuleList.t ;
      network_services: TrafficMirrorNetworkServiceList.t ;
      description: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_filter_id  ?(ingress_filter_rules= []) 
      ?(egress_filter_rules= [])  ?(network_services= [])  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_filter_id;
        ingress_filter_rules;
        egress_filter_rules;
        network_services;
        description;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          ingress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "ingressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          egress_filter_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "egressFilterRuleSet" xml)
                  TrafficMirrorFilterRuleList.parse));
          network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkServiceSet" xml)
                  TrafficMirrorNetworkServiceList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkServiceSet",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.network_services)));
           Some
             (Query.Pair
                ("EgressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query v.egress_filter_rules)));
           Some
             (Query.Pair
                ("IngressFilterRuleSet",
                  (TrafficMirrorFilterRuleList.to_query
                     v.ingress_filter_rules)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("network_services",
               (TrafficMirrorNetworkServiceList.to_json v.network_services));
           Some
             ("egress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.egress_filter_rules));
           Some
             ("ingress_filter_rules",
               (TrafficMirrorFilterRuleList.to_json v.ingress_filter_rules));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        ingress_filter_rules =
          (TrafficMirrorFilterRuleList.of_json
             (Util.of_option_exn (Json.lookup j "ingress_filter_rules")));
        egress_filter_rules =
          (TrafficMirrorFilterRuleList.of_json
             (Util.of_option_exn (Json.lookup j "egress_filter_rules")));
        network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "network_services")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PrefixListEntry =
  struct
    type t = {
      cidr: String.t option ;
      description: String.t option }
    let make ?cidr  ?description  () = { cidr; description }
    let parse xml =
      Some
        {
          cidr = (Util.option_bind (Xml.member "cidr" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr
             (fun f -> Query.Pair ("Cidr", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr (fun f -> ("cidr", (String.to_json f)))])
    let of_json j =
      {
        cidr = (Util.option_map (Json.lookup j "cidr") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module TransitGateway =
  struct
    type t =
      {
      transit_gateway_id: String.t option ;
      transit_gateway_arn: String.t option ;
      state: TransitGatewayState.t option ;
      owner_id: String.t option ;
      description: String.t option ;
      creation_time: DateTime.t option ;
      options: TransitGatewayOptions.t option ;
      tags: TagList.t }
    let make ?transit_gateway_id  ?transit_gateway_arn  ?state  ?owner_id 
      ?description  ?creation_time  ?options  ?(tags= [])  () =
      {
        transit_gateway_id;
        transit_gateway_arn;
        state;
        owner_id;
        description;
        creation_time;
        options;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_arn =
            (Util.option_bind (Xml.member "transitGatewayArn" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayState.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (TransitGatewayOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (TransitGatewayState.to_query f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> Query.Pair ("TransitGatewayArn", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f -> ("options", (TransitGatewayOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayState.to_json f)));
           Util.option_map v.transit_gateway_arn
             (fun f -> ("transit_gateway_arn", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        transit_gateway_arn =
          (Util.option_map (Json.lookup j "transit_gateway_arn")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayState.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceTagKeySet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ClientVpnAuthenticationRequest =
  struct
    type t =
      {
      type_: ClientVpnAuthenticationType.t option ;
      active_directory: DirectoryServiceAuthenticationRequest.t option ;
      mutual_authentication: CertificateAuthenticationRequest.t option ;
      federated_authentication: FederatedAuthenticationRequest.t option }
    let make ?type_  ?active_directory  ?mutual_authentication 
      ?federated_authentication  () =
      {
        type_;
        active_directory;
        mutual_authentication;
        federated_authentication
      }
    let parse xml =
      Some
        {
          type_ =
            (Util.option_bind (Xml.member "Type" xml)
               ClientVpnAuthenticationType.parse);
          active_directory =
            (Util.option_bind (Xml.member "ActiveDirectory" xml)
               DirectoryServiceAuthenticationRequest.parse);
          mutual_authentication =
            (Util.option_bind (Xml.member "MutualAuthentication" xml)
               CertificateAuthenticationRequest.parse);
          federated_authentication =
            (Util.option_bind (Xml.member "FederatedAuthentication" xml)
               FederatedAuthenticationRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.federated_authentication
              (fun f ->
                 Query.Pair
                   ("FederatedAuthentication",
                     (FederatedAuthenticationRequest.to_query f)));
           Util.option_map v.mutual_authentication
             (fun f ->
                Query.Pair
                  ("MutualAuthentication",
                    (CertificateAuthenticationRequest.to_query f)));
           Util.option_map v.active_directory
             (fun f ->
                Query.Pair
                  ("ActiveDirectory",
                    (DirectoryServiceAuthenticationRequest.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (ClientVpnAuthenticationType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.federated_authentication
              (fun f ->
                 ("federated_authentication",
                   (FederatedAuthenticationRequest.to_json f)));
           Util.option_map v.mutual_authentication
             (fun f ->
                ("mutual_authentication",
                  (CertificateAuthenticationRequest.to_json f)));
           Util.option_map v.active_directory
             (fun f ->
                ("active_directory",
                  (DirectoryServiceAuthenticationRequest.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (ClientVpnAuthenticationType.to_json f)))])
    let of_json j =
      {
        type_ =
          (Util.option_map (Json.lookup j "type_")
             ClientVpnAuthenticationType.of_json);
        active_directory =
          (Util.option_map (Json.lookup j "active_directory")
             DirectoryServiceAuthenticationRequest.of_json);
        mutual_authentication =
          (Util.option_map (Json.lookup j "mutual_authentication")
             CertificateAuthenticationRequest.of_json);
        federated_authentication =
          (Util.option_map (Json.lookup j "federated_authentication")
             FederatedAuthenticationRequest.of_json)
      }
  end
module ClassicLinkDnsSupport =
  struct
    type t =
      {
      classic_link_dns_supported: Boolean.t option ;
      vpc_id: String.t option }
    let make ?classic_link_dns_supported  ?vpc_id  () =
      { classic_link_dns_supported; vpc_id }
    let parse xml =
      Some
        {
          classic_link_dns_supported =
            (Util.option_bind (Xml.member "classicLinkDnsSupported" xml)
               Boolean.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.classic_link_dns_supported
             (fun f ->
                Query.Pair ("ClassicLinkDnsSupported", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.classic_link_dns_supported
             (fun f -> ("classic_link_dns_supported", (Boolean.to_json f)))])
    let of_json j =
      {
        classic_link_dns_supported =
          (Util.option_map (Json.lookup j "classic_link_dns_supported")
             Boolean.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ManagedPrefixList =
  struct
    type t =
      {
      prefix_list_id: String.t option ;
      address_family: String.t option ;
      state: PrefixListState.t option ;
      state_message: String.t option ;
      prefix_list_arn: String.t option ;
      prefix_list_name: String.t option ;
      max_entries: Integer.t option ;
      version: Long.t option ;
      tags: TagList.t ;
      owner_id: String.t option }
    let make ?prefix_list_id  ?address_family  ?state  ?state_message 
      ?prefix_list_arn  ?prefix_list_name  ?max_entries  ?version  ?(tags=
      [])  ?owner_id  () =
      {
        prefix_list_id;
        address_family;
        state;
        state_message;
        prefix_list_arn;
        prefix_list_name;
        max_entries;
        version;
        tags;
        owner_id
      }
    let parse xml =
      Some
        {
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          address_family =
            (Util.option_bind (Xml.member "addressFamily" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) PrefixListState.parse);
          state_message =
            (Util.option_bind (Xml.member "stateMessage" xml) String.parse);
          prefix_list_arn =
            (Util.option_bind (Xml.member "prefixListArn" xml) String.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "prefixListName" xml) String.parse);
          max_entries =
            (Util.option_bind (Xml.member "maxEntries" xml) Integer.parse);
          version = (Util.option_bind (Xml.member "version" xml) Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.version
             (fun f -> Query.Pair ("Version", (Long.to_query f)));
           Util.option_map v.max_entries
             (fun f -> Query.Pair ("MaxEntries", (Integer.to_query f)));
           Util.option_map v.prefix_list_name
             (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.prefix_list_arn
             (fun f -> Query.Pair ("PrefixListArn", (String.to_query f)));
           Util.option_map v.state_message
             (fun f -> Query.Pair ("StateMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (PrefixListState.to_query f)));
           Util.option_map v.address_family
             (fun f -> Query.Pair ("AddressFamily", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.version (fun f -> ("version", (Long.to_json f)));
           Util.option_map v.max_entries
             (fun f -> ("max_entries", (Integer.to_json f)));
           Util.option_map v.prefix_list_name
             (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.prefix_list_arn
             (fun f -> ("prefix_list_arn", (String.to_json f)));
           Util.option_map v.state_message
             (fun f -> ("state_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (PrefixListState.to_json f)));
           Util.option_map v.address_family
             (fun f -> ("address_family", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)))])
    let of_json j =
      {
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        address_family =
          (Util.option_map (Json.lookup j "address_family") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") PrefixListState.of_json);
        state_message =
          (Util.option_map (Json.lookup j "state_message") String.of_json);
        prefix_list_arn =
          (Util.option_map (Json.lookup j "prefix_list_arn") String.of_json);
        prefix_list_name =
          (Util.option_map (Json.lookup j "prefix_list_name") String.of_json);
        max_entries =
          (Util.option_map (Json.lookup j "max_entries") Integer.of_json);
        version = (Util.option_map (Json.lookup j "version") Long.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module ReservedInstancesListing =
  struct
    type t =
      {
      client_token: String.t option ;
      create_date: DateTime.t option ;
      instance_counts: InstanceCountList.t ;
      price_schedules: PriceScheduleList.t ;
      reserved_instances_id: String.t option ;
      reserved_instances_listing_id: String.t option ;
      status: ListingStatus.t option ;
      status_message: String.t option ;
      tags: TagList.t ;
      update_date: DateTime.t option }
    let make ?client_token  ?create_date  ?(instance_counts= []) 
      ?(price_schedules= [])  ?reserved_instances_id 
      ?reserved_instances_listing_id  ?status  ?status_message  ?(tags= []) 
      ?update_date  () =
      {
        client_token;
        create_date;
        instance_counts;
        price_schedules;
        reserved_instances_id;
        reserved_instances_listing_id;
        status;
        status_message;
        tags;
        update_date
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          instance_counts =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceCounts" xml)
                  InstanceCountList.parse));
          price_schedules =
            (Util.of_option []
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleList.parse));
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml) ListingStatus.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          update_date =
            (Util.option_bind (Xml.member "updateDate" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> Query.Pair ("UpdateDate", (DateTime.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (ListingStatus.to_query f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCounts",
                  (InstanceCountList.to_query v.instance_counts)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.update_date
              (fun f -> ("update_date", (DateTime.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ListingStatus.to_json f)));
           Util.option_map v.reserved_instances_listing_id
             (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Some
             ("price_schedules",
               (PriceScheduleList.to_json v.price_schedules));
           Some
             ("instance_counts",
               (InstanceCountList.to_json v.instance_counts));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        instance_counts =
          (InstanceCountList.of_json
             (Util.of_option_exn (Json.lookup j "instance_counts")));
        price_schedules =
          (PriceScheduleList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") ListingStatus.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        update_date =
          (Util.option_map (Json.lookup j "update_date") DateTime.of_json)
      }
  end
module InstanceStateChange =
  struct
    type t =
      {
      current_state: InstanceState.t option ;
      instance_id: String.t option ;
      previous_state: InstanceState.t option }
    let make ?current_state  ?instance_id  ?previous_state  () =
      { current_state; instance_id; previous_state }
    let parse xml =
      Some
        {
          current_state =
            (Util.option_bind (Xml.member "currentState" xml)
               InstanceState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml)
               InstanceState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f ->
                 Query.Pair ("PreviousState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.current_state
             (fun f ->
                Query.Pair ("CurrentState", (InstanceState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.previous_state
              (fun f -> ("previous_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.current_state
             (fun f -> ("current_state", (InstanceState.to_json f)))])
    let of_json j =
      {
        current_state =
          (Util.option_map (Json.lookup j "current_state")
             InstanceState.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state")
             InstanceState.of_json)
      }
  end
module AddPrefixListEntry =
  struct
    type t = {
      cidr: String.t ;
      description: String.t option }
    let make ~cidr  ?description  () = { cidr; description }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module ClientCertificateRevocationListStatusCode =
  struct
    type t =
      | Pending 
      | Active 
    let str_to_t = [("active", Active); ("pending", Pending)]
    let t_to_str = [(Active, "active"); (Pending, "pending")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TerminateConnectionStatus =
  struct
    type t =
      {
      connection_id: String.t option ;
      previous_status: ClientVpnConnectionStatus.t option ;
      current_status: ClientVpnConnectionStatus.t option }
    let make ?connection_id  ?previous_status  ?current_status  () =
      { connection_id; previous_status; current_status }
    let parse xml =
      Some
        {
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          previous_status =
            (Util.option_bind (Xml.member "previousStatus" xml)
               ClientVpnConnectionStatus.parse);
          current_status =
            (Util.option_bind (Xml.member "currentStatus" xml)
               ClientVpnConnectionStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 Query.Pair
                   ("CurrentStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.previous_status
             (fun f ->
                Query.Pair
                  ("PreviousStatus", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.current_status
              (fun f ->
                 ("current_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.previous_status
             (fun f ->
                ("previous_status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)))])
    let of_json j =
      {
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        previous_status =
          (Util.option_map (Json.lookup j "previous_status")
             ClientVpnConnectionStatus.of_json);
        current_status =
          (Util.option_map (Json.lookup j "current_status")
             ClientVpnConnectionStatus.of_json)
      }
  end
module InstanceTypeOffering =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      location_type: LocationType.t option ;
      location: String.t option }
    let make ?instance_type  ?location_type  ?location  () =
      { instance_type; location_type; location }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          location_type =
            (Util.option_bind (Xml.member "locationType" xml)
               LocationType.parse);
          location =
            (Util.option_bind (Xml.member "location" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> Query.Pair ("Location", (String.to_query f)));
           Util.option_map v.location_type
             (fun f -> Query.Pair ("LocationType", (LocationType.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.location
              (fun f -> ("location", (String.to_json f)));
           Util.option_map v.location_type
             (fun f -> ("location_type", (LocationType.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        location_type =
          (Util.option_map (Json.lookup j "location_type")
             LocationType.of_json);
        location =
          (Util.option_map (Json.lookup j "location") String.of_json)
      }
  end
module InstanceStatus =
  struct
    type t =
      {
      availability_zone: String.t option ;
      outpost_arn: String.t option ;
      events: InstanceStatusEventList.t ;
      instance_id: String.t option ;
      instance_state: InstanceState.t option ;
      instance_status: InstanceStatusSummary.t option ;
      system_status: InstanceStatusSummary.t option }
    let make ?availability_zone  ?outpost_arn  ?(events= [])  ?instance_id 
      ?instance_state  ?instance_status  ?system_status  () =
      {
        availability_zone;
        outpost_arn;
        events;
        instance_id;
        instance_state;
        instance_status;
        system_status
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  InstanceStatusEventList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_state =
            (Util.option_bind (Xml.member "instanceState" xml)
               InstanceState.parse);
          instance_status =
            (Util.option_bind (Xml.member "instanceStatus" xml)
               InstanceStatusSummary.parse);
          system_status =
            (Util.option_bind (Xml.member "systemStatus" xml)
               InstanceStatusSummary.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f ->
                 Query.Pair
                   ("SystemStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_status
             (fun f ->
                Query.Pair
                  ("InstanceStatus", (InstanceStatusSummary.to_query f)));
           Util.option_map v.instance_state
             (fun f ->
                Query.Pair ("InstanceState", (InstanceState.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (InstanceStatusEventList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.system_status
              (fun f -> ("system_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_status
             (fun f -> ("instance_status", (InstanceStatusSummary.to_json f)));
           Util.option_map v.instance_state
             (fun f -> ("instance_state", (InstanceState.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("events", (InstanceStatusEventList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        events =
          (InstanceStatusEventList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_state =
          (Util.option_map (Json.lookup j "instance_state")
             InstanceState.of_json);
        instance_status =
          (Util.option_map (Json.lookup j "instance_status")
             InstanceStatusSummary.of_json);
        system_status =
          (Util.option_map (Json.lookup j "system_status")
             InstanceStatusSummary.of_json)
      }
  end
module TransitGatewayPrefixListReference =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      prefix_list_id: String.t option ;
      prefix_list_owner_id: String.t option ;
      state: TransitGatewayPrefixListReferenceState.t option ;
      blackhole: Boolean.t option ;
      transit_gateway_attachment: TransitGatewayPrefixListAttachment.t option }
    let make ?transit_gateway_route_table_id  ?prefix_list_id 
      ?prefix_list_owner_id  ?state  ?blackhole  ?transit_gateway_attachment 
      () =
      {
        transit_gateway_route_table_id;
        prefix_list_id;
        prefix_list_owner_id;
        state;
        blackhole;
        transit_gateway_attachment
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          prefix_list_owner_id =
            (Util.option_bind (Xml.member "prefixListOwnerId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPrefixListReferenceState.parse);
          blackhole =
            (Util.option_bind (Xml.member "blackhole" xml) Boolean.parse);
          transit_gateway_attachment =
            (Util.option_bind (Xml.member "transitGatewayAttachment" xml)
               TransitGatewayPrefixListAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayAttachment",
                     (TransitGatewayPrefixListAttachment.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State",
                    (TransitGatewayPrefixListReferenceState.to_query f)));
           Util.option_map v.prefix_list_owner_id
             (fun f -> Query.Pair ("PrefixListOwnerId", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_attachment
              (fun f ->
                 ("transit_gateway_attachment",
                   (TransitGatewayPrefixListAttachment.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (TransitGatewayPrefixListReferenceState.to_json f)));
           Util.option_map v.prefix_list_owner_id
             (fun f -> ("prefix_list_owner_id", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        prefix_list_owner_id =
          (Util.option_map (Json.lookup j "prefix_list_owner_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPrefixListReferenceState.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        transit_gateway_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_attachment")
             TransitGatewayPrefixListAttachment.of_json)
      }
  end
module Image =
  struct
    type t =
      {
      architecture: ArchitectureValues.t ;
      creation_date: String.t option ;
      image_id: String.t ;
      image_location: String.t ;
      image_type: ImageTypeValues.t ;
      public: Boolean.t ;
      kernel_id: String.t option ;
      owner_id: String.t ;
      platform: PlatformValues.t option ;
      platform_details: String.t option ;
      usage_operation: String.t option ;
      product_codes: ProductCodeList.t ;
      ramdisk_id: String.t option ;
      state: ImageState.t ;
      block_device_mappings: BlockDeviceMappingList.t ;
      description: String.t option ;
      ena_support: Boolean.t option ;
      hypervisor: HypervisorType.t ;
      image_owner_alias: String.t option ;
      name: String.t option ;
      root_device_name: String.t option ;
      root_device_type: DeviceType.t ;
      sriov_net_support: String.t option ;
      state_reason: StateReason.t option ;
      tags: TagList.t ;
      virtualization_type: VirtualizationType.t }
    let make ~architecture  ?creation_date  ~image_id  ~image_location 
      ~image_type  ~public  ?kernel_id  ~owner_id  ?platform 
      ?platform_details  ?usage_operation  ?(product_codes= [])  ?ramdisk_id 
      ~state  ?(block_device_mappings= [])  ?description  ?ena_support 
      ~hypervisor  ?image_owner_alias  ?name  ?root_device_name 
      ~root_device_type  ?sriov_net_support  ?state_reason  ?(tags= []) 
      ~virtualization_type  () =
      {
        architecture;
        creation_date;
        image_id;
        image_location;
        image_type;
        public;
        kernel_id;
        owner_id;
        platform;
        platform_details;
        usage_operation;
        product_codes;
        ramdisk_id;
        state;
        block_device_mappings;
        description;
        ena_support;
        hypervisor;
        image_owner_alias;
        name;
        root_device_name;
        root_device_type;
        sriov_net_support;
        state_reason;
        tags;
        virtualization_type
      }
    let parse xml =
      Some
        {
          architecture =
            (Xml.required "architecture"
               (Util.option_bind (Xml.member "architecture" xml)
                  ArchitectureValues.parse));
          creation_date =
            (Util.option_bind (Xml.member "creationDate" xml) String.parse);
          image_id =
            (Xml.required "imageId"
               (Util.option_bind (Xml.member "imageId" xml) String.parse));
          image_location =
            (Xml.required "imageLocation"
               (Util.option_bind (Xml.member "imageLocation" xml)
                  String.parse));
          image_type =
            (Xml.required "imageType"
               (Util.option_bind (Xml.member "imageType" xml)
                  ImageTypeValues.parse));
          public =
            (Xml.required "isPublic"
               (Util.option_bind (Xml.member "isPublic" xml) Boolean.parse));
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          owner_id =
            (Xml.required "imageOwnerId"
               (Util.option_bind (Xml.member "imageOwnerId" xml) String.parse));
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse);
          platform_details =
            (Util.option_bind (Xml.member "platformDetails" xml) String.parse);
          usage_operation =
            (Util.option_bind (Xml.member "usageOperation" xml) String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          state =
            (Xml.required "imageState"
               (Util.option_bind (Xml.member "imageState" xml)
                  ImageState.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          hypervisor =
            (Xml.required "hypervisor"
               (Util.option_bind (Xml.member "hypervisor" xml)
                  HypervisorType.parse));
          image_owner_alias =
            (Util.option_bind (Xml.member "imageOwnerAlias" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          root_device_type =
            (Xml.required "rootDeviceType"
               (Util.option_bind (Xml.member "rootDeviceType" xml)
                  DeviceType.parse));
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          state_reason =
            (Util.option_bind (Xml.member "stateReason" xml)
               StateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          virtualization_type =
            (Xml.required "virtualizationType"
               (Util.option_bind (Xml.member "virtualizationType" xml)
                  VirtualizationType.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VirtualizationType",
                   (VirtualizationType.to_query v.virtualization_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state_reason
             (fun f -> Query.Pair ("StateReason", (StateReason.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Some
             (Query.Pair
                ("RootDeviceType", (DeviceType.to_query v.root_device_type)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.image_owner_alias
             (fun f -> Query.Pair ("ImageOwnerAlias", (String.to_query f)));
           Some
             (Query.Pair
                ("Hypervisor", (HypervisorType.to_query v.hypervisor)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Some (Query.Pair ("ImageState", (ImageState.to_query v.state)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.usage_operation
             (fun f -> Query.Pair ("UsageOperation", (String.to_query f)));
           Util.option_map v.platform_details
             (fun f -> Query.Pair ("PlatformDetails", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Some (Query.Pair ("ImageOwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some (Query.Pair ("IsPublic", (Boolean.to_query v.public)));
           Some
             (Query.Pair
                ("ImageType", (ImageTypeValues.to_query v.image_type)));
           Some
             (Query.Pair
                ("ImageLocation", (String.to_query v.image_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.creation_date
             (fun f -> Query.Pair ("CreationDate", (String.to_query f)));
           Some
             (Query.Pair
                ("Architecture",
                  (ArchitectureValues.to_query v.architecture)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("virtualization_type",
                (VirtualizationType.to_json v.virtualization_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state_reason
             (fun f -> ("state_reason", (StateReason.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Some ("root_device_type", (DeviceType.to_json v.root_device_type));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.image_owner_alias
             (fun f -> ("image_owner_alias", (String.to_json f)));
           Some ("hypervisor", (HypervisorType.to_json v.hypervisor));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Some ("state", (ImageState.to_json v.state));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.usage_operation
             (fun f -> ("usage_operation", (String.to_json f)));
           Util.option_map v.platform_details
             (fun f -> ("platform_details", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (PlatformValues.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some ("public", (Boolean.to_json v.public));
           Some ("image_type", (ImageTypeValues.to_json v.image_type));
           Some ("image_location", (String.to_json v.image_location));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.creation_date
             (fun f -> ("creation_date", (String.to_json f)));
           Some ("architecture", (ArchitectureValues.to_json v.architecture))])
    let of_json j =
      {
        architecture =
          (ArchitectureValues.of_json
             (Util.of_option_exn (Json.lookup j "architecture")));
        creation_date =
          (Util.option_map (Json.lookup j "creation_date") String.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        image_location =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "image_location")));
        image_type =
          (ImageTypeValues.of_json
             (Util.of_option_exn (Json.lookup j "image_type")));
        public =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "public")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json);
        platform_details =
          (Util.option_map (Json.lookup j "platform_details") String.of_json);
        usage_operation =
          (Util.option_map (Json.lookup j "usage_operation") String.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        state =
          (ImageState.of_json (Util.of_option_exn (Json.lookup j "state")));
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        hypervisor =
          (HypervisorType.of_json
             (Util.of_option_exn (Json.lookup j "hypervisor")));
        image_owner_alias =
          (Util.option_map (Json.lookup j "image_owner_alias") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        root_device_type =
          (DeviceType.of_json
             (Util.of_option_exn (Json.lookup j "root_device_type")));
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        state_reason =
          (Util.option_map (Json.lookup j "state_reason") StateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        virtualization_type =
          (VirtualizationType.of_json
             (Util.of_option_exn (Json.lookup j "virtualization_type")))
      }
  end
module PriceScheduleSpecification =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      price: Double.t option ;
      term: Long.t option }
    let make ?currency_code  ?price  ?term  () =
      { currency_code; price; term }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          price = (Util.option_bind (Xml.member "price" xml) Double.parse);
          term = (Util.option_bind (Xml.member "term" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.term
              (fun f -> Query.Pair ("Term", (Long.to_query f)));
           Util.option_map v.price
             (fun f -> Query.Pair ("Price", (Double.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.term (fun f -> ("term", (Long.to_json f)));
           Util.option_map v.price (fun f -> ("price", (Double.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        price = (Util.option_map (Json.lookup j "price") Double.of_json);
        term = (Util.option_map (Json.lookup j "term") Long.of_json)
      }
  end
module ImportSnapshotTask =
  struct
    type t =
      {
      description: String.t option ;
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option ;
      tags: TagList.t }
    let make ?description  ?import_task_id  ?snapshot_task_detail  ?(tags=
      [])  () = { description; import_task_id; snapshot_task_detail; tags }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module NetworkInterfacePermission =
  struct
    type t =
      {
      network_interface_permission_id: String.t option ;
      network_interface_id: String.t option ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      permission: InterfacePermissionType.t option ;
      permission_state: NetworkInterfacePermissionState.t option }
    let make ?network_interface_permission_id  ?network_interface_id 
      ?aws_account_id  ?aws_service  ?permission  ?permission_state  () =
      {
        network_interface_permission_id;
        network_interface_id;
        aws_account_id;
        aws_service;
        permission;
        permission_state
      }
    let parse xml =
      Some
        {
          network_interface_permission_id =
            (Util.option_bind (Xml.member "networkInterfacePermissionId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          permission =
            (Util.option_bind (Xml.member "permission" xml)
               InterfacePermissionType.parse);
          permission_state =
            (Util.option_bind (Xml.member "permissionState" xml)
               NetworkInterfacePermissionState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 Query.Pair
                   ("PermissionState",
                     (NetworkInterfacePermissionState.to_query f)));
           Util.option_map v.permission
             (fun f ->
                Query.Pair
                  ("Permission", (InterfacePermissionType.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                Query.Pair
                  ("NetworkInterfacePermissionId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.permission_state
              (fun f ->
                 ("permission_state",
                   (NetworkInterfacePermissionState.to_json f)));
           Util.option_map v.permission
             (fun f -> ("permission", (InterfacePermissionType.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.network_interface_permission_id
             (fun f ->
                ("network_interface_permission_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_permission_id =
          (Util.option_map (Json.lookup j "network_interface_permission_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        permission =
          (Util.option_map (Json.lookup j "permission")
             InterfacePermissionType.of_json);
        permission_state =
          (Util.option_map (Json.lookup j "permission_state")
             NetworkInterfacePermissionState.of_json)
      }
  end
module Host =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      availability_zone: String.t option ;
      available_capacity: AvailableCapacity.t option ;
      client_token: String.t option ;
      host_id: String.t option ;
      host_properties: HostProperties.t option ;
      host_reservation_id: String.t option ;
      instances: HostInstanceList.t ;
      state: AllocationState.t option ;
      allocation_time: DateTime.t option ;
      release_time: DateTime.t option ;
      tags: TagList.t ;
      host_recovery: HostRecovery.t option ;
      allows_multiple_instance_types: AllowsMultipleInstanceTypes.t option ;
      owner_id: String.t option ;
      availability_zone_id: String.t option ;
      member_of_service_linked_resource_group: Boolean.t option }
    let make ?auto_placement  ?availability_zone  ?available_capacity 
      ?client_token  ?host_id  ?host_properties  ?host_reservation_id 
      ?(instances= [])  ?state  ?allocation_time  ?release_time  ?(tags= []) 
      ?host_recovery  ?allows_multiple_instance_types  ?owner_id 
      ?availability_zone_id  ?member_of_service_linked_resource_group  () =
      {
        auto_placement;
        availability_zone;
        available_capacity;
        client_token;
        host_id;
        host_properties;
        host_reservation_id;
        instances;
        state;
        allocation_time;
        release_time;
        tags;
        host_recovery;
        allows_multiple_instance_types;
        owner_id;
        availability_zone_id;
        member_of_service_linked_resource_group
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_capacity =
            (Util.option_bind (Xml.member "availableCapacity" xml)
               AvailableCapacity.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          host_properties =
            (Util.option_bind (Xml.member "hostProperties" xml)
               HostProperties.parse);
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instances" xml)
                  HostInstanceList.parse));
          state =
            (Util.option_bind (Xml.member "state" xml) AllocationState.parse);
          allocation_time =
            (Util.option_bind (Xml.member "allocationTime" xml)
               DateTime.parse);
          release_time =
            (Util.option_bind (Xml.member "releaseTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "hostRecovery" xml)
               HostRecovery.parse);
          allows_multiple_instance_types =
            (Util.option_bind (Xml.member "allowsMultipleInstanceTypes" xml)
               AllowsMultipleInstanceTypes.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          member_of_service_linked_resource_group =
            (Util.option_bind
               (Xml.member "memberOfServiceLinkedResourceGroup" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 Query.Pair
                   ("MemberOfServiceLinkedResourceGroup",
                     (Boolean.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                Query.Pair
                  ("AllowsMultipleInstanceTypes",
                    (AllowsMultipleInstanceTypes.to_query f)));
           Util.option_map v.host_recovery
             (fun f -> Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.release_time
             (fun f -> Query.Pair ("ReleaseTime", (DateTime.to_query f)));
           Util.option_map v.allocation_time
             (fun f -> Query.Pair ("AllocationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (AllocationState.to_query f)));
           Some
             (Query.Pair
                ("Instances", (HostInstanceList.to_query v.instances)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Util.option_map v.host_properties
             (fun f ->
                Query.Pair ("HostProperties", (HostProperties.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.available_capacity
             (fun f ->
                Query.Pair
                  ("AvailableCapacity", (AvailableCapacity.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.member_of_service_linked_resource_group
              (fun f ->
                 ("member_of_service_linked_resource_group",
                   (Boolean.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.allows_multiple_instance_types
             (fun f ->
                ("allows_multiple_instance_types",
                  (AllowsMultipleInstanceTypes.to_json f)));
           Util.option_map v.host_recovery
             (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.release_time
             (fun f -> ("release_time", (DateTime.to_json f)));
           Util.option_map v.allocation_time
             (fun f -> ("allocation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AllocationState.to_json f)));
           Some ("instances", (HostInstanceList.to_json v.instances));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Util.option_map v.host_properties
             (fun f -> ("host_properties", (HostProperties.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.available_capacity
             (fun f -> ("available_capacity", (AvailableCapacity.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        available_capacity =
          (Util.option_map (Json.lookup j "available_capacity")
             AvailableCapacity.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        host_properties =
          (Util.option_map (Json.lookup j "host_properties")
             HostProperties.of_json);
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        instances =
          (HostInstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        state =
          (Util.option_map (Json.lookup j "state") AllocationState.of_json);
        allocation_time =
          (Util.option_map (Json.lookup j "allocation_time") DateTime.of_json);
        release_time =
          (Util.option_map (Json.lookup j "release_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json);
        allows_multiple_instance_types =
          (Util.option_map (Json.lookup j "allows_multiple_instance_types")
             AllowsMultipleInstanceTypes.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        member_of_service_linked_resource_group =
          (Util.option_map
             (Json.lookup j "member_of_service_linked_resource_group")
             Boolean.of_json)
      }
  end
module SubnetAssociationList =
  struct
    type t = SubnetAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SubnetAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SubnetAssociation.to_query v
    let to_json v = `List (List.map SubnetAssociation.to_json v)
    let of_json j = Json.to_list SubnetAssociation.of_json j
  end
module LaunchTemplate =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      create_time: DateTime.t option ;
      created_by: String.t option ;
      default_version_number: Long.t option ;
      latest_version_number: Long.t option ;
      tags: TagList.t }
    let make ?launch_template_id  ?launch_template_name  ?create_time 
      ?created_by  ?default_version_number  ?latest_version_number  ?(tags=
      [])  () =
      {
        launch_template_id;
        launch_template_name;
        create_time;
        created_by;
        default_version_number;
        latest_version_number;
        tags
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version_number =
            (Util.option_bind (Xml.member "defaultVersionNumber" xml)
               Long.parse);
          latest_version_number =
            (Util.option_bind (Xml.member "latestVersionNumber" xml)
               Long.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.latest_version_number
             (fun f -> Query.Pair ("LatestVersionNumber", (Long.to_query f)));
           Util.option_map v.default_version_number
             (fun f -> Query.Pair ("DefaultVersionNumber", (Long.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.latest_version_number
             (fun f -> ("latest_version_number", (Long.to_json f)));
           Util.option_map v.default_version_number
             (fun f -> ("default_version_number", (Long.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        default_version_number =
          (Util.option_map (Json.lookup j "default_version_number")
             Long.of_json);
        latest_version_number =
          (Util.option_map (Json.lookup j "latest_version_number")
             Long.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PrefixList =
  struct
    type t =
      {
      cidrs: ValueStringList.t ;
      prefix_list_id: String.t option ;
      prefix_list_name: String.t option }
    let make ?(cidrs= [])  ?prefix_list_id  ?prefix_list_name  () =
      { cidrs; prefix_list_id; prefix_list_name }
    let parse xml =
      Some
        {
          cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrSet" xml)
                  ValueStringList.parse));
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "prefixListName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Some (Query.Pair ("CidrSet", (ValueStringList.to_query v.cidrs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list_name
              (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)));
           Some ("cidrs", (ValueStringList.to_json v.cidrs))])
    let of_json j =
      {
        cidrs =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "cidrs")));
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        prefix_list_name =
          (Util.option_map (Json.lookup j "prefix_list_name") String.of_json)
      }
  end
module UnlimitedSupportedInstanceFamily =
  struct
    type t =
      | T2 
      | T3 
      | T3a 
      | T4g 
    let str_to_t = [("t4g", T4g); ("t3a", T3a); ("t3", T3); ("t2", T2)]
    let t_to_str = [(T4g, "t4g"); (T3a, "t3a"); (T3, "t3"); (T2, "t2")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ActiveInstance =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_type: String.t option ;
      spot_instance_request_id: String.t option ;
      instance_health: InstanceHealthStatus.t option }
    let make ?instance_id  ?instance_type  ?spot_instance_request_id 
      ?instance_health  () =
      { instance_id; instance_type; spot_instance_request_id; instance_health
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          instance_health =
            (Util.option_bind (Xml.member "instanceHealth" xml)
               InstanceHealthStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f ->
                 Query.Pair
                   ("InstanceHealth", (InstanceHealthStatus.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_health
              (fun f -> ("instance_health", (InstanceHealthStatus.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        instance_health =
          (Util.option_map (Json.lookup j "instance_health")
             InstanceHealthStatus.of_json)
      }
  end
module InstanceBlockDeviceMappingSpecification =
  struct
    type t =
      {
      device_name: String.t option ;
      ebs: EbsInstanceBlockDeviceSpecification.t option ;
      no_device: String.t option ;
      virtual_name: String.t option }
    let make ?device_name  ?ebs  ?no_device  ?virtual_name  () =
      { device_name; ebs; no_device; virtual_name }
    let parse xml =
      Some
        {
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          ebs =
            (Util.option_bind (Xml.member "ebs" xml)
               EbsInstanceBlockDeviceSpecification.parse);
          no_device =
            (Util.option_bind (Xml.member "noDevice" xml) String.parse);
          virtual_name =
            (Util.option_bind (Xml.member "virtualName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> Query.Pair ("VirtualName", (String.to_query f)));
           Util.option_map v.no_device
             (fun f -> Query.Pair ("NoDevice", (String.to_query f)));
           Util.option_map v.ebs
             (fun f ->
                Query.Pair
                  ("Ebs", (EbsInstanceBlockDeviceSpecification.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtual_name
              (fun f -> ("virtual_name", (String.to_json f)));
           Util.option_map v.no_device
             (fun f -> ("no_device", (String.to_json f)));
           Util.option_map v.ebs
             (fun f ->
                ("ebs", (EbsInstanceBlockDeviceSpecification.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)))])
    let of_json j =
      {
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        ebs =
          (Util.option_map (Json.lookup j "ebs")
             EbsInstanceBlockDeviceSpecification.of_json);
        no_device =
          (Util.option_map (Json.lookup j "no_device") String.of_json);
        virtual_name =
          (Util.option_map (Json.lookup j "virtual_name") String.of_json)
      }
  end
module LoadPermissionList =
  struct
    type t = LoadPermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LoadPermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LoadPermission.to_query v
    let to_json v = `List (List.map LoadPermission.to_json v)
    let of_json j = Json.to_list LoadPermission.of_json j
  end
module TransitGatewayMulticastDomain =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_id: String.t option ;
      state: TransitGatewayMulticastDomainState.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_multicast_domain_id  ?transit_gateway_id 
      ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_id;
        state;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayMulticastDomainState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayMulticastDomainState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (TransitGatewayMulticastDomainState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayMulticastDomainState.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PrincipalIdFormat =
  struct
    type t = {
      arn: String.t option ;
      statuses: IdFormatList.t }
    let make ?arn  ?(statuses= [])  () = { arn; statuses }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "arn" xml) String.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module AllowedPrincipal =
  struct
    type t =
      {
      principal_type: PrincipalType.t option ;
      principal: String.t option }
    let make ?principal_type  ?principal  () = { principal_type; principal }
    let parse xml =
      Some
        {
          principal_type =
            (Util.option_bind (Xml.member "principalType" xml)
               PrincipalType.parse);
          principal =
            (Util.option_bind (Xml.member "principal" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> Query.Pair ("Principal", (String.to_query f)));
           Util.option_map v.principal_type
             (fun f ->
                Query.Pair ("PrincipalType", (PrincipalType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.principal
              (fun f -> ("principal", (String.to_json f)));
           Util.option_map v.principal_type
             (fun f -> ("principal_type", (PrincipalType.to_json f)))])
    let of_json j =
      {
        principal_type =
          (Util.option_map (Json.lookup j "principal_type")
             PrincipalType.of_json);
        principal =
          (Util.option_map (Json.lookup j "principal") String.of_json)
      }
  end
module ByoipCidr =
  struct
    type t =
      {
      cidr: String.t option ;
      description: String.t option ;
      status_message: String.t option ;
      state: ByoipCidrState.t option }
    let make ?cidr  ?description  ?status_message  ?state  () =
      { cidr; description; status_message; state }
    let parse xml =
      Some
        {
          cidr = (Util.option_bind (Xml.member "cidr" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) ByoipCidrState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (ByoipCidrState.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.cidr
             (fun f -> Query.Pair ("Cidr", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (ByoipCidrState.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.cidr (fun f -> ("cidr", (String.to_json f)))])
    let of_json j =
      {
        cidr = (Util.option_map (Json.lookup j "cidr") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") ByoipCidrState.of_json)
      }
  end
module CoipPool =
  struct
    type t =
      {
      pool_id: String.t option ;
      pool_cidrs: ValueStringList.t ;
      local_gateway_route_table_id: String.t option ;
      tags: TagList.t ;
      pool_arn: String.t option }
    let make ?pool_id  ?(pool_cidrs= [])  ?local_gateway_route_table_id 
      ?(tags= [])  ?pool_arn  () =
      { pool_id; pool_cidrs; local_gateway_route_table_id; tags; pool_arn }
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          pool_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolCidrSet" xml)
                  ValueStringList.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          pool_arn =
            (Util.option_bind (Xml.member "poolArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.pool_arn
              (fun f -> Query.Pair ("PoolArn", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PoolCidrSet", (ValueStringList.to_query v.pool_cidrs)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.pool_arn
              (fun f -> ("pool_arn", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some ("pool_cidrs", (ValueStringList.to_json v.pool_cidrs));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let of_json j =
      {
        pool_id = (Util.option_map (Json.lookup j "pool_id") String.of_json);
        pool_cidrs =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "pool_cidrs")));
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        pool_arn =
          (Util.option_map (Json.lookup j "pool_arn") String.of_json)
      }
  end
module DatafeedSubscriptionState =
  struct
    type t =
      | Active 
      | Inactive 
    let str_to_t = [("Inactive", Inactive); ("Active", Active)]
    let t_to_str = [(Inactive, "Inactive"); (Active, "Active")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module DeleteFleetErrorItem =
  struct
    type t = {
      error: DeleteFleetError.t option ;
      fleet_id: String.t option }
    let make ?error  ?fleet_id  () = { error; fleet_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml) DeleteFleetError.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.error
             (fun f -> Query.Pair ("Error", (DeleteFleetError.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (DeleteFleetError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error") DeleteFleetError.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module DeleteFleetSuccessItem =
  struct
    type t =
      {
      current_fleet_state: FleetStateCode.t option ;
      previous_fleet_state: FleetStateCode.t option ;
      fleet_id: String.t option }
    let make ?current_fleet_state  ?previous_fleet_state  ?fleet_id  () =
      { current_fleet_state; previous_fleet_state; fleet_id }
    let parse xml =
      Some
        {
          current_fleet_state =
            (Util.option_bind (Xml.member "currentFleetState" xml)
               FleetStateCode.parse);
          previous_fleet_state =
            (Util.option_bind (Xml.member "previousFleetState" xml)
               FleetStateCode.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.previous_fleet_state
             (fun f ->
                Query.Pair
                  ("PreviousFleetState", (FleetStateCode.to_query f)));
           Util.option_map v.current_fleet_state
             (fun f ->
                Query.Pair ("CurrentFleetState", (FleetStateCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.previous_fleet_state
             (fun f -> ("previous_fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.current_fleet_state
             (fun f -> ("current_fleet_state", (FleetStateCode.to_json f)))])
    let of_json j =
      {
        current_fleet_state =
          (Util.option_map (Json.lookup j "current_fleet_state")
             FleetStateCode.of_json);
        previous_fleet_state =
          (Util.option_map (Json.lookup j "previous_fleet_state")
             FleetStateCode.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module DisableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      fast_snapshot_restore_state_errors:
        DisableFastSnapshotRestoreStateErrorSet.t }
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  DisableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (DisableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (DisableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        fast_snapshot_restore_state_errors =
          (DisableFastSnapshotRestoreStateErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "fast_snapshot_restore_state_errors")))
      }
  end
module DisableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module ScheduledInstance =
  struct
    type t =
      {
      availability_zone: String.t option ;
      create_date: DateTime.t option ;
      hourly_price: String.t option ;
      instance_count: Integer.t option ;
      instance_type: String.t option ;
      network_platform: String.t option ;
      next_slot_start_time: DateTime.t option ;
      platform: String.t option ;
      previous_slot_end_time: DateTime.t option ;
      recurrence: ScheduledInstanceRecurrence.t option ;
      scheduled_instance_id: String.t option ;
      slot_duration_in_hours: Integer.t option ;
      term_end_date: DateTime.t option ;
      term_start_date: DateTime.t option ;
      total_scheduled_instance_hours: Integer.t option }
    let make ?availability_zone  ?create_date  ?hourly_price  ?instance_count
       ?instance_type  ?network_platform  ?next_slot_start_time  ?platform 
      ?previous_slot_end_time  ?recurrence  ?scheduled_instance_id 
      ?slot_duration_in_hours  ?term_end_date  ?term_start_date 
      ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        create_date;
        hourly_price;
        instance_count;
        instance_type;
        network_platform;
        next_slot_start_time;
        platform;
        previous_slot_end_time;
        recurrence;
        scheduled_instance_id;
        slot_duration_in_hours;
        term_end_date;
        term_start_date;
        total_scheduled_instance_hours
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          create_date =
            (Util.option_bind (Xml.member "createDate" xml) DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          next_slot_start_time =
            (Util.option_bind (Xml.member "nextSlotStartTime" xml)
               DateTime.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          previous_slot_end_time =
            (Util.option_bind (Xml.member "previousSlotEndTime" xml)
               DateTime.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          scheduled_instance_id =
            (Util.option_bind (Xml.member "scheduledInstanceId" xml)
               String.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          term_end_date =
            (Util.option_bind (Xml.member "termEndDate" xml) DateTime.parse);
          term_start_date =
            (Util.option_bind (Xml.member "termStartDate" xml) DateTime.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.term_start_date
             (fun f -> Query.Pair ("TermStartDate", (DateTime.to_query f)));
           Util.option_map v.term_end_date
             (fun f -> Query.Pair ("TermEndDate", (DateTime.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.scheduled_instance_id
             (fun f ->
                Query.Pair ("ScheduledInstanceId", (String.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.previous_slot_end_time
             (fun f ->
                Query.Pair ("PreviousSlotEndTime", (DateTime.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.next_slot_start_time
             (fun f ->
                Query.Pair ("NextSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.create_date
             (fun f -> Query.Pair ("CreateDate", (DateTime.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.term_start_date
             (fun f -> ("term_start_date", (DateTime.to_json f)));
           Util.option_map v.term_end_date
             (fun f -> ("term_end_date", (DateTime.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.scheduled_instance_id
             (fun f -> ("scheduled_instance_id", (String.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.previous_slot_end_time
             (fun f -> ("previous_slot_end_time", (DateTime.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.next_slot_start_time
             (fun f -> ("next_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.create_date
             (fun f -> ("create_date", (DateTime.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        create_date =
          (Util.option_map (Json.lookup j "create_date") DateTime.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        network_platform =
          (Util.option_map (Json.lookup j "network_platform") String.of_json);
        next_slot_start_time =
          (Util.option_map (Json.lookup j "next_slot_start_time")
             DateTime.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        previous_slot_end_time =
          (Util.option_map (Json.lookup j "previous_slot_end_time")
             DateTime.of_json);
        recurrence =
          (Util.option_map (Json.lookup j "recurrence")
             ScheduledInstanceRecurrence.of_json);
        scheduled_instance_id =
          (Util.option_map (Json.lookup j "scheduled_instance_id")
             String.of_json);
        slot_duration_in_hours =
          (Util.option_map (Json.lookup j "slot_duration_in_hours")
             Integer.of_json);
        term_end_date =
          (Util.option_map (Json.lookup j "term_end_date") DateTime.of_json);
        term_start_date =
          (Util.option_map (Json.lookup j "term_start_date") DateTime.of_json);
        total_scheduled_instance_hours =
          (Util.option_map (Json.lookup j "total_scheduled_instance_hours")
             Integer.of_json)
      }
  end
module FlowLog =
  struct
    type t =
      {
      creation_time: DateTime.t option ;
      deliver_logs_error_message: String.t option ;
      deliver_logs_permission_arn: String.t option ;
      deliver_logs_status: String.t option ;
      flow_log_id: String.t option ;
      flow_log_status: String.t option ;
      log_group_name: String.t option ;
      resource_id: String.t option ;
      traffic_type: TrafficType.t option ;
      log_destination_type: LogDestinationType.t option ;
      log_destination: String.t option ;
      log_format: String.t option ;
      tags: TagList.t ;
      max_aggregation_interval: Integer.t option }
    let make ?creation_time  ?deliver_logs_error_message 
      ?deliver_logs_permission_arn  ?deliver_logs_status  ?flow_log_id 
      ?flow_log_status  ?log_group_name  ?resource_id  ?traffic_type 
      ?log_destination_type  ?log_destination  ?log_format  ?(tags= []) 
      ?max_aggregation_interval  () =
      {
        creation_time;
        deliver_logs_error_message;
        deliver_logs_permission_arn;
        deliver_logs_status;
        flow_log_id;
        flow_log_status;
        log_group_name;
        resource_id;
        traffic_type;
        log_destination_type;
        log_destination;
        log_format;
        tags;
        max_aggregation_interval
      }
    let parse xml =
      Some
        {
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          deliver_logs_error_message =
            (Util.option_bind (Xml.member "deliverLogsErrorMessage" xml)
               String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "deliverLogsPermissionArn" xml)
               String.parse);
          deliver_logs_status =
            (Util.option_bind (Xml.member "deliverLogsStatus" xml)
               String.parse);
          flow_log_id =
            (Util.option_bind (Xml.member "flowLogId" xml) String.parse);
          flow_log_status =
            (Util.option_bind (Xml.member "flowLogStatus" xml) String.parse);
          log_group_name =
            (Util.option_bind (Xml.member "logGroupName" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          traffic_type =
            (Util.option_bind (Xml.member "trafficType" xml)
               TrafficType.parse);
          log_destination_type =
            (Util.option_bind (Xml.member "logDestinationType" xml)
               LogDestinationType.parse);
          log_destination =
            (Util.option_bind (Xml.member "logDestination" xml) String.parse);
          log_format =
            (Util.option_bind (Xml.member "logFormat" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          max_aggregation_interval =
            (Util.option_bind (Xml.member "maxAggregationInterval" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_aggregation_interval
              (fun f ->
                 Query.Pair ("MaxAggregationInterval", (Integer.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.log_format
             (fun f -> Query.Pair ("LogFormat", (String.to_query f)));
           Util.option_map v.log_destination
             (fun f -> Query.Pair ("LogDestination", (String.to_query f)));
           Util.option_map v.log_destination_type
             (fun f ->
                Query.Pair
                  ("LogDestinationType", (LogDestinationType.to_query f)));
           Util.option_map v.traffic_type
             (fun f -> Query.Pair ("TrafficType", (TrafficType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.flow_log_status
             (fun f -> Query.Pair ("FlowLogStatus", (String.to_query f)));
           Util.option_map v.flow_log_id
             (fun f -> Query.Pair ("FlowLogId", (String.to_query f)));
           Util.option_map v.deliver_logs_status
             (fun f -> Query.Pair ("DeliverLogsStatus", (String.to_query f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f ->
                Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.deliver_logs_error_message
             (fun f ->
                Query.Pair ("DeliverLogsErrorMessage", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_aggregation_interval
              (fun f -> ("max_aggregation_interval", (Integer.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.log_format
             (fun f -> ("log_format", (String.to_json f)));
           Util.option_map v.log_destination
             (fun f -> ("log_destination", (String.to_json f)));
           Util.option_map v.log_destination_type
             (fun f ->
                ("log_destination_type", (LogDestinationType.to_json f)));
           Util.option_map v.traffic_type
             (fun f -> ("traffic_type", (TrafficType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.flow_log_status
             (fun f -> ("flow_log_status", (String.to_json f)));
           Util.option_map v.flow_log_id
             (fun f -> ("flow_log_id", (String.to_json f)));
           Util.option_map v.deliver_logs_status
             (fun f -> ("deliver_logs_status", (String.to_json f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.deliver_logs_error_message
             (fun f -> ("deliver_logs_error_message", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)))])
    let of_json j =
      {
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        deliver_logs_error_message =
          (Util.option_map (Json.lookup j "deliver_logs_error_message")
             String.of_json);
        deliver_logs_permission_arn =
          (Util.option_map (Json.lookup j "deliver_logs_permission_arn")
             String.of_json);
        deliver_logs_status =
          (Util.option_map (Json.lookup j "deliver_logs_status")
             String.of_json);
        flow_log_id =
          (Util.option_map (Json.lookup j "flow_log_id") String.of_json);
        flow_log_status =
          (Util.option_map (Json.lookup j "flow_log_status") String.of_json);
        log_group_name =
          (Util.option_map (Json.lookup j "log_group_name") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        traffic_type =
          (Util.option_map (Json.lookup j "traffic_type") TrafficType.of_json);
        log_destination_type =
          (Util.option_map (Json.lookup j "log_destination_type")
             LogDestinationType.of_json);
        log_destination =
          (Util.option_map (Json.lookup j "log_destination") String.of_json);
        log_format =
          (Util.option_map (Json.lookup j "log_format") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        max_aggregation_interval =
          (Util.option_map (Json.lookup j "max_aggregation_interval")
             Integer.of_json)
      }
  end
module BundleTask =
  struct
    type t =
      {
      bundle_id: String.t ;
      bundle_task_error: BundleTaskError.t option ;
      instance_id: String.t ;
      progress: String.t ;
      start_time: DateTime.t ;
      state: BundleTaskState.t ;
      storage: Storage.t ;
      update_time: DateTime.t }
    let make ~bundle_id  ?bundle_task_error  ~instance_id  ~progress 
      ~start_time  ~state  ~storage  ~update_time  () =
      {
        bundle_id;
        bundle_task_error;
        instance_id;
        progress;
        start_time;
        state;
        storage;
        update_time
      }
    let parse xml =
      Some
        {
          bundle_id =
            (Xml.required "bundleId"
               (Util.option_bind (Xml.member "bundleId" xml) String.parse));
          bundle_task_error =
            (Util.option_bind (Xml.member "error" xml) BundleTaskError.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  BundleTaskState.parse));
          storage =
            (Xml.required "storage"
               (Util.option_bind (Xml.member "storage" xml) Storage.parse));
          update_time =
            (Xml.required "updateTime"
               (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UpdateTime", (DateTime.to_query v.update_time)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("State", (BundleTaskState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.bundle_task_error
             (fun f -> Query.Pair ("Error", (BundleTaskError.to_query f)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("update_time", (DateTime.to_json v.update_time));
           Some ("storage", (Storage.to_json v.storage));
           Some ("state", (BundleTaskState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("progress", (String.to_json v.progress));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.bundle_task_error
             (fun f -> ("bundle_task_error", (BundleTaskError.to_json f)));
           Some ("bundle_id", (String.to_json v.bundle_id))])
    let of_json j =
      {
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")));
        bundle_task_error =
          (Util.option_map (Json.lookup j "bundle_task_error")
             BundleTaskError.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        state =
          (BundleTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")));
        update_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "update_time")))
      }
  end
module InstanceCreditSpecification =
  struct
    type t = {
      instance_id: String.t option ;
      cpu_credits: String.t option }
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module CoipAddressUsage =
  struct
    type t =
      {
      allocation_id: String.t option ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      co_ip: String.t option }
    let make ?allocation_id  ?aws_account_id  ?aws_service  ?co_ip  () =
      { allocation_id; aws_account_id; aws_service; co_ip }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          aws_account_id =
            (Util.option_bind (Xml.member "awsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "awsService" xml) String.parse);
          co_ip = (Util.option_bind (Xml.member "coIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.co_ip
              (fun f -> Query.Pair ("CoIp", (String.to_query f)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.co_ip (fun f -> ("co_ip", (String.to_json f)));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        co_ip = (Util.option_map (Json.lookup j "co_ip") String.of_json)
      }
  end
module TargetConfigurationRequest =
  struct
    type t = {
      instance_count: Integer.t option ;
      offering_id: String.t }
    let make ?instance_count  ~offering_id  () =
      { instance_count; offering_id }
    let parse xml =
      Some
        {
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)))])
    let of_json j =
      {
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")))
      }
  end
module StaleSecurityGroup =
  struct
    type t =
      {
      description: String.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      stale_ip_permissions: StaleIpPermissionSet.t ;
      stale_ip_permissions_egress: StaleIpPermissionSet.t ;
      vpc_id: String.t option }
    let make ?description  ?group_id  ?group_name  ?(stale_ip_permissions=
      [])  ?(stale_ip_permissions_egress= [])  ?vpc_id  () =
      {
        description;
        group_id;
        group_name;
        stale_ip_permissions;
        stale_ip_permissions_egress;
        vpc_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          stale_ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissions" xml)
                  StaleIpPermissionSet.parse));
          stale_ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleIpPermissionsEgress" xml)
                  StaleIpPermissionSet.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("StaleIpPermissionsEgress",
                  (StaleIpPermissionSet.to_query
                     v.stale_ip_permissions_egress)));
           Some
             (Query.Pair
                ("StaleIpPermissions",
                  (StaleIpPermissionSet.to_query v.stale_ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("stale_ip_permissions_egress",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions_egress));
           Some
             ("stale_ip_permissions",
               (StaleIpPermissionSet.to_json v.stale_ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        stale_ip_permissions =
          (StaleIpPermissionSet.of_json
             (Util.of_option_exn (Json.lookup j "stale_ip_permissions")));
        stale_ip_permissions_egress =
          (StaleIpPermissionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "stale_ip_permissions_egress")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module SecurityGroupReference =
  struct
    type t =
      {
      group_id: String.t option ;
      referencing_vpc_id: String.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?group_id  ?referencing_vpc_id  ?vpc_peering_connection_id  () =
      { group_id; referencing_vpc_id; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          referencing_vpc_id =
            (Util.option_bind (Xml.member "referencingVpcId" xml)
               String.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> Query.Pair ("ReferencingVpcId", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.referencing_vpc_id
             (fun f -> ("referencing_vpc_id", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        referencing_vpc_id =
          (Util.option_map (Json.lookup j "referencing_vpc_id")
             String.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module AssignedPrivateIpAddress =
  struct
    type t = {
      private_ip_address: String.t option }
    let make ?private_ip_address  () = { private_ip_address }
    let parse xml =
      Some
        {
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)))])
    let of_json j =
      {
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module LocalGatewayRouteTableVpcAssociation =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_id: String.t option ;
      local_gateway_route_table_id: String.t option ;
      local_gateway_route_table_arn: String.t option ;
      local_gateway_id: String.t option ;
      vpc_id: String.t option ;
      owner_id: String.t option ;
      state: String.t option ;
      tags: TagList.t }
    let make ?local_gateway_route_table_vpc_association_id 
      ?local_gateway_route_table_id  ?local_gateway_route_table_arn 
      ?local_gateway_id  ?vpc_id  ?owner_id  ?state  ?(tags= [])  () =
      {
        local_gateway_route_table_vpc_association_id;
        local_gateway_route_table_id;
        local_gateway_route_table_arn;
        local_gateway_id;
        vpc_id;
        owner_id;
        state;
        tags
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_id =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociationId" xml)
               String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_route_table_arn =
            (Util.option_bind (Xml.member "localGatewayRouteTableArn" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableArn", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVpcAssociationId",
                    (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f -> ("local_gateway_route_table_arn", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_vpc_association_id
             (fun f ->
                ("local_gateway_route_table_vpc_association_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_id =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association_id")
             String.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_route_table_arn =
          (Util.option_map (Json.lookup j "local_gateway_route_table_arn")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CreateVolumePermissionList =
  struct
    type t = CreateVolumePermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateVolumePermission.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateVolumePermission.to_query v
    let to_json v = `List (List.map CreateVolumePermission.to_json v)
    let of_json j = Json.to_list CreateVolumePermission.of_json j
  end
module Volume =
  struct
    type t =
      {
      attachments: VolumeAttachmentList.t ;
      availability_zone: String.t ;
      create_time: DateTime.t ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option ;
      outpost_arn: String.t option ;
      size: Integer.t ;
      snapshot_id: String.t ;
      state: VolumeState.t ;
      volume_id: String.t ;
      iops: Integer.t option ;
      tags: TagList.t ;
      volume_type: VolumeType.t ;
      fast_restored: Boolean.t option ;
      multi_attach_enabled: Boolean.t option }
    let make ?(attachments= [])  ~availability_zone  ~create_time  ~encrypted
       ?kms_key_id  ?outpost_arn  ~size  ~snapshot_id  ~state  ~volume_id 
      ?iops  ?(tags= [])  ~volume_type  ?fast_restored  ?multi_attach_enabled
       () =
      {
        attachments;
        availability_zone;
        create_time;
        encrypted;
        kms_key_id;
        outpost_arn;
        size;
        snapshot_id;
        state;
        volume_id;
        iops;
        tags;
        volume_type;
        fast_restored;
        multi_attach_enabled
      }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  VolumeAttachmentList.parse));
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          create_time =
            (Xml.required "createTime"
               (Util.option_bind (Xml.member "createTime" xml) DateTime.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          size =
            (Xml.required "size"
               (Util.option_bind (Xml.member "size" xml) Integer.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml) VolumeState.parse));
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          iops = (Util.option_bind (Xml.member "iops" xml) Integer.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          volume_type =
            (Xml.required "volumeType"
               (Util.option_bind (Xml.member "volumeType" xml)
                  VolumeType.parse));
          fast_restored =
            (Util.option_bind (Xml.member "fastRestored" xml) Boolean.parse);
          multi_attach_enabled =
            (Util.option_bind (Xml.member "multiAttachEnabled" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multi_attach_enabled
              (fun f ->
                 Query.Pair ("MultiAttachEnabled", (Boolean.to_query f)));
           Util.option_map v.fast_restored
             (fun f -> Query.Pair ("FastRestored", (Boolean.to_query f)));
           Some
             (Query.Pair ("VolumeType", (VolumeType.to_query v.volume_type)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("Status", (VolumeState.to_query v.state)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Size", (Integer.to_query v.size)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some
             (Query.Pair ("CreateTime", (DateTime.to_query v.create_time)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (VolumeAttachmentList.to_query v.attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multi_attach_enabled
              (fun f -> ("multi_attach_enabled", (Boolean.to_json f)));
           Util.option_map v.fast_restored
             (fun f -> ("fast_restored", (Boolean.to_json f)));
           Some ("volume_type", (VolumeType.to_json v.volume_type));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("state", (VolumeState.to_json v.state));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("size", (Integer.to_json v.size));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("create_time", (DateTime.to_json v.create_time));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Some ("attachments", (VolumeAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (VolumeAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        create_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "create_time")));
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        size = (Integer.of_json (Util.of_option_exn (Json.lookup j "size")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        state =
          (VolumeState.of_json (Util.of_option_exn (Json.lookup j "state")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        volume_type =
          (VolumeType.of_json
             (Util.of_option_exn (Json.lookup j "volume_type")));
        fast_restored =
          (Util.option_map (Json.lookup j "fast_restored") Boolean.of_json);
        multi_attach_enabled =
          (Util.option_map (Json.lookup j "multi_attach_enabled")
             Boolean.of_json)
      }
  end
module ClientVpnConnection =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      timestamp: String.t option ;
      connection_id: String.t option ;
      username: String.t option ;
      connection_established_time: String.t option ;
      ingress_bytes: String.t option ;
      egress_bytes: String.t option ;
      ingress_packets: String.t option ;
      egress_packets: String.t option ;
      client_ip: String.t option ;
      common_name: String.t option ;
      status: ClientVpnConnectionStatus.t option ;
      connection_end_time: String.t option ;
      posture_compliance_statuses: ValueStringList.t }
    let make ?client_vpn_endpoint_id  ?timestamp  ?connection_id  ?username 
      ?connection_established_time  ?ingress_bytes  ?egress_bytes 
      ?ingress_packets  ?egress_packets  ?client_ip  ?common_name  ?status 
      ?connection_end_time  ?(posture_compliance_statuses= [])  () =
      {
        client_vpn_endpoint_id;
        timestamp;
        connection_id;
        username;
        connection_established_time;
        ingress_bytes;
        egress_bytes;
        ingress_packets;
        egress_packets;
        client_ip;
        common_name;
        status;
        connection_end_time;
        posture_compliance_statuses
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) String.parse);
          connection_id =
            (Util.option_bind (Xml.member "connectionId" xml) String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_established_time =
            (Util.option_bind (Xml.member "connectionEstablishedTime" xml)
               String.parse);
          ingress_bytes =
            (Util.option_bind (Xml.member "ingressBytes" xml) String.parse);
          egress_bytes =
            (Util.option_bind (Xml.member "egressBytes" xml) String.parse);
          ingress_packets =
            (Util.option_bind (Xml.member "ingressPackets" xml) String.parse);
          egress_packets =
            (Util.option_bind (Xml.member "egressPackets" xml) String.parse);
          client_ip =
            (Util.option_bind (Xml.member "clientIp" xml) String.parse);
          common_name =
            (Util.option_bind (Xml.member "commonName" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnConnectionStatus.parse);
          connection_end_time =
            (Util.option_bind (Xml.member "connectionEndTime" xml)
               String.parse);
          posture_compliance_statuses =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "postureComplianceStatusSet" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PostureComplianceStatusSet",
                   (ValueStringList.to_query v.posture_compliance_statuses)));
           Util.option_map v.connection_end_time
             (fun f -> Query.Pair ("ConnectionEndTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnConnectionStatus.to_query f)));
           Util.option_map v.common_name
             (fun f -> Query.Pair ("CommonName", (String.to_query f)));
           Util.option_map v.client_ip
             (fun f -> Query.Pair ("ClientIp", (String.to_query f)));
           Util.option_map v.egress_packets
             (fun f -> Query.Pair ("EgressPackets", (String.to_query f)));
           Util.option_map v.ingress_packets
             (fun f -> Query.Pair ("IngressPackets", (String.to_query f)));
           Util.option_map v.egress_bytes
             (fun f -> Query.Pair ("EgressBytes", (String.to_query f)));
           Util.option_map v.ingress_bytes
             (fun f -> Query.Pair ("IngressBytes", (String.to_query f)));
           Util.option_map v.connection_established_time
             (fun f ->
                Query.Pair ("ConnectionEstablishedTime", (String.to_query f)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)));
           Util.option_map v.timestamp
             (fun f -> Query.Pair ("Timestamp", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("posture_compliance_statuses",
                (ValueStringList.to_json v.posture_compliance_statuses));
           Util.option_map v.connection_end_time
             (fun f -> ("connection_end_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnConnectionStatus.to_json f)));
           Util.option_map v.common_name
             (fun f -> ("common_name", (String.to_json f)));
           Util.option_map v.client_ip
             (fun f -> ("client_ip", (String.to_json f)));
           Util.option_map v.egress_packets
             (fun f -> ("egress_packets", (String.to_json f)));
           Util.option_map v.ingress_packets
             (fun f -> ("ingress_packets", (String.to_json f)));
           Util.option_map v.egress_bytes
             (fun f -> ("egress_bytes", (String.to_json f)));
           Util.option_map v.ingress_bytes
             (fun f -> ("ingress_bytes", (String.to_json f)));
           Util.option_map v.connection_established_time
             (fun f -> ("connection_established_time", (String.to_json f)));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)));
           Util.option_map v.timestamp
             (fun f -> ("timestamp", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") String.of_json);
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        connection_established_time =
          (Util.option_map (Json.lookup j "connection_established_time")
             String.of_json);
        ingress_bytes =
          (Util.option_map (Json.lookup j "ingress_bytes") String.of_json);
        egress_bytes =
          (Util.option_map (Json.lookup j "egress_bytes") String.of_json);
        ingress_packets =
          (Util.option_map (Json.lookup j "ingress_packets") String.of_json);
        egress_packets =
          (Util.option_map (Json.lookup j "egress_packets") String.of_json);
        client_ip =
          (Util.option_map (Json.lookup j "client_ip") String.of_json);
        common_name =
          (Util.option_map (Json.lookup j "common_name") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnConnectionStatus.of_json);
        connection_end_time =
          (Util.option_map (Json.lookup j "connection_end_time")
             String.of_json);
        posture_compliance_statuses =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "posture_compliance_statuses")))
      }
  end
module LocalGatewayRouteTable =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t option ;
      local_gateway_route_table_arn: String.t option ;
      local_gateway_id: String.t option ;
      outpost_arn: String.t option ;
      owner_id: String.t option ;
      state: String.t option ;
      tags: TagList.t }
    let make ?local_gateway_route_table_id  ?local_gateway_route_table_arn 
      ?local_gateway_id  ?outpost_arn  ?owner_id  ?state  ?(tags= [])  () =
      {
        local_gateway_route_table_id;
        local_gateway_route_table_arn;
        local_gateway_id;
        outpost_arn;
        owner_id;
        state;
        tags
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_route_table_arn =
            (Util.option_bind (Xml.member "localGatewayRouteTableArn" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableArn", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f -> ("local_gateway_route_table_arn", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_route_table_arn =
          (Util.option_map (Json.lookup j "local_gateway_route_table_arn")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Region =
  struct
    type t =
      {
      endpoint: String.t option ;
      region_name: String.t option ;
      opt_in_status: String.t option }
    let make ?endpoint  ?region_name  ?opt_in_status  () =
      { endpoint; region_name; opt_in_status }
    let parse xml =
      Some
        {
          endpoint =
            (Util.option_bind (Xml.member "regionEndpoint" xml) String.parse);
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> Query.Pair ("OptInStatus", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Util.option_map v.endpoint
             (fun f -> Query.Pair ("RegionEndpoint", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.opt_in_status
              (fun f -> ("opt_in_status", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Util.option_map v.endpoint
             (fun f -> ("endpoint", (String.to_json f)))])
    let of_json j =
      {
        endpoint =
          (Util.option_map (Json.lookup j "endpoint") String.of_json);
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        opt_in_status =
          (Util.option_map (Json.lookup j "opt_in_status") String.of_json)
      }
  end
module VpnTunnelOptionsSpecificationsList =
  struct
    type t = VpnTunnelOptionsSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpnTunnelOptionsSpecification.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list VpnTunnelOptionsSpecification.to_query v
    let to_json v = `List (List.map VpnTunnelOptionsSpecification.to_json v)
    let of_json j = Json.to_list VpnTunnelOptionsSpecification.of_json j
  end
module Ipv6CidrAssociation =
  struct
    type t =
      {
      ipv6_cidr: String.t option ;
      associated_resource: String.t option }
    let make ?ipv6_cidr  ?associated_resource  () =
      { ipv6_cidr; associated_resource }
    let parse xml =
      Some
        {
          ipv6_cidr =
            (Util.option_bind (Xml.member "ipv6Cidr" xml) String.parse);
          associated_resource =
            (Util.option_bind (Xml.member "associatedResource" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associated_resource
              (fun f ->
                 Query.Pair ("AssociatedResource", (String.to_query f)));
           Util.option_map v.ipv6_cidr
             (fun f -> Query.Pair ("Ipv6Cidr", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associated_resource
              (fun f -> ("associated_resource", (String.to_json f)));
           Util.option_map v.ipv6_cidr
             (fun f -> ("ipv6_cidr", (String.to_json f)))])
    let of_json j =
      {
        ipv6_cidr =
          (Util.option_map (Json.lookup j "ipv6_cidr") String.of_json);
        associated_resource =
          (Util.option_map (Json.lookup j "associated_resource")
             String.of_json)
      }
  end
module PrefixListAssociation =
  struct
    type t = {
      resource_id: String.t option ;
      resource_owner: String.t option }
    let make ?resource_id  ?resource_owner  () =
      { resource_id; resource_owner }
    let parse xml =
      Some
        {
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_owner =
            (Util.option_bind (Xml.member "resourceOwner" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource_owner
              (fun f -> Query.Pair ("ResourceOwner", (String.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource_owner
              (fun f -> ("resource_owner", (String.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)))])
    let of_json j =
      {
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_owner =
          (Util.option_map (Json.lookup j "resource_owner") String.of_json)
      }
  end
module Address =
  struct
    type t =
      {
      instance_id: String.t option ;
      public_ip: String.t option ;
      allocation_id: String.t option ;
      association_id: String.t option ;
      domain: DomainType.t option ;
      network_interface_id: String.t option ;
      network_interface_owner_id: String.t option ;
      private_ip_address: String.t option ;
      tags: TagList.t ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      customer_owned_ip: String.t option ;
      customer_owned_ipv4_pool: String.t option ;
      carrier_ip: String.t option }
    let make ?instance_id  ?public_ip  ?allocation_id  ?association_id 
      ?domain  ?network_interface_id  ?network_interface_owner_id 
      ?private_ip_address  ?(tags= [])  ?public_ipv4_pool 
      ?network_border_group  ?customer_owned_ip  ?customer_owned_ipv4_pool 
      ?carrier_ip  () =
      {
        instance_id;
        public_ip;
        allocation_id;
        association_id;
        domain;
        network_interface_id;
        network_interface_owner_id;
        private_ip_address;
        tags;
        public_ipv4_pool;
        network_border_group;
        customer_owned_ip;
        customer_owned_ipv4_pool;
        carrier_ip
      }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_interface_owner_id =
            (Util.option_bind (Xml.member "networkInterfaceOwnerId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse);
          carrier_ip =
            (Util.option_bind (Xml.member "carrierIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> Query.Pair ("CarrierIp", (String.to_query f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f ->
                Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_owner_id
             (fun f ->
                Query.Pair ("NetworkInterfaceOwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> ("carrier_ip", (String.to_json f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_owner_id
             (fun f -> ("network_interface_owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_interface_owner_id =
          (Util.option_map (Json.lookup j "network_interface_owner_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        customer_owned_ip =
          (Util.option_map (Json.lookup j "customer_owned_ip") String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json);
        carrier_ip =
          (Util.option_map (Json.lookup j "carrier_ip") String.of_json)
      }
  end
module InstanceTypeInfo =
  struct
    type t =
      {
      instance_type: InstanceType.t option ;
      current_generation: Boolean.t option ;
      free_tier_eligible: Boolean.t option ;
      supported_usage_classes: UsageClassTypeList.t ;
      supported_root_device_types: RootDeviceTypeList.t ;
      supported_virtualization_types: VirtualizationTypeList.t ;
      bare_metal: Boolean.t option ;
      hypervisor: InstanceTypeHypervisor.t option ;
      processor_info: ProcessorInfo.t option ;
      v_cpu_info: VCpuInfo.t option ;
      memory_info: MemoryInfo.t option ;
      instance_storage_supported: Boolean.t option ;
      instance_storage_info: InstanceStorageInfo.t option ;
      ebs_info: EbsInfo.t option ;
      network_info: NetworkInfo.t option ;
      gpu_info: GpuInfo.t option ;
      fpga_info: FpgaInfo.t option ;
      placement_group_info: PlacementGroupInfo.t option ;
      inference_accelerator_info: InferenceAcceleratorInfo.t option ;
      hibernation_supported: Boolean.t option ;
      burstable_performance_supported: Boolean.t option ;
      dedicated_hosts_supported: Boolean.t option ;
      auto_recovery_supported: Boolean.t option }
    let make ?instance_type  ?current_generation  ?free_tier_eligible 
      ?(supported_usage_classes= [])  ?(supported_root_device_types= []) 
      ?(supported_virtualization_types= [])  ?bare_metal  ?hypervisor 
      ?processor_info  ?v_cpu_info  ?memory_info  ?instance_storage_supported
       ?instance_storage_info  ?ebs_info  ?network_info  ?gpu_info 
      ?fpga_info  ?placement_group_info  ?inference_accelerator_info 
      ?hibernation_supported  ?burstable_performance_supported 
      ?dedicated_hosts_supported  ?auto_recovery_supported  () =
      {
        instance_type;
        current_generation;
        free_tier_eligible;
        supported_usage_classes;
        supported_root_device_types;
        supported_virtualization_types;
        bare_metal;
        hypervisor;
        processor_info;
        v_cpu_info;
        memory_info;
        instance_storage_supported;
        instance_storage_info;
        ebs_info;
        network_info;
        gpu_info;
        fpga_info;
        placement_group_info;
        inference_accelerator_info;
        hibernation_supported;
        burstable_performance_supported;
        dedicated_hosts_supported;
        auto_recovery_supported
      }
    let parse xml =
      Some
        {
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          current_generation =
            (Util.option_bind (Xml.member "currentGeneration" xml)
               Boolean.parse);
          free_tier_eligible =
            (Util.option_bind (Xml.member "freeTierEligible" xml)
               Boolean.parse);
          supported_usage_classes =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedUsageClasses" xml)
                  UsageClassTypeList.parse));
          supported_root_device_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "supportedRootDeviceTypes" xml)
                  RootDeviceTypeList.parse));
          supported_virtualization_types =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "supportedVirtualizationTypes" xml)
                  VirtualizationTypeList.parse));
          bare_metal =
            (Util.option_bind (Xml.member "bareMetal" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml)
               InstanceTypeHypervisor.parse);
          processor_info =
            (Util.option_bind (Xml.member "processorInfo" xml)
               ProcessorInfo.parse);
          v_cpu_info =
            (Util.option_bind (Xml.member "vCpuInfo" xml) VCpuInfo.parse);
          memory_info =
            (Util.option_bind (Xml.member "memoryInfo" xml) MemoryInfo.parse);
          instance_storage_supported =
            (Util.option_bind (Xml.member "instanceStorageSupported" xml)
               Boolean.parse);
          instance_storage_info =
            (Util.option_bind (Xml.member "instanceStorageInfo" xml)
               InstanceStorageInfo.parse);
          ebs_info =
            (Util.option_bind (Xml.member "ebsInfo" xml) EbsInfo.parse);
          network_info =
            (Util.option_bind (Xml.member "networkInfo" xml)
               NetworkInfo.parse);
          gpu_info =
            (Util.option_bind (Xml.member "gpuInfo" xml) GpuInfo.parse);
          fpga_info =
            (Util.option_bind (Xml.member "fpgaInfo" xml) FpgaInfo.parse);
          placement_group_info =
            (Util.option_bind (Xml.member "placementGroupInfo" xml)
               PlacementGroupInfo.parse);
          inference_accelerator_info =
            (Util.option_bind (Xml.member "inferenceAcceleratorInfo" xml)
               InferenceAcceleratorInfo.parse);
          hibernation_supported =
            (Util.option_bind (Xml.member "hibernationSupported" xml)
               Boolean.parse);
          burstable_performance_supported =
            (Util.option_bind
               (Xml.member "burstablePerformanceSupported" xml) Boolean.parse);
          dedicated_hosts_supported =
            (Util.option_bind (Xml.member "dedicatedHostsSupported" xml)
               Boolean.parse);
          auto_recovery_supported =
            (Util.option_bind (Xml.member "autoRecoverySupported" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f ->
                 Query.Pair ("AutoRecoverySupported", (Boolean.to_query f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f ->
                Query.Pair ("DedicatedHostsSupported", (Boolean.to_query f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                Query.Pair
                  ("BurstablePerformanceSupported", (Boolean.to_query f)));
           Util.option_map v.hibernation_supported
             (fun f ->
                Query.Pair ("HibernationSupported", (Boolean.to_query f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                Query.Pair
                  ("InferenceAcceleratorInfo",
                    (InferenceAcceleratorInfo.to_query f)));
           Util.option_map v.placement_group_info
             (fun f ->
                Query.Pair
                  ("PlacementGroupInfo", (PlacementGroupInfo.to_query f)));
           Util.option_map v.fpga_info
             (fun f -> Query.Pair ("FpgaInfo", (FpgaInfo.to_query f)));
           Util.option_map v.gpu_info
             (fun f -> Query.Pair ("GpuInfo", (GpuInfo.to_query f)));
           Util.option_map v.network_info
             (fun f -> Query.Pair ("NetworkInfo", (NetworkInfo.to_query f)));
           Util.option_map v.ebs_info
             (fun f -> Query.Pair ("EbsInfo", (EbsInfo.to_query f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                Query.Pair
                  ("InstanceStorageInfo", (InstanceStorageInfo.to_query f)));
           Util.option_map v.instance_storage_supported
             (fun f ->
                Query.Pair ("InstanceStorageSupported", (Boolean.to_query f)));
           Util.option_map v.memory_info
             (fun f -> Query.Pair ("MemoryInfo", (MemoryInfo.to_query f)));
           Util.option_map v.v_cpu_info
             (fun f -> Query.Pair ("VCpuInfo", (VCpuInfo.to_query f)));
           Util.option_map v.processor_info
             (fun f ->
                Query.Pair ("ProcessorInfo", (ProcessorInfo.to_query f)));
           Util.option_map v.hypervisor
             (fun f ->
                Query.Pair
                  ("Hypervisor", (InstanceTypeHypervisor.to_query f)));
           Util.option_map v.bare_metal
             (fun f -> Query.Pair ("BareMetal", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SupportedVirtualizationTypes",
                  (VirtualizationTypeList.to_query
                     v.supported_virtualization_types)));
           Some
             (Query.Pair
                ("SupportedRootDeviceTypes",
                  (RootDeviceTypeList.to_query v.supported_root_device_types)));
           Some
             (Query.Pair
                ("SupportedUsageClasses",
                  (UsageClassTypeList.to_query v.supported_usage_classes)));
           Util.option_map v.free_tier_eligible
             (fun f -> Query.Pair ("FreeTierEligible", (Boolean.to_query f)));
           Util.option_map v.current_generation
             (fun f -> Query.Pair ("CurrentGeneration", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.auto_recovery_supported
              (fun f -> ("auto_recovery_supported", (Boolean.to_json f)));
           Util.option_map v.dedicated_hosts_supported
             (fun f -> ("dedicated_hosts_supported", (Boolean.to_json f)));
           Util.option_map v.burstable_performance_supported
             (fun f ->
                ("burstable_performance_supported", (Boolean.to_json f)));
           Util.option_map v.hibernation_supported
             (fun f -> ("hibernation_supported", (Boolean.to_json f)));
           Util.option_map v.inference_accelerator_info
             (fun f ->
                ("inference_accelerator_info",
                  (InferenceAcceleratorInfo.to_json f)));
           Util.option_map v.placement_group_info
             (fun f ->
                ("placement_group_info", (PlacementGroupInfo.to_json f)));
           Util.option_map v.fpga_info
             (fun f -> ("fpga_info", (FpgaInfo.to_json f)));
           Util.option_map v.gpu_info
             (fun f -> ("gpu_info", (GpuInfo.to_json f)));
           Util.option_map v.network_info
             (fun f -> ("network_info", (NetworkInfo.to_json f)));
           Util.option_map v.ebs_info
             (fun f -> ("ebs_info", (EbsInfo.to_json f)));
           Util.option_map v.instance_storage_info
             (fun f ->
                ("instance_storage_info", (InstanceStorageInfo.to_json f)));
           Util.option_map v.instance_storage_supported
             (fun f -> ("instance_storage_supported", (Boolean.to_json f)));
           Util.option_map v.memory_info
             (fun f -> ("memory_info", (MemoryInfo.to_json f)));
           Util.option_map v.v_cpu_info
             (fun f -> ("v_cpu_info", (VCpuInfo.to_json f)));
           Util.option_map v.processor_info
             (fun f -> ("processor_info", (ProcessorInfo.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (InstanceTypeHypervisor.to_json f)));
           Util.option_map v.bare_metal
             (fun f -> ("bare_metal", (Boolean.to_json f)));
           Some
             ("supported_virtualization_types",
               (VirtualizationTypeList.to_json
                  v.supported_virtualization_types));
           Some
             ("supported_root_device_types",
               (RootDeviceTypeList.to_json v.supported_root_device_types));
           Some
             ("supported_usage_classes",
               (UsageClassTypeList.to_json v.supported_usage_classes));
           Util.option_map v.free_tier_eligible
             (fun f -> ("free_tier_eligible", (Boolean.to_json f)));
           Util.option_map v.current_generation
             (fun f -> ("current_generation", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)))])
    let of_json j =
      {
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        current_generation =
          (Util.option_map (Json.lookup j "current_generation")
             Boolean.of_json);
        free_tier_eligible =
          (Util.option_map (Json.lookup j "free_tier_eligible")
             Boolean.of_json);
        supported_usage_classes =
          (UsageClassTypeList.of_json
             (Util.of_option_exn (Json.lookup j "supported_usage_classes")));
        supported_root_device_types =
          (RootDeviceTypeList.of_json
             (Util.of_option_exn
                (Json.lookup j "supported_root_device_types")));
        supported_virtualization_types =
          (VirtualizationTypeList.of_json
             (Util.of_option_exn
                (Json.lookup j "supported_virtualization_types")));
        bare_metal =
          (Util.option_map (Json.lookup j "bare_metal") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor")
             InstanceTypeHypervisor.of_json);
        processor_info =
          (Util.option_map (Json.lookup j "processor_info")
             ProcessorInfo.of_json);
        v_cpu_info =
          (Util.option_map (Json.lookup j "v_cpu_info") VCpuInfo.of_json);
        memory_info =
          (Util.option_map (Json.lookup j "memory_info") MemoryInfo.of_json);
        instance_storage_supported =
          (Util.option_map (Json.lookup j "instance_storage_supported")
             Boolean.of_json);
        instance_storage_info =
          (Util.option_map (Json.lookup j "instance_storage_info")
             InstanceStorageInfo.of_json);
        ebs_info =
          (Util.option_map (Json.lookup j "ebs_info") EbsInfo.of_json);
        network_info =
          (Util.option_map (Json.lookup j "network_info") NetworkInfo.of_json);
        gpu_info =
          (Util.option_map (Json.lookup j "gpu_info") GpuInfo.of_json);
        fpga_info =
          (Util.option_map (Json.lookup j "fpga_info") FpgaInfo.of_json);
        placement_group_info =
          (Util.option_map (Json.lookup j "placement_group_info")
             PlacementGroupInfo.of_json);
        inference_accelerator_info =
          (Util.option_map (Json.lookup j "inference_accelerator_info")
             InferenceAcceleratorInfo.of_json);
        hibernation_supported =
          (Util.option_map (Json.lookup j "hibernation_supported")
             Boolean.of_json);
        burstable_performance_supported =
          (Util.option_map (Json.lookup j "burstable_performance_supported")
             Boolean.of_json);
        dedicated_hosts_supported =
          (Util.option_map (Json.lookup j "dedicated_hosts_supported")
             Boolean.of_json);
        auto_recovery_supported =
          (Util.option_map (Json.lookup j "auto_recovery_supported")
             Boolean.of_json)
      }
  end
module ClientVpnRoute =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      destination_cidr: String.t option ;
      target_subnet: String.t option ;
      type_: String.t option ;
      origin: String.t option ;
      status: ClientVpnRouteStatus.t option ;
      description: String.t option }
    let make ?client_vpn_endpoint_id  ?destination_cidr  ?target_subnet 
      ?type_  ?origin  ?status  ?description  () =
      {
        client_vpn_endpoint_id;
        destination_cidr;
        target_subnet;
        type_;
        origin;
        status;
        description
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          target_subnet =
            (Util.option_bind (Xml.member "targetSubnet" xml) String.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) String.parse);
          origin = (Util.option_bind (Xml.member "origin" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)));
           Util.option_map v.origin
             (fun f -> Query.Pair ("Origin", (String.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (String.to_query f)));
           Util.option_map v.target_subnet
             (fun f -> Query.Pair ("TargetSubnet", (String.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.description
              (fun f -> ("description", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnRouteStatus.to_json f)));
           Util.option_map v.origin (fun f -> ("origin", (String.to_json f)));
           Util.option_map v.type_ (fun f -> ("type_", (String.to_json f)));
           Util.option_map v.target_subnet
             (fun f -> ("target_subnet", (String.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        destination_cidr =
          (Util.option_map (Json.lookup j "destination_cidr") String.of_json);
        target_subnet =
          (Util.option_map (Json.lookup j "target_subnet") String.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") String.of_json);
        origin = (Util.option_map (Json.lookup j "origin") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json)
      }
  end
module VpnConnection =
  struct
    type t =
      {
      customer_gateway_configuration: String.t option ;
      customer_gateway_id: String.t ;
      category: String.t option ;
      state: VpnState.t ;
      type_: GatewayType.t ;
      vpn_connection_id: String.t ;
      vpn_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      options: VpnConnectionOptions.t option ;
      routes: VpnStaticRouteList.t ;
      tags: TagList.t ;
      vgw_telemetry: VgwTelemetryList.t }
    let make ?customer_gateway_configuration  ~customer_gateway_id  ?category
       ~state  ~type_  ~vpn_connection_id  ?vpn_gateway_id 
      ?transit_gateway_id  ?options  ?(routes= [])  ?(tags= []) 
      ?(vgw_telemetry= [])  () =
      {
        customer_gateway_configuration;
        customer_gateway_id;
        category;
        state;
        type_;
        vpn_connection_id;
        vpn_gateway_id;
        transit_gateway_id;
        options;
        routes;
        tags;
        vgw_telemetry
      }
    let parse xml =
      Some
        {
          customer_gateway_configuration =
            (Util.option_bind (Xml.member "customerGatewayConfiguration" xml)
               String.parse);
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          category =
            (Util.option_bind (Xml.member "category" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpnState.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) GatewayType.parse));
          vpn_connection_id =
            (Xml.required "vpnConnectionId"
               (Util.option_bind (Xml.member "vpnConnectionId" xml)
                  String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "vpnGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptions.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  VpnStaticRouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vgw_telemetry =
            (Util.of_option []
               (Util.option_bind (Xml.member "vgwTelemetry" xml)
                  VgwTelemetryList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VgwTelemetry",
                   (VgwTelemetryList.to_query v.vgw_telemetry)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair ("Routes", (VpnStaticRouteList.to_query v.routes)));
           Util.option_map v.options
             (fun f ->
                Query.Pair ("Options", (VpnConnectionOptions.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Some (Query.Pair ("State", (VpnState.to_query v.state)));
           Util.option_map v.category
             (fun f -> Query.Pair ("Category", (String.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Util.option_map v.customer_gateway_configuration
             (fun f ->
                Query.Pair
                  ("CustomerGatewayConfiguration", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vgw_telemetry", (VgwTelemetryList.to_json v.vgw_telemetry));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (VpnStaticRouteList.to_json v.routes));
           Util.option_map v.options
             (fun f -> ("options", (VpnConnectionOptions.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some ("type_", (GatewayType.to_json v.type_));
           Some ("state", (VpnState.to_json v.state));
           Util.option_map v.category
             (fun f -> ("category", (String.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Util.option_map v.customer_gateway_configuration
             (fun f -> ("customer_gateway_configuration", (String.to_json f)))])
    let of_json j =
      {
        customer_gateway_configuration =
          (Util.option_map (Json.lookup j "customer_gateway_configuration")
             String.of_json);
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        category =
          (Util.option_map (Json.lookup j "category") String.of_json);
        state =
          (VpnState.of_json (Util.of_option_exn (Json.lookup j "state")));
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptions.of_json);
        routes =
          (VpnStaticRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vgw_telemetry =
          (VgwTelemetryList.of_json
             (Util.of_option_exn (Json.lookup j "vgw_telemetry")))
      }
  end
module TargetNetwork =
  struct
    type t =
      {
      association_id: String.t option ;
      vpc_id: String.t option ;
      target_network_id: String.t option ;
      client_vpn_endpoint_id: String.t option ;
      status: AssociationStatus.t option ;
      security_groups: ValueStringList.t }
    let make ?association_id  ?vpc_id  ?target_network_id 
      ?client_vpn_endpoint_id  ?status  ?(security_groups= [])  () =
      {
        association_id;
        vpc_id;
        target_network_id;
        client_vpn_endpoint_id;
        status;
        security_groups
      }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          target_network_id =
            (Util.option_bind (Xml.member "targetNetworkId" xml) String.parse);
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse);
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroups" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroups",
                   (ValueStringList.to_query v.security_groups)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)));
           Util.option_map v.target_network_id
             (fun f -> Query.Pair ("TargetNetworkId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_groups",
                (ValueStringList.to_json v.security_groups));
           Util.option_map v.status
             (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)));
           Util.option_map v.target_network_id
             (fun f -> ("target_network_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        target_network_id =
          (Util.option_map (Json.lookup j "target_network_id") String.of_json);
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json);
        security_groups =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")))
      }
  end
module VpcPeeringConnection =
  struct
    type t =
      {
      accepter_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      expiration_time: DateTime.t option ;
      requester_vpc_info: VpcPeeringConnectionVpcInfo.t option ;
      status: VpcPeeringConnectionStateReason.t option ;
      tags: TagList.t ;
      vpc_peering_connection_id: String.t option }
    let make ?accepter_vpc_info  ?expiration_time  ?requester_vpc_info 
      ?status  ?(tags= [])  ?vpc_peering_connection_id  () =
      {
        accepter_vpc_info;
        expiration_time;
        requester_vpc_info;
        status;
        tags;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          accepter_vpc_info =
            (Util.option_bind (Xml.member "accepterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml)
               DateTime.parse);
          requester_vpc_info =
            (Util.option_bind (Xml.member "requesterVpcInfo" xml)
               VpcPeeringConnectionVpcInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               VpcPeeringConnectionStateReason.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f ->
                Query.Pair
                  ("Status", (VpcPeeringConnectionStateReason.to_query f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                Query.Pair
                  ("RequesterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (DateTime.to_query f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                Query.Pair
                  ("AccepterVpcInfo",
                    (VpcPeeringConnectionVpcInfo.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f ->
                ("status", (VpcPeeringConnectionStateReason.to_json f)));
           Util.option_map v.requester_vpc_info
             (fun f ->
                ("requester_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (DateTime.to_json f)));
           Util.option_map v.accepter_vpc_info
             (fun f ->
                ("accepter_vpc_info",
                  (VpcPeeringConnectionVpcInfo.to_json f)))])
    let of_json j =
      {
        accepter_vpc_info =
          (Util.option_map (Json.lookup j "accepter_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") DateTime.of_json);
        requester_vpc_info =
          (Util.option_map (Json.lookup j "requester_vpc_info")
             VpcPeeringConnectionVpcInfo.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             VpcPeeringConnectionStateReason.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module NetworkAcl =
  struct
    type t =
      {
      associations: NetworkAclAssociationList.t ;
      entries: NetworkAclEntryList.t ;
      is_default: Boolean.t option ;
      network_acl_id: String.t option ;
      tags: TagList.t ;
      vpc_id: String.t option ;
      owner_id: String.t option }
    let make ?(associations= [])  ?(entries= [])  ?is_default 
      ?network_acl_id  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        entries;
        is_default;
        network_acl_id;
        tags;
        vpc_id;
        owner_id
      }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  NetworkAclAssociationList.parse));
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "entrySet" xml)
                  NetworkAclEntryList.parse));
          is_default =
            (Util.option_bind (Xml.member "default" xml) Boolean.parse);
          network_acl_id =
            (Util.option_bind (Xml.member "networkAclId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.network_acl_id
             (fun f -> Query.Pair ("NetworkAclId", (String.to_query f)));
           Util.option_map v.is_default
             (fun f -> Query.Pair ("Default", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("EntrySet", (NetworkAclEntryList.to_query v.entries)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (NetworkAclAssociationList.to_query v.associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.network_acl_id
             (fun f -> ("network_acl_id", (String.to_json f)));
           Util.option_map v.is_default
             (fun f -> ("is_default", (Boolean.to_json f)));
           Some ("entries", (NetworkAclEntryList.to_json v.entries));
           Some
             ("associations",
               (NetworkAclAssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (NetworkAclAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        entries =
          (NetworkAclEntryList.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        is_default =
          (Util.option_map (Json.lookup j "is_default") Boolean.of_json);
        network_acl_id =
          (Util.option_map (Json.lookup j "network_acl_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociation =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_association_id:
        String.t option ;
      local_gateway_virtual_interface_group_id: String.t option ;
      local_gateway_id: String.t option ;
      local_gateway_route_table_id: String.t option ;
      local_gateway_route_table_arn: String.t option ;
      owner_id: String.t option ;
      state: String.t option ;
      tags: TagList.t }
    let make
      ?local_gateway_route_table_virtual_interface_group_association_id 
      ?local_gateway_virtual_interface_group_id  ?local_gateway_id 
      ?local_gateway_route_table_id  ?local_gateway_route_table_arn 
      ?owner_id  ?state  ?(tags= [])  () =
      {
        local_gateway_route_table_virtual_interface_group_association_id;
        local_gateway_virtual_interface_group_id;
        local_gateway_id;
        local_gateway_route_table_id;
        local_gateway_route_table_arn;
        owner_id;
        state;
        tags
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_association_id =
            (Util.option_bind
               (Xml.member
                  "localGatewayRouteTableVirtualInterfaceGroupAssociationId"
                  xml) String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_route_table_arn =
            (Util.option_bind (Xml.member "localGatewayRouteTableArn" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableArn", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
                    (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f -> ("local_gateway_route_table_arn", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map
             v.local_gateway_route_table_virtual_interface_group_association_id
             (fun f ->
                ("local_gateway_route_table_virtual_interface_group_association_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_association_id =
          (Util.option_map
             (Json.lookup j
                "local_gateway_route_table_virtual_interface_group_association_id")
             String.of_json);
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_route_table_arn =
          (Util.option_map (Json.lookup j "local_gateway_route_table_arn")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CancelSpotFleetRequestsErrorItem =
  struct
    type t =
      {
      error: CancelSpotFleetRequestsError.t option ;
      spot_fleet_request_id: String.t option }
    let make ?error  ?spot_fleet_request_id  () =
      { error; spot_fleet_request_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               CancelSpotFleetRequestsError.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (CancelSpotFleetRequestsError.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.error
             (fun f -> ("error", (CancelSpotFleetRequestsError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             CancelSpotFleetRequestsError.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module CancelSpotFleetRequestsSuccessItem =
  struct
    type t =
      {
      current_spot_fleet_request_state: BatchState.t option ;
      previous_spot_fleet_request_state: BatchState.t option ;
      spot_fleet_request_id: String.t option }
    let make ?current_spot_fleet_request_state 
      ?previous_spot_fleet_request_state  ?spot_fleet_request_id  () =
      {
        current_spot_fleet_request_state;
        previous_spot_fleet_request_state;
        spot_fleet_request_id
      }
    let parse xml =
      Some
        {
          current_spot_fleet_request_state =
            (Util.option_bind (Xml.member "currentSpotFleetRequestState" xml)
               BatchState.parse);
          previous_spot_fleet_request_state =
            (Util.option_bind
               (Xml.member "previousSpotFleetRequestState" xml)
               BatchState.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("PreviousSpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                Query.Pair
                  ("CurrentSpotFleetRequestState", (BatchState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.previous_spot_fleet_request_state
             (fun f ->
                ("previous_spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.current_spot_fleet_request_state
             (fun f ->
                ("current_spot_fleet_request_state", (BatchState.to_json f)))])
    let of_json j =
      {
        current_spot_fleet_request_state =
          (Util.option_map (Json.lookup j "current_spot_fleet_request_state")
             BatchState.of_json);
        previous_spot_fleet_request_state =
          (Util.option_map
             (Json.lookup j "previous_spot_fleet_request_state")
             BatchState.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module AccountAttribute =
  struct
    type t =
      {
      attribute_name: String.t option ;
      attribute_values: AccountAttributeValueList.t }
    let make ?attribute_name  ?(attribute_values= [])  () =
      { attribute_name; attribute_values }
    let parse xml =
      Some
        {
          attribute_name =
            (Util.option_bind (Xml.member "attributeName" xml) String.parse);
          attribute_values =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeValueSet" xml)
                  AccountAttributeValueList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttributeValueSet",
                   (AccountAttributeValueList.to_query v.attribute_values)));
           Util.option_map v.attribute_name
             (fun f -> Query.Pair ("AttributeName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attribute_values",
                (AccountAttributeValueList.to_json v.attribute_values));
           Util.option_map v.attribute_name
             (fun f -> ("attribute_name", (String.to_json f)))])
    let of_json j =
      {
        attribute_name =
          (Util.option_map (Json.lookup j "attribute_name") String.of_json);
        attribute_values =
          (AccountAttributeValueList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_values")))
      }
  end
module DiskImage =
  struct
    type t =
      {
      description: String.t option ;
      image: DiskImageDetail.t option ;
      volume: VolumeDetail.t option }
    let make ?description  ?image  ?volume  () =
      { description; image; volume }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          image =
            (Util.option_bind (Xml.member "Image" xml) DiskImageDetail.parse);
          volume =
            (Util.option_bind (Xml.member "Volume" xml) VolumeDetail.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> Query.Pair ("Volume", (VolumeDetail.to_query f)));
           Util.option_map v.image
             (fun f -> Query.Pair ("Image", (DiskImageDetail.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume
              (fun f -> ("volume", (VolumeDetail.to_json f)));
           Util.option_map v.image
             (fun f -> ("image", (DiskImageDetail.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        image =
          (Util.option_map (Json.lookup j "image") DiskImageDetail.of_json);
        volume =
          (Util.option_map (Json.lookup j "volume") VolumeDetail.of_json)
      }
  end
module SecurityGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SecurityGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserData =
  struct
    type t = {
      data: String.t option }
    let make ?data  () = { data }
    let parse xml =
      Some { data = (Util.option_bind (Xml.member "data" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data
              (fun f -> Query.Pair ("Data", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data (fun f -> ("data", (String.to_json f)))])
    let of_json j =
      { data = (Util.option_map (Json.lookup j "data") String.of_json) }
  end
module VpcEndpoint =
  struct
    type t =
      {
      vpc_endpoint_id: String.t option ;
      vpc_endpoint_type: VpcEndpointType.t option ;
      vpc_id: String.t option ;
      service_name: String.t option ;
      state: State.t option ;
      policy_document: String.t option ;
      route_table_ids: ValueStringList.t ;
      subnet_ids: ValueStringList.t ;
      groups: GroupIdentifierSet.t ;
      private_dns_enabled: Boolean.t option ;
      requester_managed: Boolean.t option ;
      network_interface_ids: ValueStringList.t ;
      dns_entries: DnsEntrySet.t ;
      creation_timestamp: DateTime.t option ;
      tags: TagList.t ;
      owner_id: String.t option ;
      last_error: LastError.t option }
    let make ?vpc_endpoint_id  ?vpc_endpoint_type  ?vpc_id  ?service_name 
      ?state  ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(groups= [])  ?private_dns_enabled  ?requester_managed 
      ?(network_interface_ids= [])  ?(dns_entries= [])  ?creation_timestamp 
      ?(tags= [])  ?owner_id  ?last_error  () =
      {
        vpc_endpoint_id;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        state;
        policy_document;
        route_table_ids;
        subnet_ids;
        groups;
        private_dns_enabled;
        requester_managed;
        network_interface_ids;
        dns_entries;
        creation_timestamp;
        tags;
        owner_id;
        last_error
      }
    let parse xml =
      Some
        {
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "vpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) State.parse);
          policy_document =
            (Util.option_bind (Xml.member "policyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableIdSet" xml)
                  ValueStringList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIdSet" xml)
                  ValueStringList.parse));
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierSet.parse));
          private_dns_enabled =
            (Util.option_bind (Xml.member "privateDnsEnabled" xml)
               Boolean.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceIdSet" xml)
                  ValueStringList.parse));
          dns_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsEntrySet" xml)
                  DnsEntrySet.parse));
          creation_timestamp =
            (Util.option_bind (Xml.member "creationTimestamp" xml)
               DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          last_error =
            (Util.option_bind (Xml.member "lastError" xml) LastError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.last_error
              (fun f -> Query.Pair ("LastError", (LastError.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_timestamp
             (fun f ->
                Query.Pair ("CreationTimestamp", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("DnsEntrySet", (DnsEntrySet.to_query v.dns_entries)));
           Some
             (Query.Pair
                ("NetworkInterfaceIdSet",
                  (ValueStringList.to_query v.network_interface_ids)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.private_dns_enabled
             (fun f -> Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair ("GroupSet", (GroupIdentifierSet.to_query v.groups)));
           Some
             (Query.Pair
                ("SubnetIdSet", (ValueStringList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableIdSet",
                  (ValueStringList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (State.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.last_error
              (fun f -> ("last_error", (LastError.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_timestamp
             (fun f -> ("creation_timestamp", (DateTime.to_json f)));
           Some ("dns_entries", (DnsEntrySet.to_json v.dns_entries));
           Some
             ("network_interface_ids",
               (ValueStringList.to_json v.network_interface_ids));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.private_dns_enabled
             (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Some ("groups", (GroupIdentifierSet.to_json v.groups));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Some
             ("route_table_ids", (ValueStringList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.state (fun f -> ("state", (State.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        vpc_endpoint_type =
          (Util.option_map (Json.lookup j "vpc_endpoint_type")
             VpcEndpointType.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        state = (Util.option_map (Json.lookup j "state") State.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        groups =
          (GroupIdentifierSet.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json);
        requester_managed =
          (Util.option_map (Json.lookup j "requester_managed")
             Boolean.of_json);
        network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dns_entries =
          (DnsEntrySet.of_json
             (Util.of_option_exn (Json.lookup j "dns_entries")));
        creation_timestamp =
          (Util.option_map (Json.lookup j "creation_timestamp")
             DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        last_error =
          (Util.option_map (Json.lookup j "last_error") LastError.of_json)
      }
  end
module ClassicLinkInstance =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      instance_id: String.t option ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ?(groups= [])  ?instance_id  ?(tags= [])  ?vpc_id  () =
      { groups; instance_id; tags; vpc_id }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module Purchase =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      host_id_set: ResponseHostIdSet.t ;
      host_reservation_id: String.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      payment_option: PaymentOption.t option ;
      upfront_price: String.t option }
    let make ?currency_code  ?duration  ?(host_id_set= []) 
      ?host_reservation_id  ?hourly_price  ?instance_family  ?payment_option 
      ?upfront_price  () =
      {
        currency_code;
        duration;
        host_id_set;
        host_reservation_id;
        hourly_price;
        instance_family;
        payment_option;
        upfront_price
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          host_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdSet.parse));
          host_reservation_id =
            (Util.option_bind (Xml.member "hostReservationId" xml)
               String.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.host_reservation_id
             (fun f -> Query.Pair ("HostReservationId", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (ResponseHostIdSet.to_query v.host_id_set)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.host_reservation_id
             (fun f -> ("host_reservation_id", (String.to_json f)));
           Some ("host_id_set", (ResponseHostIdSet.to_json v.host_id_set));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        host_id_set =
          (ResponseHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        host_reservation_id =
          (Util.option_map (Json.lookup j "host_reservation_id")
             String.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json)
      }
  end
module TransitGatewayAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      transit_gateway_id: String.t option ;
      transit_gateway_owner_id: String.t option ;
      resource_owner_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      resource_id: String.t option ;
      state: TransitGatewayAttachmentState.t option ;
      association: TransitGatewayAttachmentAssociation.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?transit_gateway_id 
      ?transit_gateway_owner_id  ?resource_owner_id  ?resource_type 
      ?resource_id  ?state  ?association  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        transit_gateway_owner_id;
        resource_owner_id;
        resource_type;
        resource_id;
        state;
        association;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          transit_gateway_owner_id =
            (Util.option_bind (Xml.member "transitGatewayOwnerId" xml)
               String.parse);
          resource_owner_id =
            (Util.option_bind (Xml.member "resourceOwnerId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAttachmentAssociation.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association",
                    (TransitGatewayAttachmentAssociation.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_owner_id
             (fun f -> Query.Pair ("ResourceOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f ->
                Query.Pair ("TransitGatewayOwnerId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association",
                  (TransitGatewayAttachmentAssociation.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_owner_id
             (fun f -> ("resource_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_owner_id
             (fun f -> ("transit_gateway_owner_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        transit_gateway_owner_id =
          (Util.option_map (Json.lookup j "transit_gateway_owner_id")
             String.of_json);
        resource_owner_id =
          (Util.option_map (Json.lookup j "resource_owner_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAttachmentAssociation.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Snapshot =
  struct
    type t =
      {
      data_encryption_key_id: String.t option ;
      description: String.t ;
      encrypted: Boolean.t ;
      kms_key_id: String.t option ;
      owner_id: String.t ;
      progress: String.t ;
      snapshot_id: String.t ;
      start_time: DateTime.t ;
      state: SnapshotState.t ;
      state_message: String.t option ;
      volume_id: String.t ;
      volume_size: Integer.t ;
      owner_alias: String.t option ;
      tags: TagList.t }
    let make ?data_encryption_key_id  ~description  ~encrypted  ?kms_key_id 
      ~owner_id  ~progress  ~snapshot_id  ~start_time  ~state  ?state_message
       ~volume_id  ~volume_size  ?owner_alias  ?(tags= [])  () =
      {
        data_encryption_key_id;
        description;
        encrypted;
        kms_key_id;
        owner_id;
        progress;
        snapshot_id;
        start_time;
        state;
        state_message;
        volume_id;
        volume_size;
        owner_alias;
        tags
      }
    let parse xml =
      Some
        {
          data_encryption_key_id =
            (Util.option_bind (Xml.member "dataEncryptionKeyId" xml)
               String.parse);
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          encrypted =
            (Xml.required "encrypted"
               (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse));
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          progress =
            (Xml.required "progress"
               (Util.option_bind (Xml.member "progress" xml) String.parse));
          snapshot_id =
            (Xml.required "snapshotId"
               (Util.option_bind (Xml.member "snapshotId" xml) String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse));
          state =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  SnapshotState.parse));
          state_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse));
          volume_size =
            (Xml.required "volumeSize"
               (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse));
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Some (Query.Pair ("VolumeSize", (Integer.to_query v.volume_size)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.state_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Some (Query.Pair ("Status", (SnapshotState.to_query v.state)));
           Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some (Query.Pair ("Progress", (String.to_query v.progress)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Some (Query.Pair ("Encrypted", (Boolean.to_query v.encrypted)));
           Some (Query.Pair ("Description", (String.to_query v.description)));
           Util.option_map v.data_encryption_key_id
             (fun f ->
                Query.Pair ("DataEncryptionKeyId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Some ("volume_size", (Integer.to_json v.volume_size));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.state_message
             (fun f -> ("state_message", (String.to_json f)));
           Some ("state", (SnapshotState.to_json v.state));
           Some ("start_time", (DateTime.to_json v.start_time));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("progress", (String.to_json v.progress));
           Some ("owner_id", (String.to_json v.owner_id));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Some ("encrypted", (Boolean.to_json v.encrypted));
           Some ("description", (String.to_json v.description));
           Util.option_map v.data_encryption_key_id
             (fun f -> ("data_encryption_key_id", (String.to_json f)))])
    let of_json j =
      {
        data_encryption_key_id =
          (Util.option_map (Json.lookup j "data_encryption_key_id")
             String.of_json);
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        encrypted =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "encrypted")));
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        progress =
          (String.of_json (Util.of_option_exn (Json.lookup j "progress")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")));
        state =
          (SnapshotState.of_json (Util.of_option_exn (Json.lookup j "state")));
        state_message =
          (Util.option_map (Json.lookup j "state_message") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        volume_size =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "volume_size")));
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CreateFleetError =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      error_code: String.t option ;
      error_message: String.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?error_code 
      ?error_message  () =
      { launch_template_and_overrides; lifecycle; error_code; error_message }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          error_code =
            (Util.option_bind (Xml.member "errorCode" xml) String.parse);
          error_message =
            (Util.option_bind (Xml.member "errorMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> Query.Pair ("ErrorMessage", (String.to_query f)));
           Util.option_map v.error_code
             (fun f -> Query.Pair ("ErrorCode", (String.to_query f)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error_message
              (fun f -> ("error_message", (String.to_json f)));
           Util.option_map v.error_code
             (fun f -> ("error_code", (String.to_json f)));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        error_code =
          (Util.option_map (Json.lookup j "error_code") String.of_json);
        error_message =
          (Util.option_map (Json.lookup j "error_message") String.of_json)
      }
  end
module CreateFleetInstance =
  struct
    type t =
      {
      launch_template_and_overrides:
        LaunchTemplateAndOverridesResponse.t option ;
      lifecycle: InstanceLifecycle.t option ;
      instance_ids: InstanceIdsSet.t ;
      instance_type: InstanceType.t option ;
      platform: PlatformValues.t option }
    let make ?launch_template_and_overrides  ?lifecycle  ?(instance_ids= []) 
      ?instance_type  ?platform  () =
      {
        launch_template_and_overrides;
        lifecycle;
        instance_ids;
        instance_type;
        platform
      }
    let parse xml =
      Some
        {
          launch_template_and_overrides =
            (Util.option_bind (Xml.member "launchTemplateAndOverrides" xml)
               LaunchTemplateAndOverridesResponse.parse);
          lifecycle =
            (Util.option_bind (Xml.member "lifecycle" xml)
               InstanceLifecycle.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIds" xml)
                  InstanceIdsSet.parse));
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml)
               PlatformValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> Query.Pair ("Platform", (PlatformValues.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Some
             (Query.Pair
                ("InstanceIds", (InstanceIdsSet.to_query v.instance_ids)));
           Util.option_map v.lifecycle
             (fun f ->
                Query.Pair ("Lifecycle", (InstanceLifecycle.to_query f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                Query.Pair
                  ("LaunchTemplateAndOverrides",
                    (LaunchTemplateAndOverridesResponse.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.platform
              (fun f -> ("platform", (PlatformValues.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Some ("instance_ids", (InstanceIdsSet.to_json v.instance_ids));
           Util.option_map v.lifecycle
             (fun f -> ("lifecycle", (InstanceLifecycle.to_json f)));
           Util.option_map v.launch_template_and_overrides
             (fun f ->
                ("launch_template_and_overrides",
                  (LaunchTemplateAndOverridesResponse.to_json f)))])
    let of_json j =
      {
        launch_template_and_overrides =
          (Util.option_map (Json.lookup j "launch_template_and_overrides")
             LaunchTemplateAndOverridesResponse.of_json);
        lifecycle =
          (Util.option_map (Json.lookup j "lifecycle")
             InstanceLifecycle.of_json);
        instance_ids =
          (InstanceIdsSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") PlatformValues.of_json)
      }
  end
module SnapshotInfo =
  struct
    type t =
      {
      description: String.t option ;
      tags: TagList.t ;
      encrypted: Boolean.t option ;
      volume_id: String.t option ;
      state: SnapshotState.t option ;
      volume_size: Integer.t option ;
      start_time: DateTime.t option ;
      progress: String.t option ;
      owner_id: String.t option ;
      snapshot_id: String.t option }
    let make ?description  ?(tags= [])  ?encrypted  ?volume_id  ?state 
      ?volume_size  ?start_time  ?progress  ?owner_id  ?snapshot_id  () =
      {
        description;
        tags;
        encrypted;
        volume_id;
        state;
        volume_size;
        start_time;
        progress;
        owner_id;
        snapshot_id
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) SnapshotState.parse);
          volume_size =
            (Util.option_bind (Xml.member "volumeSize" xml) Integer.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.volume_size
             (fun f -> Query.Pair ("VolumeSize", (Integer.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SnapshotState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.volume_size
             (fun f -> ("volume_size", (Integer.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SnapshotState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") SnapshotState.of_json);
        volume_size =
          (Util.option_map (Json.lookup j "volume_size") Integer.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module TrafficMirrorTarget =
  struct
    type t =
      {
      traffic_mirror_target_id: String.t option ;
      network_interface_id: String.t option ;
      network_load_balancer_arn: String.t option ;
      type_: TrafficMirrorTargetType.t option ;
      description: String.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_target_id  ?network_interface_id 
      ?network_load_balancer_arn  ?type_  ?description  ?owner_id  ?(tags=
      [])  () =
      {
        traffic_mirror_target_id;
        network_interface_id;
        network_load_balancer_arn;
        type_;
        description;
        owner_id;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          network_load_balancer_arn =
            (Util.option_bind (Xml.member "networkLoadBalancerArn" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TrafficMirrorTargetType.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TrafficMirrorTargetType.to_query f)));
           Util.option_map v.network_load_balancer_arn
             (fun f ->
                Query.Pair ("NetworkLoadBalancerArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TrafficMirrorTargetType.to_json f)));
           Util.option_map v.network_load_balancer_arn
             (fun f -> ("network_load_balancer_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_load_balancer_arn =
          (Util.option_map (Json.lookup j "network_load_balancer_arn")
             String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             TrafficMirrorTargetType.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TrafficMirrorFilterRuleField =
  struct
    type t =
      | Destination_port_range 
      | Source_port_range 
      | Protocol 
      | Description 
    let str_to_t =
      [("description", Description);
      ("protocol", Protocol);
      ("source-port-range", Source_port_range);
      ("destination-port-range", Destination_port_range)]
    let t_to_str =
      [(Description, "description");
      (Protocol, "protocol");
      (Source_port_range, "source-port-range");
      (Destination_port_range, "destination-port-range")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeModification =
  struct
    type t =
      {
      volume_id: String.t option ;
      modification_state: VolumeModificationState.t option ;
      status_message: String.t option ;
      target_size: Integer.t option ;
      target_iops: Integer.t option ;
      target_volume_type: VolumeType.t option ;
      original_size: Integer.t option ;
      original_iops: Integer.t option ;
      original_volume_type: VolumeType.t option ;
      progress: Long.t option ;
      start_time: DateTime.t option ;
      end_time: DateTime.t option }
    let make ?volume_id  ?modification_state  ?status_message  ?target_size 
      ?target_iops  ?target_volume_type  ?original_size  ?original_iops 
      ?original_volume_type  ?progress  ?start_time  ?end_time  () =
      {
        volume_id;
        modification_state;
        status_message;
        target_size;
        target_iops;
        target_volume_type;
        original_size;
        original_iops;
        original_volume_type;
        progress;
        start_time;
        end_time
      }
    let parse xml =
      Some
        {
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          modification_state =
            (Util.option_bind (Xml.member "modificationState" xml)
               VolumeModificationState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          target_size =
            (Util.option_bind (Xml.member "targetSize" xml) Integer.parse);
          target_iops =
            (Util.option_bind (Xml.member "targetIops" xml) Integer.parse);
          target_volume_type =
            (Util.option_bind (Xml.member "targetVolumeType" xml)
               VolumeType.parse);
          original_size =
            (Util.option_bind (Xml.member "originalSize" xml) Integer.parse);
          original_iops =
            (Util.option_bind (Xml.member "originalIops" xml) Integer.parse);
          original_volume_type =
            (Util.option_bind (Xml.member "originalVolumeType" xml)
               VolumeType.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) Long.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (Long.to_query f)));
           Util.option_map v.original_volume_type
             (fun f ->
                Query.Pair ("OriginalVolumeType", (VolumeType.to_query f)));
           Util.option_map v.original_iops
             (fun f -> Query.Pair ("OriginalIops", (Integer.to_query f)));
           Util.option_map v.original_size
             (fun f -> Query.Pair ("OriginalSize", (Integer.to_query f)));
           Util.option_map v.target_volume_type
             (fun f ->
                Query.Pair ("TargetVolumeType", (VolumeType.to_query f)));
           Util.option_map v.target_iops
             (fun f -> Query.Pair ("TargetIops", (Integer.to_query f)));
           Util.option_map v.target_size
             (fun f -> Query.Pair ("TargetSize", (Integer.to_query f)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.modification_state
             (fun f ->
                Query.Pair
                  ("ModificationState", (VolumeModificationState.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.end_time
              (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (Long.to_json f)));
           Util.option_map v.original_volume_type
             (fun f -> ("original_volume_type", (VolumeType.to_json f)));
           Util.option_map v.original_iops
             (fun f -> ("original_iops", (Integer.to_json f)));
           Util.option_map v.original_size
             (fun f -> ("original_size", (Integer.to_json f)));
           Util.option_map v.target_volume_type
             (fun f -> ("target_volume_type", (VolumeType.to_json f)));
           Util.option_map v.target_iops
             (fun f -> ("target_iops", (Integer.to_json f)));
           Util.option_map v.target_size
             (fun f -> ("target_size", (Integer.to_json f)));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.modification_state
             (fun f ->
                ("modification_state", (VolumeModificationState.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)))])
    let of_json j =
      {
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        modification_state =
          (Util.option_map (Json.lookup j "modification_state")
             VolumeModificationState.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        target_size =
          (Util.option_map (Json.lookup j "target_size") Integer.of_json);
        target_iops =
          (Util.option_map (Json.lookup j "target_iops") Integer.of_json);
        target_volume_type =
          (Util.option_map (Json.lookup j "target_volume_type")
             VolumeType.of_json);
        original_size =
          (Util.option_map (Json.lookup j "original_size") Integer.of_json);
        original_iops =
          (Util.option_map (Json.lookup j "original_iops") Integer.of_json);
        original_volume_type =
          (Util.option_map (Json.lookup j "original_volume_type")
             VolumeType.of_json);
        progress = (Util.option_map (Json.lookup j "progress") Long.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json)
      }
  end
module NewDhcpConfiguration =
  struct
    type t = {
      key: String.t option ;
      values: ValueStringList.t }
    let make ?key  ?(values= [])  () = { key; values }
    let parse xml =
      Some
        {
          key = (Util.option_bind (Xml.member "key" xml) String.parse);
          values =
            (Util.of_option []
               (Util.option_bind (Xml.member "Value" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Value", (ValueStringList.to_query v.values)));
           Util.option_map v.key
             (fun f -> Query.Pair ("Key", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("values", (ValueStringList.to_json v.values));
           Util.option_map v.key (fun f -> ("key", (String.to_json f)))])
    let of_json j =
      {
        key = (Util.option_map (Json.lookup j "key") String.of_json);
        values =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "values")))
      }
  end
module NetworkInterface =
  struct
    type t =
      {
      association: NetworkInterfaceAssociation.t option ;
      attachment: NetworkInterfaceAttachment.t option ;
      availability_zone: String.t option ;
      description: String.t option ;
      groups: GroupIdentifierList.t ;
      interface_type: NetworkInterfaceType.t option ;
      ipv6_addresses: NetworkInterfaceIpv6AddressesList.t ;
      mac_address: String.t option ;
      network_interface_id: String.t option ;
      outpost_arn: String.t option ;
      owner_id: String.t option ;
      private_dns_name: String.t option ;
      private_ip_address: String.t option ;
      private_ip_addresses: NetworkInterfacePrivateIpAddressList.t ;
      requester_id: String.t option ;
      requester_managed: Boolean.t option ;
      source_dest_check: Boolean.t option ;
      status: NetworkInterfaceStatus.t option ;
      subnet_id: String.t option ;
      tag_set: TagList.t ;
      vpc_id: String.t option }
    let make ?association  ?attachment  ?availability_zone  ?description 
      ?(groups= [])  ?interface_type  ?(ipv6_addresses= [])  ?mac_address 
      ?network_interface_id  ?outpost_arn  ?owner_id  ?private_dns_name 
      ?private_ip_address  ?(private_ip_addresses= [])  ?requester_id 
      ?requester_managed  ?source_dest_check  ?status  ?subnet_id  ?(tag_set=
      [])  ?vpc_id  () =
      {
        association;
        attachment;
        availability_zone;
        description;
        groups;
        interface_type;
        ipv6_addresses;
        mac_address;
        network_interface_id;
        outpost_arn;
        owner_id;
        private_dns_name;
        private_ip_address;
        private_ip_addresses;
        requester_id;
        requester_managed;
        source_dest_check;
        status;
        subnet_id;
        tag_set;
        vpc_id
      }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               NetworkInterfaceAssociation.parse);
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          interface_type =
            (Util.option_bind (Xml.member "interfaceType" xml)
               NetworkInterfaceType.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6AddressesSet" xml)
                  NetworkInterfaceIpv6AddressesList.parse));
          mac_address =
            (Util.option_bind (Xml.member "macAddress" xml) String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddressesSet" xml)
                  NetworkInterfacePrivateIpAddressList.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          requester_managed =
            (Util.option_bind (Xml.member "requesterManaged" xml)
               Boolean.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               Boolean.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               NetworkInterfaceStatus.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          tag_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tag_set)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (NetworkInterfaceStatus.to_query f)));
           Util.option_map v.source_dest_check
             (fun f -> Query.Pair ("SourceDestCheck", (Boolean.to_query f)));
           Util.option_map v.requester_managed
             (fun f -> Query.Pair ("RequesterManaged", (Boolean.to_query f)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddressesSet",
                  (NetworkInterfacePrivateIpAddressList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.mac_address
             (fun f -> Query.Pair ("MacAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6AddressesSet",
                  (NetworkInterfaceIpv6AddressesList.to_query
                     v.ipv6_addresses)));
           Util.option_map v.interface_type
             (fun f ->
                Query.Pair
                  ("InterfaceType", (NetworkInterfaceType.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)));
           Util.option_map v.association
             (fun f ->
                Query.Pair
                  ("Association", (NetworkInterfaceAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tag_set", (TagList.to_json v.tag_set));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (NetworkInterfaceStatus.to_json f)));
           Util.option_map v.source_dest_check
             (fun f -> ("source_dest_check", (Boolean.to_json f)));
           Util.option_map v.requester_managed
             (fun f -> ("requester_managed", (Boolean.to_json f)));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some
             ("private_ip_addresses",
               (NetworkInterfacePrivateIpAddressList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.mac_address
             (fun f -> ("mac_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (NetworkInterfaceIpv6AddressesList.to_json v.ipv6_addresses));
           Util.option_map v.interface_type
             (fun f -> ("interface_type", (NetworkInterfaceType.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)));
           Util.option_map v.association
             (fun f ->
                ("association", (NetworkInterfaceAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             NetworkInterfaceAssociation.of_json);
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        interface_type =
          (Util.option_map (Json.lookup j "interface_type")
             NetworkInterfaceType.of_json);
        ipv6_addresses =
          (NetworkInterfaceIpv6AddressesList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        mac_address =
          (Util.option_map (Json.lookup j "mac_address") String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (NetworkInterfacePrivateIpAddressList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        requester_managed =
          (Util.option_map (Json.lookup j "requester_managed")
             Boolean.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             Boolean.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             NetworkInterfaceStatus.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        tag_set =
          (TagList.of_json (Util.of_option_exn (Json.lookup j "tag_set")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ConnectionNotification =
  struct
    type t =
      {
      connection_notification_id: String.t option ;
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      connection_notification_type: ConnectionNotificationType.t option ;
      connection_notification_arn: String.t option ;
      connection_events: ValueStringList.t ;
      connection_notification_state: ConnectionNotificationState.t option }
    let make ?connection_notification_id  ?service_id  ?vpc_endpoint_id 
      ?connection_notification_type  ?connection_notification_arn 
      ?(connection_events= [])  ?connection_notification_state  () =
      {
        connection_notification_id;
        service_id;
        vpc_endpoint_id;
        connection_notification_type;
        connection_notification_arn;
        connection_events;
        connection_notification_state
      }
    let parse xml =
      Some
        {
          connection_notification_id =
            (Util.option_bind (Xml.member "connectionNotificationId" xml)
               String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "vpcEndpointId" xml) String.parse);
          connection_notification_type =
            (Util.option_bind (Xml.member "connectionNotificationType" xml)
               ConnectionNotificationType.parse);
          connection_notification_arn =
            (Util.option_bind (Xml.member "connectionNotificationArn" xml)
               String.parse);
          connection_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionEvents" xml)
                  ValueStringList.parse));
          connection_notification_state =
            (Util.option_bind (Xml.member "connectionNotificationState" xml)
               ConnectionNotificationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 Query.Pair
                   ("ConnectionNotificationState",
                     (ConnectionNotificationState.to_query f)));
           Some
             (Query.Pair
                ("ConnectionEvents",
                  (ValueStringList.to_query v.connection_events)));
           Util.option_map v.connection_notification_arn
             (fun f ->
                Query.Pair ("ConnectionNotificationArn", (String.to_query f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                Query.Pair
                  ("ConnectionNotificationType",
                    (ConnectionNotificationType.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.connection_notification_id
             (fun f ->
                Query.Pair ("ConnectionNotificationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.connection_notification_state
              (fun f ->
                 ("connection_notification_state",
                   (ConnectionNotificationState.to_json f)));
           Some
             ("connection_events",
               (ValueStringList.to_json v.connection_events));
           Util.option_map v.connection_notification_arn
             (fun f -> ("connection_notification_arn", (String.to_json f)));
           Util.option_map v.connection_notification_type
             (fun f ->
                ("connection_notification_type",
                  (ConnectionNotificationType.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.connection_notification_id
             (fun f -> ("connection_notification_id", (String.to_json f)))])
    let of_json j =
      {
        connection_notification_id =
          (Util.option_map (Json.lookup j "connection_notification_id")
             String.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        connection_notification_type =
          (Util.option_map (Json.lookup j "connection_notification_type")
             ConnectionNotificationType.of_json);
        connection_notification_arn =
          (Util.option_map (Json.lookup j "connection_notification_arn")
             String.of_json);
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")));
        connection_notification_state =
          (Util.option_map (Json.lookup j "connection_notification_state")
             ConnectionNotificationState.of_json)
      }
  end
module ReservedInstances =
  struct
    type t =
      {
      availability_zone: String.t option ;
      duration: Long.t option ;
      end_: DateTime.t option ;
      fixed_price: Float.t option ;
      instance_count: Integer.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_id: String.t option ;
      start: DateTime.t option ;
      state: ReservedInstanceState.t option ;
      usage_price: Float.t option ;
      currency_code: CurrencyCodeValues.t option ;
      instance_tenancy: Tenancy.t option ;
      offering_class: OfferingClassType.t option ;
      offering_type: OfferingTypeValues.t option ;
      recurring_charges: RecurringChargesList.t ;
      scope: Scope.t option ;
      tags: TagList.t }
    let make ?availability_zone  ?duration  ?end_  ?fixed_price 
      ?instance_count  ?instance_type  ?product_description 
      ?reserved_instances_id  ?start  ?state  ?usage_price  ?currency_code 
      ?instance_tenancy  ?offering_class  ?offering_type 
      ?(recurring_charges= [])  ?scope  ?(tags= [])  () =
      {
        availability_zone;
        duration;
        end_;
        fixed_price;
        instance_count;
        instance_type;
        product_description;
        reserved_instances_id;
        start;
        state;
        usage_price;
        currency_code;
        instance_tenancy;
        offering_class;
        offering_type;
        recurring_charges;
        scope;
        tags
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          end_ = (Util.option_bind (Xml.member "end" xml) DateTime.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          start = (Util.option_bind (Xml.member "start" xml) DateTime.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ReservedInstanceState.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.scope
             (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (ReservedInstanceState.to_query f)));
           Util.option_map v.start
             (fun f -> Query.Pair ("Start", (DateTime.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.end_
             (fun f -> Query.Pair ("End", (DateTime.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ReservedInstanceState.to_json f)));
           Util.option_map v.start (fun f -> ("start", (DateTime.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.end_ (fun f -> ("end_", (DateTime.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        end_ = (Util.option_map (Json.lookup j "end_") DateTime.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        start = (Util.option_map (Json.lookup j "start") DateTime.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             ReservedInstanceState.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")));
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayPeeringAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      requester_tgw_info: PeeringTgwInfo.t option ;
      accepter_tgw_info: PeeringTgwInfo.t option ;
      status: PeeringAttachmentStatus.t option ;
      state: TransitGatewayAttachmentState.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?requester_tgw_info 
      ?accepter_tgw_info  ?status  ?state  ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        requester_tgw_info;
        accepter_tgw_info;
        status;
        state;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          requester_tgw_info =
            (Util.option_bind (Xml.member "requesterTgwInfo" xml)
               PeeringTgwInfo.parse);
          accepter_tgw_info =
            (Util.option_bind (Xml.member "accepterTgwInfo" xml)
               PeeringTgwInfo.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               PeeringAttachmentStatus.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (PeeringAttachmentStatus.to_query f)));
           Util.option_map v.accepter_tgw_info
             (fun f ->
                Query.Pair ("AccepterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.requester_tgw_info
             (fun f ->
                Query.Pair ("RequesterTgwInfo", (PeeringTgwInfo.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (PeeringAttachmentStatus.to_json f)));
           Util.option_map v.accepter_tgw_info
             (fun f -> ("accepter_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.requester_tgw_info
             (fun f -> ("requester_tgw_info", (PeeringTgwInfo.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        requester_tgw_info =
          (Util.option_map (Json.lookup j "requester_tgw_info")
             PeeringTgwInfo.of_json);
        accepter_tgw_info =
          (Util.option_map (Json.lookup j "accepter_tgw_info")
             PeeringTgwInfo.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             PeeringAttachmentStatus.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CancelledSpotInstanceRequest =
  struct
    type t =
      {
      spot_instance_request_id: String.t option ;
      state: CancelSpotInstanceRequestState.t option }
    let make ?spot_instance_request_id  ?state  () =
      { spot_instance_request_id; state }
    let parse xml =
      Some
        {
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CancelSpotInstanceRequestState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (CancelSpotInstanceRequestState.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (CancelSpotInstanceRequestState.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CancelSpotInstanceRequestState.of_json)
      }
  end
module ServiceConfiguration =
  struct
    type t =
      {
      service_type: ServiceTypeDetailSet.t ;
      service_id: String.t option ;
      service_name: String.t option ;
      service_state: ServiceState.t option ;
      availability_zones: ValueStringList.t ;
      acceptance_required: Boolean.t option ;
      manages_vpc_endpoints: Boolean.t option ;
      network_load_balancer_arns: ValueStringList.t ;
      gateway_load_balancer_arns: ValueStringList.t ;
      base_endpoint_dns_names: ValueStringList.t ;
      private_dns_name: String.t option ;
      private_dns_name_configuration: PrivateDnsNameConfiguration.t option ;
      tags: TagList.t }
    let make ?(service_type= [])  ?service_id  ?service_name  ?service_state 
      ?(availability_zones= [])  ?acceptance_required  ?manages_vpc_endpoints
       ?(network_load_balancer_arns= [])  ?(gateway_load_balancer_arns= []) 
      ?(base_endpoint_dns_names= [])  ?private_dns_name 
      ?private_dns_name_configuration  ?(tags= [])  () =
      {
        service_type;
        service_id;
        service_name;
        service_state;
        availability_zones;
        acceptance_required;
        manages_vpc_endpoints;
        network_load_balancer_arns;
        gateway_load_balancer_arns;
        base_endpoint_dns_names;
        private_dns_name;
        private_dns_name_configuration;
        tags
      }
    let parse xml =
      Some
        {
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_state =
            (Util.option_bind (Xml.member "serviceState" xml)
               ServiceState.parse);
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkLoadBalancerArnSet" xml)
                  ValueStringList.parse));
          gateway_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "gatewayLoadBalancerArnSet" xml)
                  ValueStringList.parse));
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          private_dns_name_configuration =
            (Util.option_bind (Xml.member "privateDnsNameConfiguration" xml)
               PrivateDnsNameConfiguration.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.private_dns_name_configuration
             (fun f ->
                Query.Pair
                  ("PrivateDnsNameConfiguration",
                    (PrivateDnsNameConfiguration.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Some
             (Query.Pair
                ("GatewayLoadBalancerArnSet",
                  (ValueStringList.to_query v.gateway_load_balancer_arns)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArnSet",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Util.option_map v.service_state
             (fun f -> Query.Pair ("ServiceState", (ServiceState.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.private_dns_name_configuration
             (fun f ->
                ("private_dns_name_configuration",
                  (PrivateDnsNameConfiguration.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Some
             ("gateway_load_balancer_arns",
               (ValueStringList.to_json v.gateway_load_balancer_arns));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Util.option_map v.service_state
             (fun f -> ("service_state", (ServiceState.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type))])
    let of_json j =
      {
        service_type =
          (ServiceTypeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_type")));
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        service_state =
          (Util.option_map (Json.lookup j "service_state")
             ServiceState.of_json);
        availability_zones =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        manages_vpc_endpoints =
          (Util.option_map (Json.lookup j "manages_vpc_endpoints")
             Boolean.of_json);
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")));
        gateway_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "gateway_load_balancer_arns")));
        base_endpoint_dns_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "base_endpoint_dns_names")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        private_dns_name_configuration =
          (Util.option_map (Json.lookup j "private_dns_name_configuration")
             PrivateDnsNameConfiguration.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ConversionTask =
  struct
    type t =
      {
      conversion_task_id: String.t option ;
      expiration_time: String.t option ;
      import_instance: ImportInstanceTaskDetails.t option ;
      import_volume: ImportVolumeTaskDetails.t option ;
      state: ConversionTaskState.t option ;
      status_message: String.t option ;
      tags: TagList.t }
    let make ?conversion_task_id  ?expiration_time  ?import_instance 
      ?import_volume  ?state  ?status_message  ?(tags= [])  () =
      {
        conversion_task_id;
        expiration_time;
        import_instance;
        import_volume;
        state;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          conversion_task_id =
            (Util.option_bind (Xml.member "conversionTaskId" xml)
               String.parse);
          expiration_time =
            (Util.option_bind (Xml.member "expirationTime" xml) String.parse);
          import_instance =
            (Util.option_bind (Xml.member "importInstance" xml)
               ImportInstanceTaskDetails.parse);
          import_volume =
            (Util.option_bind (Xml.member "importVolume" xml)
               ImportVolumeTaskDetails.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               ConversionTaskState.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (ConversionTaskState.to_query f)));
           Util.option_map v.import_volume
             (fun f ->
                Query.Pair
                  ("ImportVolume", (ImportVolumeTaskDetails.to_query f)));
           Util.option_map v.import_instance
             (fun f ->
                Query.Pair
                  ("ImportInstance", (ImportInstanceTaskDetails.to_query f)));
           Util.option_map v.expiration_time
             (fun f -> Query.Pair ("ExpirationTime", (String.to_query f)));
           Util.option_map v.conversion_task_id
             (fun f -> Query.Pair ("ConversionTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (ConversionTaskState.to_json f)));
           Util.option_map v.import_volume
             (fun f -> ("import_volume", (ImportVolumeTaskDetails.to_json f)));
           Util.option_map v.import_instance
             (fun f ->
                ("import_instance", (ImportInstanceTaskDetails.to_json f)));
           Util.option_map v.expiration_time
             (fun f -> ("expiration_time", (String.to_json f)));
           Util.option_map v.conversion_task_id
             (fun f -> ("conversion_task_id", (String.to_json f)))])
    let of_json j =
      {
        conversion_task_id =
          (Util.option_map (Json.lookup j "conversion_task_id")
             String.of_json);
        expiration_time =
          (Util.option_map (Json.lookup j "expiration_time") String.of_json);
        import_instance =
          (Util.option_map (Json.lookup j "import_instance")
             ImportInstanceTaskDetails.of_json);
        import_volume =
          (Util.option_map (Json.lookup j "import_volume")
             ImportVolumeTaskDetails.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             ConversionTaskState.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module TransitGatewayVpcAttachment =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      transit_gateway_id: String.t option ;
      vpc_id: String.t option ;
      vpc_owner_id: String.t option ;
      state: TransitGatewayAttachmentState.t option ;
      subnet_ids: ValueStringList.t ;
      creation_time: DateTime.t option ;
      options: TransitGatewayVpcAttachmentOptions.t option ;
      tags: TagList.t }
    let make ?transit_gateway_attachment_id  ?transit_gateway_id  ?vpc_id 
      ?vpc_owner_id  ?state  ?(subnet_ids= [])  ?creation_time  ?options 
      ?(tags= [])  () =
      {
        transit_gateway_attachment_id;
        transit_gateway_id;
        vpc_id;
        vpc_owner_id;
        state;
        subnet_ids;
        creation_time;
        options;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          vpc_owner_id =
            (Util.option_bind (Xml.member "vpcOwnerId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAttachmentState.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetIds" xml)
                  ValueStringList.parse));
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               TransitGatewayVpcAttachmentOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (TransitGatewayVpcAttachmentOptions.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayAttachmentState.to_query f)));
           Util.option_map v.vpc_owner_id
             (fun f -> Query.Pair ("VpcOwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.options
             (fun f ->
                ("options", (TransitGatewayVpcAttachmentOptions.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayAttachmentState.to_json f)));
           Util.option_map v.vpc_owner_id
             (fun f -> ("vpc_owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        vpc_owner_id =
          (Util.option_map (Json.lookup j "vpc_owner_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAttachmentState.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayVpcAttachmentOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ReservedInstanceReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option ;
      reserved_instance_id: String.t option }
    let make ?reservation_value  ?reserved_instance_id  () =
      { reservation_value; reserved_instance_id }
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          reserved_instance_id =
            (Util.option_bind (Xml.member "reservedInstanceId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f ->
                 Query.Pair ("ReservedInstanceId", (String.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instance_id
              (fun f -> ("reserved_instance_id", (String.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let of_json j =
      {
        reservation_value =
          (Util.option_map (Json.lookup j "reservation_value")
             ReservationValue.of_json);
        reserved_instance_id =
          (Util.option_map (Json.lookup j "reserved_instance_id")
             String.of_json)
      }
  end
module TargetReservationValue =
  struct
    type t =
      {
      reservation_value: ReservationValue.t option ;
      target_configuration: TargetConfiguration.t option }
    let make ?reservation_value  ?target_configuration  () =
      { reservation_value; target_configuration }
    let parse xml =
      Some
        {
          reservation_value =
            (Util.option_bind (Xml.member "reservationValue" xml)
               ReservationValue.parse);
          target_configuration =
            (Util.option_bind (Xml.member "targetConfiguration" xml)
               TargetConfiguration.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 Query.Pair
                   ("TargetConfiguration", (TargetConfiguration.to_query f)));
           Util.option_map v.reservation_value
             (fun f ->
                Query.Pair
                  ("ReservationValue", (ReservationValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_configuration
              (fun f ->
                 ("target_configuration", (TargetConfiguration.to_json f)));
           Util.option_map v.reservation_value
             (fun f -> ("reservation_value", (ReservationValue.to_json f)))])
    let of_json j =
      {
        reservation_value =
          (Util.option_map (Json.lookup j "reservation_value")
             ReservationValue.of_json);
        target_configuration =
          (Util.option_map (Json.lookup j "target_configuration")
             TargetConfiguration.of_json)
      }
  end
module TransitGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      prefix_list_id: String.t option ;
      transit_gateway_attachments: TransitGatewayRouteAttachmentList.t ;
      type_: TransitGatewayRouteType.t option ;
      state: TransitGatewayRouteState.t option }
    let make ?destination_cidr_block  ?prefix_list_id 
      ?(transit_gateway_attachments= [])  ?type_  ?state  () =
      {
        destination_cidr_block;
        prefix_list_id;
        transit_gateway_attachments;
        type_;
        state
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          prefix_list_id =
            (Util.option_bind (Xml.member "prefixListId" xml) String.parse);
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayRouteAttachmentList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               TransitGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (TransitGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (TransitGatewayRouteType.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayRouteAttachmentList.to_query
                     v.transit_gateway_attachments)));
           Util.option_map v.prefix_list_id
             (fun f -> Query.Pair ("PrefixListId", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (TransitGatewayRouteType.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayRouteAttachmentList.to_json
                  v.transit_gateway_attachments));
           Util.option_map v.prefix_list_id
             (fun f -> ("prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        prefix_list_id =
          (Util.option_map (Json.lookup j "prefix_list_id") String.of_json);
        transit_gateway_attachments =
          (TransitGatewayRouteAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachments")));
        type_ =
          (Util.option_map (Json.lookup j "type_")
             TransitGatewayRouteType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayRouteState.of_json)
      }
  end
module HistoryRecord =
  struct
    type t =
      {
      event_information: EventInformation.t option ;
      event_type: EventType.t option ;
      timestamp: DateTime.t option }
    let make ?event_information  ?event_type  ?timestamp  () =
      { event_information; event_type; timestamp }
    let parse xml =
      Some
        {
          event_information =
            (Util.option_bind (Xml.member "eventInformation" xml)
               EventInformation.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Util.option_map v.event_information
             (fun f ->
                Query.Pair
                  ("EventInformation", (EventInformation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Util.option_map v.event_information
             (fun f -> ("event_information", (EventInformation.to_json f)))])
    let of_json j =
      {
        event_information =
          (Util.option_map (Json.lookup j "event_information")
             EventInformation.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") EventType.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module FpgaImage =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      fpga_image_global_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      shell_version: String.t option ;
      pci_id: PciId.t option ;
      state: FpgaImageState.t option ;
      create_time: DateTime.t option ;
      update_time: DateTime.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      product_codes: ProductCodeList.t ;
      tags: TagList.t ;
      public: Boolean.t option ;
      data_retention_support: Boolean.t option }
    let make ?fpga_image_id  ?fpga_image_global_id  ?name  ?description 
      ?shell_version  ?pci_id  ?state  ?create_time  ?update_time  ?owner_id 
      ?owner_alias  ?(product_codes= [])  ?(tags= [])  ?public 
      ?data_retention_support  () =
      {
        fpga_image_id;
        fpga_image_global_id;
        name;
        description;
        shell_version;
        pci_id;
        state;
        create_time;
        update_time;
        owner_id;
        owner_alias;
        product_codes;
        tags;
        public;
        data_retention_support
      }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          shell_version =
            (Util.option_bind (Xml.member "shellVersion" xml) String.parse);
          pci_id = (Util.option_bind (Xml.member "pciId" xml) PciId.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) FpgaImageState.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          update_time =
            (Util.option_bind (Xml.member "updateTime" xml) DateTime.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tags" xml) TagList.parse));
          public = (Util.option_bind (Xml.member "public" xml) Boolean.parse);
          data_retention_support =
            (Util.option_bind (Xml.member "dataRetentionSupport" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f ->
                 Query.Pair ("DataRetentionSupport", (Boolean.to_query f)));
           Util.option_map v.public
             (fun f -> Query.Pair ("Public", (Boolean.to_query f)));
           Some (Query.Pair ("Tags", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.update_time
             (fun f -> Query.Pair ("UpdateTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (FpgaImageState.to_query f)));
           Util.option_map v.pci_id
             (fun f -> Query.Pair ("PciId", (PciId.to_query f)));
           Util.option_map v.shell_version
             (fun f -> Query.Pair ("ShellVersion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.data_retention_support
              (fun f -> ("data_retention_support", (Boolean.to_json f)));
           Util.option_map v.public
             (fun f -> ("public", (Boolean.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.update_time
             (fun f -> ("update_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FpgaImageState.to_json f)));
           Util.option_map v.pci_id (fun f -> ("pci_id", (PciId.to_json f)));
           Util.option_map v.shell_version
             (fun f -> ("shell_version", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_global_id
             (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        fpga_image_global_id =
          (Util.option_map (Json.lookup j "fpga_image_global_id")
             String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        shell_version =
          (Util.option_map (Json.lookup j "shell_version") String.of_json);
        pci_id = (Util.option_map (Json.lookup j "pci_id") PciId.of_json);
        state =
          (Util.option_map (Json.lookup j "state") FpgaImageState.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        update_time =
          (Util.option_map (Json.lookup j "update_time") DateTime.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        public = (Util.option_map (Json.lookup j "public") Boolean.of_json);
        data_retention_support =
          (Util.option_map (Json.lookup j "data_retention_support")
             Boolean.of_json)
      }
  end
module EnableFastSnapshotRestoreErrorItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      fast_snapshot_restore_state_errors:
        EnableFastSnapshotRestoreStateErrorSet.t }
    let make ?snapshot_id  ?(fast_snapshot_restore_state_errors= [])  () =
      { snapshot_id; fast_snapshot_restore_state_errors }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          fast_snapshot_restore_state_errors =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "fastSnapshotRestoreStateErrorSet" xml)
                  EnableFastSnapshotRestoreStateErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FastSnapshotRestoreStateErrorSet",
                   (EnableFastSnapshotRestoreStateErrorSet.to_query
                      v.fast_snapshot_restore_state_errors)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("fast_snapshot_restore_state_errors",
                (EnableFastSnapshotRestoreStateErrorSet.to_json
                   v.fast_snapshot_restore_state_errors));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        fast_snapshot_restore_state_errors =
          (EnableFastSnapshotRestoreStateErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "fast_snapshot_restore_state_errors")))
      }
  end
module EnableFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module RouteTable =
  struct
    type t =
      {
      associations: RouteTableAssociationList.t ;
      propagating_vgws: PropagatingVgwList.t ;
      route_table_id: String.t option ;
      routes: RouteList.t ;
      tags: TagList.t ;
      vpc_id: String.t option ;
      owner_id: String.t option }
    let make ?(associations= [])  ?(propagating_vgws= [])  ?route_table_id 
      ?(routes= [])  ?(tags= [])  ?vpc_id  ?owner_id  () =
      {
        associations;
        propagating_vgws;
        route_table_id;
        routes;
        tags;
        vpc_id;
        owner_id
      }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associationSet" xml)
                  RouteTableAssociationList.parse));
          propagating_vgws =
            (Util.of_option []
               (Util.option_bind (Xml.member "propagatingVgwSet" xml)
                  PropagatingVgwList.parse));
          route_table_id =
            (Util.option_bind (Xml.member "routeTableId" xml) String.parse);
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml) RouteList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("RouteSet", (RouteList.to_query v.routes)));
           Util.option_map v.route_table_id
             (fun f -> Query.Pair ("RouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("PropagatingVgwSet",
                  (PropagatingVgwList.to_query v.propagating_vgws)));
           Some
             (Query.Pair
                ("AssociationSet",
                  (RouteTableAssociationList.to_query v.associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some ("routes", (RouteList.to_json v.routes));
           Util.option_map v.route_table_id
             (fun f -> ("route_table_id", (String.to_json f)));
           Some
             ("propagating_vgws",
               (PropagatingVgwList.to_json v.propagating_vgws));
           Some
             ("associations",
               (RouteTableAssociationList.to_json v.associations))])
    let of_json j =
      {
        associations =
          (RouteTableAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        propagating_vgws =
          (PropagatingVgwList.of_json
             (Util.of_option_exn (Json.lookup j "propagating_vgws")));
        route_table_id =
          (Util.option_map (Json.lookup j "route_table_id") String.of_json);
        routes =
          (RouteList.of_json (Util.of_option_exn (Json.lookup j "routes")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module IamInstanceProfileAssociation =
  struct
    type t =
      {
      association_id: String.t option ;
      instance_id: String.t option ;
      iam_instance_profile: IamInstanceProfile.t option ;
      state: IamInstanceProfileAssociationState.t option ;
      timestamp: DateTime.t option }
    let make ?association_id  ?instance_id  ?iam_instance_profile  ?state 
      ?timestamp  () =
      { association_id; instance_id; iam_instance_profile; state; timestamp }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfile.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               IamInstanceProfileAssociationState.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (IamInstanceProfileAssociationState.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile", (IamInstanceProfile.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.state
             (fun f ->
                ("state", (IamInstanceProfileAssociationState.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile", (IamInstanceProfile.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfile.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             IamInstanceProfileAssociationState.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module LaunchTemplateVersion =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option ;
      version_description: String.t option ;
      create_time: DateTime.t option ;
      created_by: String.t option ;
      default_version: Boolean.t option ;
      launch_template_data: ResponseLaunchTemplateData.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?version_description  ?create_time  ?created_by  ?default_version 
      ?launch_template_data  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        version_description;
        create_time;
        created_by;
        default_version;
        launch_template_data
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          version_description =
            (Util.option_bind (Xml.member "versionDescription" xml)
               String.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          created_by =
            (Util.option_bind (Xml.member "createdBy" xml) String.parse);
          default_version =
            (Util.option_bind (Xml.member "defaultVersion" xml) Boolean.parse);
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)));
           Util.option_map v.default_version
             (fun f -> Query.Pair ("DefaultVersion", (Boolean.to_query f)));
           Util.option_map v.created_by
             (fun f -> Query.Pair ("CreatedBy", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)));
           Util.option_map v.default_version
             (fun f -> ("default_version", (Boolean.to_json f)));
           Util.option_map v.created_by
             (fun f -> ("created_by", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json);
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        created_by =
          (Util.option_map (Json.lookup j "created_by") String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") Boolean.of_json);
        launch_template_data =
          (Util.option_map (Json.lookup j "launch_template_data")
             ResponseLaunchTemplateData.of_json)
      }
  end
module CarrierGateway =
  struct
    type t =
      {
      carrier_gateway_id: String.t option ;
      vpc_id: String.t option ;
      state: CarrierGatewayState.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?carrier_gateway_id  ?vpc_id  ?state  ?owner_id  ?(tags= [])  ()
      = { carrier_gateway_id; vpc_id; state; owner_id; tags }
    let parse xml =
      Some
        {
          carrier_gateway_id =
            (Util.option_bind (Xml.member "carrierGatewayId" xml)
               String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CarrierGatewayState.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (CarrierGatewayState.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> Query.Pair ("CarrierGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (CarrierGatewayState.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> ("carrier_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        carrier_gateway_id =
          (Util.option_map (Json.lookup j "carrier_gateway_id")
             String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CarrierGatewayState.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module CapacityReservationGroup =
  struct
    type t = {
      group_arn: String.t option ;
      owner_id: String.t option }
    let make ?group_arn  ?owner_id  () = { group_arn; owner_id }
    let parse xml =
      Some
        {
          group_arn =
            (Util.option_bind (Xml.member "groupArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.group_arn
             (fun f -> Query.Pair ("GroupArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.group_arn
             (fun f -> ("group_arn", (String.to_json f)))])
    let of_json j =
      {
        group_arn =
          (Util.option_map (Json.lookup j "group_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module TransitGatewayMulticastGroup =
  struct
    type t =
      {
      group_ip_address: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      network_interface_id: String.t option ;
      group_member: Boolean.t option ;
      group_source: Boolean.t option ;
      member_type: MembershipType.t option ;
      source_type: MembershipType.t option }
    let make ?group_ip_address  ?transit_gateway_attachment_id  ?subnet_id 
      ?resource_id  ?resource_type  ?network_interface_id  ?group_member 
      ?group_source  ?member_type  ?source_type  () =
      {
        group_ip_address;
        transit_gateway_attachment_id;
        subnet_id;
        resource_id;
        resource_type;
        network_interface_id;
        group_member;
        group_source;
        member_type;
        source_type
      }
    let parse xml =
      Some
        {
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          group_member =
            (Util.option_bind (Xml.member "groupMember" xml) Boolean.parse);
          group_source =
            (Util.option_bind (Xml.member "groupSource" xml) Boolean.parse);
          member_type =
            (Util.option_bind (Xml.member "memberType" xml)
               MembershipType.parse);
          source_type =
            (Util.option_bind (Xml.member "sourceType" xml)
               MembershipType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f ->
                 Query.Pair ("SourceType", (MembershipType.to_query f)));
           Util.option_map v.member_type
             (fun f -> Query.Pair ("MemberType", (MembershipType.to_query f)));
           Util.option_map v.group_source
             (fun f -> Query.Pair ("GroupSource", (Boolean.to_query f)));
           Util.option_map v.group_member
             (fun f -> Query.Pair ("GroupMember", (Boolean.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_type
              (fun f -> ("source_type", (MembershipType.to_json f)));
           Util.option_map v.member_type
             (fun f -> ("member_type", (MembershipType.to_json f)));
           Util.option_map v.group_source
             (fun f -> ("group_source", (Boolean.to_json f)));
           Util.option_map v.group_member
             (fun f -> ("group_member", (Boolean.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)))])
    let of_json j =
      {
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        group_member =
          (Util.option_map (Json.lookup j "group_member") Boolean.of_json);
        group_source =
          (Util.option_map (Json.lookup j "group_source") Boolean.of_json);
        member_type =
          (Util.option_map (Json.lookup j "member_type")
             MembershipType.of_json);
        source_type =
          (Util.option_map (Json.lookup j "source_type")
             MembershipType.of_json)
      }
  end
module LocalGatewayVirtualInterface =
  struct
    type t =
      {
      local_gateway_virtual_interface_id: String.t option ;
      local_gateway_id: String.t option ;
      vlan: Integer.t option ;
      local_address: String.t option ;
      peer_address: String.t option ;
      local_bgp_asn: Integer.t option ;
      peer_bgp_asn: Integer.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?local_gateway_virtual_interface_id  ?local_gateway_id  ?vlan 
      ?local_address  ?peer_address  ?local_bgp_asn  ?peer_bgp_asn  ?owner_id
       ?(tags= [])  () =
      {
        local_gateway_virtual_interface_id;
        local_gateway_id;
        vlan;
        local_address;
        peer_address;
        local_bgp_asn;
        peer_bgp_asn;
        owner_id;
        tags
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceId" xml) String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          vlan = (Util.option_bind (Xml.member "vlan" xml) Integer.parse);
          local_address =
            (Util.option_bind (Xml.member "localAddress" xml) String.parse);
          peer_address =
            (Util.option_bind (Xml.member "peerAddress" xml) String.parse);
          local_bgp_asn =
            (Util.option_bind (Xml.member "localBgpAsn" xml) Integer.parse);
          peer_bgp_asn =
            (Util.option_bind (Xml.member "peerBgpAsn" xml) Integer.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.peer_bgp_asn
             (fun f -> Query.Pair ("PeerBgpAsn", (Integer.to_query f)));
           Util.option_map v.local_bgp_asn
             (fun f -> Query.Pair ("LocalBgpAsn", (Integer.to_query f)));
           Util.option_map v.peer_address
             (fun f -> Query.Pair ("PeerAddress", (String.to_query f)));
           Util.option_map v.local_address
             (fun f -> Query.Pair ("LocalAddress", (String.to_query f)));
           Util.option_map v.vlan
             (fun f -> Query.Pair ("Vlan", (Integer.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.peer_bgp_asn
             (fun f -> ("peer_bgp_asn", (Integer.to_json f)));
           Util.option_map v.local_bgp_asn
             (fun f -> ("local_bgp_asn", (Integer.to_json f)));
           Util.option_map v.peer_address
             (fun f -> ("peer_address", (String.to_json f)));
           Util.option_map v.local_address
             (fun f -> ("local_address", (String.to_json f)));
           Util.option_map v.vlan (fun f -> ("vlan", (Integer.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_id
             (fun f ->
                ("local_gateway_virtual_interface_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_virtual_interface_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        vlan = (Util.option_map (Json.lookup j "vlan") Integer.of_json);
        local_address =
          (Util.option_map (Json.lookup j "local_address") String.of_json);
        peer_address =
          (Util.option_map (Json.lookup j "peer_address") String.of_json);
        local_bgp_asn =
          (Util.option_map (Json.lookup j "local_bgp_asn") Integer.of_json);
        peer_bgp_asn =
          (Util.option_map (Json.lookup j "peer_bgp_asn") Integer.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ElasticInferenceAccelerator =
  struct
    type t = {
      type_: String.t ;
      count: Integer.t option }
    let make ~type_  ?count  () = { type_; count }
    let parse xml =
      Some
        {
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          count = (Util.option_bind (Xml.member "Count" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.count
              (fun f -> Query.Pair ("Count", (Integer.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.count (fun f -> ("count", (Integer.to_json f)));
           Some ("type_", (String.to_json v.type_))])
    let of_json j =
      {
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        count = (Util.option_map (Json.lookup j "count") Integer.of_json)
      }
  end
module SpotMarketOptions =
  struct
    type t =
      {
      max_price: String.t option ;
      spot_instance_type: SpotInstanceType.t option ;
      block_duration_minutes: Integer.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?max_price  ?spot_instance_type  ?block_duration_minutes 
      ?valid_until  ?instance_interruption_behavior  () =
      {
        max_price;
        spot_instance_type;
        block_duration_minutes;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          max_price =
            (Util.option_bind (Xml.member "MaxPrice" xml) String.parse);
          spot_instance_type =
            (Util.option_bind (Xml.member "SpotInstanceType" xml)
               SpotInstanceType.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "BlockDurationMinutes" xml)
               Integer.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.spot_instance_type
             (fun f ->
                Query.Pair
                  ("SpotInstanceType", (SpotInstanceType.to_query f)));
           Util.option_map v.max_price
             (fun f -> Query.Pair ("MaxPrice", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.spot_instance_type
             (fun f -> ("spot_instance_type", (SpotInstanceType.to_json f)));
           Util.option_map v.max_price
             (fun f -> ("max_price", (String.to_json f)))])
    let of_json j =
      {
        max_price =
          (Util.option_map (Json.lookup j "max_price") String.of_json);
        spot_instance_type =
          (Util.option_map (Json.lookup j "spot_instance_type")
             SpotInstanceType.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module LicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LocalGatewayVirtualInterfaceGroup =
  struct
    type t =
      {
      local_gateway_virtual_interface_group_id: String.t option ;
      local_gateway_virtual_interface_ids:
        LocalGatewayVirtualInterfaceIdSet.t ;
      local_gateway_id: String.t option ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?local_gateway_virtual_interface_group_id 
      ?(local_gateway_virtual_interface_ids= [])  ?local_gateway_id 
      ?owner_id  ?(tags= [])  () =
      {
        local_gateway_virtual_interface_group_id;
        local_gateway_virtual_interface_ids;
        local_gateway_id;
        owner_id;
        tags
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          local_gateway_virtual_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceIdSet" xml)
                  LocalGatewayVirtualInterfaceIdSet.parse));
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceIdSet",
                  (LocalGatewayVirtualInterfaceIdSet.to_query
                     v.local_gateway_virtual_interface_ids)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_ids",
               (LocalGatewayVirtualInterfaceIdSet.to_json
                  v.local_gateway_virtual_interface_ids));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)))])
    let of_json j =
      {
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        local_gateway_virtual_interface_ids =
          (LocalGatewayVirtualInterfaceIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_ids")));
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module MovingAddressStatus =
  struct
    type t = {
      move_status: MoveStatus.t option ;
      public_ip: String.t option }
    let make ?move_status  ?public_ip  () = { move_status; public_ip }
    let parse xml =
      Some
        {
          move_status =
            (Util.option_bind (Xml.member "moveStatus" xml) MoveStatus.parse);
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.move_status
             (fun f -> Query.Pair ("MoveStatus", (MoveStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.public_ip
              (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.move_status
             (fun f -> ("move_status", (MoveStatus.to_json f)))])
    let of_json j =
      {
        move_status =
          (Util.option_map (Json.lookup j "move_status") MoveStatus.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json)
      }
  end
module CreditSpecificationRequest =
  struct
    type t = {
      cpu_credits: String.t }
    let make ~cpu_credits  () = { cpu_credits }
    let parse xml =
      Some
        {
          cpu_credits =
            (Xml.required "CpuCredits"
               (Util.option_bind (Xml.member "CpuCredits" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CpuCredits", (String.to_query v.cpu_credits)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cpu_credits", (String.to_json v.cpu_credits))])
    let of_json j =
      {
        cpu_credits =
          (String.of_json (Util.of_option_exn (Json.lookup j "cpu_credits")))
      }
  end
module ElasticGpuSpecificationList =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse
           (Xml.members "ElasticGpuSpecification" xml))
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecification.of_json j
  end
module LaunchTemplateBlockDeviceMappingRequestList =
  struct
    type t = LaunchTemplateBlockDeviceMappingRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateBlockDeviceMappingRequest.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateBlockDeviceMappingRequest.to_query v
    let to_json v =
      `List (List.map LaunchTemplateBlockDeviceMappingRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateBlockDeviceMappingRequest.of_json j
  end
module LaunchTemplateCapacityReservationSpecificationRequest =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTarget.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTarget.of_json)
      }
  end
module LaunchTemplateCpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module LaunchTemplateElasticInferenceAcceleratorList =
  struct
    type t = LaunchTemplateElasticInferenceAccelerator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateElasticInferenceAccelerator.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateElasticInferenceAccelerator.to_query
        v
    let to_json v =
      `List (List.map LaunchTemplateElasticInferenceAccelerator.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateElasticInferenceAccelerator.of_json j
  end
module LaunchTemplateEnclaveOptionsRequest =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module LaunchTemplateHibernationOptionsRequest =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module LaunchTemplateIamInstanceProfileSpecificationRequest =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module LaunchTemplateInstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: LaunchTemplateSpotMarketOptionsRequest.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               LaunchTemplateSpotMarketOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair
                   ("SpotOptions",
                     (LaunchTemplateSpotMarketOptionsRequest.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 ("spot_options",
                   (LaunchTemplateSpotMarketOptionsRequest.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             LaunchTemplateSpotMarketOptionsRequest.of_json)
      }
  end
module LaunchTemplateInstanceMetadataOptionsRequest =
  struct
    type t =
      {
      http_tokens: LaunchTemplateHttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: LaunchTemplateInstanceMetadataEndpointState.t option }
    let make ?http_tokens  ?http_put_response_hop_limit  ?http_endpoint  () =
      { http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               LaunchTemplateHttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               LaunchTemplateInstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (LaunchTemplateInstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair
                  ("HttpTokens", (LaunchTemplateHttpTokensState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint",
                   (LaunchTemplateInstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f ->
                ("http_tokens", (LaunchTemplateHttpTokensState.to_json f)))])
    let of_json j =
      {
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             LaunchTemplateHttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             LaunchTemplateInstanceMetadataEndpointState.of_json)
      }
  end
module LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList =
  struct
    type t =
      LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.parse
           (Xml.members "InstanceNetworkInterfaceSpecification" xml))
    let to_query v =
      Query.to_query_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_query v
    let to_json v =
      `List
        (List.map
           LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.to_json
           v)
    let of_json j =
      Json.to_list
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequest.of_json j
  end
module LaunchTemplateLicenseSpecificationListRequest =
  struct
    type t = LaunchTemplateLicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateLicenseConfigurationRequest.to_query
        v
    let to_json v =
      `List (List.map LaunchTemplateLicenseConfigurationRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateLicenseConfigurationRequest.of_json j
  end
module LaunchTemplatePlacementRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      affinity: String.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      tenancy: Tenancy.t option ;
      spread_domain: String.t option ;
      host_resource_group_arn: String.t option ;
      partition_number: Integer.t option }
    let make ?availability_zone  ?affinity  ?group_name  ?host_id  ?tenancy 
      ?spread_domain  ?host_resource_group_arn  ?partition_number  () =
      {
        availability_zone;
        affinity;
        group_name;
        host_id;
        tenancy;
        spread_domain;
        host_resource_group_arn;
        partition_number
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          affinity =
            (Util.option_bind (Xml.member "Affinity" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "HostId" xml) String.parse);
          tenancy =
            (Util.option_bind (Xml.member "Tenancy" xml) Tenancy.parse);
          spread_domain =
            (Util.option_bind (Xml.member "SpreadDomain" xml) String.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "HostResourceGroupArn" xml)
               String.parse);
          partition_number =
            (Util.option_bind (Xml.member "PartitionNumber" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.partition_number
              (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.host_resource_group_arn
             (fun f ->
                Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.spread_domain
             (fun f -> Query.Pair ("SpreadDomain", (String.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (Tenancy.to_query f)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.partition_number
              (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.host_resource_group_arn
             (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.spread_domain
             (fun f -> ("spread_domain", (String.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (Tenancy.to_json f)));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        affinity =
          (Util.option_map (Json.lookup j "affinity") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        tenancy = (Util.option_map (Json.lookup j "tenancy") Tenancy.of_json);
        spread_domain =
          (Util.option_map (Json.lookup j "spread_domain") String.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json)
      }
  end
module LaunchTemplateTagSpecificationRequestList =
  struct
    type t = LaunchTemplateTagSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateTagSpecificationRequest.parse
           (Xml.members "LaunchTemplateTagSpecificationRequest" xml))
    let to_query v =
      Query.to_query_list LaunchTemplateTagSpecificationRequest.to_query v
    let to_json v =
      `List (List.map LaunchTemplateTagSpecificationRequest.to_json v)
    let of_json j =
      Json.to_list LaunchTemplateTagSpecificationRequest.of_json j
  end
module LaunchTemplatesMonitoringRequest =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module TrafficMirrorSession =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t option ;
      traffic_mirror_target_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      network_interface_id: String.t option ;
      owner_id: String.t option ;
      packet_length: Integer.t option ;
      session_number: Integer.t option ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      tags: TagList.t }
    let make ?traffic_mirror_session_id  ?traffic_mirror_target_id 
      ?traffic_mirror_filter_id  ?network_interface_id  ?owner_id 
      ?packet_length  ?session_number  ?virtual_network_id  ?description 
      ?(tags= [])  () =
      {
        traffic_mirror_session_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        network_interface_id;
        owner_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        tags
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse);
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          packet_length =
            (Util.option_bind (Xml.member "packetLength" xml) Integer.parse);
          session_number =
            (Util.option_bind (Xml.member "sessionNumber" xml) Integer.parse);
          virtual_network_id =
            (Util.option_bind (Xml.member "virtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Util.option_map v.session_number
             (fun f -> Query.Pair ("SessionNumber", (Integer.to_query f)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f ->
                Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Util.option_map v.session_number
             (fun f -> ("session_number", (Integer.to_json f)));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_session_id
             (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (Util.option_map (Json.lookup j "traffic_mirror_session_id")
             String.of_json);
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Util.option_map (Json.lookup j "session_number") Integer.of_json);
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Ipv6Pool =
  struct
    type t =
      {
      pool_id: String.t option ;
      description: String.t option ;
      pool_cidr_blocks: PoolCidrBlocksSet.t ;
      tags: TagList.t }
    let make ?pool_id  ?description  ?(pool_cidr_blocks= [])  ?(tags= [])  ()
      = { pool_id; description; pool_cidr_blocks; tags }
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          pool_cidr_blocks =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolCidrBlockSet" xml)
                  PoolCidrBlocksSet.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("PoolCidrBlockSet",
                  (PoolCidrBlocksSet.to_query v.pool_cidr_blocks)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("pool_cidr_blocks",
               (PoolCidrBlocksSet.to_json v.pool_cidr_blocks));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let of_json j =
      {
        pool_id = (Util.option_map (Json.lookup j "pool_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        pool_cidr_blocks =
          (PoolCidrBlocksSet.of_json
             (Util.of_option_exn (Json.lookup j "pool_cidr_blocks")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DeleteLaunchTemplateVersionsResponseErrorItem =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option ;
      response_error: ResponseError.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number 
      ?response_error  () =
      {
        launch_template_id;
        launch_template_name;
        version_number;
        response_error
      }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse);
          response_error =
            (Util.option_bind (Xml.member "responseError" xml)
               ResponseError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f ->
                 Query.Pair ("ResponseError", (ResponseError.to_query f)));
           Util.option_map v.version_number
             (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.response_error
              (fun f -> ("response_error", (ResponseError.to_json f)));
           Util.option_map v.version_number
             (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json);
        response_error =
          (Util.option_map (Json.lookup j "response_error")
             ResponseError.of_json)
      }
  end
module DeleteLaunchTemplateVersionsResponseSuccessItem =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version_number: Long.t option }
    let make ?launch_template_id  ?launch_template_name  ?version_number  ()
      = { launch_template_id; launch_template_name; version_number }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "launchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "launchTemplateName" xml)
               String.parse);
          version_number =
            (Util.option_bind (Xml.member "versionNumber" xml) Long.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> Query.Pair ("VersionNumber", (Long.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version_number
              (fun f -> ("version_number", (Long.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version_number =
          (Util.option_map (Json.lookup j "version_number") Long.of_json)
      }
  end
module SpotInstanceRequest =
  struct
    type t =
      {
      actual_block_hourly_price: String.t option ;
      availability_zone_group: String.t option ;
      block_duration_minutes: Integer.t option ;
      create_time: DateTime.t option ;
      fault: SpotInstanceStateFault.t option ;
      instance_id: String.t option ;
      launch_group: String.t option ;
      launch_specification: LaunchSpecification.t option ;
      launched_availability_zone: String.t option ;
      product_description: RIProductDescription.t option ;
      spot_instance_request_id: String.t option ;
      spot_price: String.t option ;
      state: SpotInstanceState.t option ;
      status: SpotInstanceStatus.t option ;
      tags: TagList.t ;
      type_: SpotInstanceType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?actual_block_hourly_price  ?availability_zone_group 
      ?block_duration_minutes  ?create_time  ?fault  ?instance_id 
      ?launch_group  ?launch_specification  ?launched_availability_zone 
      ?product_description  ?spot_instance_request_id  ?spot_price  ?state 
      ?status  ?(tags= [])  ?type_  ?valid_from  ?valid_until 
      ?instance_interruption_behavior  () =
      {
        actual_block_hourly_price;
        availability_zone_group;
        block_duration_minutes;
        create_time;
        fault;
        instance_id;
        launch_group;
        launch_specification;
        launched_availability_zone;
        product_description;
        spot_instance_request_id;
        spot_price;
        state;
        status;
        tags;
        type_;
        valid_from;
        valid_until;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          actual_block_hourly_price =
            (Util.option_bind (Xml.member "actualBlockHourlyPrice" xml)
               String.parse);
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               LaunchSpecification.parse);
          launched_availability_zone =
            (Util.option_bind (Xml.member "launchedAvailabilityZone" xml)
               String.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_instance_request_id =
            (Util.option_bind (Xml.member "spotInstanceRequestId" xml)
               String.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               SpotInstanceState.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               SpotInstanceStatus.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "instanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (SpotInstanceStatus.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (SpotInstanceState.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.spot_instance_request_id
             (fun f ->
                Query.Pair ("SpotInstanceRequestId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.launched_availability_zone
             (fun f ->
                Query.Pair ("LaunchedAvailabilityZone", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification", (LaunchSpecification.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)));
           Util.option_map v.actual_block_hourly_price
             (fun f ->
                Query.Pair ("ActualBlockHourlyPrice", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status
             (fun f -> ("status", (SpotInstanceStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (SpotInstanceState.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.spot_instance_request_id
             (fun f -> ("spot_instance_request_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.launched_availability_zone
             (fun f -> ("launched_availability_zone", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification", (LaunchSpecification.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)));
           Util.option_map v.actual_block_hourly_price
             (fun f -> ("actual_block_hourly_price", (String.to_json f)))])
    let of_json j =
      {
        actual_block_hourly_price =
          (Util.option_map (Json.lookup j "actual_block_hourly_price")
             String.of_json);
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             LaunchSpecification.of_json);
        launched_availability_zone =
          (Util.option_map (Json.lookup j "launched_availability_zone")
             String.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        spot_instance_request_id =
          (Util.option_map (Json.lookup j "spot_instance_request_id")
             String.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state") SpotInstanceState.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             SpotInstanceStatus.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module FailedQueuedPurchaseDeletion =
  struct
    type t =
      {
      error: DeleteQueuedReservedInstancesError.t option ;
      reserved_instances_id: String.t option }
    let make ?error  ?reserved_instances_id  () =
      { error; reserved_instances_id }
    let parse xml =
      Some
        {
          error =
            (Util.option_bind (Xml.member "error" xml)
               DeleteQueuedReservedInstancesError.parse);
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Util.option_map v.error
             (fun f ->
                Query.Pair
                  ("Error", (DeleteQueuedReservedInstancesError.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)));
           Util.option_map v.error
             (fun f ->
                ("error", (DeleteQueuedReservedInstancesError.to_json f)))])
    let of_json j =
      {
        error =
          (Util.option_map (Json.lookup j "error")
             DeleteQueuedReservedInstancesError.of_json);
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module SuccessfulQueuedPurchaseDeletion =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module ExportTask =
  struct
    type t =
      {
      description: String.t ;
      export_task_id: String.t ;
      export_to_s3_task: ExportToS3Task.t ;
      instance_export_details: InstanceExportDetails.t ;
      state: ExportTaskState.t ;
      status_message: String.t ;
      tags: TagList.t }
    let make ~description  ~export_task_id  ~export_to_s3_task 
      ~instance_export_details  ~state  ~status_message  ?(tags= [])  () =
      {
        description;
        export_task_id;
        export_to_s3_task;
        instance_export_details;
        state;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          description =
            (Xml.required "description"
               (Util.option_bind (Xml.member "description" xml) String.parse));
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse));
          export_to_s3_task =
            (Xml.required "exportToS3"
               (Util.option_bind (Xml.member "exportToS3" xml)
                  ExportToS3Task.parse));
          instance_export_details =
            (Xml.required "instanceExport"
               (Util.option_bind (Xml.member "instanceExport" xml)
                  InstanceExportDetails.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml)
                  ExportTaskState.parse));
          status_message =
            (Xml.required "statusMessage"
               (Util.option_bind (Xml.member "statusMessage" xml)
                  String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("StatusMessage", (String.to_query v.status_message)));
           Some (Query.Pair ("State", (ExportTaskState.to_query v.state)));
           Some
             (Query.Pair
                ("InstanceExport",
                  (InstanceExportDetails.to_query v.instance_export_details)));
           Some
             (Query.Pair
                ("ExportToS3", (ExportToS3Task.to_query v.export_to_s3_task)));
           Some
             (Query.Pair ("ExportTaskId", (String.to_query v.export_task_id)));
           Some (Query.Pair ("Description", (String.to_query v.description)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("status_message", (String.to_json v.status_message));
           Some ("state", (ExportTaskState.to_json v.state));
           Some
             ("instance_export_details",
               (InstanceExportDetails.to_json v.instance_export_details));
           Some
             ("export_to_s3_task",
               (ExportToS3Task.to_json v.export_to_s3_task));
           Some ("export_task_id", (String.to_json v.export_task_id));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")));
        export_to_s3_task =
          (ExportToS3Task.of_json
             (Util.of_option_exn (Json.lookup j "export_to_s3_task")));
        instance_export_details =
          (InstanceExportDetails.of_json
             (Util.of_option_exn (Json.lookup j "instance_export_details")));
        state =
          (ExportTaskState.of_json
             (Util.of_option_exn (Json.lookup j "state")));
        status_message =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "status_message")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceMonitoring =
  struct
    type t = {
      instance_id: String.t option ;
      monitoring: Monitoring.t option }
    let make ?instance_id  ?monitoring  () = { instance_id; monitoring }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Monitoring.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> Query.Pair ("Monitoring", (Monitoring.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.monitoring
              (fun f -> ("monitoring", (Monitoring.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Monitoring.of_json)
      }
  end
module SecurityGroup =
  struct
    type t =
      {
      description: String.t ;
      group_name: String.t ;
      ip_permissions: IpPermissionList.t ;
      owner_id: String.t ;
      group_id: String.t ;
      ip_permissions_egress: IpPermissionList.t ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ~description  ~group_name  ?(ip_permissions= [])  ~owner_id 
      ~group_id  ?(ip_permissions_egress= [])  ?(tags= [])  ?vpc_id  () =
      {
        description;
        group_name;
        ip_permissions;
        owner_id;
        group_id;
        ip_permissions_egress;
        tags;
        vpc_id
      }
    let parse xml =
      Some
        {
          description =
            (Xml.required "groupDescription"
               (Util.option_bind (Xml.member "groupDescription" xml)
                  String.parse));
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions_egress =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissionsEgress" xml)
                  IpPermissionList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("IpPermissionsEgress",
                  (IpPermissionList.to_query v.ip_permissions_egress)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ip_permissions_egress",
               (IpPermissionList.to_json v.ip_permissions_egress));
           Some ("group_id", (String.to_json v.group_id));
           Some ("owner_id", (String.to_json v.owner_id));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_name", (String.to_json v.group_name));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions_egress =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions_egress")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ServiceDetail =
  struct
    type t =
      {
      service_name: String.t option ;
      service_id: String.t option ;
      service_type: ServiceTypeDetailSet.t ;
      availability_zones: ValueStringList.t ;
      owner: String.t option ;
      base_endpoint_dns_names: ValueStringList.t ;
      private_dns_name: String.t option ;
      vpc_endpoint_policy_supported: Boolean.t option ;
      acceptance_required: Boolean.t option ;
      manages_vpc_endpoints: Boolean.t option ;
      tags: TagList.t ;
      private_dns_name_verification_state: DnsNameState.t option }
    let make ?service_name  ?service_id  ?(service_type= []) 
      ?(availability_zones= [])  ?owner  ?(base_endpoint_dns_names= []) 
      ?private_dns_name  ?vpc_endpoint_policy_supported  ?acceptance_required
       ?manages_vpc_endpoints  ?(tags= []) 
      ?private_dns_name_verification_state  () =
      {
        service_name;
        service_id;
        service_type;
        availability_zones;
        owner;
        base_endpoint_dns_names;
        private_dns_name;
        vpc_endpoint_policy_supported;
        acceptance_required;
        manages_vpc_endpoints;
        tags;
        private_dns_name_verification_state
      }
    let parse xml =
      Some
        {
          service_name =
            (Util.option_bind (Xml.member "serviceName" xml) String.parse);
          service_id =
            (Util.option_bind (Xml.member "serviceId" xml) String.parse);
          service_type =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceType" xml)
                  ServiceTypeDetailSet.parse));
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneSet" xml)
                  ValueStringList.parse));
          owner = (Util.option_bind (Xml.member "owner" xml) String.parse);
          base_endpoint_dns_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "baseEndpointDnsNameSet" xml)
                  ValueStringList.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "privateDnsName" xml) String.parse);
          vpc_endpoint_policy_supported =
            (Util.option_bind (Xml.member "vpcEndpointPolicySupported" xml)
               Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "acceptanceRequired" xml)
               Boolean.parse);
          manages_vpc_endpoints =
            (Util.option_bind (Xml.member "managesVpcEndpoints" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          private_dns_name_verification_state =
            (Util.option_bind
               (Xml.member "privateDnsNameVerificationState" xml)
               DnsNameState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_dns_name_verification_state
              (fun f ->
                 Query.Pair
                   ("PrivateDnsNameVerificationState",
                     (DnsNameState.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.manages_vpc_endpoints
             (fun f ->
                Query.Pair ("ManagesVpcEndpoints", (Boolean.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f ->
                Query.Pair
                  ("VpcEndpointPolicySupported", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some
             (Query.Pair
                ("BaseEndpointDnsNameSet",
                  (ValueStringList.to_query v.base_endpoint_dns_names)));
           Util.option_map v.owner
             (fun f -> Query.Pair ("Owner", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZoneSet",
                  (ValueStringList.to_query v.availability_zones)));
           Some
             (Query.Pair
                ("ServiceType",
                  (ServiceTypeDetailSet.to_query v.service_type)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.service_name
             (fun f -> Query.Pair ("ServiceName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_dns_name_verification_state
              (fun f ->
                 ("private_dns_name_verification_state",
                   (DnsNameState.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.manages_vpc_endpoints
             (fun f -> ("manages_vpc_endpoints", (Boolean.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.vpc_endpoint_policy_supported
             (fun f -> ("vpc_endpoint_policy_supported", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some
             ("base_endpoint_dns_names",
               (ValueStringList.to_json v.base_endpoint_dns_names));
           Util.option_map v.owner (fun f -> ("owner", (String.to_json f)));
           Some
             ("availability_zones",
               (ValueStringList.to_json v.availability_zones));
           Some
             ("service_type", (ServiceTypeDetailSet.to_json v.service_type));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.service_name
             (fun f -> ("service_name", (String.to_json f)))])
    let of_json j =
      {
        service_name =
          (Util.option_map (Json.lookup j "service_name") String.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        service_type =
          (ServiceTypeDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_type")));
        availability_zones =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        owner = (Util.option_map (Json.lookup j "owner") String.of_json);
        base_endpoint_dns_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "base_endpoint_dns_names")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        vpc_endpoint_policy_supported =
          (Util.option_map (Json.lookup j "vpc_endpoint_policy_supported")
             Boolean.of_json);
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        manages_vpc_endpoints =
          (Util.option_map (Json.lookup j "manages_vpc_endpoints")
             Boolean.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        private_dns_name_verification_state =
          (Util.option_map
             (Json.lookup j "private_dns_name_verification_state")
             DnsNameState.of_json)
      }
  end
module ClientVpnEndpoint =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      description: String.t option ;
      status: ClientVpnEndpointStatus.t option ;
      creation_time: String.t option ;
      deletion_time: String.t option ;
      dns_name: String.t option ;
      client_cidr_block: String.t option ;
      dns_servers: ValueStringList.t ;
      split_tunnel: Boolean.t option ;
      vpn_protocol: VpnProtocol.t option ;
      transport_protocol: TransportProtocol.t option ;
      vpn_port: Integer.t option ;
      associated_target_networks: AssociatedTargetNetworkSet.t ;
      server_certificate_arn: String.t option ;
      authentication_options: ClientVpnAuthenticationList.t ;
      connection_log_options: ConnectionLogResponseOptions.t option ;
      tags: TagList.t ;
      security_group_ids: ClientVpnSecurityGroupIdSet.t ;
      vpc_id: String.t option ;
      self_service_portal_url: String.t option ;
      client_connect_options: ClientConnectResponseOptions.t option }
    let make ?client_vpn_endpoint_id  ?description  ?status  ?creation_time 
      ?deletion_time  ?dns_name  ?client_cidr_block  ?(dns_servers= []) 
      ?split_tunnel  ?vpn_protocol  ?transport_protocol  ?vpn_port 
      ?(associated_target_networks= [])  ?server_certificate_arn 
      ?(authentication_options= [])  ?connection_log_options  ?(tags= []) 
      ?(security_group_ids= [])  ?vpc_id  ?self_service_portal_url 
      ?client_connect_options  () =
      {
        client_vpn_endpoint_id;
        description;
        status;
        creation_time;
        deletion_time;
        dns_name;
        client_cidr_block;
        dns_servers;
        split_tunnel;
        vpn_protocol;
        transport_protocol;
        vpn_port;
        associated_target_networks;
        server_certificate_arn;
        authentication_options;
        connection_log_options;
        tags;
        security_group_ids;
        vpc_id;
        self_service_portal_url;
        client_connect_options
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) String.parse);
          deletion_time =
            (Util.option_bind (Xml.member "deletionTime" xml) String.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse);
          client_cidr_block =
            (Util.option_bind (Xml.member "clientCidrBlock" xml) String.parse);
          dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "dnsServer" xml)
                  ValueStringList.parse));
          split_tunnel =
            (Util.option_bind (Xml.member "splitTunnel" xml) Boolean.parse);
          vpn_protocol =
            (Util.option_bind (Xml.member "vpnProtocol" xml)
               VpnProtocol.parse);
          transport_protocol =
            (Util.option_bind (Xml.member "transportProtocol" xml)
               TransportProtocol.parse);
          vpn_port =
            (Util.option_bind (Xml.member "vpnPort" xml) Integer.parse);
          associated_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "associatedTargetNetwork" xml)
                  AssociatedTargetNetworkSet.parse));
          server_certificate_arn =
            (Util.option_bind (Xml.member "serverCertificateArn" xml)
               String.parse);
          authentication_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "authenticationOptions" xml)
                  ClientVpnAuthenticationList.parse));
          connection_log_options =
            (Util.option_bind (Xml.member "connectionLogOptions" xml)
               ConnectionLogResponseOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIdSet" xml)
                  ClientVpnSecurityGroupIdSet.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          self_service_portal_url =
            (Util.option_bind (Xml.member "selfServicePortalUrl" xml)
               String.parse);
          client_connect_options =
            (Util.option_bind (Xml.member "clientConnectOptions" xml)
               ClientConnectResponseOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 Query.Pair
                   ("ClientConnectOptions",
                     (ClientConnectResponseOptions.to_query f)));
           Util.option_map v.self_service_portal_url
             (fun f ->
                Query.Pair ("SelfServicePortalUrl", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupIdSet",
                  (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.connection_log_options
             (fun f ->
                Query.Pair
                  ("ConnectionLogOptions",
                    (ConnectionLogResponseOptions.to_query f)));
           Some
             (Query.Pair
                ("AuthenticationOptions",
                  (ClientVpnAuthenticationList.to_query
                     v.authentication_options)));
           Util.option_map v.server_certificate_arn
             (fun f ->
                Query.Pair ("ServerCertificateArn", (String.to_query f)));
           Some
             (Query.Pair
                ("AssociatedTargetNetwork",
                  (AssociatedTargetNetworkSet.to_query
                     v.associated_target_networks)));
           Util.option_map v.vpn_port
             (fun f -> Query.Pair ("VpnPort", (Integer.to_query f)));
           Util.option_map v.transport_protocol
             (fun f ->
                Query.Pair
                  ("TransportProtocol", (TransportProtocol.to_query f)));
           Util.option_map v.vpn_protocol
             (fun f -> Query.Pair ("VpnProtocol", (VpnProtocol.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DnsServer", (ValueStringList.to_query v.dns_servers)));
           Util.option_map v.client_cidr_block
             (fun f -> Query.Pair ("ClientCidrBlock", (String.to_query f)));
           Util.option_map v.dns_name
             (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.deletion_time
             (fun f -> Query.Pair ("DeletionTime", (String.to_query f)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 ("client_connect_options",
                   (ClientConnectResponseOptions.to_json f)));
           Util.option_map v.self_service_portal_url
             (fun f -> ("self_service_portal_url", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.connection_log_options
             (fun f ->
                ("connection_log_options",
                  (ConnectionLogResponseOptions.to_json f)));
           Some
             ("authentication_options",
               (ClientVpnAuthenticationList.to_json v.authentication_options));
           Util.option_map v.server_certificate_arn
             (fun f -> ("server_certificate_arn", (String.to_json f)));
           Some
             ("associated_target_networks",
               (AssociatedTargetNetworkSet.to_json
                  v.associated_target_networks));
           Util.option_map v.vpn_port
             (fun f -> ("vpn_port", (Integer.to_json f)));
           Util.option_map v.transport_protocol
             (fun f -> ("transport_protocol", (TransportProtocol.to_json f)));
           Util.option_map v.vpn_protocol
             (fun f -> ("vpn_protocol", (VpnProtocol.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Some ("dns_servers", (ValueStringList.to_json v.dns_servers));
           Util.option_map v.client_cidr_block
             (fun f -> ("client_cidr_block", (String.to_json f)));
           Util.option_map v.dns_name
             (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.deletion_time
             (fun f -> ("deletion_time", (String.to_json f)));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") String.of_json);
        deletion_time =
          (Util.option_map (Json.lookup j "deletion_time") String.of_json);
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json);
        client_cidr_block =
          (Util.option_map (Json.lookup j "client_cidr_block") String.of_json);
        dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "dns_servers")));
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        vpn_protocol =
          (Util.option_map (Json.lookup j "vpn_protocol") VpnProtocol.of_json);
        transport_protocol =
          (Util.option_map (Json.lookup j "transport_protocol")
             TransportProtocol.of_json);
        vpn_port =
          (Util.option_map (Json.lookup j "vpn_port") Integer.of_json);
        associated_target_networks =
          (AssociatedTargetNetworkSet.of_json
             (Util.of_option_exn (Json.lookup j "associated_target_networks")));
        server_certificate_arn =
          (Util.option_map (Json.lookup j "server_certificate_arn")
             String.of_json);
        authentication_options =
          (ClientVpnAuthenticationList.of_json
             (Util.of_option_exn (Json.lookup j "authentication_options")));
        connection_log_options =
          (Util.option_map (Json.lookup j "connection_log_options")
             ConnectionLogResponseOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        self_service_portal_url =
          (Util.option_map (Json.lookup j "self_service_portal_url")
             String.of_json);
        client_connect_options =
          (Util.option_map (Json.lookup j "client_connect_options")
             ClientConnectResponseOptions.of_json)
      }
  end
module FleetLaunchTemplateConfigRequest =
  struct
    type t =
      {
      launch_template_specification:
        FleetLaunchTemplateSpecificationRequest.t option ;
      overrides: FleetLaunchTemplateOverridesListRequest.t }
    let make ?launch_template_specification  ?(overrides= [])  () =
      { launch_template_specification; overrides }
    let parse xml =
      Some
        {
          launch_template_specification =
            (Util.option_bind (Xml.member "LaunchTemplateSpecification" xml)
               FleetLaunchTemplateSpecificationRequest.parse);
          overrides =
            (Util.of_option []
               (Util.option_bind (Xml.member "Overrides" xml)
                  FleetLaunchTemplateOverridesListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Overrides",
                   (FleetLaunchTemplateOverridesListRequest.to_query
                      v.overrides)));
           Util.option_map v.launch_template_specification
             (fun f ->
                Query.Pair
                  ("LaunchTemplateSpecification",
                    (FleetLaunchTemplateSpecificationRequest.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("overrides",
                (FleetLaunchTemplateOverridesListRequest.to_json v.overrides));
           Util.option_map v.launch_template_specification
             (fun f ->
                ("launch_template_specification",
                  (FleetLaunchTemplateSpecificationRequest.to_json f)))])
    let of_json j =
      {
        launch_template_specification =
          (Util.option_map (Json.lookup j "launch_template_specification")
             FleetLaunchTemplateSpecificationRequest.of_json);
        overrides =
          (FleetLaunchTemplateOverridesListRequest.of_json
             (Util.of_option_exn (Json.lookup j "overrides")))
      }
  end
module CapacityReservationOptionsRequest =
  struct
    type t =
      {
      usage_strategy: FleetCapacityReservationUsageStrategy.t option }
    let make ?usage_strategy  () = { usage_strategy }
    let parse xml =
      Some
        {
          usage_strategy =
            (Util.option_bind (Xml.member "UsageStrategy" xml)
               FleetCapacityReservationUsageStrategy.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 Query.Pair
                   ("UsageStrategy",
                     (FleetCapacityReservationUsageStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.usage_strategy
              (fun f ->
                 ("usage_strategy",
                   (FleetCapacityReservationUsageStrategy.to_json f)))])
    let of_json j =
      {
        usage_strategy =
          (Util.option_map (Json.lookup j "usage_strategy")
             FleetCapacityReservationUsageStrategy.of_json)
      }
  end
module FleetSpotMaintenanceStrategiesRequest =
  struct
    type t =
      {
      capacity_rebalance: FleetSpotCapacityRebalanceRequest.t option }
    let make ?capacity_rebalance  () = { capacity_rebalance }
    let parse xml =
      Some
        {
          capacity_rebalance =
            (Util.option_bind (Xml.member "CapacityRebalance" xml)
               FleetSpotCapacityRebalanceRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 Query.Pair
                   ("CapacityRebalance",
                     (FleetSpotCapacityRebalanceRequest.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_rebalance
              (fun f ->
                 ("capacity_rebalance",
                   (FleetSpotCapacityRebalanceRequest.to_json f)))])
    let of_json j =
      {
        capacity_rebalance =
          (Util.option_map (Json.lookup j "capacity_rebalance")
             FleetSpotCapacityRebalanceRequest.of_json)
      }
  end
module InternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t ;
      internet_gateway_id: String.t ;
      owner_id: String.t option ;
      tags: TagList.t }
    let make ?(attachments= [])  ~internet_gateway_id  ?owner_id  ?(tags= [])
       () = { attachments; internet_gateway_id; owner_id; tags }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (InternetGatewayAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AccountAttributeName =
  struct
    type t =
      | Supported_platforms 
      | Default_vpc 
    let str_to_t =
      [("default-vpc", Default_vpc);
      ("supported-platforms", Supported_platforms)]
    let t_to_str =
      [(Default_vpc, "default-vpc");
      (Supported_platforms, "supported-platforms")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FleetData =
  struct
    type t =
      {
      activity_status: FleetActivityStatus.t option ;
      create_time: DateTime.t option ;
      fleet_id: String.t option ;
      fleet_state: FleetStateCode.t option ;
      client_token: String.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      fulfilled_capacity: Double.t option ;
      fulfilled_on_demand_capacity: Double.t option ;
      launch_template_configs: FleetLaunchTemplateConfigList.t ;
      target_capacity_specification: TargetCapacitySpecification.t option ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      spot_options: SpotOptions.t option ;
      on_demand_options: OnDemandOptions.t option ;
      tags: TagList.t ;
      errors: DescribeFleetsErrorSet.t ;
      instances: DescribeFleetsInstancesSet.t }
    let make ?activity_status  ?create_time  ?fleet_id  ?fleet_state 
      ?client_token  ?excess_capacity_termination_policy  ?fulfilled_capacity
       ?fulfilled_on_demand_capacity  ?(launch_template_configs= []) 
      ?target_capacity_specification  ?terminate_instances_with_expiration 
      ?type_  ?valid_from  ?valid_until  ?replace_unhealthy_instances 
      ?spot_options  ?on_demand_options  ?(tags= [])  ?(errors= []) 
      ?(instances= [])  () =
      {
        activity_status;
        create_time;
        fleet_id;
        fleet_state;
        client_token;
        excess_capacity_termination_policy;
        fulfilled_capacity;
        fulfilled_on_demand_capacity;
        launch_template_configs;
        target_capacity_specification;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        spot_options;
        on_demand_options;
        tags;
        errors;
        instances
      }
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               FleetActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          fleet_state =
            (Util.option_bind (Xml.member "fleetState" xml)
               FleetStateCode.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          fulfilled_capacity =
            (Util.option_bind (Xml.member "fulfilledCapacity" xml)
               Double.parse);
          fulfilled_on_demand_capacity =
            (Util.option_bind (Xml.member "fulfilledOnDemandCapacity" xml)
               Double.parse);
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateConfigs" xml)
                  FleetLaunchTemplateConfigList.parse));
          target_capacity_specification =
            (Util.option_bind (Xml.member "targetCapacitySpecification" xml)
               TargetCapacitySpecification.parse);
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "terminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "replaceUnhealthyInstances" xml)
               Boolean.parse);
          spot_options =
            (Util.option_bind (Xml.member "spotOptions" xml)
               SpotOptions.parse);
          on_demand_options =
            (Util.option_bind (Xml.member "onDemandOptions" xml)
               OnDemandOptions.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  DescribeFleetsErrorSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  DescribeFleetsInstancesSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (DescribeFleetsInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (DescribeFleetsErrorSet.to_query v.errors)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.on_demand_options
             (fun f ->
                Query.Pair ("OnDemandOptions", (OnDemandOptions.to_query f)));
           Util.option_map v.spot_options
             (fun f -> Query.Pair ("SpotOptions", (SpotOptions.to_query f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                Query.Pair
                  ("TargetCapacitySpecification",
                    (TargetCapacitySpecification.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (FleetLaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f ->
                Query.Pair ("FulfilledOnDemandCapacity", (Double.to_query f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> Query.Pair ("FulfilledCapacity", (Double.to_query f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.fleet_state
             (fun f -> Query.Pair ("FleetState", (FleetStateCode.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair
                  ("ActivityStatus", (FleetActivityStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instances", (DescribeFleetsInstancesSet.to_json v.instances));
           Some ("errors", (DescribeFleetsErrorSet.to_json v.errors));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.on_demand_options
             (fun f -> ("on_demand_options", (OnDemandOptions.to_json f)));
           Util.option_map v.spot_options
             (fun f -> ("spot_options", (SpotOptions.to_json f)));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Util.option_map v.target_capacity_specification
             (fun f ->
                ("target_capacity_specification",
                  (TargetCapacitySpecification.to_json f)));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigList.to_json
                  v.launch_template_configs));
           Util.option_map v.fulfilled_on_demand_capacity
             (fun f -> ("fulfilled_on_demand_capacity", (Double.to_json f)));
           Util.option_map v.fulfilled_capacity
             (fun f -> ("fulfilled_capacity", (Double.to_json f)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.fleet_state
             (fun f -> ("fleet_state", (FleetStateCode.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (FleetActivityStatus.to_json f)))])
    let of_json j =
      {
        activity_status =
          (Util.option_map (Json.lookup j "activity_status")
             FleetActivityStatus.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        fleet_state =
          (Util.option_map (Json.lookup j "fleet_state")
             FleetStateCode.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        fulfilled_capacity =
          (Util.option_map (Json.lookup j "fulfilled_capacity")
             Double.of_json);
        fulfilled_on_demand_capacity =
          (Util.option_map (Json.lookup j "fulfilled_on_demand_capacity")
             Double.of_json);
        launch_template_configs =
          (FleetLaunchTemplateConfigList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        target_capacity_specification =
          (Util.option_map (Json.lookup j "target_capacity_specification")
             TargetCapacitySpecification.of_json);
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options") SpotOptions.of_json);
        on_demand_options =
          (Util.option_map (Json.lookup j "on_demand_options")
             OnDemandOptions.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        errors =
          (DescribeFleetsErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "errors")));
        instances =
          (DescribeFleetsInstancesSet.of_json
             (Util.of_option_exn (Json.lookup j "instances")))
      }
  end
module SpotFleetRequestConfig =
  struct
    type t =
      {
      activity_status: ActivityStatus.t option ;
      create_time: DateTime.t option ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t option ;
      spot_fleet_request_id: String.t option ;
      spot_fleet_request_state: BatchState.t option ;
      tags: TagList.t }
    let make ?activity_status  ?create_time  ?spot_fleet_request_config 
      ?spot_fleet_request_id  ?spot_fleet_request_state  ?(tags= [])  () =
      {
        activity_status;
        create_time;
        spot_fleet_request_config;
        spot_fleet_request_id;
        spot_fleet_request_state;
        tags
      }
    let parse xml =
      Some
        {
          activity_status =
            (Util.option_bind (Xml.member "activityStatus" xml)
               ActivityStatus.parse);
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          spot_fleet_request_config =
            (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
               SpotFleetRequestConfigData.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          spot_fleet_request_state =
            (Util.option_bind (Xml.member "spotFleetRequestState" xml)
               BatchState.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.spot_fleet_request_state
             (fun f ->
                Query.Pair ("SpotFleetRequestState", (BatchState.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                Query.Pair
                  ("SpotFleetRequestConfig",
                    (SpotFleetRequestConfigData.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)));
           Util.option_map v.activity_status
             (fun f ->
                Query.Pair ("ActivityStatus", (ActivityStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.spot_fleet_request_state
             (fun f -> ("spot_fleet_request_state", (BatchState.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.spot_fleet_request_config
             (fun f ->
                ("spot_fleet_request_config",
                  (SpotFleetRequestConfigData.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)));
           Util.option_map v.activity_status
             (fun f -> ("activity_status", (ActivityStatus.to_json f)))])
    let of_json j =
      {
        activity_status =
          (Util.option_map (Json.lookup j "activity_status")
             ActivityStatus.of_json);
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        spot_fleet_request_config =
          (Util.option_map (Json.lookup j "spot_fleet_request_config")
             SpotFleetRequestConfigData.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json);
        spot_fleet_request_state =
          (Util.option_map (Json.lookup j "spot_fleet_request_state")
             BatchState.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module PurchaseRequest =
  struct
    type t = {
      instance_count: Integer.t ;
      purchase_token: String.t }
    let make ~instance_count  ~purchase_token  () =
      { instance_count; purchase_token }
    let parse xml =
      Some
        {
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          purchase_token =
            (Xml.required "PurchaseToken"
               (Util.option_bind (Xml.member "PurchaseToken" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PurchaseToken", (String.to_query v.purchase_token)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("purchase_token", (String.to_json v.purchase_token));
           Some ("instance_count", (Integer.to_json v.instance_count))])
    let of_json j =
      {
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        purchase_token =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "purchase_token")))
      }
  end
module AvailabilityZone =
  struct
    type t =
      {
      state: AvailabilityZoneState.t option ;
      opt_in_status: AvailabilityZoneOptInStatus.t option ;
      messages: AvailabilityZoneMessageList.t ;
      region_name: String.t option ;
      zone_name: String.t option ;
      zone_id: String.t option ;
      group_name: String.t option ;
      network_border_group: String.t option ;
      zone_type: String.t option ;
      parent_zone_name: String.t option ;
      parent_zone_id: String.t option }
    let make ?state  ?opt_in_status  ?(messages= [])  ?region_name 
      ?zone_name  ?zone_id  ?group_name  ?network_border_group  ?zone_type 
      ?parent_zone_name  ?parent_zone_id  () =
      {
        state;
        opt_in_status;
        messages;
        region_name;
        zone_name;
        zone_id;
        group_name;
        network_border_group;
        zone_type;
        parent_zone_name;
        parent_zone_id
      }
    let parse xml =
      Some
        {
          state =
            (Util.option_bind (Xml.member "zoneState" xml)
               AvailabilityZoneState.parse);
          opt_in_status =
            (Util.option_bind (Xml.member "optInStatus" xml)
               AvailabilityZoneOptInStatus.parse);
          messages =
            (Util.of_option []
               (Util.option_bind (Xml.member "messageSet" xml)
                  AvailabilityZoneMessageList.parse));
          region_name =
            (Util.option_bind (Xml.member "regionName" xml) String.parse);
          zone_name =
            (Util.option_bind (Xml.member "zoneName" xml) String.parse);
          zone_id = (Util.option_bind (Xml.member "zoneId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          zone_type =
            (Util.option_bind (Xml.member "zoneType" xml) String.parse);
          parent_zone_name =
            (Util.option_bind (Xml.member "parentZoneName" xml) String.parse);
          parent_zone_id =
            (Util.option_bind (Xml.member "parentZoneId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.parent_zone_id
              (fun f -> Query.Pair ("ParentZoneId", (String.to_query f)));
           Util.option_map v.parent_zone_name
             (fun f -> Query.Pair ("ParentZoneName", (String.to_query f)));
           Util.option_map v.zone_type
             (fun f -> Query.Pair ("ZoneType", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.zone_id
             (fun f -> Query.Pair ("ZoneId", (String.to_query f)));
           Util.option_map v.zone_name
             (fun f -> Query.Pair ("ZoneName", (String.to_query f)));
           Util.option_map v.region_name
             (fun f -> Query.Pair ("RegionName", (String.to_query f)));
           Some
             (Query.Pair
                ("MessageSet",
                  (AvailabilityZoneMessageList.to_query v.messages)));
           Util.option_map v.opt_in_status
             (fun f ->
                Query.Pair
                  ("OptInStatus", (AvailabilityZoneOptInStatus.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("ZoneState", (AvailabilityZoneState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.parent_zone_id
              (fun f -> ("parent_zone_id", (String.to_json f)));
           Util.option_map v.parent_zone_name
             (fun f -> ("parent_zone_name", (String.to_json f)));
           Util.option_map v.zone_type
             (fun f -> ("zone_type", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.zone_id
             (fun f -> ("zone_id", (String.to_json f)));
           Util.option_map v.zone_name
             (fun f -> ("zone_name", (String.to_json f)));
           Util.option_map v.region_name
             (fun f -> ("region_name", (String.to_json f)));
           Some
             ("messages", (AvailabilityZoneMessageList.to_json v.messages));
           Util.option_map v.opt_in_status
             (fun f ->
                ("opt_in_status", (AvailabilityZoneOptInStatus.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (AvailabilityZoneState.to_json f)))])
    let of_json j =
      {
        state =
          (Util.option_map (Json.lookup j "state")
             AvailabilityZoneState.of_json);
        opt_in_status =
          (Util.option_map (Json.lookup j "opt_in_status")
             AvailabilityZoneOptInStatus.of_json);
        messages =
          (AvailabilityZoneMessageList.of_json
             (Util.of_option_exn (Json.lookup j "messages")));
        region_name =
          (Util.option_map (Json.lookup j "region_name") String.of_json);
        zone_name =
          (Util.option_map (Json.lookup j "zone_name") String.of_json);
        zone_id = (Util.option_map (Json.lookup j "zone_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        zone_type =
          (Util.option_map (Json.lookup j "zone_type") String.of_json);
        parent_zone_name =
          (Util.option_map (Json.lookup j "parent_zone_name") String.of_json);
        parent_zone_id =
          (Util.option_map (Json.lookup j "parent_zone_id") String.of_json)
      }
  end
module CustomerGateway =
  struct
    type t =
      {
      bgp_asn: String.t ;
      customer_gateway_id: String.t ;
      ip_address: String.t ;
      certificate_arn: String.t option ;
      state: String.t ;
      type_: String.t ;
      device_name: String.t option ;
      tags: TagList.t }
    let make ~bgp_asn  ~customer_gateway_id  ~ip_address  ?certificate_arn 
      ~state  ~type_  ?device_name  ?(tags= [])  () =
      {
        bgp_asn;
        customer_gateway_id;
        ip_address;
        certificate_arn;
        state;
        type_;
        device_name;
        tags
      }
    let parse xml =
      Some
        {
          bgp_asn =
            (Xml.required "bgpAsn"
               (Util.option_bind (Xml.member "bgpAsn" xml) String.parse));
          customer_gateway_id =
            (Xml.required "customerGatewayId"
               (Util.option_bind (Xml.member "customerGatewayId" xml)
                  String.parse));
          ip_address =
            (Xml.required "ipAddress"
               (Util.option_bind (Xml.member "ipAddress" xml) String.parse));
          certificate_arn =
            (Util.option_bind (Xml.member "certificateArn" xml) String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) String.parse));
          type_ =
            (Xml.required "type"
               (Util.option_bind (Xml.member "type" xml) String.parse));
          device_name =
            (Util.option_bind (Xml.member "deviceName" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some (Query.Pair ("State", (String.to_query v.state)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Some (Query.Pair ("IpAddress", (String.to_query v.ip_address)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)));
           Some (Query.Pair ("BgpAsn", (String.to_query v.bgp_asn)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Some ("type_", (String.to_json v.type_));
           Some ("state", (String.to_json v.state));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)));
           Some ("ip_address", (String.to_json v.ip_address));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id));
           Some ("bgp_asn", (String.to_json v.bgp_asn))])
    let of_json j =
      {
        bgp_asn =
          (String.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")));
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        ip_address =
          (String.of_json (Util.of_option_exn (Json.lookup j "ip_address")));
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        state = (String.of_json (Util.of_option_exn (Json.lookup j "state")));
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VolumeStatusItem =
  struct
    type t =
      {
      actions: VolumeStatusActionsList.t ;
      availability_zone: String.t option ;
      outpost_arn: String.t option ;
      events: VolumeStatusEventsList.t ;
      volume_id: String.t option ;
      volume_status: VolumeStatusInfo.t option ;
      attachment_statuses: VolumeStatusAttachmentStatusList.t }
    let make ?(actions= [])  ?availability_zone  ?outpost_arn  ?(events= []) 
      ?volume_id  ?volume_status  ?(attachment_statuses= [])  () =
      {
        actions;
        availability_zone;
        outpost_arn;
        events;
        volume_id;
        volume_status;
        attachment_statuses
      }
    let parse xml =
      Some
        {
          actions =
            (Util.of_option []
               (Util.option_bind (Xml.member "actionsSet" xml)
                  VolumeStatusActionsList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          events =
            (Util.of_option []
               (Util.option_bind (Xml.member "eventsSet" xml)
                  VolumeStatusEventsList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse);
          volume_status =
            (Util.option_bind (Xml.member "volumeStatus" xml)
               VolumeStatusInfo.parse);
          attachment_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentStatuses" xml)
                  VolumeStatusAttachmentStatusList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AttachmentStatuses",
                   (VolumeStatusAttachmentStatusList.to_query
                      v.attachment_statuses)));
           Util.option_map v.volume_status
             (fun f ->
                Query.Pair ("VolumeStatus", (VolumeStatusInfo.to_query f)));
           Util.option_map v.volume_id
             (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("EventsSet", (VolumeStatusEventsList.to_query v.events)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("ActionsSet", (VolumeStatusActionsList.to_query v.actions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("attachment_statuses",
                (VolumeStatusAttachmentStatusList.to_json
                   v.attachment_statuses));
           Util.option_map v.volume_status
             (fun f -> ("volume_status", (VolumeStatusInfo.to_json f)));
           Util.option_map v.volume_id
             (fun f -> ("volume_id", (String.to_json f)));
           Some ("events", (VolumeStatusEventsList.to_json v.events));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("actions", (VolumeStatusActionsList.to_json v.actions))])
    let of_json j =
      {
        actions =
          (VolumeStatusActionsList.of_json
             (Util.of_option_exn (Json.lookup j "actions")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        events =
          (VolumeStatusEventsList.of_json
             (Util.of_option_exn (Json.lookup j "events")));
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json);
        volume_status =
          (Util.option_map (Json.lookup j "volume_status")
             VolumeStatusInfo.of_json);
        attachment_statuses =
          (VolumeStatusAttachmentStatusList.of_json
             (Util.of_option_exn (Json.lookup j "attachment_statuses")))
      }
  end
module TransitGatewayRouteTableAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?state  () =
      { transit_gateway_attachment_id; resource_id; resource_type; state }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module HostOffering =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      duration: Integer.t option ;
      hourly_price: String.t option ;
      instance_family: String.t option ;
      offering_id: String.t option ;
      payment_option: PaymentOption.t option ;
      upfront_price: String.t option }
    let make ?currency_code  ?duration  ?hourly_price  ?instance_family 
      ?offering_id  ?payment_option  ?upfront_price  () =
      {
        currency_code;
        duration;
        hourly_price;
        instance_family;
        offering_id;
        payment_option;
        upfront_price
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Integer.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "offeringId" xml) String.parse);
          payment_option =
            (Util.option_bind (Xml.member "paymentOption" xml)
               PaymentOption.parse);
          upfront_price =
            (Util.option_bind (Xml.member "upfrontPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> Query.Pair ("UpfrontPrice", (String.to_query f)));
           Util.option_map v.payment_option
             (fun f ->
                Query.Pair ("PaymentOption", (PaymentOption.to_query f)));
           Util.option_map v.offering_id
             (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Integer.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upfront_price
              (fun f -> ("upfront_price", (String.to_json f)));
           Util.option_map v.payment_option
             (fun f -> ("payment_option", (PaymentOption.to_json f)));
           Util.option_map v.offering_id
             (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Integer.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        duration =
          (Util.option_map (Json.lookup j "duration") Integer.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json);
        payment_option =
          (Util.option_map (Json.lookup j "payment_option")
             PaymentOption.of_json);
        upfront_price =
          (Util.option_map (Json.lookup j "upfront_price") String.of_json)
      }
  end
module TransitGatewayRouteTable =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      transit_gateway_id: String.t option ;
      state: TransitGatewayRouteTableState.t option ;
      default_association_route_table: Boolean.t option ;
      default_propagation_route_table: Boolean.t option ;
      creation_time: DateTime.t option ;
      tags: TagList.t }
    let make ?transit_gateway_route_table_id  ?transit_gateway_id  ?state 
      ?default_association_route_table  ?default_propagation_route_table 
      ?creation_time  ?(tags= [])  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_id;
        state;
        default_association_route_table;
        default_propagation_route_table;
        creation_time;
        tags
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "transitGatewayId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayRouteTableState.parse);
          default_association_route_table =
            (Util.option_bind (Xml.member "defaultAssociationRouteTable" xml)
               Boolean.parse);
          default_propagation_route_table =
            (Util.option_bind (Xml.member "defaultPropagationRouteTable" xml)
               Boolean.parse);
          creation_time =
            (Util.option_bind (Xml.member "creationTime" xml) DateTime.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.creation_time
             (fun f -> Query.Pair ("CreationTime", (DateTime.to_query f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                Query.Pair
                  ("DefaultPropagationRouteTable", (Boolean.to_query f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                Query.Pair
                  ("DefaultAssociationRouteTable", (Boolean.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (TransitGatewayRouteTableState.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.creation_time
             (fun f -> ("creation_time", (DateTime.to_json f)));
           Util.option_map v.default_propagation_route_table
             (fun f ->
                ("default_propagation_route_table", (Boolean.to_json f)));
           Util.option_map v.default_association_route_table
             (fun f ->
                ("default_association_route_table", (Boolean.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (TransitGatewayRouteTableState.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayRouteTableState.of_json);
        default_association_route_table =
          (Util.option_map (Json.lookup j "default_association_route_table")
             Boolean.of_json);
        default_propagation_route_table =
          (Util.option_map (Json.lookup j "default_propagation_route_table")
             Boolean.of_json);
        creation_time =
          (Util.option_map (Json.lookup j "creation_time") DateTime.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module RemovePrefixListEntry =
  struct
    type t = {
      cidr: String.t }
    let make ~cidr  () = { cidr }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc (Util.list_filter_opt [Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      { cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr"))) }
  end
module AuthorizationRule =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      description: String.t option ;
      group_id: String.t option ;
      access_all: Boolean.t option ;
      destination_cidr: String.t option ;
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?client_vpn_endpoint_id  ?description  ?group_id  ?access_all 
      ?destination_cidr  ?status  () =
      {
        client_vpn_endpoint_id;
        description;
        group_id;
        access_all;
        destination_cidr;
        status
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          group_id =
            (Util.option_bind (Xml.member "groupId" xml) String.parse);
          access_all =
            (Util.option_bind (Xml.member "accessAll" xml) Boolean.parse);
          destination_cidr =
            (Util.option_bind (Xml.member "destinationCidr" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)));
           Util.option_map v.destination_cidr
             (fun f -> Query.Pair ("DestinationCidr", (String.to_query f)));
           Util.option_map v.access_all
             (fun f -> Query.Pair ("AccessAll", (Boolean.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)));
           Util.option_map v.destination_cidr
             (fun f -> ("destination_cidr", (String.to_json f)));
           Util.option_map v.access_all
             (fun f -> ("access_all", (Boolean.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        access_all =
          (Util.option_map (Json.lookup j "access_all") Boolean.of_json);
        destination_cidr =
          (Util.option_map (Json.lookup j "destination_cidr") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module TransitGatewayMulticastDomainAssociation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      subnet: SubnetAssociation.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?subnet  () =
      { transit_gateway_attachment_id; resource_id; resource_type; subnet }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnet =
            (Util.option_bind (Xml.member "subnet" xml)
               SubnetAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (SubnetAssociation.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (SubnetAssociation.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        subnet =
          (Util.option_map (Json.lookup j "subnet") SubnetAssociation.of_json)
      }
  end
module TrafficMirrorSessionField =
  struct
    type t =
      | Packet_length 
      | Description 
      | Virtual_network_id 
    let str_to_t =
      [("virtual-network-id", Virtual_network_id);
      ("description", Description);
      ("packet-length", Packet_length)]
    let t_to_str =
      [(Virtual_network_id, "virtual-network-id");
      (Description, "description");
      (Packet_length, "packet-length")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SuccessfulInstanceCreditSpecificationItem =
  struct
    type t = {
      instance_id: String.t option }
    let make ?instance_id  () = { instance_id }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module UnsuccessfulInstanceCreditSpecificationItem =
  struct
    type t =
      {
      instance_id: String.t option ;
      error: UnsuccessfulInstanceCreditSpecificationItemError.t option }
    let make ?instance_id  ?error  () = { instance_id; error }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          error =
            (Util.option_bind (Xml.member "error" xml)
               UnsuccessfulInstanceCreditSpecificationItemError.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 Query.Pair
                   ("Error",
                     (UnsuccessfulInstanceCreditSpecificationItemError.to_query
                        f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.error
              (fun f ->
                 ("error",
                   (UnsuccessfulInstanceCreditSpecificationItemError.to_json
                      f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        error =
          (Util.option_map (Json.lookup j "error")
             UnsuccessfulInstanceCreditSpecificationItemError.of_json)
      }
  end
module ReservedInstancesOffering =
  struct
    type t =
      {
      availability_zone: String.t option ;
      duration: Long.t option ;
      fixed_price: Float.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_offering_id: String.t option ;
      usage_price: Float.t option ;
      currency_code: CurrencyCodeValues.t option ;
      instance_tenancy: Tenancy.t option ;
      marketplace: Boolean.t option ;
      offering_class: OfferingClassType.t option ;
      offering_type: OfferingTypeValues.t option ;
      pricing_details: PricingDetailsList.t ;
      recurring_charges: RecurringChargesList.t ;
      scope: Scope.t option }
    let make ?availability_zone  ?duration  ?fixed_price  ?instance_type 
      ?product_description  ?reserved_instances_offering_id  ?usage_price 
      ?currency_code  ?instance_tenancy  ?marketplace  ?offering_class 
      ?offering_type  ?(pricing_details= [])  ?(recurring_charges= []) 
      ?scope  () =
      {
        availability_zone;
        duration;
        fixed_price;
        instance_type;
        product_description;
        reserved_instances_offering_id;
        usage_price;
        currency_code;
        instance_tenancy;
        marketplace;
        offering_class;
        offering_type;
        pricing_details;
        recurring_charges;
        scope
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          duration =
            (Util.option_bind (Xml.member "duration" xml) Long.parse);
          fixed_price =
            (Util.option_bind (Xml.member "fixedPrice" xml) Float.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          reserved_instances_offering_id =
            (Util.option_bind (Xml.member "reservedInstancesOfferingId" xml)
               String.parse);
          usage_price =
            (Util.option_bind (Xml.member "usagePrice" xml) Float.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          marketplace =
            (Util.option_bind (Xml.member "marketplace" xml) Boolean.parse);
          offering_class =
            (Util.option_bind (Xml.member "offeringClass" xml)
               OfferingClassType.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse);
          pricing_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "pricingDetailsSet" xml)
                  PricingDetailsList.parse));
          recurring_charges =
            (Util.of_option []
               (Util.option_bind (Xml.member "recurringCharges" xml)
                  RecurringChargesList.parse));
          scope = (Util.option_bind (Xml.member "scope" xml) Scope.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.scope
              (fun f -> Query.Pair ("Scope", (Scope.to_query f)));
           Some
             (Query.Pair
                ("RecurringCharges",
                  (RecurringChargesList.to_query v.recurring_charges)));
           Some
             (Query.Pair
                ("PricingDetailsSet",
                  (PricingDetailsList.to_query v.pricing_details)));
           Util.option_map v.offering_type
             (fun f ->
                Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.marketplace
             (fun f -> Query.Pair ("Marketplace", (Boolean.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.usage_price
             (fun f -> Query.Pair ("UsagePrice", (Float.to_query f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f ->
                Query.Pair
                  ("ReservedInstancesOfferingId", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.fixed_price
             (fun f -> Query.Pair ("FixedPrice", (Float.to_query f)));
           Util.option_map v.duration
             (fun f -> Query.Pair ("Duration", (Long.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.scope (fun f -> ("scope", (Scope.to_json f)));
           Some
             ("recurring_charges",
               (RecurringChargesList.to_json v.recurring_charges));
           Some
             ("pricing_details",
               (PricingDetailsList.to_json v.pricing_details));
           Util.option_map v.offering_type
             (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.marketplace
             (fun f -> ("marketplace", (Boolean.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.usage_price
             (fun f -> ("usage_price", (Float.to_json f)));
           Util.option_map v.reserved_instances_offering_id
             (fun f -> ("reserved_instances_offering_id", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.fixed_price
             (fun f -> ("fixed_price", (Float.to_json f)));
           Util.option_map v.duration
             (fun f -> ("duration", (Long.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        duration = (Util.option_map (Json.lookup j "duration") Long.of_json);
        fixed_price =
          (Util.option_map (Json.lookup j "fixed_price") Float.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_offering_id =
          (Util.option_map (Json.lookup j "reserved_instances_offering_id")
             String.of_json);
        usage_price =
          (Util.option_map (Json.lookup j "usage_price") Float.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        marketplace =
          (Util.option_map (Json.lookup j "marketplace") Boolean.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json);
        pricing_details =
          (PricingDetailsList.of_json
             (Util.of_option_exn (Json.lookup j "pricing_details")));
        recurring_charges =
          (RecurringChargesList.of_json
             (Util.of_option_exn (Json.lookup j "recurring_charges")));
        scope = (Util.option_map (Json.lookup j "scope") Scope.of_json)
      }
  end
module ScheduledInstanceAvailability =
  struct
    type t =
      {
      availability_zone: String.t option ;
      available_instance_count: Integer.t option ;
      first_slot_start_time: DateTime.t option ;
      hourly_price: String.t option ;
      instance_type: String.t option ;
      max_term_duration_in_days: Integer.t option ;
      min_term_duration_in_days: Integer.t option ;
      network_platform: String.t option ;
      platform: String.t option ;
      purchase_token: String.t option ;
      recurrence: ScheduledInstanceRecurrence.t option ;
      slot_duration_in_hours: Integer.t option ;
      total_scheduled_instance_hours: Integer.t option }
    let make ?availability_zone  ?available_instance_count 
      ?first_slot_start_time  ?hourly_price  ?instance_type 
      ?max_term_duration_in_days  ?min_term_duration_in_days 
      ?network_platform  ?platform  ?purchase_token  ?recurrence 
      ?slot_duration_in_hours  ?total_scheduled_instance_hours  () =
      {
        availability_zone;
        available_instance_count;
        first_slot_start_time;
        hourly_price;
        instance_type;
        max_term_duration_in_days;
        min_term_duration_in_days;
        network_platform;
        platform;
        purchase_token;
        recurrence;
        slot_duration_in_hours;
        total_scheduled_instance_hours
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          first_slot_start_time =
            (Util.option_bind (Xml.member "firstSlotStartTime" xml)
               DateTime.parse);
          hourly_price =
            (Util.option_bind (Xml.member "hourlyPrice" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          max_term_duration_in_days =
            (Util.option_bind (Xml.member "maxTermDurationInDays" xml)
               Integer.parse);
          min_term_duration_in_days =
            (Util.option_bind (Xml.member "minTermDurationInDays" xml)
               Integer.parse);
          network_platform =
            (Util.option_bind (Xml.member "networkPlatform" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          purchase_token =
            (Util.option_bind (Xml.member "purchaseToken" xml) String.parse);
          recurrence =
            (Util.option_bind (Xml.member "recurrence" xml)
               ScheduledInstanceRecurrence.parse);
          slot_duration_in_hours =
            (Util.option_bind (Xml.member "slotDurationInHours" xml)
               Integer.parse);
          total_scheduled_instance_hours =
            (Util.option_bind (Xml.member "totalScheduledInstanceHours" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 Query.Pair
                   ("TotalScheduledInstanceHours", (Integer.to_query f)));
           Util.option_map v.slot_duration_in_hours
             (fun f ->
                Query.Pair ("SlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.recurrence
             (fun f ->
                Query.Pair
                  ("Recurrence", (ScheduledInstanceRecurrence.to_query f)));
           Util.option_map v.purchase_token
             (fun f -> Query.Pair ("PurchaseToken", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.network_platform
             (fun f -> Query.Pair ("NetworkPlatform", (String.to_query f)));
           Util.option_map v.min_term_duration_in_days
             (fun f ->
                Query.Pair ("MinTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.max_term_duration_in_days
             (fun f ->
                Query.Pair ("MaxTermDurationInDays", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.hourly_price
             (fun f -> Query.Pair ("HourlyPrice", (String.to_query f)));
           Util.option_map v.first_slot_start_time
             (fun f ->
                Query.Pair ("FirstSlotStartTime", (DateTime.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_scheduled_instance_hours
              (fun f ->
                 ("total_scheduled_instance_hours", (Integer.to_json f)));
           Util.option_map v.slot_duration_in_hours
             (fun f -> ("slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.recurrence
             (fun f ->
                ("recurrence", (ScheduledInstanceRecurrence.to_json f)));
           Util.option_map v.purchase_token
             (fun f -> ("purchase_token", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.network_platform
             (fun f -> ("network_platform", (String.to_json f)));
           Util.option_map v.min_term_duration_in_days
             (fun f -> ("min_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.max_term_duration_in_days
             (fun f -> ("max_term_duration_in_days", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.hourly_price
             (fun f -> ("hourly_price", (String.to_json f)));
           Util.option_map v.first_slot_start_time
             (fun f -> ("first_slot_start_time", (DateTime.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        first_slot_start_time =
          (Util.option_map (Json.lookup j "first_slot_start_time")
             DateTime.of_json);
        hourly_price =
          (Util.option_map (Json.lookup j "hourly_price") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        max_term_duration_in_days =
          (Util.option_map (Json.lookup j "max_term_duration_in_days")
             Integer.of_json);
        min_term_duration_in_days =
          (Util.option_map (Json.lookup j "min_term_duration_in_days")
             Integer.of_json);
        network_platform =
          (Util.option_map (Json.lookup j "network_platform") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        purchase_token =
          (Util.option_map (Json.lookup j "purchase_token") String.of_json);
        recurrence =
          (Util.option_map (Json.lookup j "recurrence")
             ScheduledInstanceRecurrence.of_json);
        slot_duration_in_hours =
          (Util.option_map (Json.lookup j "slot_duration_in_hours")
             Integer.of_json);
        total_scheduled_instance_hours =
          (Util.option_map (Json.lookup j "total_scheduled_instance_hours")
             Integer.of_json)
      }
  end
module Reservation =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      instances: InstanceList.t ;
      owner_id: String.t ;
      requester_id: String.t option ;
      reservation_id: String.t }
    let make ?(groups= [])  ?(instances= [])  ~owner_id  ?requester_id 
      ~reservation_id  () =
      { groups; instances; owner_id; requester_id; reservation_id }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceList.parse));
          owner_id =
            (Xml.required "ownerId"
               (Util.option_bind (Xml.member "ownerId" xml) String.parse));
          requester_id =
            (Util.option_bind (Xml.member "requesterId" xml) String.parse);
          reservation_id =
            (Xml.required "reservationId"
               (Util.option_bind (Xml.member "reservationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservationId", (String.to_query v.reservation_id)));
           Util.option_map v.requester_id
             (fun f -> Query.Pair ("RequesterId", (String.to_query f)));
           Some (Query.Pair ("OwnerId", (String.to_query v.owner_id)));
           Some
             (Query.Pair
                ("InstancesSet", (InstanceList.to_query v.instances)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("reservation_id", (String.to_json v.reservation_id));
           Util.option_map v.requester_id
             (fun f -> ("requester_id", (String.to_json f)));
           Some ("owner_id", (String.to_json v.owner_id));
           Some ("instances", (InstanceList.to_json v.instances));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instances =
          (InstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        owner_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "owner_id")));
        requester_id =
          (Util.option_map (Json.lookup j "requester_id") String.of_json);
        reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reservation_id")))
      }
  end
module PublicIpv4Pool =
  struct
    type t =
      {
      pool_id: String.t option ;
      description: String.t option ;
      pool_address_ranges: PublicIpv4PoolRangeSet.t ;
      total_address_count: Integer.t option ;
      total_available_address_count: Integer.t option ;
      network_border_group: String.t option ;
      tags: TagList.t }
    let make ?pool_id  ?description  ?(pool_address_ranges= []) 
      ?total_address_count  ?total_available_address_count 
      ?network_border_group  ?(tags= [])  () =
      {
        pool_id;
        description;
        pool_address_ranges;
        total_address_count;
        total_available_address_count;
        network_border_group;
        tags
      }
    let parse xml =
      Some
        {
          pool_id = (Util.option_bind (Xml.member "poolId" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          pool_address_ranges =
            (Util.of_option []
               (Util.option_bind (Xml.member "poolAddressRangeSet" xml)
                  PublicIpv4PoolRangeSet.parse));
          total_address_count =
            (Util.option_bind (Xml.member "totalAddressCount" xml)
               Integer.parse);
          total_available_address_count =
            (Util.option_bind (Xml.member "totalAvailableAddressCount" xml)
               Integer.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.total_available_address_count
             (fun f ->
                Query.Pair
                  ("TotalAvailableAddressCount", (Integer.to_query f)));
           Util.option_map v.total_address_count
             (fun f -> Query.Pair ("TotalAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PoolAddressRangeSet",
                  (PublicIpv4PoolRangeSet.to_query v.pool_address_ranges)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.pool_id
             (fun f -> Query.Pair ("PoolId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.total_available_address_count
             (fun f -> ("total_available_address_count", (Integer.to_json f)));
           Util.option_map v.total_address_count
             (fun f -> ("total_address_count", (Integer.to_json f)));
           Some
             ("pool_address_ranges",
               (PublicIpv4PoolRangeSet.to_json v.pool_address_ranges));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.pool_id
             (fun f -> ("pool_id", (String.to_json f)))])
    let of_json j =
      {
        pool_id = (Util.option_map (Json.lookup j "pool_id") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        pool_address_ranges =
          (PublicIpv4PoolRangeSet.of_json
             (Util.of_option_exn (Json.lookup j "pool_address_ranges")));
        total_address_count =
          (Util.option_map (Json.lookup j "total_address_count")
             Integer.of_json);
        total_available_address_count =
          (Util.option_map (Json.lookup j "total_available_address_count")
             Integer.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Vpc =
  struct
    type t =
      {
      cidr_block: String.t ;
      dhcp_options_id: String.t ;
      state: VpcState.t ;
      vpc_id: String.t ;
      owner_id: String.t option ;
      instance_tenancy: Tenancy.t ;
      ipv6_cidr_block_association_set: VpcIpv6CidrBlockAssociationSet.t ;
      cidr_block_association_set: VpcCidrBlockAssociationSet.t ;
      is_default: Boolean.t ;
      tags: TagList.t }
    let make ~cidr_block  ~dhcp_options_id  ~state  ~vpc_id  ?owner_id 
      ~instance_tenancy  ?(ipv6_cidr_block_association_set= []) 
      ?(cidr_block_association_set= [])  ~is_default  ?(tags= [])  () =
      {
        cidr_block;
        dhcp_options_id;
        state;
        vpc_id;
        owner_id;
        instance_tenancy;
        ipv6_cidr_block_association_set;
        cidr_block_association_set;
        is_default;
        tags
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          dhcp_options_id =
            (Xml.required "dhcpOptionsId"
               (Util.option_bind (Xml.member "dhcpOptionsId" xml)
                  String.parse));
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) VpcState.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          instance_tenancy =
            (Xml.required "instanceTenancy"
               (Util.option_bind (Xml.member "instanceTenancy" xml)
                  Tenancy.parse));
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  VpcIpv6CidrBlockAssociationSet.parse));
          cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "cidrBlockAssociationSet" xml)
                  VpcCidrBlockAssociationSet.parse));
          is_default =
            (Xml.required "isDefault"
               (Util.option_bind (Xml.member "isDefault" xml) Boolean.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("IsDefault", (Boolean.to_query v.is_default)));
           Some
             (Query.Pair
                ("CidrBlockAssociationSet",
                  (VpcCidrBlockAssociationSet.to_query
                     v.cidr_block_association_set)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (VpcIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Some
             (Query.Pair
                ("InstanceTenancy", (Tenancy.to_query v.instance_tenancy)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("State", (VpcState.to_query v.state)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("is_default", (Boolean.to_json v.is_default));
           Some
             ("cidr_block_association_set",
               (VpcCidrBlockAssociationSet.to_json
                  v.cidr_block_association_set));
           Some
             ("ipv6_cidr_block_association_set",
               (VpcIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Some ("instance_tenancy", (Tenancy.to_json v.instance_tenancy));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("state", (VpcState.to_json v.state));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id));
           Some ("cidr_block", (String.to_json v.cidr_block))])
    let of_json j =
      {
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        state =
          (VpcState.of_json (Util.of_option_exn (Json.lookup j "state")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        instance_tenancy =
          (Tenancy.of_json
             (Util.of_option_exn (Json.lookup j "instance_tenancy")));
        ipv6_cidr_block_association_set =
          (VpcIpv6CidrBlockAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "ipv6_cidr_block_association_set")));
        cidr_block_association_set =
          (VpcCidrBlockAssociationSet.of_json
             (Util.of_option_exn (Json.lookup j "cidr_block_association_set")));
        is_default =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "is_default")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module LocalGateway =
  struct
    type t =
      {
      local_gateway_id: String.t option ;
      outpost_arn: String.t option ;
      owner_id: String.t option ;
      state: String.t option ;
      tags: TagList.t }
    let make ?local_gateway_id  ?outpost_arn  ?owner_id  ?state  ?(tags= []) 
      () = { local_gateway_id; outpost_arn; owner_id; state; tags }
    let parse xml =
      Some
        {
          local_gateway_id =
            (Util.option_bind (Xml.member "localGatewayId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module Subnet =
  struct
    type t =
      {
      availability_zone: String.t ;
      availability_zone_id: String.t option ;
      available_ip_address_count: Integer.t ;
      cidr_block: String.t ;
      default_for_az: Boolean.t ;
      map_public_ip_on_launch: Boolean.t ;
      map_customer_owned_ip_on_launch: Boolean.t option ;
      customer_owned_ipv4_pool: String.t option ;
      state: SubnetState.t ;
      subnet_id: String.t ;
      vpc_id: String.t ;
      owner_id: String.t option ;
      assign_ipv6_address_on_creation: Boolean.t option ;
      ipv6_cidr_block_association_set: SubnetIpv6CidrBlockAssociationSet.t ;
      tags: TagList.t ;
      subnet_arn: String.t option ;
      outpost_arn: String.t option }
    let make ~availability_zone  ?availability_zone_id 
      ~available_ip_address_count  ~cidr_block  ~default_for_az 
      ~map_public_ip_on_launch  ?map_customer_owned_ip_on_launch 
      ?customer_owned_ipv4_pool  ~state  ~subnet_id  ~vpc_id  ?owner_id 
      ?assign_ipv6_address_on_creation  ?(ipv6_cidr_block_association_set=
      [])  ?(tags= [])  ?subnet_arn  ?outpost_arn  () =
      {
        availability_zone;
        availability_zone_id;
        available_ip_address_count;
        cidr_block;
        default_for_az;
        map_public_ip_on_launch;
        map_customer_owned_ip_on_launch;
        customer_owned_ipv4_pool;
        state;
        subnet_id;
        vpc_id;
        owner_id;
        assign_ipv6_address_on_creation;
        ipv6_cidr_block_association_set;
        tags;
        subnet_arn;
        outpost_arn
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          availability_zone_id =
            (Util.option_bind (Xml.member "availabilityZoneId" xml)
               String.parse);
          available_ip_address_count =
            (Xml.required "availableIpAddressCount"
               (Util.option_bind (Xml.member "availableIpAddressCount" xml)
                  Integer.parse));
          cidr_block =
            (Xml.required "cidrBlock"
               (Util.option_bind (Xml.member "cidrBlock" xml) String.parse));
          default_for_az =
            (Xml.required "defaultForAz"
               (Util.option_bind (Xml.member "defaultForAz" xml)
                  Boolean.parse));
          map_public_ip_on_launch =
            (Xml.required "mapPublicIpOnLaunch"
               (Util.option_bind (Xml.member "mapPublicIpOnLaunch" xml)
                  Boolean.parse));
          map_customer_owned_ip_on_launch =
            (Util.option_bind (Xml.member "mapCustomerOwnedIpOnLaunch" xml)
               Boolean.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse);
          state =
            (Xml.required "state"
               (Util.option_bind (Xml.member "state" xml) SubnetState.parse));
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          assign_ipv6_address_on_creation =
            (Util.option_bind (Xml.member "assignIpv6AddressOnCreation" xml)
               Boolean.parse);
          ipv6_cidr_block_association_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ipv6CidrBlockAssociationSet" xml)
                  SubnetIpv6CidrBlockAssociationSet.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          subnet_arn =
            (Util.option_bind (Xml.member "subnetArn" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "outpostArn" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.subnet_arn
             (fun f -> Query.Pair ("SubnetArn", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("Ipv6CidrBlockAssociationSet",
                  (SubnetIpv6CidrBlockAssociationSet.to_query
                     v.ipv6_cidr_block_association_set)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                Query.Pair
                  ("AssignIpv6AddressOnCreation", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some (Query.Pair ("State", (SubnetState.to_query v.state)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f ->
                Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.map_customer_owned_ip_on_launch
             (fun f ->
                Query.Pair
                  ("MapCustomerOwnedIpOnLaunch", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("MapPublicIpOnLaunch",
                  (Boolean.to_query v.map_public_ip_on_launch)));
           Some
             (Query.Pair
                ("DefaultForAz", (Boolean.to_query v.default_for_az)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Some
             (Query.Pair
                ("AvailableIpAddressCount",
                  (Integer.to_query v.available_ip_address_count)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.outpost_arn
              (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.subnet_arn
             (fun f -> ("subnet_arn", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Some
             ("ipv6_cidr_block_association_set",
               (SubnetIpv6CidrBlockAssociationSet.to_json
                  v.ipv6_cidr_block_association_set));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                ("assign_ipv6_address_on_creation", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Some ("state", (SubnetState.to_json v.state));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.map_customer_owned_ip_on_launch
             (fun f ->
                ("map_customer_owned_ip_on_launch", (Boolean.to_json f)));
           Some
             ("map_public_ip_on_launch",
               (Boolean.to_json v.map_public_ip_on_launch));
           Some ("default_for_az", (Boolean.to_json v.default_for_az));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Some
             ("available_ip_address_count",
               (Integer.to_json v.available_ip_address_count));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        available_ip_address_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "available_ip_address_count")));
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        default_for_az =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "default_for_az")));
        map_public_ip_on_launch =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "map_public_ip_on_launch")));
        map_customer_owned_ip_on_launch =
          (Util.option_map (Json.lookup j "map_customer_owned_ip_on_launch")
             Boolean.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json);
        state =
          (SubnetState.of_json (Util.of_option_exn (Json.lookup j "state")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        assign_ipv6_address_on_creation =
          (Util.option_map (Json.lookup j "assign_ipv6_address_on_creation")
             Boolean.of_json);
        ipv6_cidr_block_association_set =
          (SubnetIpv6CidrBlockAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "ipv6_cidr_block_association_set")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        subnet_arn =
          (Util.option_map (Json.lookup j "subnet_arn") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json)
      }
  end
module ElasticGpus =
  struct
    type t =
      {
      elastic_gpu_id: String.t option ;
      availability_zone: String.t option ;
      elastic_gpu_type: String.t option ;
      elastic_gpu_health: ElasticGpuHealth.t option ;
      elastic_gpu_state: ElasticGpuState.t option ;
      instance_id: String.t option ;
      tags: TagList.t }
    let make ?elastic_gpu_id  ?availability_zone  ?elastic_gpu_type 
      ?elastic_gpu_health  ?elastic_gpu_state  ?instance_id  ?(tags= [])  ()
      =
      {
        elastic_gpu_id;
        availability_zone;
        elastic_gpu_type;
        elastic_gpu_health;
        elastic_gpu_state;
        instance_id;
        tags
      }
    let parse xml =
      Some
        {
          elastic_gpu_id =
            (Util.option_bind (Xml.member "elasticGpuId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          elastic_gpu_type =
            (Util.option_bind (Xml.member "elasticGpuType" xml) String.parse);
          elastic_gpu_health =
            (Util.option_bind (Xml.member "elasticGpuHealth" xml)
               ElasticGpuHealth.parse);
          elastic_gpu_state =
            (Util.option_bind (Xml.member "elasticGpuState" xml)
               ElasticGpuState.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.elastic_gpu_state
             (fun f ->
                Query.Pair ("ElasticGpuState", (ElasticGpuState.to_query f)));
           Util.option_map v.elastic_gpu_health
             (fun f ->
                Query.Pair
                  ("ElasticGpuHealth", (ElasticGpuHealth.to_query f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> Query.Pair ("ElasticGpuType", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> Query.Pair ("ElasticGpuId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.elastic_gpu_state
             (fun f -> ("elastic_gpu_state", (ElasticGpuState.to_json f)));
           Util.option_map v.elastic_gpu_health
             (fun f -> ("elastic_gpu_health", (ElasticGpuHealth.to_json f)));
           Util.option_map v.elastic_gpu_type
             (fun f -> ("elastic_gpu_type", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.elastic_gpu_id
             (fun f -> ("elastic_gpu_id", (String.to_json f)))])
    let of_json j =
      {
        elastic_gpu_id =
          (Util.option_map (Json.lookup j "elastic_gpu_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        elastic_gpu_type =
          (Util.option_map (Json.lookup j "elastic_gpu_type") String.of_json);
        elastic_gpu_health =
          (Util.option_map (Json.lookup j "elastic_gpu_health")
             ElasticGpuHealth.of_json);
        elastic_gpu_state =
          (Util.option_map (Json.lookup j "elastic_gpu_state")
             ElasticGpuState.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module VpcClassicLink =
  struct
    type t =
      {
      classic_link_enabled: Boolean.t option ;
      tags: TagList.t ;
      vpc_id: String.t option }
    let make ?classic_link_enabled  ?(tags= [])  ?vpc_id  () =
      { classic_link_enabled; tags; vpc_id }
    let parse xml =
      Some
        {
          classic_link_enabled =
            (Util.option_bind (Xml.member "classicLinkEnabled" xml)
               Boolean.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.classic_link_enabled
             (fun f ->
                Query.Pair ("ClassicLinkEnabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.classic_link_enabled
             (fun f -> ("classic_link_enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        classic_link_enabled =
          (Util.option_map (Json.lookup j "classic_link_enabled")
             Boolean.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ImportImageTask =
  struct
    type t =
      {
      architecture: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      image_id: String.t option ;
      import_task_id: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      progress: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      status: String.t option ;
      status_message: String.t option ;
      tags: TagList.t ;
      license_specifications: ImportImageLicenseSpecificationListResponse.t }
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message  ?(tags= []) 
      ?(license_specifications= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        tags;
        license_specifications
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse));
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LicenseSpecifications",
                   (ImportImageLicenseSpecificationListResponse.to_query
                      v.license_specifications)));
           Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("license_specifications",
                (ImportImageLicenseSpecificationListResponse.to_json
                   v.license_specifications));
           Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")));
        license_specifications =
          (ImportImageLicenseSpecificationListResponse.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")))
      }
  end
module SpotPrice =
  struct
    type t =
      {
      availability_zone: String.t option ;
      instance_type: InstanceType.t option ;
      product_description: RIProductDescription.t option ;
      spot_price: String.t option ;
      timestamp: DateTime.t option }
    let make ?availability_zone  ?instance_type  ?product_description 
      ?spot_price  ?timestamp  () =
      {
        availability_zone;
        instance_type;
        product_description;
        spot_price;
        timestamp
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          product_description =
            (Util.option_bind (Xml.member "productDescription" xml)
               RIProductDescription.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module ReportInstanceReasonCodes =
  struct
    type t =
      | Instance_stuck_in_state 
      | Unresponsive 
      | Not_accepting_credentials 
      | Password_not_available 
      | Performance_network 
      | Performance_instance_store 
      | Performance_ebs_volume 
      | Performance_other 
      | Other 
    let str_to_t =
      [("other", Other);
      ("performance-other", Performance_other);
      ("performance-ebs-volume", Performance_ebs_volume);
      ("performance-instance-store", Performance_instance_store);
      ("performance-network", Performance_network);
      ("password-not-available", Password_not_available);
      ("not-accepting-credentials", Not_accepting_credentials);
      ("unresponsive", Unresponsive);
      ("instance-stuck-in-state", Instance_stuck_in_state)]
    let t_to_str =
      [(Other, "other");
      (Performance_other, "performance-other");
      (Performance_ebs_volume, "performance-ebs-volume");
      (Performance_instance_store, "performance-instance-store");
      (Performance_network, "performance-network");
      (Password_not_available, "password-not-available");
      (Not_accepting_credentials, "not-accepting-credentials");
      (Unresponsive, "unresponsive");
      (Instance_stuck_in_state, "instance-stuck-in-state")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCreditSpecificationRequest =
  struct
    type t = {
      instance_id: String.t option ;
      cpu_credits: String.t option }
    let make ?instance_id  ?cpu_credits  () = { instance_id; cpu_credits }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "CpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module OccurrenceDayRequestSet =
  struct
    type t = Integer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Integer.parse (Xml.members "OccurenceDay" xml))
    let to_query v = Query.to_query_list Integer.to_query v
    let to_json v = `List (List.map Integer.to_json v)
    let of_json j = Json.to_list Integer.of_json j
  end
module ImageDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      device_name: String.t option ;
      format: String.t option ;
      snapshot_id: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option }
    let make ?description  ?device_name  ?format  ?snapshot_id  ?url 
      ?user_bucket  () =
      { description; device_name; format; snapshot_id; url; user_bucket }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json)
      }
  end
module ImportImageLicenseConfigurationRequest =
  struct
    type t = {
      license_configuration_arn: String.t option }
    let make ?license_configuration_arn  () = { license_configuration_arn }
    let parse xml =
      Some
        {
          license_configuration_arn =
            (Util.option_bind (Xml.member "LicenseConfigurationArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f ->
                 Query.Pair ("LicenseConfigurationArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.license_configuration_arn
              (fun f -> ("license_configuration_arn", (String.to_json f)))])
    let of_json j =
      {
        license_configuration_arn =
          (Util.option_map (Json.lookup j "license_configuration_arn")
             String.of_json)
      }
  end
module LocalGatewayRoute =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      local_gateway_virtual_interface_group_id: String.t option ;
      type_: LocalGatewayRouteType.t option ;
      state: LocalGatewayRouteState.t option ;
      local_gateway_route_table_id: String.t option ;
      local_gateway_route_table_arn: String.t option ;
      owner_id: String.t option }
    let make ?destination_cidr_block 
      ?local_gateway_virtual_interface_group_id  ?type_  ?state 
      ?local_gateway_route_table_id  ?local_gateway_route_table_arn 
      ?owner_id  () =
      {
        destination_cidr_block;
        local_gateway_virtual_interface_group_id;
        type_;
        state;
        local_gateway_route_table_id;
        local_gateway_route_table_arn;
        owner_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          local_gateway_virtual_interface_group_id =
            (Util.option_bind
               (Xml.member "localGatewayVirtualInterfaceGroupId" xml)
               String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml)
               LocalGatewayRouteType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               LocalGatewayRouteState.parse);
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse);
          local_gateway_route_table_arn =
            (Util.option_bind (Xml.member "localGatewayRouteTableArn" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableArn", (String.to_query f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f ->
                Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (LocalGatewayRouteState.to_query f)));
           Util.option_map v.type_
             (fun f ->
                Query.Pair ("Type", (LocalGatewayRouteType.to_query f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                Query.Pair
                  ("LocalGatewayVirtualInterfaceGroupId",
                    (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.owner_id
              (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_arn
             (fun f -> ("local_gateway_route_table_arn", (String.to_json f)));
           Util.option_map v.local_gateway_route_table_id
             (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (LocalGatewayRouteState.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (LocalGatewayRouteType.to_json f)));
           Util.option_map v.local_gateway_virtual_interface_group_id
             (fun f ->
                ("local_gateway_virtual_interface_group_id",
                  (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        local_gateway_virtual_interface_group_id =
          (Util.option_map
             (Json.lookup j "local_gateway_virtual_interface_group_id")
             String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_")
             LocalGatewayRouteType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             LocalGatewayRouteState.of_json);
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json);
        local_gateway_route_table_arn =
          (Util.option_map (Json.lookup j "local_gateway_route_table_arn")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json)
      }
  end
module ScheduledInstancesBlockDeviceMappingSet =
  struct
    type t = ScheduledInstancesBlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesBlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesBlockDeviceMapping.to_query v
    let to_json v =
      `List (List.map ScheduledInstancesBlockDeviceMapping.to_json v)
    let of_json j =
      Json.to_list ScheduledInstancesBlockDeviceMapping.of_json j
  end
module ScheduledInstancesIamInstanceProfile =
  struct
    type t = {
      arn: String.t option ;
      name: String.t option }
    let make ?arn  ?name  () = { arn; name }
    let parse xml =
      Some
        {
          arn = (Util.option_bind (Xml.member "Arn" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.arn
             (fun f -> Query.Pair ("Arn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.arn (fun f -> ("arn", (String.to_json f)))])
    let of_json j =
      {
        arn = (Util.option_map (Json.lookup j "arn") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ScheduledInstancesMonitoring =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module ScheduledInstancesNetworkInterfaceSet =
  struct
    type t = ScheduledInstancesNetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstancesNetworkInterface.parse
           (Xml.members "NetworkInterface" xml))
    let to_query v =
      Query.to_query_list ScheduledInstancesNetworkInterface.to_query v
    let to_json v =
      `List (List.map ScheduledInstancesNetworkInterface.to_json v)
    let of_json j = Json.to_list ScheduledInstancesNetworkInterface.of_json j
  end
module ScheduledInstancesPlacement =
  struct
    type t =
      {
      availability_zone: String.t option ;
      group_name: String.t option }
    let make ?availability_zone  ?group_name  () =
      { availability_zone; group_name }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_name
              (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json)
      }
  end
module NatGateway =
  struct
    type t =
      {
      create_time: DateTime.t option ;
      delete_time: DateTime.t option ;
      failure_code: String.t option ;
      failure_message: String.t option ;
      nat_gateway_addresses: NatGatewayAddressList.t ;
      nat_gateway_id: String.t option ;
      provisioned_bandwidth: ProvisionedBandwidth.t option ;
      state: NatGatewayState.t option ;
      subnet_id: String.t option ;
      vpc_id: String.t option ;
      tags: TagList.t }
    let make ?create_time  ?delete_time  ?failure_code  ?failure_message 
      ?(nat_gateway_addresses= [])  ?nat_gateway_id  ?provisioned_bandwidth 
      ?state  ?subnet_id  ?vpc_id  ?(tags= [])  () =
      {
        create_time;
        delete_time;
        failure_code;
        failure_message;
        nat_gateway_addresses;
        nat_gateway_id;
        provisioned_bandwidth;
        state;
        subnet_id;
        vpc_id;
        tags
      }
    let parse xml =
      Some
        {
          create_time =
            (Util.option_bind (Xml.member "createTime" xml) DateTime.parse);
          delete_time =
            (Util.option_bind (Xml.member "deleteTime" xml) DateTime.parse);
          failure_code =
            (Util.option_bind (Xml.member "failureCode" xml) String.parse);
          failure_message =
            (Util.option_bind (Xml.member "failureMessage" xml) String.parse);
          nat_gateway_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewayAddressSet" xml)
                  NatGatewayAddressList.parse));
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          provisioned_bandwidth =
            (Util.option_bind (Xml.member "provisionedBandwidth" xml)
               ProvisionedBandwidth.parse);
          state =
            (Util.option_bind (Xml.member "state" xml) NatGatewayState.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.state
             (fun f -> Query.Pair ("State", (NatGatewayState.to_query f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                Query.Pair
                  ("ProvisionedBandwidth", (ProvisionedBandwidth.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewayAddressSet",
                  (NatGatewayAddressList.to_query v.nat_gateway_addresses)));
           Util.option_map v.failure_message
             (fun f -> Query.Pair ("FailureMessage", (String.to_query f)));
           Util.option_map v.failure_code
             (fun f -> Query.Pair ("FailureCode", (String.to_query f)));
           Util.option_map v.delete_time
             (fun f -> Query.Pair ("DeleteTime", (DateTime.to_query f)));
           Util.option_map v.create_time
             (fun f -> Query.Pair ("CreateTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (NatGatewayState.to_json f)));
           Util.option_map v.provisioned_bandwidth
             (fun f ->
                ("provisioned_bandwidth", (ProvisionedBandwidth.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Some
             ("nat_gateway_addresses",
               (NatGatewayAddressList.to_json v.nat_gateway_addresses));
           Util.option_map v.failure_message
             (fun f -> ("failure_message", (String.to_json f)));
           Util.option_map v.failure_code
             (fun f -> ("failure_code", (String.to_json f)));
           Util.option_map v.delete_time
             (fun f -> ("delete_time", (DateTime.to_json f)));
           Util.option_map v.create_time
             (fun f -> ("create_time", (DateTime.to_json f)))])
    let of_json j =
      {
        create_time =
          (Util.option_map (Json.lookup j "create_time") DateTime.of_json);
        delete_time =
          (Util.option_map (Json.lookup j "delete_time") DateTime.of_json);
        failure_code =
          (Util.option_map (Json.lookup j "failure_code") String.of_json);
        failure_message =
          (Util.option_map (Json.lookup j "failure_message") String.of_json);
        nat_gateway_addresses =
          (NatGatewayAddressList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_addresses")));
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        provisioned_bandwidth =
          (Util.option_map (Json.lookup j "provisioned_bandwidth")
             ProvisionedBandwidth.of_json);
        state =
          (Util.option_map (Json.lookup j "state") NatGatewayState.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module InstanceUsage =
  struct
    type t =
      {
      account_id: String.t option ;
      used_instance_count: Integer.t option }
    let make ?account_id  ?used_instance_count  () =
      { account_id; used_instance_count }
    let parse xml =
      Some
        {
          account_id =
            (Util.option_bind (Xml.member "accountId" xml) String.parse);
          used_instance_count =
            (Util.option_bind (Xml.member "usedInstanceCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f ->
                 Query.Pair ("UsedInstanceCount", (Integer.to_query f)));
           Util.option_map v.account_id
             (fun f -> Query.Pair ("AccountId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.used_instance_count
              (fun f -> ("used_instance_count", (Integer.to_json f)));
           Util.option_map v.account_id
             (fun f -> ("account_id", (String.to_json f)))])
    let of_json j =
      {
        account_id =
          (Util.option_map (Json.lookup j "account_id") String.of_json);
        used_instance_count =
          (Util.option_map (Json.lookup j "used_instance_count")
             Integer.of_json)
      }
  end
module DescribeFastSnapshotRestoreSuccessItem =
  struct
    type t =
      {
      snapshot_id: String.t option ;
      availability_zone: String.t option ;
      state: FastSnapshotRestoreStateCode.t option ;
      state_transition_reason: String.t option ;
      owner_id: String.t option ;
      owner_alias: String.t option ;
      enabling_time: DateTime.t option ;
      optimizing_time: DateTime.t option ;
      enabled_time: DateTime.t option ;
      disabling_time: DateTime.t option ;
      disabled_time: DateTime.t option }
    let make ?snapshot_id  ?availability_zone  ?state 
      ?state_transition_reason  ?owner_id  ?owner_alias  ?enabling_time 
      ?optimizing_time  ?enabled_time  ?disabling_time  ?disabled_time  () =
      {
        snapshot_id;
        availability_zone;
        state;
        state_transition_reason;
        owner_id;
        owner_alias;
        enabling_time;
        optimizing_time;
        enabled_time;
        disabling_time;
        disabled_time
      }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               FastSnapshotRestoreStateCode.parse);
          state_transition_reason =
            (Util.option_bind (Xml.member "stateTransitionReason" xml)
               String.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          owner_alias =
            (Util.option_bind (Xml.member "ownerAlias" xml) String.parse);
          enabling_time =
            (Util.option_bind (Xml.member "enablingTime" xml) DateTime.parse);
          optimizing_time =
            (Util.option_bind (Xml.member "optimizingTime" xml)
               DateTime.parse);
          enabled_time =
            (Util.option_bind (Xml.member "enabledTime" xml) DateTime.parse);
          disabling_time =
            (Util.option_bind (Xml.member "disablingTime" xml) DateTime.parse);
          disabled_time =
            (Util.option_bind (Xml.member "disabledTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> Query.Pair ("DisabledTime", (DateTime.to_query f)));
           Util.option_map v.disabling_time
             (fun f -> Query.Pair ("DisablingTime", (DateTime.to_query f)));
           Util.option_map v.enabled_time
             (fun f -> Query.Pair ("EnabledTime", (DateTime.to_query f)));
           Util.option_map v.optimizing_time
             (fun f -> Query.Pair ("OptimizingTime", (DateTime.to_query f)));
           Util.option_map v.enabling_time
             (fun f -> Query.Pair ("EnablingTime", (DateTime.to_query f)));
           Util.option_map v.owner_alias
             (fun f -> Query.Pair ("OwnerAlias", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.state_transition_reason
             (fun f ->
                Query.Pair ("StateTransitionReason", (String.to_query f)));
           Util.option_map v.state
             (fun f ->
                Query.Pair
                  ("State", (FastSnapshotRestoreStateCode.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.disabled_time
              (fun f -> ("disabled_time", (DateTime.to_json f)));
           Util.option_map v.disabling_time
             (fun f -> ("disabling_time", (DateTime.to_json f)));
           Util.option_map v.enabled_time
             (fun f -> ("enabled_time", (DateTime.to_json f)));
           Util.option_map v.optimizing_time
             (fun f -> ("optimizing_time", (DateTime.to_json f)));
           Util.option_map v.enabling_time
             (fun f -> ("enabling_time", (DateTime.to_json f)));
           Util.option_map v.owner_alias
             (fun f -> ("owner_alias", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.state_transition_reason
             (fun f -> ("state_transition_reason", (String.to_json f)));
           Util.option_map v.state
             (fun f -> ("state", (FastSnapshotRestoreStateCode.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             FastSnapshotRestoreStateCode.of_json);
        state_transition_reason =
          (Util.option_map (Json.lookup j "state_transition_reason")
             String.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        owner_alias =
          (Util.option_map (Json.lookup j "owner_alias") String.of_json);
        enabling_time =
          (Util.option_map (Json.lookup j "enabling_time") DateTime.of_json);
        optimizing_time =
          (Util.option_map (Json.lookup j "optimizing_time") DateTime.of_json);
        enabled_time =
          (Util.option_map (Json.lookup j "enabled_time") DateTime.of_json);
        disabling_time =
          (Util.option_map (Json.lookup j "disabling_time") DateTime.of_json);
        disabled_time =
          (Util.option_map (Json.lookup j "disabled_time") DateTime.of_json)
      }
  end
module EgressOnlyInternetGateway =
  struct
    type t =
      {
      attachments: InternetGatewayAttachmentList.t ;
      egress_only_internet_gateway_id: String.t option ;
      tags: TagList.t }
    let make ?(attachments= [])  ?egress_only_internet_gateway_id  ?(tags=
      [])  () = { attachments; egress_only_internet_gateway_id; tags }
    let parse xml =
      Some
        {
          attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "attachmentSet" xml)
                  InternetGatewayAttachmentList.parse));
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("AttachmentSet",
                  (InternetGatewayAttachmentList.to_query v.attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Some
             ("attachments",
               (InternetGatewayAttachmentList.to_json v.attachments))])
    let of_json j =
      {
        attachments =
          (InternetGatewayAttachmentList.of_json
             (Util.of_option_exn (Json.lookup j "attachments")));
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module LoadPermissionListRequest =
  struct
    type t = LoadPermissionRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LoadPermissionRequest.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LoadPermissionRequest.to_query v
    let to_json v = `List (List.map LoadPermissionRequest.to_json v)
    let of_json j = Json.to_list LoadPermissionRequest.of_json j
  end
module CapacityReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module FilterList =
  struct
    type t = Filter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Filter.parse (Xml.members "Filter" xml))
    let to_query v = Query.to_query_list Filter.to_query v
    let to_json v = `List (List.map Filter.to_json v)
    let of_json j = Json.to_list Filter.of_json j
  end
module BlockDeviceMappingRequestList =
  struct
    type t = BlockDeviceMapping.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map BlockDeviceMapping.parse
           (Xml.members "BlockDeviceMapping" xml))
    let to_query v = Query.to_query_list BlockDeviceMapping.to_query v
    let to_json v = `List (List.map BlockDeviceMapping.to_json v)
    let of_json j = Json.to_list BlockDeviceMapping.of_json j
  end
module TagDescriptionList =
  struct
    type t = TagDescription.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TagDescription.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TagDescription.to_query v
    let to_json v = `List (List.map TagDescription.to_json v)
    let of_json j = Json.to_list TagDescription.of_json j
  end
module DhcpOptionsList =
  struct
    type t = DhcpOptions.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DhcpOptions.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DhcpOptions.to_query v
    let to_json v = `List (List.map DhcpOptions.to_json v)
    let of_json j = Json.to_list DhcpOptions.of_json j
  end
module VpnGatewayList =
  struct
    type t = VpnGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnGateway.to_query v
    let to_json v = `List (List.map VpnGateway.to_json v)
    let of_json j = Json.to_list VpnGateway.of_json j
  end
module TransitGatewayAttachmentPropagationList =
  struct
    type t = TransitGatewayAttachmentPropagation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachmentPropagation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayAttachmentPropagation.to_query v
    let to_json v =
      `List (List.map TransitGatewayAttachmentPropagation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayAttachmentPropagation.of_json j
  end
module CapacityReservationSet =
  struct
    type t = CapacityReservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CapacityReservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CapacityReservation.to_query v
    let to_json v = `List (List.map CapacityReservation.to_json v)
    let of_json j = Json.to_list CapacityReservation.of_json j
  end
module ElasticGpuIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesModificationList =
  struct
    type t = ReservedInstancesModification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesModification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesModification.to_query v
    let to_json v = `List (List.map ReservedInstancesModification.to_json v)
    let of_json j = Json.to_list ReservedInstancesModification.of_json j
  end
module PlacementGroupList =
  struct
    type t = PlacementGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PlacementGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PlacementGroup.to_query v
    let to_json v = `List (List.map PlacementGroup.to_json v)
    let of_json j = Json.to_list PlacementGroup.of_json j
  end
module TransitGatewayRouteTablePropagationList =
  struct
    type t = TransitGatewayRouteTablePropagation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTablePropagation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteTablePropagation.to_query v
    let to_json v =
      `List (List.map TransitGatewayRouteTablePropagation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayRouteTablePropagation.of_json j
  end
module KeyPairList =
  struct
    type t = KeyPairInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map KeyPairInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list KeyPairInfo.to_query v
    let to_json v = `List (List.map KeyPairInfo.to_json v)
    let of_json j = Json.to_list KeyPairInfo.of_json j
  end
module ValidationWarning =
  struct
    type t = {
      errors: ErrorSet.t }
    let make ?(errors= [])  () = { errors }
    let parse xml =
      Some
        {
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml) ErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ErrorSet", (ErrorSet.to_query v.errors)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("errors", (ErrorSet.to_json v.errors))])
    let of_json j =
      {
        errors =
          (ErrorSet.of_json (Util.of_option_exn (Json.lookup j "errors")))
      }
  end
module HistoryRecordSet =
  struct
    type t = HistoryRecordEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map HistoryRecordEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HistoryRecordEntry.to_query v
    let to_json v = `List (List.map HistoryRecordEntry.to_json v)
    let of_json j = Json.to_list HistoryRecordEntry.of_json j
  end
module HostReservationSet =
  struct
    type t = HostReservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map HostReservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostReservation.to_query v
    let to_json v = `List (List.map HostReservation.to_json v)
    let of_json j = Json.to_list HostReservation.of_json j
  end
module LaunchPermissionModifications =
  struct
    type t = {
      add: LaunchPermissionList.t ;
      remove: LaunchPermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LaunchPermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LaunchPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LaunchPermissionList.to_query v.remove)));
           Some (Query.Pair ("Add", (LaunchPermissionList.to_query v.add)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LaunchPermissionList.to_json v.remove));
           Some ("add", (LaunchPermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module OperationType =
  struct
    type t =
      | Add 
      | Remove 
    let str_to_t = [("remove", Remove); ("add", Add)]
    let t_to_str = [(Remove, "remove"); (Add, "add")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ProductCodeStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ProductCode" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserGroup" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UserIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "UserId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceAttributeName =
  struct
    type t =
      | InstanceType 
      | Kernel 
      | Ramdisk 
      | UserData 
      | DisableApiTermination 
      | InstanceInitiatedShutdownBehavior 
      | RootDeviceName 
      | BlockDeviceMapping 
      | ProductCodes 
      | SourceDestCheck 
      | GroupSet 
      | EbsOptimized 
      | SriovNetSupport 
      | EnaSupport 
      | EnclaveOptions 
    let str_to_t =
      [("enclaveOptions", EnclaveOptions);
      ("enaSupport", EnaSupport);
      ("sriovNetSupport", SriovNetSupport);
      ("ebsOptimized", EbsOptimized);
      ("groupSet", GroupSet);
      ("sourceDestCheck", SourceDestCheck);
      ("productCodes", ProductCodes);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("rootDeviceName", RootDeviceName);
      ("instanceInitiatedShutdownBehavior",
        InstanceInitiatedShutdownBehavior);
      ("disableApiTermination", DisableApiTermination);
      ("userData", UserData);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("instanceType", InstanceType)]
    let t_to_str =
      [(EnclaveOptions, "enclaveOptions");
      (EnaSupport, "enaSupport");
      (SriovNetSupport, "sriovNetSupport");
      (EbsOptimized, "ebsOptimized");
      (GroupSet, "groupSet");
      (SourceDestCheck, "sourceDestCheck");
      (ProductCodes, "productCodes");
      (BlockDeviceMapping, "blockDeviceMapping");
      (RootDeviceName, "rootDeviceName");
      (InstanceInitiatedShutdownBehavior,
        "instanceInitiatedShutdownBehavior");
      (DisableApiTermination, "disableApiTermination");
      (UserData, "userData");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (InstanceType, "instanceType")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module RequestHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CreateTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option ;
      appliance_mode_support: ApplianceModeSupportValue.t option }
    let make ?dns_support  ?ipv6_support  ?appliance_mode_support  () =
      { dns_support; ipv6_support; appliance_mode_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse);
          appliance_mode_support =
            (Util.option_bind (Xml.member "ApplianceModeSupport" xml)
               ApplianceModeSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 Query.Pair
                   ("ApplianceModeSupport",
                     (ApplianceModeSupportValue.to_query f)));
           Util.option_map v.ipv6_support
             (fun f ->
                Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 ("appliance_mode_support",
                   (ApplianceModeSupportValue.to_json f)));
           Util.option_map v.ipv6_support
             (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json);
        appliance_mode_support =
          (Util.option_map (Json.lookup j "appliance_mode_support")
             ApplianceModeSupportValue.of_json)
      }
  end
module TransitGatewaySubnetIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LocalGatewayIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesConfigurationList =
  struct
    type t = ReservedInstancesConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesConfiguration.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstancesConfiguration.to_query v
    let to_json v = `List (List.map ReservedInstancesConfiguration.to_json v)
    let of_json j = Json.to_list ReservedInstancesConfiguration.of_json j
  end
module ReservedInstancesIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstancesId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcEndpointConnectionSet =
  struct
    type t = VpcEndpointConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcEndpointConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcEndpointConnection.to_query v
    let to_json v = `List (List.map VpcEndpointConnection.to_json v)
    let of_json j = Json.to_list VpcEndpointConnection.of_json j
  end
module GroupNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ExportImageTaskList =
  struct
    type t = ExportImageTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ExportImageTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ExportImageTask.to_query v
    let to_json v = `List (List.map ExportImageTask.to_json v)
    let of_json j = Json.to_list ExportImageTask.of_json j
  end
module ExportTaskS3LocationRequest =
  struct
    type t = {
      s3_bucket: String.t ;
      s3_prefix: String.t option }
    let make ~s3_bucket  ?s3_prefix  () = { s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          s3_bucket =
            (Xml.required "S3Bucket"
               (Util.option_bind (Xml.member "S3Bucket" xml) String.parse));
          s3_prefix =
            (Util.option_bind (Xml.member "S3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Some (Query.Pair ("S3Bucket", (String.to_query v.s3_bucket)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Some ("s3_bucket", (String.to_json v.s3_bucket))])
    let of_json j =
      {
        s3_bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "s3_bucket")));
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module RequestSpotLaunchSpecification =
  struct
    type t =
      {
      security_group_ids: RequestSpotLaunchSpecificationSecurityGroupIdList.t ;
      security_groups: RequestSpotLaunchSpecificationSecurityGroupList.t ;
      addressing_type: String.t option ;
      block_device_mappings: BlockDeviceMappingList.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      placement: SpotPlacement.t option ;
      ramdisk_id: String.t option ;
      subnet_id: String.t option ;
      user_data: String.t option }
    let make ?(security_group_ids= [])  ?(security_groups= []) 
      ?addressing_type  ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ?image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?subnet_id  ?user_data  () =
      {
        security_group_ids;
        security_groups;
        addressing_type;
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  RequestSpotLaunchSpecificationSecurityGroupIdList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  RequestSpotLaunchSpecificationSecurityGroupList.parse));
          addressing_type =
            (Util.option_bind (Xml.member "addressingType" xml) String.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          placement =
            (Util.option_bind (Xml.member "placement" xml)
               SpotPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (SpotPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)));
           Util.option_map v.addressing_type
             (fun f -> Query.Pair ("AddressingType", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (RequestSpotLaunchSpecificationSecurityGroupList.to_query
                     v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (RequestSpotLaunchSpecificationSecurityGroupIdList.to_query
                     v.security_group_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (SpotPlacement.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings));
           Util.option_map v.addressing_type
             (fun f -> ("addressing_type", (String.to_json f)));
           Some
             ("security_groups",
               (RequestSpotLaunchSpecificationSecurityGroupList.to_json
                  v.security_groups));
           Some
             ("security_group_ids",
               (RequestSpotLaunchSpecificationSecurityGroupIdList.to_json
                  v.security_group_ids))])
    let of_json j =
      {
        security_group_ids =
          (RequestSpotLaunchSpecificationSecurityGroupIdList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (RequestSpotLaunchSpecificationSecurityGroupList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        addressing_type =
          (Util.option_map (Json.lookup j "addressing_type") String.of_json);
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement") SpotPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json)
      }
  end
module AssociatedRolesList =
  struct
    type t = AssociatedRole.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssociatedRole.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AssociatedRole.to_query v
    let to_json v = `List (List.map AssociatedRole.to_json v)
    let of_json j = Json.to_list AssociatedRole.of_json j
  end
module UnsuccessfulItemSet =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let of_json j = Json.to_list UnsuccessfulItem.of_json j
  end
module Status =
  struct
    type t =
      | MoveInProgress 
      | InVpc 
      | InClassic 
    let str_to_t =
      [("InClassic", InClassic);
      ("InVpc", InVpc);
      ("MoveInProgress", MoveInProgress)]
    let t_to_str =
      [(InClassic, "InClassic");
      (InVpc, "InVpc");
      (MoveInProgress, "MoveInProgress")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayRouteTableIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TrafficMirrorFilterSet =
  struct
    type t = TrafficMirrorFilter.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilter.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorFilter.to_query v
    let to_json v = `List (List.map TrafficMirrorFilter.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilter.of_json j
  end
module TrafficMirrorTargetIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PrivateIpAddressStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "PrivateIpAddress" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotFleetRequestIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PrefixListEntrySet =
  struct
    type t = PrefixListEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrefixListEntry.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixListEntry.to_query v
    let to_json v = `List (List.map PrefixListEntry.to_json v)
    let of_json j = Json.to_list PrefixListEntry.of_json j
  end
module Ipv6PoolIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayList =
  struct
    type t = TransitGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGateway.to_query v
    let to_json v = `List (List.map TransitGateway.to_json v)
    let of_json j = Json.to_list TransitGateway.of_json j
  end
module InstanceTagNotificationAttribute =
  struct
    type t =
      {
      instance_tag_keys: InstanceTagKeySet.t ;
      include_all_tags_of_instance: Boolean.t option }
    let make ?(instance_tag_keys= [])  ?include_all_tags_of_instance  () =
      { instance_tag_keys; include_all_tags_of_instance }
    let parse xml =
      Some
        {
          instance_tag_keys =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTagKeySet" xml)
                  InstanceTagKeySet.parse));
          include_all_tags_of_instance =
            (Util.option_bind (Xml.member "includeAllTagsOfInstance" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.include_all_tags_of_instance
              (fun f ->
                 Query.Pair
                   ("IncludeAllTagsOfInstance", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceTagKeySet",
                  (InstanceTagKeySet.to_query v.instance_tag_keys)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.include_all_tags_of_instance
              (fun f -> ("include_all_tags_of_instance", (Boolean.to_json f)));
           Some
             ("instance_tag_keys",
               (InstanceTagKeySet.to_json v.instance_tag_keys))])
    let of_json j =
      {
        instance_tag_keys =
          (InstanceTagKeySet.of_json
             (Util.of_option_exn (Json.lookup j "instance_tag_keys")));
        include_all_tags_of_instance =
          (Util.option_map (Json.lookup j "include_all_tags_of_instance")
             Boolean.of_json)
      }
  end
module ClientConnectOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      lambda_function_arn: String.t option }
    let make ?enabled  ?lambda_function_arn  () =
      { enabled; lambda_function_arn }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          lambda_function_arn =
            (Util.option_bind (Xml.member "LambdaFunctionArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.lambda_function_arn
              (fun f -> Query.Pair ("LambdaFunctionArn", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.lambda_function_arn
              (fun f -> ("lambda_function_arn", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        lambda_function_arn =
          (Util.option_map (Json.lookup j "lambda_function_arn")
             String.of_json)
      }
  end
module ClientVpnAuthenticationRequestList =
  struct
    type t = ClientVpnAuthenticationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnAuthenticationRequest.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list ClientVpnAuthenticationRequest.to_query v
    let to_json v = `List (List.map ClientVpnAuthenticationRequest.to_json v)
    let of_json j = Json.to_list ClientVpnAuthenticationRequest.of_json j
  end
module ConnectionLogOptions =
  struct
    type t =
      {
      enabled: Boolean.t option ;
      cloudwatch_log_group: String.t option ;
      cloudwatch_log_stream: String.t option }
    let make ?enabled  ?cloudwatch_log_group  ?cloudwatch_log_stream  () =
      { enabled; cloudwatch_log_group; cloudwatch_log_stream }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse);
          cloudwatch_log_group =
            (Util.option_bind (Xml.member "CloudwatchLogGroup" xml)
               String.parse);
          cloudwatch_log_stream =
            (Util.option_bind (Xml.member "CloudwatchLogStream" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f ->
                 Query.Pair ("CloudwatchLogStream", (String.to_query f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> Query.Pair ("CloudwatchLogGroup", (String.to_query f)));
           Util.option_map v.enabled
             (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cloudwatch_log_stream
              (fun f -> ("cloudwatch_log_stream", (String.to_json f)));
           Util.option_map v.cloudwatch_log_group
             (fun f -> ("cloudwatch_log_group", (String.to_json f)));
           Util.option_map v.enabled
             (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      {
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json);
        cloudwatch_log_group =
          (Util.option_map (Json.lookup j "cloudwatch_log_group")
             String.of_json);
        cloudwatch_log_stream =
          (Util.option_map (Json.lookup j "cloudwatch_log_stream")
             String.of_json)
      }
  end
module SelfServicePortal =
  struct
    type t =
      | Enabled 
      | Disabled 
    let str_to_t = [("disabled", Disabled); ("enabled", Enabled)]
    let t_to_str = [(Disabled, "disabled"); (Enabled, "enabled")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TransitGatewayPropagation =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      transit_gateway_route_table_id: String.t option ;
      state: TransitGatewayPropagationState.t option }
    let make ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?transit_gateway_route_table_id  ?state  () =
      {
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        transit_gateway_route_table_id;
        state
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayPropagationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayPropagationState.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayPropagationState.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayPropagationState.of_json)
      }
  end
module ClassicLinkDnsSupportList =
  struct
    type t = ClassicLinkDnsSupport.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLinkDnsSupport.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLinkDnsSupport.to_query v
    let to_json v = `List (List.map ClassicLinkDnsSupport.to_json v)
    let of_json j = Json.to_list ClassicLinkDnsSupport.of_json j
  end
module ImportSnapshotTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ImportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ManagedPrefixListSet =
  struct
    type t = ManagedPrefixList.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ManagedPrefixList.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ManagedPrefixList.to_query v
    let to_json v = `List (List.map ManagedPrefixList.to_json v)
    let of_json j = Json.to_list ManagedPrefixList.of_json j
  end
module ReservedInstancesListingList =
  struct
    type t = ReservedInstancesListing.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesListing.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesListing.to_query v
    let to_json v = `List (List.map ReservedInstancesListing.to_json v)
    let of_json j = Json.to_list ReservedInstancesListing.of_json j
  end
module VpcEndpointIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceStateChangeList =
  struct
    type t = InstanceStateChange.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStateChange.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStateChange.to_query v
    let to_json v = `List (List.map InstanceStateChange.to_json v)
    let of_json j = Json.to_list InstanceStateChange.of_json j
  end
module AddPrefixListEntries =
  struct
    type t = AddPrefixListEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AddPrefixListEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list AddPrefixListEntry.to_query v
    let to_json v = `List (List.map AddPrefixListEntry.to_json v)
    let of_json j = Json.to_list AddPrefixListEntry.of_json j
  end
module ClientCertificateRevocationListStatus =
  struct
    type t =
      {
      code: ClientCertificateRevocationListStatusCode.t option ;
      message: String.t option }
    let make ?code  ?message  () = { code; message }
    let parse xml =
      Some
        {
          code =
            (Util.option_bind (Xml.member "code" xml)
               ClientCertificateRevocationListStatusCode.parse);
          message =
            (Util.option_bind (Xml.member "message" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> Query.Pair ("Message", (String.to_query f)));
           Util.option_map v.code
             (fun f ->
                Query.Pair
                  ("Code",
                    (ClientCertificateRevocationListStatusCode.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.message
              (fun f -> ("message", (String.to_json f)));
           Util.option_map v.code
             (fun f ->
                ("code",
                  (ClientCertificateRevocationListStatusCode.to_json f)))])
    let of_json j =
      {
        code =
          (Util.option_map (Json.lookup j "code")
             ClientCertificateRevocationListStatusCode.of_json);
        message = (Util.option_map (Json.lookup j "message") String.of_json)
      }
  end
module TerminateConnectionStatusSet =
  struct
    type t = TerminateConnectionStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TerminateConnectionStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TerminateConnectionStatus.to_query v
    let to_json v = `List (List.map TerminateConnectionStatus.to_json v)
    let of_json j = Json.to_list TerminateConnectionStatus.of_json j
  end
module InstanceTypeOfferingsList =
  struct
    type t = InstanceTypeOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceTypeOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceTypeOffering.to_query v
    let to_json v = `List (List.map InstanceTypeOffering.to_json v)
    let of_json j = Json.to_list InstanceTypeOffering.of_json j
  end
module InstanceStatusList =
  struct
    type t = InstanceStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceStatus.to_query v
    let to_json v = `List (List.map InstanceStatus.to_json v)
    let of_json j = Json.to_list InstanceStatus.of_json j
  end
module TransitGatewayPrefixListReferenceSet =
  struct
    type t = TransitGatewayPrefixListReference.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayPrefixListReference.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayPrefixListReference.to_query v
    let to_json v =
      `List (List.map TransitGatewayPrefixListReference.to_json v)
    let of_json j = Json.to_list TransitGatewayPrefixListReference.of_json j
  end
module ImageList =
  struct
    type t = Image.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Image.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Image.to_query v
    let to_json v = `List (List.map Image.to_json v)
    let of_json j = Json.to_list Image.of_json j
  end
module VpcEndpointServiceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PriceScheduleSpecificationList =
  struct
    type t = PriceScheduleSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PriceScheduleSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list PriceScheduleSpecification.to_query v
    let to_json v = `List (List.map PriceScheduleSpecification.to_json v)
    let of_json j = Json.to_list PriceScheduleSpecification.of_json j
  end
module ImportSnapshotTaskList =
  struct
    type t = ImportSnapshotTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportSnapshotTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportSnapshotTask.to_query v
    let to_json v = `List (List.map ImportSnapshotTask.to_json v)
    let of_json j = Json.to_list ImportSnapshotTask.of_json j
  end
module NetworkInterfacePermissionList =
  struct
    type t = NetworkInterfacePermission.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterfacePermission.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list NetworkInterfacePermission.to_query v
    let to_json v = `List (List.map NetworkInterfacePermission.to_json v)
    let of_json j = Json.to_list NetworkInterfacePermission.of_json j
  end
module SpotInstanceRequestIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "SpotInstanceRequestId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayAssociation =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      state: TransitGatewayAssociationState.t option }
    let make ?transit_gateway_route_table_id  ?transit_gateway_attachment_id 
      ?resource_id  ?resource_type  ?state  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        state
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Util.option_bind (Xml.member "transitGatewayRouteTableId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               TransitGatewayAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair
                   ("State", (TransitGatewayAssociationState.to_query f)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayRouteTableId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (TransitGatewayAssociationState.to_json f)));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_route_table_id
             (fun f -> ("transit_gateway_route_table_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (Util.option_map (Json.lookup j "transit_gateway_route_table_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             TransitGatewayAssociationState.of_json)
      }
  end
module InstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_json v = `List (List.map InstanceType.to_json v)
    let of_json j = Json.to_list InstanceType.of_json j
  end
module ProductDescriptionList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResponseHostIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module HostList =
  struct
    type t = Host.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Host.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Host.to_query v
    let to_json v = `List (List.map Host.to_json v)
    let of_json j = Json.to_list Host.of_json j
  end
module CustomerGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "CustomerGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastDomainAssociations =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      resource_id: String.t option ;
      resource_type: TransitGatewayAttachmentResourceType.t option ;
      subnets: SubnetAssociationList.t }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?resource_id  ?resource_type 
      ?(subnets= [])  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        resource_id;
        resource_type;
        subnets
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "transitGatewayAttachmentId" xml)
               String.parse);
          resource_id =
            (Util.option_bind (Xml.member "resourceId" xml) String.parse);
          resource_type =
            (Util.option_bind (Xml.member "resourceType" xml)
               TransitGatewayAttachmentResourceType.parse);
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnets" xml)
                  SubnetAssociationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Subnets", (SubnetAssociationList.to_query v.subnets)));
           Util.option_map v.resource_type
             (fun f ->
                Query.Pair
                  ("ResourceType",
                    (TransitGatewayAttachmentResourceType.to_query f)));
           Util.option_map v.resource_id
             (fun f -> Query.Pair ("ResourceId", (String.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnets", (SubnetAssociationList.to_json v.subnets));
           Util.option_map v.resource_type
             (fun f ->
                ("resource_type",
                  (TransitGatewayAttachmentResourceType.to_json f)));
           Util.option_map v.resource_id
             (fun f -> ("resource_id", (String.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        resource_id =
          (Util.option_map (Json.lookup j "resource_id") String.of_json);
        resource_type =
          (Util.option_map (Json.lookup j "resource_type")
             TransitGatewayAttachmentResourceType.of_json);
        subnets =
          (SubnetAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "subnets")))
      }
  end
module LaunchTemplateSet =
  struct
    type t = LaunchTemplate.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplate.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplate.to_query v
    let to_json v = `List (List.map LaunchTemplate.to_json v)
    let of_json j = Json.to_list LaunchTemplate.of_json j
  end
module PrefixListSet =
  struct
    type t = PrefixList.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map PrefixList.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixList.to_query v
    let to_json v = `List (List.map PrefixList.to_json v)
    let of_json j = Json.to_list PrefixList.of_json j
  end
module TrafficMirrorSessionIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpnConnectionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnConnectionId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceFamilyCreditSpecification =
  struct
    type t =
      {
      instance_family: UnlimitedSupportedInstanceFamily.t option ;
      cpu_credits: String.t option }
    let make ?instance_family  ?cpu_credits  () =
      { instance_family; cpu_credits }
    let parse xml =
      Some
        {
          instance_family =
            (Util.option_bind (Xml.member "instanceFamily" xml)
               UnlimitedSupportedInstanceFamily.parse);
          cpu_credits =
            (Util.option_bind (Xml.member "cpuCredits" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> Query.Pair ("CpuCredits", (String.to_query f)));
           Util.option_map v.instance_family
             (fun f ->
                Query.Pair
                  ("InstanceFamily",
                    (UnlimitedSupportedInstanceFamily.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.cpu_credits
              (fun f -> ("cpu_credits", (String.to_json f)));
           Util.option_map v.instance_family
             (fun f ->
                ("instance_family",
                  (UnlimitedSupportedInstanceFamily.to_json f)))])
    let of_json j =
      {
        instance_family =
          (Util.option_map (Json.lookup j "instance_family")
             UnlimitedSupportedInstanceFamily.of_json);
        cpu_credits =
          (Util.option_map (Json.lookup j "cpu_credits") String.of_json)
      }
  end
module ActiveInstanceSet =
  struct
    type t = ActiveInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ActiveInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ActiveInstance.to_query v
    let to_json v = `List (List.map ActiveInstance.to_json v)
    let of_json j = Json.to_list ActiveInstance.of_json j
  end
module SnapshotAttributeName =
  struct
    type t =
      | ProductCodes 
      | CreateVolumePermission 
    let str_to_t =
      [("createVolumePermission", CreateVolumePermission);
      ("productCodes", ProductCodes)]
    let t_to_str =
      [(CreateVolumePermission, "createVolumePermission");
      (ProductCodes, "productCodes")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module AttributeBooleanValue =
  struct
    type t = {
      value: Boolean.t option }
    let make ?value  () = { value }
    let parse xml =
      Some
        { value = (Util.option_bind (Xml.member "value" xml) Boolean.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Boolean.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Boolean.of_json) }
  end
module BlobAttributeValue =
  struct
    type t = {
      value: Blob.t option }
    let make ?value  () = { value }
    let parse xml =
      Some { value = (Util.option_bind (Xml.member "value" xml) Blob.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (Blob.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (Blob.to_json f)))])
    let of_json j =
      { value = (Util.option_map (Json.lookup j "value") Blob.of_json) }
  end
module InstanceBlockDeviceMappingSpecificationList =
  struct
    type t = InstanceBlockDeviceMappingSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceBlockDeviceMappingSpecification.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceBlockDeviceMappingSpecification.to_query v
    let to_json v =
      `List (List.map InstanceBlockDeviceMappingSpecification.to_json v)
    let of_json j =
      Json.to_list InstanceBlockDeviceMappingSpecification.of_json j
  end
module FpgaImageAttribute =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      name: String.t option ;
      description: String.t option ;
      load_permissions: LoadPermissionList.t ;
      product_codes: ProductCodeList.t }
    let make ?fpga_image_id  ?name  ?description  ?(load_permissions= []) 
      ?(product_codes= [])  () =
      { fpga_image_id; name; description; load_permissions; product_codes }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          name = (Util.option_bind (Xml.member "name" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          load_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "loadPermissions" xml)
                  LoadPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LoadPermissions",
                  (LoadPermissionList.to_query v.load_permissions)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("load_permissions",
               (LoadPermissionList.to_json v.load_permissions));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        load_permissions =
          (LoadPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "load_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")))
      }
  end
module CopyTagsFromSource =
  struct
    type t =
      | Volume 
    let str_to_t = [("volume", Volume)]
    let t_to_str = [(Volume, "volume")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceSpecification =
  struct
    type t =
      {
      instance_id: String.t option ;
      exclude_boot_volume: Boolean.t option }
    let make ?instance_id  ?exclude_boot_volume  () =
      { instance_id; exclude_boot_volume }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          exclude_boot_volume =
            (Util.option_bind (Xml.member "ExcludeBootVolume" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f ->
                 Query.Pair ("ExcludeBootVolume", (Boolean.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exclude_boot_volume
              (fun f -> ("exclude_boot_volume", (Boolean.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        exclude_boot_volume =
          (Util.option_map (Json.lookup j "exclude_boot_volume")
             Boolean.of_json)
      }
  end
module ZoneIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ZoneNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ZoneName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InstanceIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "InstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastDomainList =
  struct
    type t = TransitGatewayMulticastDomain.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomain.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomain.to_query v
    let to_json v = `List (List.map TransitGatewayMulticastDomain.to_json v)
    let of_json j = Json.to_list TransitGatewayMulticastDomain.of_json j
  end
module PrincipalIdFormatList =
  struct
    type t = PrincipalIdFormat.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrincipalIdFormat.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrincipalIdFormat.to_query v
    let to_json v = `List (List.map PrincipalIdFormat.to_json v)
    let of_json j = Json.to_list PrincipalIdFormat.of_json j
  end
module TransitGatewayNetworkInterfaceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpnGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "VpnGatewayId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AllowedPrincipalSet =
  struct
    type t = AllowedPrincipal.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AllowedPrincipal.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AllowedPrincipal.to_query v
    let to_json v = `List (List.map AllowedPrincipal.to_json v)
    let of_json j = Json.to_list AllowedPrincipal.of_json j
  end
module ByoipCidrSet =
  struct
    type t = ByoipCidr.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ByoipCidr.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ByoipCidr.to_query v
    let to_json v = `List (List.map ByoipCidr.to_json v)
    let of_json j = Json.to_list ByoipCidr.of_json j
  end
module CoipPoolSet =
  struct
    type t = CoipPool.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map CoipPool.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CoipPool.to_query v
    let to_json v = `List (List.map CoipPool.to_json v)
    let of_json j = Json.to_list CoipPool.of_json j
  end
module SpotDatafeedSubscription =
  struct
    type t =
      {
      bucket: String.t option ;
      fault: SpotInstanceStateFault.t option ;
      owner_id: String.t option ;
      prefix: String.t option ;
      state: DatafeedSubscriptionState.t option }
    let make ?bucket  ?fault  ?owner_id  ?prefix  ?state  () =
      { bucket; fault; owner_id; prefix; state }
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "bucket" xml) String.parse);
          fault =
            (Util.option_bind (Xml.member "fault" xml)
               SpotInstanceStateFault.parse);
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               DatafeedSubscriptionState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f ->
                 Query.Pair ("State", (DatafeedSubscriptionState.to_query f)));
           Util.option_map v.prefix
             (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)));
           Util.option_map v.fault
             (fun f ->
                Query.Pair ("Fault", (SpotInstanceStateFault.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> ("state", (DatafeedSubscriptionState.to_json f)));
           Util.option_map v.prefix (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)));
           Util.option_map v.fault
             (fun f -> ("fault", (SpotInstanceStateFault.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let of_json j =
      {
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        fault =
          (Util.option_map (Json.lookup j "fault")
             SpotInstanceStateFault.of_json);
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             DatafeedSubscriptionState.of_json)
      }
  end
module DeleteFleetErrorSet =
  struct
    type t = DeleteFleetErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteFleetErrorItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DeleteFleetErrorItem.to_query v
    let to_json v = `List (List.map DeleteFleetErrorItem.to_json v)
    let of_json j = Json.to_list DeleteFleetErrorItem.of_json j
  end
module DeleteFleetSuccessSet =
  struct
    type t = DeleteFleetSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteFleetSuccessItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list DeleteFleetSuccessItem.to_query v
    let to_json v = `List (List.map DeleteFleetSuccessItem.to_json v)
    let of_json j = Json.to_list DeleteFleetSuccessItem.of_json j
  end
module DisableFastSnapshotRestoreErrorSet =
  struct
    type t = DisableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreErrorItem.to_query v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreErrorItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreErrorItem.of_json j
  end
module DisableFastSnapshotRestoreSuccessSet =
  struct
    type t = DisableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DisableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DisableFastSnapshotRestoreSuccessItem.to_query v
    let to_json v =
      `List (List.map DisableFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list DisableFastSnapshotRestoreSuccessItem.of_json j
  end
module ReservedInstancesModificationIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse
           (Xml.members "ReservedInstancesModificationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestInstanceTypeList =
  struct
    type t = InstanceType.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceType.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list InstanceType.to_query v
    let to_json v = `List (List.map InstanceType.to_json v)
    let of_json j = Json.to_list InstanceType.of_json j
  end
module PlacementGroupIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "GroupId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PlacementGroupStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Ipv6AddressList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let of_json j = Json.to_list ScheduledInstance.of_json j
  end
module FlowLogSet =
  struct
    type t = FlowLog.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FlowLog.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FlowLog.to_query v
    let to_json v = `List (List.map FlowLog.to_json v)
    let of_json j = Json.to_list FlowLog.of_json j
  end
module BundleTaskList =
  struct
    type t = BundleTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map BundleTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list BundleTask.to_query v
    let to_json v = `List (List.map BundleTask.to_json v)
    let of_json j = Json.to_list BundleTask.of_json j
  end
module InstanceCreditSpecificationList =
  struct
    type t = InstanceCreditSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecification.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceCreditSpecification.to_query v
    let to_json v = `List (List.map InstanceCreditSpecification.to_json v)
    let of_json j = Json.to_list InstanceCreditSpecification.of_json j
  end
module SubnetIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SubnetId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CoipAddressUsageSet =
  struct
    type t = CoipAddressUsage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CoipAddressUsage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CoipAddressUsage.to_query v
    let to_json v = `List (List.map CoipAddressUsage.to_json v)
    let of_json j = Json.to_list CoipAddressUsage.of_json j
  end
module ReservedInstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ReservedInstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TargetConfigurationRequestSet =
  struct
    type t = TargetConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TargetConfigurationRequest.parse
           (Xml.members "TargetConfigurationRequest" xml))
    let to_query v =
      Query.to_query_list TargetConfigurationRequest.to_query v
    let to_json v = `List (List.map TargetConfigurationRequest.to_json v)
    let of_json j = Json.to_list TargetConfigurationRequest.of_json j
  end
module LocalGatewayRouteTableVpcAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module StaleSecurityGroupSet =
  struct
    type t = StaleSecurityGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map StaleSecurityGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list StaleSecurityGroup.to_query v
    let to_json v = `List (List.map StaleSecurityGroup.to_json v)
    let of_json j = Json.to_list StaleSecurityGroup.of_json j
  end
module SecurityGroupReferences =
  struct
    type t = SecurityGroupReference.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SecurityGroupReference.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroupReference.to_query v
    let to_json v = `List (List.map SecurityGroupReference.to_json v)
    let of_json j = Json.to_list SecurityGroupReference.of_json j
  end
module AssignedPrivateIpAddressList =
  struct
    type t = AssignedPrivateIpAddress.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AssignedPrivateIpAddress.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AssignedPrivateIpAddress.to_query v
    let to_json v = `List (List.map AssignedPrivateIpAddress.to_json v)
    let of_json j = Json.to_list AssignedPrivateIpAddress.of_json j
  end
module TransitGatewayMulticastRegisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      registered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        registered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "registered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module LocalGatewayRouteTableVpcAssociationSet =
  struct
    type t = LocalGatewayRouteTableVpcAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTableVpcAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayRouteTableVpcAssociation.to_query v
    let to_json v =
      `List (List.map LocalGatewayRouteTableVpcAssociation.to_json v)
    let of_json j =
      Json.to_list LocalGatewayRouteTableVpcAssociation.of_json j
  end
module AssociationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AssociationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CreateVolumePermissionModifications =
  struct
    type t =
      {
      add: CreateVolumePermissionList.t ;
      remove: CreateVolumePermissionList.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  CreateVolumePermissionList.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  CreateVolumePermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (CreateVolumePermissionList.to_query v.remove)));
           Some
             (Query.Pair ("Add", (CreateVolumePermissionList.to_query v.add)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (CreateVolumePermissionList.to_json v.remove));
           Some ("add", (CreateVolumePermissionList.to_json v.add))])
    let of_json j =
      {
        add =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module VolumeList =
  struct
    type t = Volume.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Volume.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Volume.to_query v
    let to_json v = `List (List.map Volume.to_json v)
    let of_json j = Json.to_list Volume.of_json j
  end
module AvailabilityZoneStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AvailabilityZone" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SnapshotIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "SnapshotId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ClientVpnConnectionSet =
  struct
    type t = ClientVpnConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnConnection.to_query v
    let to_json v = `List (List.map ClientVpnConnection.to_json v)
    let of_json j = Json.to_list ClientVpnConnection.of_json j
  end
module TrafficMirrorPortRangeRequest =
  struct
    type t = {
      from_port: Integer.t option ;
      to_port: Integer.t option }
    let make ?from_port  ?to_port  () = { from_port; to_port }
    let parse xml =
      Some
        {
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.to_port
              (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)))])
    let of_json j =
      {
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json)
      }
  end
module VolumeIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VolumeId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LocalGatewayRouteTableSet =
  struct
    type t = LocalGatewayRouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGatewayRouteTable.to_query v
    let to_json v = `List (List.map LocalGatewayRouteTable.to_json v)
    let of_json j = Json.to_list LocalGatewayRouteTable.of_json j
  end
module VpcClassicLinkIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RegionList =
  struct
    type t = Region.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Region.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Region.to_query v
    let to_json v = `List (List.map Region.to_json v)
    let of_json j = Json.to_list Region.of_json j
  end
module VpnConnectionOptionsSpecification =
  struct
    type t =
      {
      enable_acceleration: Boolean.t option ;
      static_routes_only: Boolean.t option ;
      tunnel_inside_ip_version: TunnelInsideIpVersion.t option ;
      tunnel_options: VpnTunnelOptionsSpecificationsList.t ;
      local_ipv4_network_cidr: String.t option ;
      remote_ipv4_network_cidr: String.t option ;
      local_ipv6_network_cidr: String.t option ;
      remote_ipv6_network_cidr: String.t option }
    let make ?enable_acceleration  ?static_routes_only 
      ?tunnel_inside_ip_version  ?(tunnel_options= []) 
      ?local_ipv4_network_cidr  ?remote_ipv4_network_cidr 
      ?local_ipv6_network_cidr  ?remote_ipv6_network_cidr  () =
      {
        enable_acceleration;
        static_routes_only;
        tunnel_inside_ip_version;
        tunnel_options;
        local_ipv4_network_cidr;
        remote_ipv4_network_cidr;
        local_ipv6_network_cidr;
        remote_ipv6_network_cidr
      }
    let parse xml =
      Some
        {
          enable_acceleration =
            (Util.option_bind (Xml.member "EnableAcceleration" xml)
               Boolean.parse);
          static_routes_only =
            (Util.option_bind (Xml.member "staticRoutesOnly" xml)
               Boolean.parse);
          tunnel_inside_ip_version =
            (Util.option_bind (Xml.member "TunnelInsideIpVersion" xml)
               TunnelInsideIpVersion.parse);
          tunnel_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "TunnelOptions" xml)
                  VpnTunnelOptionsSpecificationsList.parse));
          local_ipv4_network_cidr =
            (Util.option_bind (Xml.member "LocalIpv4NetworkCidr" xml)
               String.parse);
          remote_ipv4_network_cidr =
            (Util.option_bind (Xml.member "RemoteIpv4NetworkCidr" xml)
               String.parse);
          local_ipv6_network_cidr =
            (Util.option_bind (Xml.member "LocalIpv6NetworkCidr" xml)
               String.parse);
          remote_ipv6_network_cidr =
            (Util.option_bind (Xml.member "RemoteIpv6NetworkCidr" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.remote_ipv6_network_cidr
              (fun f ->
                 Query.Pair ("RemoteIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f ->
                Query.Pair ("RemoteIpv4NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv4NetworkCidr", (String.to_query f)));
           Some
             (Query.Pair
                ("TunnelOptions",
                  (VpnTunnelOptionsSpecificationsList.to_query
                     v.tunnel_options)));
           Util.option_map v.tunnel_inside_ip_version
             (fun f ->
                Query.Pair
                  ("TunnelInsideIpVersion",
                    (TunnelInsideIpVersion.to_query f)));
           Util.option_map v.static_routes_only
             (fun f -> Query.Pair ("StaticRoutesOnly", (Boolean.to_query f)));
           Util.option_map v.enable_acceleration
             (fun f ->
                Query.Pair ("EnableAcceleration", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.remote_ipv6_network_cidr
              (fun f -> ("remote_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f -> ("local_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f -> ("remote_ipv4_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f -> ("local_ipv4_network_cidr", (String.to_json f)));
           Some
             ("tunnel_options",
               (VpnTunnelOptionsSpecificationsList.to_json v.tunnel_options));
           Util.option_map v.tunnel_inside_ip_version
             (fun f ->
                ("tunnel_inside_ip_version",
                  (TunnelInsideIpVersion.to_json f)));
           Util.option_map v.static_routes_only
             (fun f -> ("static_routes_only", (Boolean.to_json f)));
           Util.option_map v.enable_acceleration
             (fun f -> ("enable_acceleration", (Boolean.to_json f)))])
    let of_json j =
      {
        enable_acceleration =
          (Util.option_map (Json.lookup j "enable_acceleration")
             Boolean.of_json);
        static_routes_only =
          (Util.option_map (Json.lookup j "static_routes_only")
             Boolean.of_json);
        tunnel_inside_ip_version =
          (Util.option_map (Json.lookup j "tunnel_inside_ip_version")
             TunnelInsideIpVersion.of_json);
        tunnel_options =
          (VpnTunnelOptionsSpecificationsList.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")));
        local_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv4_network_cidr")
             String.of_json);
        remote_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv4_network_cidr")
             String.of_json);
        local_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv6_network_cidr")
             String.of_json);
        remote_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv6_network_cidr")
             String.of_json)
      }
  end
module Ipv6CidrAssociationSet =
  struct
    type t = Ipv6CidrAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map Ipv6CidrAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6CidrAssociation.to_query v
    let to_json v = `List (List.map Ipv6CidrAssociation.to_json v)
    let of_json j = Json.to_list Ipv6CidrAssociation.of_json j
  end
module CidrAuthorizationContext =
  struct
    type t = {
      message: String.t ;
      signature: String.t }
    let make ~message  ~signature  () = { message; signature }
    let parse xml =
      Some
        {
          message =
            (Xml.required "Message"
               (Util.option_bind (Xml.member "Message" xml) String.parse));
          signature =
            (Xml.required "Signature"
               (Util.option_bind (Xml.member "Signature" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Signature", (String.to_query v.signature)));
           Some (Query.Pair ("Message", (String.to_query v.message)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("signature", (String.to_json v.signature));
           Some ("message", (String.to_json v.message))])
    let of_json j =
      {
        message =
          (String.of_json (Util.of_option_exn (Json.lookup j "message")));
        signature =
          (String.of_json (Util.of_option_exn (Json.lookup j "signature")))
      }
  end
module ModifyTransitGatewayVpcAttachmentRequestOptions =
  struct
    type t =
      {
      dns_support: DnsSupportValue.t option ;
      ipv6_support: Ipv6SupportValue.t option ;
      appliance_mode_support: ApplianceModeSupportValue.t option }
    let make ?dns_support  ?ipv6_support  ?appliance_mode_support  () =
      { dns_support; ipv6_support; appliance_mode_support }
    let parse xml =
      Some
        {
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          ipv6_support =
            (Util.option_bind (Xml.member "Ipv6Support" xml)
               Ipv6SupportValue.parse);
          appliance_mode_support =
            (Util.option_bind (Xml.member "ApplianceModeSupport" xml)
               ApplianceModeSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 Query.Pair
                   ("ApplianceModeSupport",
                     (ApplianceModeSupportValue.to_query f)));
           Util.option_map v.ipv6_support
             (fun f ->
                Query.Pair ("Ipv6Support", (Ipv6SupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.appliance_mode_support
              (fun f ->
                 ("appliance_mode_support",
                   (ApplianceModeSupportValue.to_json f)));
           Util.option_map v.ipv6_support
             (fun f -> ("ipv6_support", (Ipv6SupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)))])
    let of_json j =
      {
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        ipv6_support =
          (Util.option_map (Json.lookup j "ipv6_support")
             Ipv6SupportValue.of_json);
        appliance_mode_support =
          (Util.option_map (Json.lookup j "appliance_mode_support")
             ApplianceModeSupportValue.of_json)
      }
  end
module AllocationIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "AllocationId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PublicIpStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "PublicIp" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PeeringConnectionOptionsRequest =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "AllowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module PrefixListAssociationSet =
  struct
    type t = PrefixListAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PrefixListAssociation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PrefixListAssociation.to_query v
    let to_json v = `List (List.map PrefixListAssociation.to_json v)
    let of_json j = Json.to_list PrefixListAssociation.of_json j
  end
module AddressList =
  struct
    type t = Address.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Address.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Address.to_query v
    let to_json v = `List (List.map Address.to_json v)
    let of_json j = Json.to_list Address.of_json j
  end
module InstanceTypeInfoList =
  struct
    type t = InstanceTypeInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceTypeInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceTypeInfo.to_query v
    let to_json v = `List (List.map InstanceTypeInfo.to_json v)
    let of_json j = Json.to_list InstanceTypeInfo.of_json j
  end
module ClientVpnRouteSet =
  struct
    type t = ClientVpnRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnRoute.to_query v
    let to_json v = `List (List.map ClientVpnRoute.to_json v)
    let of_json j = Json.to_list ClientVpnRoute.of_json j
  end
module CapacityReservationSpecification =
  struct
    type t =
      {
      capacity_reservation_preference: CapacityReservationPreference.t option ;
      capacity_reservation_target: CapacityReservationTarget.t option }
    let make ?capacity_reservation_preference  ?capacity_reservation_target 
      () = { capacity_reservation_preference; capacity_reservation_target }
    let parse xml =
      Some
        {
          capacity_reservation_preference =
            (Util.option_bind
               (Xml.member "CapacityReservationPreference" xml)
               CapacityReservationPreference.parse);
          capacity_reservation_target =
            (Util.option_bind (Xml.member "CapacityReservationTarget" xml)
               CapacityReservationTarget.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 Query.Pair
                   ("CapacityReservationTarget",
                     (CapacityReservationTarget.to_query f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                Query.Pair
                  ("CapacityReservationPreference",
                    (CapacityReservationPreference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation_target
              (fun f ->
                 ("capacity_reservation_target",
                   (CapacityReservationTarget.to_json f)));
           Util.option_map v.capacity_reservation_preference
             (fun f ->
                ("capacity_reservation_preference",
                  (CapacityReservationPreference.to_json f)))])
    let of_json j =
      {
        capacity_reservation_preference =
          (Util.option_map (Json.lookup j "capacity_reservation_preference")
             CapacityReservationPreference.of_json);
        capacity_reservation_target =
          (Util.option_map (Json.lookup j "capacity_reservation_target")
             CapacityReservationTarget.of_json)
      }
  end
module VpnConnectionList =
  struct
    type t = VpnConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpnConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpnConnection.to_query v
    let to_json v = `List (List.map VpnConnection.to_json v)
    let of_json j = Json.to_list VpnConnection.of_json j
  end
module RequestHostIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DnsServersOptionsModifyStructure =
  struct
    type t =
      {
      custom_dns_servers: ValueStringList.t ;
      enabled: Boolean.t option }
    let make ?(custom_dns_servers= [])  ?enabled  () =
      { custom_dns_servers; enabled }
    let parse xml =
      Some
        {
          custom_dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomDnsServers" xml)
                  ValueStringList.parse));
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CustomDnsServers",
                  (ValueStringList.to_query v.custom_dns_servers)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)));
           Some
             ("custom_dns_servers",
               (ValueStringList.to_json v.custom_dns_servers))])
    let of_json j =
      {
        custom_dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "custom_dns_servers")));
        enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module TargetNetworkSet =
  struct
    type t = TargetNetwork.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map TargetNetwork.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetNetwork.to_query v
    let to_json v = `List (List.map TargetNetwork.to_json v)
    let of_json j = Json.to_list TargetNetwork.of_json j
  end
module RegionNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "RegionName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module BillingProductList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcPeeringConnectionList =
  struct
    type t = VpcPeeringConnection.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcPeeringConnection.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcPeeringConnection.to_query v
    let to_json v = `List (List.map VpcPeeringConnection.to_json v)
    let of_json j = Json.to_list VpcPeeringConnection.of_json j
  end
module NetworkAclList =
  struct
    type t = NetworkAcl.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map NetworkAcl.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkAcl.to_query v
    let to_json v = `List (List.map NetworkAcl.to_json v)
    let of_json j = Json.to_list NetworkAcl.of_json j
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet =
  struct
    type t = LocalGatewayRouteTableVirtualInterfaceGroupAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_query v
    let to_json v =
      `List
        (List.map
           LocalGatewayRouteTableVirtualInterfaceGroupAssociation.to_json v)
    let of_json j =
      Json.to_list
        LocalGatewayRouteTableVirtualInterfaceGroupAssociation.of_json j
  end
module FleetIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchTemplateIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module LaunchTemplateNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CancelSpotFleetRequestsErrorSet =
  struct
    type t = CancelSpotFleetRequestsErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsErrorItem.to_query v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsErrorItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsErrorItem.of_json j
  end
module CancelSpotFleetRequestsSuccessSet =
  struct
    type t = CancelSpotFleetRequestsSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelSpotFleetRequestsSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelSpotFleetRequestsSuccessItem.to_query v
    let to_json v =
      `List (List.map CancelSpotFleetRequestsSuccessItem.to_json v)
    let of_json j = Json.to_list CancelSpotFleetRequestsSuccessItem.of_json j
  end
module AccountAttributeList =
  struct
    type t = AccountAttribute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttribute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AccountAttribute.to_query v
    let to_json v = `List (List.map AccountAttribute.to_json v)
    let of_json j = Json.to_list AccountAttribute.of_json j
  end
module ResourceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DeregisterInstanceTagAttributeRequest =
  struct
    type t =
      {
      include_all_tags_of_instance: Boolean.t option ;
      instance_tag_keys: InstanceTagKeySet.t }
    let make ?include_all_tags_of_instance  ?(instance_tag_keys= [])  () =
      { include_all_tags_of_instance; instance_tag_keys }
    let parse xml =
      Some
        {
          include_all_tags_of_instance =
            (Util.option_bind (Xml.member "IncludeAllTagsOfInstance" xml)
               Boolean.parse);
          instance_tag_keys =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceTagKey" xml)
                  InstanceTagKeySet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceTagKey",
                   (InstanceTagKeySet.to_query v.instance_tag_keys)));
           Util.option_map v.include_all_tags_of_instance
             (fun f ->
                Query.Pair ("IncludeAllTagsOfInstance", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_tag_keys",
                (InstanceTagKeySet.to_json v.instance_tag_keys));
           Util.option_map v.include_all_tags_of_instance
             (fun f -> ("include_all_tags_of_instance", (Boolean.to_json f)))])
    let of_json j =
      {
        include_all_tags_of_instance =
          (Util.option_map (Json.lookup j "include_all_tags_of_instance")
             Boolean.of_json);
        instance_tag_keys =
          (InstanceTagKeySet.of_json
             (Util.of_option_exn (Json.lookup j "instance_tag_keys")))
      }
  end
module PeeringConnectionOptions =
  struct
    type t =
      {
      allow_dns_resolution_from_remote_vpc: Boolean.t option ;
      allow_egress_from_local_classic_link_to_remote_vpc: Boolean.t option ;
      allow_egress_from_local_vpc_to_remote_classic_link: Boolean.t option }
    let make ?allow_dns_resolution_from_remote_vpc 
      ?allow_egress_from_local_classic_link_to_remote_vpc 
      ?allow_egress_from_local_vpc_to_remote_classic_link  () =
      {
        allow_dns_resolution_from_remote_vpc;
        allow_egress_from_local_classic_link_to_remote_vpc;
        allow_egress_from_local_vpc_to_remote_classic_link
      }
    let parse xml =
      Some
        {
          allow_dns_resolution_from_remote_vpc =
            (Util.option_bind
               (Xml.member "allowDnsResolutionFromRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_classic_link_to_remote_vpc =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalClassicLinkToRemoteVpc" xml)
               Boolean.parse);
          allow_egress_from_local_vpc_to_remote_classic_link =
            (Util.option_bind
               (Xml.member "allowEgressFromLocalVpcToRemoteClassicLink" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 Query.Pair
                   ("AllowEgressFromLocalVpcToRemoteClassicLink",
                     (Boolean.to_query f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowEgressFromLocalClassicLinkToRemoteVpc",
                    (Boolean.to_query f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                Query.Pair
                  ("AllowDnsResolutionFromRemoteVpc", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map
              v.allow_egress_from_local_vpc_to_remote_classic_link
              (fun f ->
                 ("allow_egress_from_local_vpc_to_remote_classic_link",
                   (Boolean.to_json f)));
           Util.option_map
             v.allow_egress_from_local_classic_link_to_remote_vpc
             (fun f ->
                ("allow_egress_from_local_classic_link_to_remote_vpc",
                  (Boolean.to_json f)));
           Util.option_map v.allow_dns_resolution_from_remote_vpc
             (fun f ->
                ("allow_dns_resolution_from_remote_vpc", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_dns_resolution_from_remote_vpc =
          (Util.option_map
             (Json.lookup j "allow_dns_resolution_from_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_classic_link_to_remote_vpc =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_classic_link_to_remote_vpc")
             Boolean.of_json);
        allow_egress_from_local_vpc_to_remote_classic_link =
          (Util.option_map
             (Json.lookup j
                "allow_egress_from_local_vpc_to_remote_classic_link")
             Boolean.of_json)
      }
  end
module VpcIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "VpcId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DiskImageList =
  struct
    type t = DiskImage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map DiskImage.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list DiskImage.to_query v
    let to_json v = `List (List.map DiskImage.to_json v)
    let of_json j = Json.to_list DiskImage.of_json j
  end
module ImportInstanceLaunchSpecification =
  struct
    type t =
      {
      additional_info: String.t option ;
      architecture: ArchitectureValues.t option ;
      group_ids: SecurityGroupIdStringList.t ;
      group_names: SecurityGroupStringList.t ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      instance_type: InstanceType.t option ;
      monitoring: Boolean.t option ;
      placement: Placement.t option ;
      private_ip_address: String.t option ;
      subnet_id: String.t option ;
      user_data: UserData.t option }
    let make ?additional_info  ?architecture  ?(group_ids= []) 
      ?(group_names= [])  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?monitoring  ?placement  ?private_ip_address 
      ?subnet_id  ?user_data  () =
      {
        additional_info;
        architecture;
        group_ids;
        group_names;
        instance_initiated_shutdown_behavior;
        instance_type;
        monitoring;
        placement;
        private_ip_address;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  SecurityGroupIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  SecurityGroupStringList.parse));
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               InstanceType.parse);
          monitoring =
            (Util.option_bind (Xml.member "monitoring" xml) Boolean.parse);
          placement =
            (Util.option_bind (Xml.member "placement" xml) Placement.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml) UserData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (UserData.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.monitoring
             (fun f -> Query.Pair ("Monitoring", (Boolean.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Some
             (Query.Pair
                ("GroupName",
                  (SecurityGroupStringList.to_query v.group_names)));
           Some
             (Query.Pair
                ("GroupId", (SecurityGroupIdStringList.to_query v.group_ids)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (UserData.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.monitoring
             (fun f -> ("monitoring", (Boolean.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Some
             ("group_names", (SecurityGroupStringList.to_json v.group_names));
           Some
             ("group_ids", (SecurityGroupIdStringList.to_json v.group_ids));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)))])
    let of_json j =
      {
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        group_names =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring") Boolean.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") UserData.of_json)
      }
  end
module VpcEndpointSet =
  struct
    type t = VpcEndpoint.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map VpcEndpoint.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcEndpoint.to_query v
    let to_json v = `List (List.map VpcEndpoint.to_json v)
    let of_json j = Json.to_list VpcEndpoint.of_json j
  end
module ClassicLinkInstanceList =
  struct
    type t = ClassicLinkInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClassicLinkInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClassicLinkInstance.to_query v
    let to_json v = `List (List.map ClassicLinkInstance.to_json v)
    let of_json j = Json.to_list ClassicLinkInstance.of_json j
  end
module PurchaseSet =
  struct
    type t = Purchase.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Purchase.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Purchase.to_query v
    let to_json v = `List (List.map Purchase.to_json v)
    let of_json j = Json.to_list Purchase.of_json j
  end
module TransitGatewayAttachmentList =
  struct
    type t = TransitGatewayAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayAttachment.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayAttachment.to_query v
    let to_json v = `List (List.map TransitGatewayAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayAttachment.of_json j
  end
module ModifyTransitGatewayOptions =
  struct
    type t =
      {
      vpn_ecmp_support: VpnEcmpSupportValue.t option ;
      dns_support: DnsSupportValue.t option ;
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option ;
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option ;
      association_default_route_table_id: String.t option ;
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option ;
      propagation_default_route_table_id: String.t option }
    let make ?vpn_ecmp_support  ?dns_support  ?auto_accept_shared_attachments
       ?default_route_table_association  ?association_default_route_table_id 
      ?default_route_table_propagation  ?propagation_default_route_table_id 
      () =
      {
        vpn_ecmp_support;
        dns_support;
        auto_accept_shared_attachments;
        default_route_table_association;
        association_default_route_table_id;
        default_route_table_propagation;
        propagation_default_route_table_id
      }
    let parse xml =
      Some
        {
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "VpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "AutoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "DefaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          association_default_route_table_id =
            (Util.option_bind
               (Xml.member "AssociationDefaultRouteTableId" xml) String.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "DefaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          propagation_default_route_table_id =
            (Util.option_bind
               (Xml.member "PropagationDefaultRouteTableId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation_default_route_table_id
              (fun f ->
                 Query.Pair
                   ("PropagationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                Query.Pair
                  ("AssociationDefaultRouteTableId", (String.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation_default_route_table_id
              (fun f ->
                 ("propagation_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.association_default_route_table_id
             (fun f ->
                ("association_default_route_table_id", (String.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)))])
    let of_json j =
      {
        vpn_ecmp_support =
          (Util.option_map (Json.lookup j "vpn_ecmp_support")
             VpnEcmpSupportValue.of_json);
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        auto_accept_shared_attachments =
          (Util.option_map (Json.lookup j "auto_accept_shared_attachments")
             AutoAcceptSharedAttachmentsValue.of_json);
        default_route_table_association =
          (Util.option_map (Json.lookup j "default_route_table_association")
             DefaultRouteTableAssociationValue.of_json);
        association_default_route_table_id =
          (Util.option_map
             (Json.lookup j "association_default_route_table_id")
             String.of_json);
        default_route_table_propagation =
          (Util.option_map (Json.lookup j "default_route_table_propagation")
             DefaultRouteTablePropagationValue.of_json);
        propagation_default_route_table_id =
          (Util.option_map
             (Json.lookup j "propagation_default_route_table_id")
             String.of_json)
      }
  end
module ImageAttributeName =
  struct
    type t =
      | Description 
      | Kernel 
      | Ramdisk 
      | LaunchPermission 
      | ProductCodes 
      | BlockDeviceMapping 
      | SriovNetSupport 
    let str_to_t =
      [("sriovNetSupport", SriovNetSupport);
      ("blockDeviceMapping", BlockDeviceMapping);
      ("productCodes", ProductCodes);
      ("launchPermission", LaunchPermission);
      ("ramdisk", Ramdisk);
      ("kernel", Kernel);
      ("description", Description)]
    let t_to_str =
      [(SriovNetSupport, "sriovNetSupport");
      (BlockDeviceMapping, "blockDeviceMapping");
      (ProductCodes, "productCodes");
      (LaunchPermission, "launchPermission");
      (Ramdisk, "ramdisk");
      (Kernel, "kernel");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module SnapshotList =
  struct
    type t = Snapshot.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Snapshot.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Snapshot.to_query v
    let to_json v = `List (List.map Snapshot.to_json v)
    let of_json j = Json.to_list Snapshot.of_json j
  end
module TransitGatewayMulticastDomainIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PurchasedScheduledInstanceSet =
  struct
    type t = ScheduledInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ScheduledInstance.to_query v
    let to_json v = `List (List.map ScheduledInstance.to_json v)
    let of_json j = Json.to_list ScheduledInstance.of_json j
  end
module CreateFleetErrorsSet =
  struct
    type t = CreateFleetError.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateFleetError.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateFleetError.to_query v
    let to_json v = `List (List.map CreateFleetError.to_json v)
    let of_json j = Json.to_list CreateFleetError.of_json j
  end
module CreateFleetInstancesSet =
  struct
    type t = CreateFleetInstance.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CreateFleetInstance.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CreateFleetInstance.to_query v
    let to_json v = `List (List.map CreateFleetInstance.to_json v)
    let of_json j = Json.to_list CreateFleetInstance.of_json j
  end
module SnapshotSet =
  struct
    type t = SnapshotInfo.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SnapshotInfo.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SnapshotInfo.to_query v
    let to_json v = `List (List.map SnapshotInfo.to_json v)
    let of_json j = Json.to_list SnapshotInfo.of_json j
  end
module TrafficMirrorTargetSet =
  struct
    type t = TrafficMirrorTarget.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorTarget.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorTarget.to_query v
    let to_json v = `List (List.map TrafficMirrorTarget.to_json v)
    let of_json j = Json.to_list TrafficMirrorTarget.of_json j
  end
module NetworkInterfaceAttribute =
  struct
    type t =
      | Description 
      | GroupSet 
      | SourceDestCheck 
      | Attachment 
    let str_to_t =
      [("attachment", Attachment);
      ("sourceDestCheck", SourceDestCheck);
      ("groupSet", GroupSet);
      ("description", Description)]
    let t_to_str =
      [(Attachment, "attachment");
      (SourceDestCheck, "sourceDestCheck");
      (GroupSet, "groupSet");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module TrafficMirrorFilterRuleFieldList =
  struct
    type t = TrafficMirrorFilterRuleField.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorFilterRuleField.parse
           (Xml.members "member" xml))
    let to_query v =
      Query.to_query_list TrafficMirrorFilterRuleField.to_query v
    let to_json v = `List (List.map TrafficMirrorFilterRuleField.to_json v)
    let of_json j = Json.to_list TrafficMirrorFilterRuleField.of_json j
  end
module VolumeModificationList =
  struct
    type t = VolumeModification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeModification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeModification.to_query v
    let to_json v = `List (List.map VolumeModification.to_json v)
    let of_json j = Json.to_list VolumeModification.of_json j
  end
module ResetImageAttributeName =
  struct
    type t =
      | LaunchPermission 
    let str_to_t = [("launchPermission", LaunchPermission)]
    let t_to_str = [(LaunchPermission, "launchPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NewDhcpConfigurationList =
  struct
    type t = NewDhcpConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NewDhcpConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NewDhcpConfiguration.to_query v
    let to_json v = `List (List.map NewDhcpConfiguration.to_json v)
    let of_json j = Json.to_list NewDhcpConfiguration.of_json j
  end
module VpcAttributeName =
  struct
    type t =
      | EnableDnsSupport 
      | EnableDnsHostnames 
    let str_to_t =
      [("enableDnsHostnames", EnableDnsHostnames);
      ("enableDnsSupport", EnableDnsSupport)]
    let t_to_str =
      [(EnableDnsHostnames, "enableDnsHostnames");
      (EnableDnsSupport, "enableDnsSupport")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NetworkInterfaceList =
  struct
    type t = NetworkInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map NetworkInterface.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NetworkInterface.to_query v
    let to_json v = `List (List.map NetworkInterface.to_json v)
    let of_json j = Json.to_list NetworkInterface.of_json j
  end
module ConnectionNotificationSet =
  struct
    type t = ConnectionNotification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ConnectionNotification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ConnectionNotification.to_query v
    let to_json v = `List (List.map ConnectionNotification.to_json v)
    let of_json j = Json.to_list ConnectionNotification.of_json j
  end
module ResetFpgaImageAttributeName =
  struct
    type t =
      | LoadPermission 
    let str_to_t = [("loadPermission", LoadPermission)]
    let t_to_str = [(LoadPermission, "loadPermission")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module ReservedInstancesList =
  struct
    type t = ReservedInstances.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstances.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstances.to_query v
    let to_json v = `List (List.map ReservedInstances.to_json v)
    let of_json j = Json.to_list ReservedInstances.of_json j
  end
module GroupIds =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ResourceList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayPeeringAttachmentList =
  struct
    type t = TransitGatewayPeeringAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayPeeringAttachment.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayPeeringAttachment.to_query v
    let to_json v =
      `List (List.map TransitGatewayPeeringAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayPeeringAttachment.of_json j
  end
module CancelledSpotInstanceRequestList =
  struct
    type t = CancelledSpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CancelledSpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list CancelledSpotInstanceRequest.to_query v
    let to_json v = `List (List.map CancelledSpotInstanceRequest.to_json v)
    let of_json j = Json.to_list CancelledSpotInstanceRequest.of_json j
  end
module ServiceConfigurationSet =
  struct
    type t = ServiceConfiguration.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ServiceConfiguration.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceConfiguration.to_query v
    let to_json v = `List (List.map ServiceConfiguration.to_json v)
    let of_json j = Json.to_list ServiceConfiguration.of_json j
  end
module StorageLocation =
  struct
    type t = {
      bucket: String.t option ;
      key: String.t option }
    let make ?bucket  ?key  () = { bucket; key }
    let parse xml =
      Some
        {
          bucket = (Util.option_bind (Xml.member "Bucket" xml) String.parse);
          key = (Util.option_bind (Xml.member "Key" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.key
              (fun f -> Query.Pair ("Key", (String.to_query f)));
           Util.option_map v.bucket
             (fun f -> Query.Pair ("Bucket", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.key (fun f -> ("key", (String.to_json f)));
           Util.option_map v.bucket (fun f -> ("bucket", (String.to_json f)))])
    let of_json j =
      {
        bucket = (Util.option_map (Json.lookup j "bucket") String.of_json);
        key = (Util.option_map (Json.lookup j "key") String.of_json)
      }
  end
module BundleIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "BundleId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DescribeConversionTaskList =
  struct
    type t = ConversionTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ConversionTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ConversionTask.to_query v
    let to_json v = `List (List.map ConversionTask.to_json v)
    let of_json j = Json.to_list ConversionTask.of_json j
  end
module LocalGatewayRouteTableIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayVpcAttachmentList =
  struct
    type t = TransitGatewayVpcAttachment.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayVpcAttachment.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayVpcAttachment.to_query v
    let to_json v = `List (List.map TransitGatewayVpcAttachment.to_json v)
    let of_json j = Json.to_list TransitGatewayVpcAttachment.of_json j
  end
module ExportToS3TaskSpecification =
  struct
    type t =
      {
      container_format: ContainerFormat.t option ;
      disk_image_format: DiskImageFormat.t option ;
      s3_bucket: String.t option ;
      s3_prefix: String.t option }
    let make ?container_format  ?disk_image_format  ?s3_bucket  ?s3_prefix 
      () = { container_format; disk_image_format; s3_bucket; s3_prefix }
    let parse xml =
      Some
        {
          container_format =
            (Util.option_bind (Xml.member "containerFormat" xml)
               ContainerFormat.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          s3_bucket =
            (Util.option_bind (Xml.member "s3Bucket" xml) String.parse);
          s3_prefix =
            (Util.option_bind (Xml.member "s3Prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> Query.Pair ("S3Prefix", (String.to_query f)));
           Util.option_map v.s3_bucket
             (fun f -> Query.Pair ("S3Bucket", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.container_format
             (fun f ->
                Query.Pair ("ContainerFormat", (ContainerFormat.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_prefix
              (fun f -> ("s3_prefix", (String.to_json f)));
           Util.option_map v.s3_bucket
             (fun f -> ("s3_bucket", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.container_format
             (fun f -> ("container_format", (ContainerFormat.to_json f)))])
    let of_json j =
      {
        container_format =
          (Util.option_map (Json.lookup j "container_format")
             ContainerFormat.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        s3_bucket =
          (Util.option_map (Json.lookup j "s3_bucket") String.of_json);
        s3_prefix =
          (Util.option_map (Json.lookup j "s3_prefix") String.of_json)
      }
  end
module ReservedInstanceReservationValueSet =
  struct
    type t = ReservedInstanceReservationValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstanceReservationValue.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ReservedInstanceReservationValue.to_query v
    let to_json v =
      `List (List.map ReservedInstanceReservationValue.to_json v)
    let of_json j = Json.to_list ReservedInstanceReservationValue.of_json j
  end
module TargetReservationValueSet =
  struct
    type t = TargetReservationValue.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TargetReservationValue.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TargetReservationValue.to_query v
    let to_json v = `List (List.map TargetReservationValue.to_json v)
    let of_json j = Json.to_list TargetReservationValue.of_json j
  end
module TransitGatewayRouteList =
  struct
    type t = TransitGatewayRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayRoute.to_query v
    let to_json v = `List (List.map TransitGatewayRoute.to_json v)
    let of_json j = Json.to_list TransitGatewayRoute.of_json j
  end
module HistoryRecords =
  struct
    type t = HistoryRecord.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HistoryRecord.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HistoryRecord.to_query v
    let to_json v = `List (List.map HistoryRecord.to_json v)
    let of_json j = Json.to_list HistoryRecord.of_json j
  end
module FpgaImageList =
  struct
    type t = FpgaImage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FpgaImage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FpgaImage.to_query v
    let to_json v = `List (List.map FpgaImage.to_json v)
    let of_json j = Json.to_list FpgaImage.of_json j
  end
module OwnerStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "Owner" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RestorableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ModifyAvailabilityZoneOptInStatus =
  struct
    type t =
      | Opted_in 
      | Not_opted_in 
    let str_to_t = [("not-opted-in", Not_opted_in); ("opted-in", Opted_in)]
    let t_to_str = [(Not_opted_in, "not-opted-in"); (Opted_in, "opted-in")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FlowLogIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module EnableFastSnapshotRestoreErrorSet =
  struct
    type t = EnableFastSnapshotRestoreErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreErrorItem.to_query v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreErrorItem.to_json v)
    let of_json j = Json.to_list EnableFastSnapshotRestoreErrorItem.of_json j
  end
module EnableFastSnapshotRestoreSuccessSet =
  struct
    type t = EnableFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EnableFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list EnableFastSnapshotRestoreSuccessItem.to_query v
    let to_json v =
      `List (List.map EnableFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list EnableFastSnapshotRestoreSuccessItem.of_json j
  end
module InstanceIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RouteTableList =
  struct
    type t = RouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map RouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list RouteTable.to_query v
    let to_json v = `List (List.map RouteTable.to_json v)
    let of_json j = Json.to_list RouteTable.of_json j
  end
module LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module UnsuccessfulItemList =
  struct
    type t = UnsuccessfulItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list UnsuccessfulItem.to_query v
    let to_json v = `List (List.map UnsuccessfulItem.to_json v)
    let of_json j = Json.to_list UnsuccessfulItem.of_json j
  end
module IamInstanceProfileAssociationSet =
  struct
    type t = IamInstanceProfileAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map IamInstanceProfileAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list IamInstanceProfileAssociation.to_query v
    let to_json v = `List (List.map IamInstanceProfileAssociation.to_json v)
    let of_json j = Json.to_list IamInstanceProfileAssociation.of_json j
  end
module LaunchTemplateVersionSet =
  struct
    type t = LaunchTemplateVersion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LaunchTemplateVersion.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LaunchTemplateVersion.to_query v
    let to_json v = `List (List.map LaunchTemplateVersion.to_json v)
    let of_json j = Json.to_list LaunchTemplateVersion.of_json j
  end
module CarrierGatewaySet =
  struct
    type t = CarrierGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CarrierGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CarrierGateway.to_query v
    let to_json v = `List (List.map CarrierGateway.to_json v)
    let of_json j = Json.to_list CarrierGateway.of_json j
  end
module CapacityReservationGroupSet =
  struct
    type t = CapacityReservationGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CapacityReservationGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CapacityReservationGroup.to_query v
    let to_json v = `List (List.map CapacityReservationGroup.to_json v)
    let of_json j = Json.to_list CapacityReservationGroup.of_json j
  end
module VpcEndpointRouteTableIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcEndpointSecurityGroupIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcEndpointSubnetIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayAttachmentIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastGroupList =
  struct
    type t = TransitGatewayMulticastGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastGroup.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastGroup.to_query v
    let to_json v = `List (List.map TransitGatewayMulticastGroup.to_json v)
    let of_json j = Json.to_list TransitGatewayMulticastGroup.of_json j
  end
module ScheduledInstanceIdRequestSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ScheduledInstanceId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SlotStartTimeRangeRequest =
  struct
    type t =
      {
      earliest_time: DateTime.t option ;
      latest_time: DateTime.t option }
    let make ?earliest_time  ?latest_time  () =
      { earliest_time; latest_time }
    let parse xml =
      Some
        {
          earliest_time =
            (Util.option_bind (Xml.member "EarliestTime" xml) DateTime.parse);
          latest_time =
            (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> Query.Pair ("LatestTime", (DateTime.to_query f)));
           Util.option_map v.earliest_time
             (fun f -> Query.Pair ("EarliestTime", (DateTime.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.latest_time
              (fun f -> ("latest_time", (DateTime.to_json f)));
           Util.option_map v.earliest_time
             (fun f -> ("earliest_time", (DateTime.to_json f)))])
    let of_json j =
      {
        earliest_time =
          (Util.option_map (Json.lookup j "earliest_time") DateTime.of_json);
        latest_time =
          (Util.option_map (Json.lookup j "latest_time") DateTime.of_json)
      }
  end
module LocalGatewayVirtualInterfaceSet =
  struct
    type t = LocalGatewayVirtualInterface.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterface.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterface.to_query v
    let to_json v = `List (List.map LocalGatewayVirtualInterface.to_json v)
    let of_json j = Json.to_list LocalGatewayVirtualInterface.of_json j
  end
module CpuOptionsRequest =
  struct
    type t =
      {
      core_count: Integer.t option ;
      threads_per_core: Integer.t option }
    let make ?core_count  ?threads_per_core  () =
      { core_count; threads_per_core }
    let parse xml =
      Some
        {
          core_count =
            (Util.option_bind (Xml.member "CoreCount" xml) Integer.parse);
          threads_per_core =
            (Util.option_bind (Xml.member "ThreadsPerCore" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> Query.Pair ("ThreadsPerCore", (Integer.to_query f)));
           Util.option_map v.core_count
             (fun f -> Query.Pair ("CoreCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.threads_per_core
              (fun f -> ("threads_per_core", (Integer.to_json f)));
           Util.option_map v.core_count
             (fun f -> ("core_count", (Integer.to_json f)))])
    let of_json j =
      {
        core_count =
          (Util.option_map (Json.lookup j "core_count") Integer.of_json);
        threads_per_core =
          (Util.option_map (Json.lookup j "threads_per_core") Integer.of_json)
      }
  end
module ElasticGpuSpecifications =
  struct
    type t = ElasticGpuSpecification.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticGpuSpecification.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpuSpecification.to_query v
    let to_json v = `List (List.map ElasticGpuSpecification.to_json v)
    let of_json j = Json.to_list ElasticGpuSpecification.of_json j
  end
module ElasticInferenceAccelerators =
  struct
    type t = ElasticInferenceAccelerator.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ElasticInferenceAccelerator.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ElasticInferenceAccelerator.to_query v
    let to_json v = `List (List.map ElasticInferenceAccelerator.to_json v)
    let of_json j = Json.to_list ElasticInferenceAccelerator.of_json j
  end
module EnclaveOptionsRequest =
  struct
    type t = {
      enabled: Boolean.t option }
    let make ?enabled  () = { enabled }
    let parse xml =
      Some
        {
          enabled =
            (Util.option_bind (Xml.member "Enabled" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> Query.Pair ("Enabled", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enabled
              (fun f -> ("enabled", (Boolean.to_json f)))])
    let of_json j =
      { enabled = (Util.option_map (Json.lookup j "enabled") Boolean.of_json)
      }
  end
module HibernationOptionsRequest =
  struct
    type t = {
      configured: Boolean.t option }
    let make ?configured  () = { configured }
    let parse xml =
      Some
        {
          configured =
            (Util.option_bind (Xml.member "Configured" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> Query.Pair ("Configured", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.configured
              (fun f -> ("configured", (Boolean.to_json f)))])
    let of_json j =
      {
        configured =
          (Util.option_map (Json.lookup j "configured") Boolean.of_json)
      }
  end
module InstanceMarketOptionsRequest =
  struct
    type t =
      {
      market_type: MarketType.t option ;
      spot_options: SpotMarketOptions.t option }
    let make ?market_type  ?spot_options  () = { market_type; spot_options }
    let parse xml =
      Some
        {
          market_type =
            (Util.option_bind (Xml.member "MarketType" xml) MarketType.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               SpotMarketOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f ->
                 Query.Pair ("SpotOptions", (SpotMarketOptions.to_query f)));
           Util.option_map v.market_type
             (fun f -> Query.Pair ("MarketType", (MarketType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_options
              (fun f -> ("spot_options", (SpotMarketOptions.to_json f)));
           Util.option_map v.market_type
             (fun f -> ("market_type", (MarketType.to_json f)))])
    let of_json j =
      {
        market_type =
          (Util.option_map (Json.lookup j "market_type") MarketType.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             SpotMarketOptions.of_json)
      }
  end
module InstanceMetadataOptionsRequest =
  struct
    type t =
      {
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option }
    let make ?http_tokens  ?http_put_response_hop_limit  ?http_endpoint  () =
      { http_tokens; http_put_response_hop_limit; http_endpoint }
    let parse xml =
      Some
        {
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               InstanceMetadataEndpointState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 Query.Pair
                   ("HttpEndpoint",
                     (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.http_endpoint
              (fun f ->
                 ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)))])
    let of_json j =
      {
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json)
      }
  end
module LaunchTemplateSpecification =
  struct
    type t =
      {
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      version: String.t option }
    let make ?launch_template_id  ?launch_template_name  ?version  () =
      { launch_template_id; launch_template_name; version }
    let parse xml =
      Some
        {
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          version =
            (Util.option_bind (Xml.member "Version" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> Query.Pair ("Version", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.version
              (fun f -> ("version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)))])
    let of_json j =
      {
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        version = (Util.option_map (Json.lookup j "version") String.of_json)
      }
  end
module LicenseSpecificationListRequest =
  struct
    type t = LicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LicenseConfigurationRequest.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LicenseConfigurationRequest.to_query v
    let to_json v = `List (List.map LicenseConfigurationRequest.to_json v)
    let of_json j = Json.to_list LicenseConfigurationRequest.of_json j
  end
module LocalGatewayVirtualInterfaceGroupSet =
  struct
    type t = LocalGatewayVirtualInterfaceGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayVirtualInterfaceGroup.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list LocalGatewayVirtualInterfaceGroup.to_query v
    let to_json v =
      `List (List.map LocalGatewayVirtualInterfaceGroup.to_json v)
    let of_json j = Json.to_list LocalGatewayVirtualInterfaceGroup.of_json j
  end
module ExecutableByStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExecutableBy" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ImageIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "ImageId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module VpcPeeringConnectionIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module MovingAddressStatusSet =
  struct
    type t = MovingAddressStatus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map MovingAddressStatus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list MovingAddressStatus.to_query v
    let to_json v = `List (List.map MovingAddressStatus.to_json v)
    let of_json j = Json.to_list MovingAddressStatus.of_json j
  end
module ExportTaskIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ReservedInstancesOfferingIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RequestLaunchTemplateData =
  struct
    type t =
      {
      kernel_id: String.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile:
        LaunchTemplateIamInstanceProfileSpecificationRequest.t option ;
      block_device_mappings: LaunchTemplateBlockDeviceMappingRequestList.t ;
      network_interfaces:
        LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      key_name: String.t option ;
      monitoring: LaunchTemplatesMonitoringRequest.t option ;
      placement: LaunchTemplatePlacementRequest.t option ;
      ram_disk_id: String.t option ;
      disable_api_termination: Boolean.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      user_data: String.t option ;
      tag_specifications: LaunchTemplateTagSpecificationRequestList.t ;
      elastic_gpu_specifications: ElasticGpuSpecificationList.t ;
      elastic_inference_accelerators:
        LaunchTemplateElasticInferenceAcceleratorList.t ;
      security_group_ids: SecurityGroupIdStringList.t ;
      security_groups: SecurityGroupStringList.t ;
      instance_market_options:
        LaunchTemplateInstanceMarketOptionsRequest.t option ;
      credit_specification: CreditSpecificationRequest.t option ;
      cpu_options: LaunchTemplateCpuOptionsRequest.t option ;
      capacity_reservation_specification:
        LaunchTemplateCapacityReservationSpecificationRequest.t option ;
      license_specifications: LaunchTemplateLicenseSpecificationListRequest.t ;
      hibernation_options: LaunchTemplateHibernationOptionsRequest.t option ;
      metadata_options: LaunchTemplateInstanceMetadataOptionsRequest.t option ;
      enclave_options: LaunchTemplateEnclaveOptionsRequest.t option }
    let make ?kernel_id  ?ebs_optimized  ?iam_instance_profile 
      ?(block_device_mappings= [])  ?(network_interfaces= [])  ?image_id 
      ?instance_type  ?key_name  ?monitoring  ?placement  ?ram_disk_id 
      ?disable_api_termination  ?instance_initiated_shutdown_behavior 
      ?user_data  ?(tag_specifications= [])  ?(elastic_gpu_specifications=
      [])  ?(elastic_inference_accelerators= [])  ?(security_group_ids= []) 
      ?(security_groups= [])  ?instance_market_options  ?credit_specification
       ?cpu_options  ?capacity_reservation_specification 
      ?(license_specifications= [])  ?hibernation_options  ?metadata_options 
      ?enclave_options  () =
      {
        kernel_id;
        ebs_optimized;
        iam_instance_profile;
        block_device_mappings;
        network_interfaces;
        image_id;
        instance_type;
        key_name;
        monitoring;
        placement;
        ram_disk_id;
        disable_api_termination;
        instance_initiated_shutdown_behavior;
        user_data;
        tag_specifications;
        elastic_gpu_specifications;
        elastic_inference_accelerators;
        security_group_ids;
        security_groups;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        license_specifications;
        hibernation_options;
        metadata_options;
        enclave_options
      }
    let parse xml =
      Some
        {
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               LaunchTemplateIamInstanceProfileSpecificationRequest.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  LaunchTemplateBlockDeviceMappingRequestList.parse));
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.parse));
          image_id =
            (Util.option_bind (Xml.member "ImageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               LaunchTemplatesMonitoringRequest.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               LaunchTemplatePlacementRequest.parse);
          ram_disk_id =
            (Util.option_bind (Xml.member "RamDiskId" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "DisableApiTermination" xml)
               Boolean.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "InstanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  LaunchTemplateTagSpecificationRequestList.parse));
          elastic_gpu_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuSpecification" xml)
                  ElasticGpuSpecificationList.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ElasticInferenceAccelerator" xml)
                  LaunchTemplateElasticInferenceAcceleratorList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          instance_market_options =
            (Util.option_bind (Xml.member "InstanceMarketOptions" xml)
               LaunchTemplateInstanceMarketOptionsRequest.parse);
          credit_specification =
            (Util.option_bind (Xml.member "CreditSpecification" xml)
               CreditSpecificationRequest.parse);
          cpu_options =
            (Util.option_bind (Xml.member "CpuOptions" xml)
               LaunchTemplateCpuOptionsRequest.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "CapacityReservationSpecification" xml)
               LaunchTemplateCapacityReservationSpecificationRequest.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecification" xml)
                  LaunchTemplateLicenseSpecificationListRequest.parse));
          hibernation_options =
            (Util.option_bind (Xml.member "HibernationOptions" xml)
               LaunchTemplateHibernationOptionsRequest.parse);
          metadata_options =
            (Util.option_bind (Xml.member "MetadataOptions" xml)
               LaunchTemplateInstanceMetadataOptionsRequest.parse);
          enclave_options =
            (Util.option_bind (Xml.member "EnclaveOptions" xml)
               LaunchTemplateEnclaveOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 Query.Pair
                   ("EnclaveOptions",
                     (LaunchTemplateEnclaveOptionsRequest.to_query f)));
           Util.option_map v.metadata_options
             (fun f ->
                Query.Pair
                  ("MetadataOptions",
                    (LaunchTemplateInstanceMetadataOptionsRequest.to_query f)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions",
                    (LaunchTemplateHibernationOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("LicenseSpecification",
                  (LaunchTemplateLicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (LaunchTemplateCapacityReservationSpecificationRequest.to_query
                       f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair
                  ("CpuOptions",
                    (LaunchTemplateCpuOptionsRequest.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification",
                    (CreditSpecificationRequest.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (LaunchTemplateInstanceMarketOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("ElasticInferenceAccelerator",
                  (LaunchTemplateElasticInferenceAcceleratorList.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecification",
                  (ElasticGpuSpecificationList.to_query
                     v.elastic_gpu_specifications)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (LaunchTemplateTagSpecificationRequestList.to_query
                     v.tag_specifications)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.ram_disk_id
             (fun f -> Query.Pair ("RamDiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (LaunchTemplatePlacementRequest.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring",
                    (LaunchTemplatesMonitoringRequest.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_query
                     v.network_interfaces)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (LaunchTemplateBlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (LaunchTemplateIamInstanceProfileSpecificationRequest.to_query
                       f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 ("enclave_options",
                   (LaunchTemplateEnclaveOptionsRequest.to_json f)));
           Util.option_map v.metadata_options
             (fun f ->
                ("metadata_options",
                  (LaunchTemplateInstanceMetadataOptionsRequest.to_json f)));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options",
                  (LaunchTemplateHibernationOptionsRequest.to_json f)));
           Some
             ("license_specifications",
               (LaunchTemplateLicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (LaunchTemplateCapacityReservationSpecificationRequest.to_json
                     f)));
           Util.option_map v.cpu_options
             (fun f ->
                ("cpu_options", (LaunchTemplateCpuOptionsRequest.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification",
                  (CreditSpecificationRequest.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (LaunchTemplateInstanceMarketOptionsRequest.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Some
             ("elastic_inference_accelerators",
               (LaunchTemplateElasticInferenceAcceleratorList.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specifications",
               (ElasticGpuSpecificationList.to_json
                  v.elastic_gpu_specifications));
           Some
             ("tag_specifications",
               (LaunchTemplateTagSpecificationRequestList.to_json
                  v.tag_specifications));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.ram_disk_id
             (fun f -> ("ram_disk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f ->
                ("placement", (LaunchTemplatePlacementRequest.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (LaunchTemplatesMonitoringRequest.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("network_interfaces",
               (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.to_json
                  v.network_interfaces));
           Some
             ("block_device_mappings",
               (LaunchTemplateBlockDeviceMappingRequestList.to_json
                  v.block_device_mappings));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (LaunchTemplateIamInstanceProfileSpecificationRequest.to_json
                     f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)))])
    let of_json j =
      {
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             LaunchTemplateIamInstanceProfileSpecificationRequest.of_json);
        block_device_mappings =
          (LaunchTemplateBlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        network_interfaces =
          (LaunchTemplateInstanceNetworkInterfaceSpecificationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             LaunchTemplatesMonitoringRequest.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement")
             LaunchTemplatePlacementRequest.of_json);
        ram_disk_id =
          (Util.option_map (Json.lookup j "ram_disk_id") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        tag_specifications =
          (LaunchTemplateTagSpecificationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        elastic_gpu_specifications =
          (ElasticGpuSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specifications")));
        elastic_inference_accelerators =
          (LaunchTemplateElasticInferenceAcceleratorList.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        security_group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             LaunchTemplateInstanceMarketOptionsRequest.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecificationRequest.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             LaunchTemplateCpuOptionsRequest.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             LaunchTemplateCapacityReservationSpecificationRequest.of_json);
        license_specifications =
          (LaunchTemplateLicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             LaunchTemplateHibernationOptionsRequest.of_json);
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             LaunchTemplateInstanceMetadataOptionsRequest.of_json);
        enclave_options =
          (Util.option_map (Json.lookup j "enclave_options")
             LaunchTemplateEnclaveOptionsRequest.of_json)
      }
  end
module NetworkAclIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TrafficMirrorSessionSet =
  struct
    type t = TrafficMirrorSession.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSession.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TrafficMirrorSession.to_query v
    let to_json v = `List (List.map TrafficMirrorSession.to_json v)
    let of_json j = Json.to_list TrafficMirrorSession.of_json j
  end
module ClientVpnEndpointIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NetworkInterfaceAttachmentChanges =
  struct
    type t =
      {
      attachment_id: String.t option ;
      delete_on_termination: Boolean.t option }
    let make ?attachment_id  ?delete_on_termination  () =
      { attachment_id; delete_on_termination }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          delete_on_termination =
            (Util.option_bind (Xml.member "deleteOnTermination" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f ->
                 Query.Pair ("DeleteOnTermination", (Boolean.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.delete_on_termination
              (fun f -> ("delete_on_termination", (Boolean.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        delete_on_termination =
          (Util.option_map (Json.lookup j "delete_on_termination")
             Boolean.of_json)
      }
  end
module PublicIpv4PoolIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Ipv6PoolSet =
  struct
    type t = Ipv6Pool.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Ipv6Pool.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Ipv6Pool.to_query v
    let to_json v = `List (List.map Ipv6Pool.to_json v)
    let of_json j = Json.to_list Ipv6Pool.of_json j
  end
module DeleteLaunchTemplateVersionsResponseErrorSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseErrorItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseErrorItem.to_query v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseErrorItem.to_json v)
    let of_json j =
      Json.to_list DeleteLaunchTemplateVersionsResponseErrorItem.of_json j
  end
module DeleteLaunchTemplateVersionsResponseSuccessSet =
  struct
    type t = DeleteLaunchTemplateVersionsResponseSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        DeleteLaunchTemplateVersionsResponseSuccessItem.to_query v
    let to_json v =
      `List
        (List.map DeleteLaunchTemplateVersionsResponseSuccessItem.to_json v)
    let of_json j =
      Json.to_list DeleteLaunchTemplateVersionsResponseSuccessItem.of_json j
  end
module KeyNameStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyName" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module KeyPairIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "KeyPairId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TransitGatewayMulticastRegisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      registered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(registered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        registered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          registered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "registeredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("RegisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.registered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("registered_network_interface_ids",
               (ValueStringList.to_json v.registered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        registered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "registered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module SpotInstanceRequestList =
  struct
    type t = SpotInstanceRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotInstanceRequest.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotInstanceRequest.to_query v
    let to_json v = `List (List.map SpotInstanceRequest.to_json v)
    let of_json j = Json.to_list SpotInstanceRequest.of_json j
  end
module FailedQueuedPurchaseDeletionSet =
  struct
    type t = FailedQueuedPurchaseDeletion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FailedQueuedPurchaseDeletion.parse (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FailedQueuedPurchaseDeletion.to_query v
    let to_json v = `List (List.map FailedQueuedPurchaseDeletion.to_json v)
    let of_json j = Json.to_list FailedQueuedPurchaseDeletion.of_json j
  end
module SuccessfulQueuedPurchaseDeletionSet =
  struct
    type t = SuccessfulQueuedPurchaseDeletion.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SuccessfulQueuedPurchaseDeletion.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SuccessfulQueuedPurchaseDeletion.to_query v
    let to_json v =
      `List (List.map SuccessfulQueuedPurchaseDeletion.to_json v)
    let of_json j = Json.to_list SuccessfulQueuedPurchaseDeletion.of_json j
  end
module ExportTaskList =
  struct
    type t = ExportTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ExportTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ExportTask.to_query v
    let to_json v = `List (List.map ExportTask.to_json v)
    let of_json j = Json.to_list ExportTask.of_json j
  end
module InstanceMonitoringList =
  struct
    type t = InstanceMonitoring.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceMonitoring.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceMonitoring.to_query v
    let to_json v = `List (List.map InstanceMonitoring.to_json v)
    let of_json j = Json.to_list InstanceMonitoring.of_json j
  end
module SecurityGroupList =
  struct
    type t = SecurityGroup.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SecurityGroup.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SecurityGroup.to_query v
    let to_json v = `List (List.map SecurityGroup.to_json v)
    let of_json j = Json.to_list SecurityGroup.of_json j
  end
module ServiceDetailSet =
  struct
    type t = ServiceDetail.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ServiceDetail.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ServiceDetail.to_query v
    let to_json v = `List (List.map ServiceDetail.to_json v)
    let of_json j = Json.to_list ServiceDetail.of_json j
  end
module EndpointSet =
  struct
    type t = ClientVpnEndpoint.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ClientVpnEndpoint.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ClientVpnEndpoint.to_query v
    let to_json v = `List (List.map ClientVpnEndpoint.to_json v)
    let of_json j = Json.to_list ClientVpnEndpoint.of_json j
  end
module FleetLaunchTemplateConfigListRequest =
  struct
    type t = FleetLaunchTemplateConfigRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map FleetLaunchTemplateConfigRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list FleetLaunchTemplateConfigRequest.to_query v
    let to_json v =
      `List (List.map FleetLaunchTemplateConfigRequest.to_json v)
    let of_json j = Json.to_list FleetLaunchTemplateConfigRequest.of_json j
  end
module OnDemandOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: FleetOnDemandAllocationStrategy.t option ;
      capacity_reservation_options:
        CapacityReservationOptionsRequest.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?capacity_reservation_options 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        capacity_reservation_options;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               FleetOnDemandAllocationStrategy.parse);
          capacity_reservation_options =
            (Util.option_bind (Xml.member "CapacityReservationOptions" xml)
               CapacityReservationOptionsRequest.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                Query.Pair
                  ("CapacityReservationOptions",
                    (CapacityReservationOptionsRequest.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy",
                    (FleetOnDemandAllocationStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.capacity_reservation_options
             (fun f ->
                ("capacity_reservation_options",
                  (CapacityReservationOptionsRequest.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy",
                  (FleetOnDemandAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             FleetOnDemandAllocationStrategy.of_json);
        capacity_reservation_options =
          (Util.option_map (Json.lookup j "capacity_reservation_options")
             CapacityReservationOptionsRequest.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module SpotOptionsRequest =
  struct
    type t =
      {
      allocation_strategy: SpotAllocationStrategy.t option ;
      maintenance_strategies: FleetSpotMaintenanceStrategiesRequest.t option ;
      instance_interruption_behavior:
        SpotInstanceInterruptionBehavior.t option ;
      instance_pools_to_use_count: Integer.t option ;
      single_instance_type: Boolean.t option ;
      single_availability_zone: Boolean.t option ;
      min_target_capacity: Integer.t option ;
      max_total_price: String.t option }
    let make ?allocation_strategy  ?maintenance_strategies 
      ?instance_interruption_behavior  ?instance_pools_to_use_count 
      ?single_instance_type  ?single_availability_zone  ?min_target_capacity 
      ?max_total_price  () =
      {
        allocation_strategy;
        maintenance_strategies;
        instance_interruption_behavior;
        instance_pools_to_use_count;
        single_instance_type;
        single_availability_zone;
        min_target_capacity;
        max_total_price
      }
    let parse xml =
      Some
        {
          allocation_strategy =
            (Util.option_bind (Xml.member "AllocationStrategy" xml)
               SpotAllocationStrategy.parse);
          maintenance_strategies =
            (Util.option_bind (Xml.member "MaintenanceStrategies" xml)
               FleetSpotMaintenanceStrategiesRequest.parse);
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               SpotInstanceInterruptionBehavior.parse);
          instance_pools_to_use_count =
            (Util.option_bind (Xml.member "InstancePoolsToUseCount" xml)
               Integer.parse);
          single_instance_type =
            (Util.option_bind (Xml.member "SingleInstanceType" xml)
               Boolean.parse);
          single_availability_zone =
            (Util.option_bind (Xml.member "SingleAvailabilityZone" xml)
               Boolean.parse);
          min_target_capacity =
            (Util.option_bind (Xml.member "MinTargetCapacity" xml)
               Integer.parse);
          max_total_price =
            (Util.option_bind (Xml.member "MaxTotalPrice" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> Query.Pair ("MaxTotalPrice", (String.to_query f)));
           Util.option_map v.min_target_capacity
             (fun f -> Query.Pair ("MinTargetCapacity", (Integer.to_query f)));
           Util.option_map v.single_availability_zone
             (fun f ->
                Query.Pair ("SingleAvailabilityZone", (Boolean.to_query f)));
           Util.option_map v.single_instance_type
             (fun f ->
                Query.Pair ("SingleInstanceType", (Boolean.to_query f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f ->
                Query.Pair ("InstancePoolsToUseCount", (Integer.to_query f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInterruptionBehavior",
                    (SpotInstanceInterruptionBehavior.to_query f)));
           Util.option_map v.maintenance_strategies
             (fun f ->
                Query.Pair
                  ("MaintenanceStrategies",
                    (FleetSpotMaintenanceStrategiesRequest.to_query f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                Query.Pair
                  ("AllocationStrategy", (SpotAllocationStrategy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_total_price
              (fun f -> ("max_total_price", (String.to_json f)));
           Util.option_map v.min_target_capacity
             (fun f -> ("min_target_capacity", (Integer.to_json f)));
           Util.option_map v.single_availability_zone
             (fun f -> ("single_availability_zone", (Boolean.to_json f)));
           Util.option_map v.single_instance_type
             (fun f -> ("single_instance_type", (Boolean.to_json f)));
           Util.option_map v.instance_pools_to_use_count
             (fun f -> ("instance_pools_to_use_count", (Integer.to_json f)));
           Util.option_map v.instance_interruption_behavior
             (fun f ->
                ("instance_interruption_behavior",
                  (SpotInstanceInterruptionBehavior.to_json f)));
           Util.option_map v.maintenance_strategies
             (fun f ->
                ("maintenance_strategies",
                  (FleetSpotMaintenanceStrategiesRequest.to_json f)));
           Util.option_map v.allocation_strategy
             (fun f ->
                ("allocation_strategy", (SpotAllocationStrategy.to_json f)))])
    let of_json j =
      {
        allocation_strategy =
          (Util.option_map (Json.lookup j "allocation_strategy")
             SpotAllocationStrategy.of_json);
        maintenance_strategies =
          (Util.option_map (Json.lookup j "maintenance_strategies")
             FleetSpotMaintenanceStrategiesRequest.of_json);
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             SpotInstanceInterruptionBehavior.of_json);
        instance_pools_to_use_count =
          (Util.option_map (Json.lookup j "instance_pools_to_use_count")
             Integer.of_json);
        single_instance_type =
          (Util.option_map (Json.lookup j "single_instance_type")
             Boolean.of_json);
        single_availability_zone =
          (Util.option_map (Json.lookup j "single_availability_zone")
             Boolean.of_json);
        min_target_capacity =
          (Util.option_map (Json.lookup j "min_target_capacity")
             Integer.of_json);
        max_total_price =
          (Util.option_map (Json.lookup j "max_total_price") String.of_json)
      }
  end
module TargetCapacitySpecificationRequest =
  struct
    type t =
      {
      total_target_capacity: Integer.t ;
      on_demand_target_capacity: Integer.t option ;
      spot_target_capacity: Integer.t option ;
      default_target_capacity_type: DefaultTargetCapacityType.t option }
    let make ~total_target_capacity  ?on_demand_target_capacity 
      ?spot_target_capacity  ?default_target_capacity_type  () =
      {
        total_target_capacity;
        on_demand_target_capacity;
        spot_target_capacity;
        default_target_capacity_type
      }
    let parse xml =
      Some
        {
          total_target_capacity =
            (Xml.required "TotalTargetCapacity"
               (Util.option_bind (Xml.member "TotalTargetCapacity" xml)
                  Integer.parse));
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "OnDemandTargetCapacity" xml)
               Integer.parse);
          spot_target_capacity =
            (Util.option_bind (Xml.member "SpotTargetCapacity" xml)
               Integer.parse);
          default_target_capacity_type =
            (Util.option_bind (Xml.member "DefaultTargetCapacityType" xml)
               DefaultTargetCapacityType.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 Query.Pair
                   ("DefaultTargetCapacityType",
                     (DefaultTargetCapacityType.to_query f)));
           Util.option_map v.spot_target_capacity
             (fun f ->
                Query.Pair ("SpotTargetCapacity", (Integer.to_query f)));
           Util.option_map v.on_demand_target_capacity
             (fun f ->
                Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TotalTargetCapacity",
                  (Integer.to_query v.total_target_capacity)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_target_capacity_type
              (fun f ->
                 ("default_target_capacity_type",
                   (DefaultTargetCapacityType.to_json f)));
           Util.option_map v.spot_target_capacity
             (fun f -> ("spot_target_capacity", (Integer.to_json f)));
           Util.option_map v.on_demand_target_capacity
             (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Some
             ("total_target_capacity",
               (Integer.to_json v.total_target_capacity))])
    let of_json j =
      {
        total_target_capacity =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "total_target_capacity")));
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json);
        spot_target_capacity =
          (Util.option_map (Json.lookup j "spot_target_capacity")
             Integer.of_json);
        default_target_capacity_type =
          (Util.option_map (Json.lookup j "default_target_capacity_type")
             DefaultTargetCapacityType.of_json)
      }
  end
module TransitGatewayMulticastDeregisteredGroupSources =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      deregistered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        deregistered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "deregistered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module InternetGatewayList =
  struct
    type t = InternetGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InternetGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InternetGateway.to_query v
    let to_json v = `List (List.map InternetGateway.to_json v)
    let of_json j = Json.to_list InternetGateway.of_json j
  end
module NetworkInterfaceIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module AccountAttributeNameStringList =
  struct
    type t = AccountAttributeName.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AccountAttributeName.parse
           (Xml.members "attributeName" xml))
    let to_query v = Query.to_query_list AccountAttributeName.to_query v
    let to_json v = `List (List.map AccountAttributeName.to_json v)
    let of_json j = Json.to_list AccountAttributeName.of_json j
  end
module ConversionIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CarrierGatewayIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module FleetSet =
  struct
    type t = FleetData.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map FleetData.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list FleetData.to_query v
    let to_json v = `List (List.map FleetData.to_json v)
    let of_json j = Json.to_list FleetData.of_json j
  end
module ImportTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ImportTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module InternetGatewayIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DeleteQueuedReservedInstancesIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotFleetRequestConfigSet =
  struct
    type t = SpotFleetRequestConfig.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SpotFleetRequestConfig.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotFleetRequestConfig.to_query v
    let to_json v = `List (List.map SpotFleetRequestConfig.to_json v)
    let of_json j = Json.to_list SpotFleetRequestConfig.of_json j
  end
module FpgaImageAttributeName =
  struct
    type t =
      | Description 
      | Name 
      | LoadPermission 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes);
      ("loadPermission", LoadPermission);
      ("name", Name);
      ("description", Description)]
    let t_to_str =
      [(ProductCodes, "productCodes");
      (LoadPermission, "loadPermission");
      (Name, "name");
      (Description, "description")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VolumeAttributeName =
  struct
    type t =
      | AutoEnableIO 
      | ProductCodes 
    let str_to_t =
      [("productCodes", ProductCodes); ("autoEnableIO", AutoEnableIO)]
    let t_to_str =
      [(ProductCodes, "productCodes"); (AutoEnableIO, "autoEnableIO")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module PurchaseRequestSet =
  struct
    type t = PurchaseRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PurchaseRequest.parse (Xml.members "PurchaseRequest" xml))
    let to_query v = Query.to_query_list PurchaseRequest.to_query v
    let to_json v = `List (List.map PurchaseRequest.to_json v)
    let of_json j = Json.to_list PurchaseRequest.of_json j
  end
module AvailabilityZoneList =
  struct
    type t = AvailabilityZone.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AvailabilityZone.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AvailabilityZone.to_query v
    let to_json v = `List (List.map AvailabilityZone.to_json v)
    let of_json j = Json.to_list AvailabilityZone.of_json j
  end
module CoipPoolIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module CustomerGatewayList =
  struct
    type t = CustomerGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map CustomerGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list CustomerGateway.to_query v
    let to_json v = `List (List.map CustomerGateway.to_json v)
    let of_json j = Json.to_list CustomerGateway.of_json j
  end
module VolumeStatusList =
  struct
    type t = VolumeStatusItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VolumeStatusItem.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VolumeStatusItem.to_query v
    let to_json v = `List (List.map VolumeStatusItem.to_json v)
    let of_json j = Json.to_list VolumeStatusItem.of_json j
  end
module TransitGatewayRequestOptions =
  struct
    type t =
      {
      amazon_side_asn: Long.t option ;
      auto_accept_shared_attachments:
        AutoAcceptSharedAttachmentsValue.t option ;
      default_route_table_association:
        DefaultRouteTableAssociationValue.t option ;
      default_route_table_propagation:
        DefaultRouteTablePropagationValue.t option ;
      vpn_ecmp_support: VpnEcmpSupportValue.t option ;
      dns_support: DnsSupportValue.t option ;
      multicast_support: MulticastSupportValue.t option }
    let make ?amazon_side_asn  ?auto_accept_shared_attachments 
      ?default_route_table_association  ?default_route_table_propagation 
      ?vpn_ecmp_support  ?dns_support  ?multicast_support  () =
      {
        amazon_side_asn;
        auto_accept_shared_attachments;
        default_route_table_association;
        default_route_table_propagation;
        vpn_ecmp_support;
        dns_support;
        multicast_support
      }
    let parse xml =
      Some
        {
          amazon_side_asn =
            (Util.option_bind (Xml.member "AmazonSideAsn" xml) Long.parse);
          auto_accept_shared_attachments =
            (Util.option_bind (Xml.member "AutoAcceptSharedAttachments" xml)
               AutoAcceptSharedAttachmentsValue.parse);
          default_route_table_association =
            (Util.option_bind (Xml.member "DefaultRouteTableAssociation" xml)
               DefaultRouteTableAssociationValue.parse);
          default_route_table_propagation =
            (Util.option_bind (Xml.member "DefaultRouteTablePropagation" xml)
               DefaultRouteTablePropagationValue.parse);
          vpn_ecmp_support =
            (Util.option_bind (Xml.member "VpnEcmpSupport" xml)
               VpnEcmpSupportValue.parse);
          dns_support =
            (Util.option_bind (Xml.member "DnsSupport" xml)
               DnsSupportValue.parse);
          multicast_support =
            (Util.option_bind (Xml.member "MulticastSupport" xml)
               MulticastSupportValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 Query.Pair
                   ("MulticastSupport", (MulticastSupportValue.to_query f)));
           Util.option_map v.dns_support
             (fun f ->
                Query.Pair ("DnsSupport", (DnsSupportValue.to_query f)));
           Util.option_map v.vpn_ecmp_support
             (fun f ->
                Query.Pair
                  ("VpnEcmpSupport", (VpnEcmpSupportValue.to_query f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                Query.Pair
                  ("DefaultRouteTablePropagation",
                    (DefaultRouteTablePropagationValue.to_query f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                Query.Pair
                  ("DefaultRouteTableAssociation",
                    (DefaultRouteTableAssociationValue.to_query f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                Query.Pair
                  ("AutoAcceptSharedAttachments",
                    (AutoAcceptSharedAttachmentsValue.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multicast_support
              (fun f ->
                 ("multicast_support", (MulticastSupportValue.to_json f)));
           Util.option_map v.dns_support
             (fun f -> ("dns_support", (DnsSupportValue.to_json f)));
           Util.option_map v.vpn_ecmp_support
             (fun f -> ("vpn_ecmp_support", (VpnEcmpSupportValue.to_json f)));
           Util.option_map v.default_route_table_propagation
             (fun f ->
                ("default_route_table_propagation",
                  (DefaultRouteTablePropagationValue.to_json f)));
           Util.option_map v.default_route_table_association
             (fun f ->
                ("default_route_table_association",
                  (DefaultRouteTableAssociationValue.to_json f)));
           Util.option_map v.auto_accept_shared_attachments
             (fun f ->
                ("auto_accept_shared_attachments",
                  (AutoAcceptSharedAttachmentsValue.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)))])
    let of_json j =
      {
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        auto_accept_shared_attachments =
          (Util.option_map (Json.lookup j "auto_accept_shared_attachments")
             AutoAcceptSharedAttachmentsValue.of_json);
        default_route_table_association =
          (Util.option_map (Json.lookup j "default_route_table_association")
             DefaultRouteTableAssociationValue.of_json);
        default_route_table_propagation =
          (Util.option_map (Json.lookup j "default_route_table_propagation")
             DefaultRouteTablePropagationValue.of_json);
        vpn_ecmp_support =
          (Util.option_map (Json.lookup j "vpn_ecmp_support")
             VpnEcmpSupportValue.of_json);
        dns_support =
          (Util.option_map (Json.lookup j "dns_support")
             DnsSupportValue.of_json);
        multicast_support =
          (Util.option_map (Json.lookup j "multicast_support")
             MulticastSupportValue.of_json)
      }
  end
module TransitGatewayRouteTableAssociationList =
  struct
    type t = TransitGatewayRouteTableAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTableAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayRouteTableAssociation.to_query v
    let to_json v =
      `List (List.map TransitGatewayRouteTableAssociation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayRouteTableAssociation.of_json j
  end
module HostOfferingSet =
  struct
    type t = HostOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map HostOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list HostOffering.to_query v
    let to_json v = `List (List.map HostOffering.to_json v)
    let of_json j = Json.to_list HostOffering.of_json j
  end
module TransitGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module Affinity =
  struct
    type t =
      | Default 
      | Host 
    let str_to_t = [("host", Host); ("default", Default)]
    let t_to_str = [(Host, "host"); (Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module HostTenancy =
  struct
    type t =
      | Dedicated 
      | Host 
    let str_to_t = [("host", Host); ("dedicated", Dedicated)]
    let t_to_str = [(Host, "host"); (Dedicated, "dedicated")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module NatGatewayIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module EgressOnlyInternetGatewayIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NetworkInterfacePermissionIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module TrafficMirrorFilterIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ModifyVpnTunnelOptionsSpecification =
  struct
    type t =
      {
      tunnel_inside_cidr: String.t option ;
      tunnel_inside_ipv6_cidr: String.t option ;
      pre_shared_key: String.t option ;
      phase1_lifetime_seconds: Integer.t option ;
      phase2_lifetime_seconds: Integer.t option ;
      rekey_margin_time_seconds: Integer.t option ;
      rekey_fuzz_percentage: Integer.t option ;
      replay_window_size: Integer.t option ;
      d_p_d_timeout_seconds: Integer.t option ;
      d_p_d_timeout_action: String.t option ;
      phase1_encryption_algorithms: Phase1EncryptionAlgorithmsRequestList.t ;
      phase2_encryption_algorithms: Phase2EncryptionAlgorithmsRequestList.t ;
      phase1_integrity_algorithms: Phase1IntegrityAlgorithmsRequestList.t ;
      phase2_integrity_algorithms: Phase2IntegrityAlgorithmsRequestList.t ;
      phase1_d_h_group_numbers: Phase1DHGroupNumbersRequestList.t ;
      phase2_d_h_group_numbers: Phase2DHGroupNumbersRequestList.t ;
      i_k_e_versions: IKEVersionsRequestList.t ;
      startup_action: String.t option }
    let make ?tunnel_inside_cidr  ?tunnel_inside_ipv6_cidr  ?pre_shared_key 
      ?phase1_lifetime_seconds  ?phase2_lifetime_seconds 
      ?rekey_margin_time_seconds  ?rekey_fuzz_percentage  ?replay_window_size
       ?d_p_d_timeout_seconds  ?d_p_d_timeout_action 
      ?(phase1_encryption_algorithms= [])  ?(phase2_encryption_algorithms=
      [])  ?(phase1_integrity_algorithms= [])  ?(phase2_integrity_algorithms=
      [])  ?(phase1_d_h_group_numbers= [])  ?(phase2_d_h_group_numbers= []) 
      ?(i_k_e_versions= [])  ?startup_action  () =
      {
        tunnel_inside_cidr;
        tunnel_inside_ipv6_cidr;
        pre_shared_key;
        phase1_lifetime_seconds;
        phase2_lifetime_seconds;
        rekey_margin_time_seconds;
        rekey_fuzz_percentage;
        replay_window_size;
        d_p_d_timeout_seconds;
        d_p_d_timeout_action;
        phase1_encryption_algorithms;
        phase2_encryption_algorithms;
        phase1_integrity_algorithms;
        phase2_integrity_algorithms;
        phase1_d_h_group_numbers;
        phase2_d_h_group_numbers;
        i_k_e_versions;
        startup_action
      }
    let parse xml =
      Some
        {
          tunnel_inside_cidr =
            (Util.option_bind (Xml.member "TunnelInsideCidr" xml)
               String.parse);
          tunnel_inside_ipv6_cidr =
            (Util.option_bind (Xml.member "TunnelInsideIpv6Cidr" xml)
               String.parse);
          pre_shared_key =
            (Util.option_bind (Xml.member "PreSharedKey" xml) String.parse);
          phase1_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase1LifetimeSeconds" xml)
               Integer.parse);
          phase2_lifetime_seconds =
            (Util.option_bind (Xml.member "Phase2LifetimeSeconds" xml)
               Integer.parse);
          rekey_margin_time_seconds =
            (Util.option_bind (Xml.member "RekeyMarginTimeSeconds" xml)
               Integer.parse);
          rekey_fuzz_percentage =
            (Util.option_bind (Xml.member "RekeyFuzzPercentage" xml)
               Integer.parse);
          replay_window_size =
            (Util.option_bind (Xml.member "ReplayWindowSize" xml)
               Integer.parse);
          d_p_d_timeout_seconds =
            (Util.option_bind (Xml.member "DPDTimeoutSeconds" xml)
               Integer.parse);
          d_p_d_timeout_action =
            (Util.option_bind (Xml.member "DPDTimeoutAction" xml)
               String.parse);
          phase1_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1EncryptionAlgorithm" xml)
                  Phase1EncryptionAlgorithmsRequestList.parse));
          phase2_encryption_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2EncryptionAlgorithm" xml)
                  Phase2EncryptionAlgorithmsRequestList.parse));
          phase1_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1IntegrityAlgorithm" xml)
                  Phase1IntegrityAlgorithmsRequestList.parse));
          phase2_integrity_algorithms =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2IntegrityAlgorithm" xml)
                  Phase2IntegrityAlgorithmsRequestList.parse));
          phase1_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase1DHGroupNumber" xml)
                  Phase1DHGroupNumbersRequestList.parse));
          phase2_d_h_group_numbers =
            (Util.of_option []
               (Util.option_bind (Xml.member "Phase2DHGroupNumber" xml)
                  Phase2DHGroupNumbersRequestList.parse));
          i_k_e_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IKEVersion" xml)
                  IKEVersionsRequestList.parse));
          startup_action =
            (Util.option_bind (Xml.member "StartupAction" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> Query.Pair ("StartupAction", (String.to_query f)));
           Some
             (Query.Pair
                ("IKEVersion",
                  (IKEVersionsRequestList.to_query v.i_k_e_versions)));
           Some
             (Query.Pair
                ("Phase2DHGroupNumber",
                  (Phase2DHGroupNumbersRequestList.to_query
                     v.phase2_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase1DHGroupNumber",
                  (Phase1DHGroupNumbersRequestList.to_query
                     v.phase1_d_h_group_numbers)));
           Some
             (Query.Pair
                ("Phase2IntegrityAlgorithm",
                  (Phase2IntegrityAlgorithmsRequestList.to_query
                     v.phase2_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase1IntegrityAlgorithm",
                  (Phase1IntegrityAlgorithmsRequestList.to_query
                     v.phase1_integrity_algorithms)));
           Some
             (Query.Pair
                ("Phase2EncryptionAlgorithm",
                  (Phase2EncryptionAlgorithmsRequestList.to_query
                     v.phase2_encryption_algorithms)));
           Some
             (Query.Pair
                ("Phase1EncryptionAlgorithm",
                  (Phase1EncryptionAlgorithmsRequestList.to_query
                     v.phase1_encryption_algorithms)));
           Util.option_map v.d_p_d_timeout_action
             (fun f -> Query.Pair ("DPDTimeoutAction", (String.to_query f)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> Query.Pair ("DPDTimeoutSeconds", (Integer.to_query f)));
           Util.option_map v.replay_window_size
             (fun f -> Query.Pair ("ReplayWindowSize", (Integer.to_query f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f ->
                Query.Pair ("RekeyFuzzPercentage", (Integer.to_query f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f ->
                Query.Pair ("RekeyMarginTimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase2LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f ->
                Query.Pair ("Phase1LifetimeSeconds", (Integer.to_query f)));
           Util.option_map v.pre_shared_key
             (fun f -> Query.Pair ("PreSharedKey", (String.to_query f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f ->
                Query.Pair ("TunnelInsideIpv6Cidr", (String.to_query f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> Query.Pair ("TunnelInsideCidr", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.startup_action
              (fun f -> ("startup_action", (String.to_json f)));
           Some
             ("i_k_e_versions",
               (IKEVersionsRequestList.to_json v.i_k_e_versions));
           Some
             ("phase2_d_h_group_numbers",
               (Phase2DHGroupNumbersRequestList.to_json
                  v.phase2_d_h_group_numbers));
           Some
             ("phase1_d_h_group_numbers",
               (Phase1DHGroupNumbersRequestList.to_json
                  v.phase1_d_h_group_numbers));
           Some
             ("phase2_integrity_algorithms",
               (Phase2IntegrityAlgorithmsRequestList.to_json
                  v.phase2_integrity_algorithms));
           Some
             ("phase1_integrity_algorithms",
               (Phase1IntegrityAlgorithmsRequestList.to_json
                  v.phase1_integrity_algorithms));
           Some
             ("phase2_encryption_algorithms",
               (Phase2EncryptionAlgorithmsRequestList.to_json
                  v.phase2_encryption_algorithms));
           Some
             ("phase1_encryption_algorithms",
               (Phase1EncryptionAlgorithmsRequestList.to_json
                  v.phase1_encryption_algorithms));
           Util.option_map v.d_p_d_timeout_action
             (fun f -> ("d_p_d_timeout_action", (String.to_json f)));
           Util.option_map v.d_p_d_timeout_seconds
             (fun f -> ("d_p_d_timeout_seconds", (Integer.to_json f)));
           Util.option_map v.replay_window_size
             (fun f -> ("replay_window_size", (Integer.to_json f)));
           Util.option_map v.rekey_fuzz_percentage
             (fun f -> ("rekey_fuzz_percentage", (Integer.to_json f)));
           Util.option_map v.rekey_margin_time_seconds
             (fun f -> ("rekey_margin_time_seconds", (Integer.to_json f)));
           Util.option_map v.phase2_lifetime_seconds
             (fun f -> ("phase2_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.phase1_lifetime_seconds
             (fun f -> ("phase1_lifetime_seconds", (Integer.to_json f)));
           Util.option_map v.pre_shared_key
             (fun f -> ("pre_shared_key", (String.to_json f)));
           Util.option_map v.tunnel_inside_ipv6_cidr
             (fun f -> ("tunnel_inside_ipv6_cidr", (String.to_json f)));
           Util.option_map v.tunnel_inside_cidr
             (fun f -> ("tunnel_inside_cidr", (String.to_json f)))])
    let of_json j =
      {
        tunnel_inside_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_cidr")
             String.of_json);
        tunnel_inside_ipv6_cidr =
          (Util.option_map (Json.lookup j "tunnel_inside_ipv6_cidr")
             String.of_json);
        pre_shared_key =
          (Util.option_map (Json.lookup j "pre_shared_key") String.of_json);
        phase1_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase1_lifetime_seconds")
             Integer.of_json);
        phase2_lifetime_seconds =
          (Util.option_map (Json.lookup j "phase2_lifetime_seconds")
             Integer.of_json);
        rekey_margin_time_seconds =
          (Util.option_map (Json.lookup j "rekey_margin_time_seconds")
             Integer.of_json);
        rekey_fuzz_percentage =
          (Util.option_map (Json.lookup j "rekey_fuzz_percentage")
             Integer.of_json);
        replay_window_size =
          (Util.option_map (Json.lookup j "replay_window_size")
             Integer.of_json);
        d_p_d_timeout_seconds =
          (Util.option_map (Json.lookup j "d_p_d_timeout_seconds")
             Integer.of_json);
        d_p_d_timeout_action =
          (Util.option_map (Json.lookup j "d_p_d_timeout_action")
             String.of_json);
        phase1_encryption_algorithms =
          (Phase1EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_encryption_algorithms")));
        phase2_encryption_algorithms =
          (Phase2EncryptionAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_encryption_algorithms")));
        phase1_integrity_algorithms =
          (Phase1IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase1_integrity_algorithms")));
        phase2_integrity_algorithms =
          (Phase2IntegrityAlgorithmsRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "phase2_integrity_algorithms")));
        phase1_d_h_group_numbers =
          (Phase1DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase1_d_h_group_numbers")));
        phase2_d_h_group_numbers =
          (Phase2DHGroupNumbersRequestList.of_json
             (Util.of_option_exn (Json.lookup j "phase2_d_h_group_numbers")));
        i_k_e_versions =
          (IKEVersionsRequestList.of_json
             (Util.of_option_exn (Json.lookup j "i_k_e_versions")));
        startup_action =
          (Util.option_map (Json.lookup j "startup_action") String.of_json)
      }
  end
module TransitGatewayRouteTableList =
  struct
    type t = TransitGatewayRouteTable.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayRouteTable.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list TransitGatewayRouteTable.to_query v
    let to_json v = `List (List.map TransitGatewayRouteTable.to_json v)
    let of_json j = Json.to_list TransitGatewayRouteTable.of_json j
  end
module RemovePrefixListEntries =
  struct
    type t = RemovePrefixListEntry.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map RemovePrefixListEntry.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list RemovePrefixListEntry.to_query v
    let to_json v = `List (List.map RemovePrefixListEntry.to_json v)
    let of_json j = Json.to_list RemovePrefixListEntry.of_json j
  end
module RouteTableIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ClientData =
  struct
    type t =
      {
      comment: String.t option ;
      upload_end: DateTime.t option ;
      upload_size: Double.t option ;
      upload_start: DateTime.t option }
    let make ?comment  ?upload_end  ?upload_size  ?upload_start  () =
      { comment; upload_end; upload_size; upload_start }
    let parse xml =
      Some
        {
          comment =
            (Util.option_bind (Xml.member "Comment" xml) String.parse);
          upload_end =
            (Util.option_bind (Xml.member "UploadEnd" xml) DateTime.parse);
          upload_size =
            (Util.option_bind (Xml.member "UploadSize" xml) Double.parse);
          upload_start =
            (Util.option_bind (Xml.member "UploadStart" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> Query.Pair ("UploadStart", (DateTime.to_query f)));
           Util.option_map v.upload_size
             (fun f -> Query.Pair ("UploadSize", (Double.to_query f)));
           Util.option_map v.upload_end
             (fun f -> Query.Pair ("UploadEnd", (DateTime.to_query f)));
           Util.option_map v.comment
             (fun f -> Query.Pair ("Comment", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.upload_start
              (fun f -> ("upload_start", (DateTime.to_json f)));
           Util.option_map v.upload_size
             (fun f -> ("upload_size", (Double.to_json f)));
           Util.option_map v.upload_end
             (fun f -> ("upload_end", (DateTime.to_json f)));
           Util.option_map v.comment
             (fun f -> ("comment", (String.to_json f)))])
    let of_json j =
      {
        comment = (Util.option_map (Json.lookup j "comment") String.of_json);
        upload_end =
          (Util.option_map (Json.lookup j "upload_end") DateTime.of_json);
        upload_size =
          (Util.option_map (Json.lookup j "upload_size") Double.of_json);
        upload_start =
          (Util.option_map (Json.lookup j "upload_start") DateTime.of_json)
      }
  end
module SnapshotDiskContainer =
  struct
    type t =
      {
      description: String.t option ;
      format: String.t option ;
      url: String.t option ;
      user_bucket: UserBucket.t option }
    let make ?description  ?format  ?url  ?user_bucket  () =
      { description; format; url; user_bucket }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          format = (Util.option_bind (Xml.member "Format" xml) String.parse);
          url = (Util.option_bind (Xml.member "Url" xml) String.parse);
          user_bucket =
            (Util.option_bind (Xml.member "UserBucket" xml) UserBucket.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> Query.Pair ("UserBucket", (UserBucket.to_query f)));
           Util.option_map v.url
             (fun f -> Query.Pair ("Url", (String.to_query f)));
           Util.option_map v.format
             (fun f -> Query.Pair ("Format", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_bucket
              (fun f -> ("user_bucket", (UserBucket.to_json f)));
           Util.option_map v.url (fun f -> ("url", (String.to_json f)));
           Util.option_map v.format (fun f -> ("format", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        format = (Util.option_map (Json.lookup j "format") String.of_json);
        url = (Util.option_map (Json.lookup j "url") String.of_json);
        user_bucket =
          (Util.option_map (Json.lookup j "user_bucket") UserBucket.of_json)
      }
  end
module TransitGatewayMulticastDeregisteredGroupMembers =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      deregistered_network_interface_ids: ValueStringList.t ;
      group_ip_address: String.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?(deregistered_network_interface_ids= [])  ?group_ip_address  () =
      {
        transit_gateway_multicast_domain_id;
        deregistered_network_interface_ids;
        group_ip_address
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomainId" xml)
               String.parse);
          deregistered_network_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "deregisteredNetworkInterfaceIds" xml)
                  ValueStringList.parse));
          group_ip_address =
            (Util.option_bind (Xml.member "groupIpAddress" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("DeregisteredNetworkInterfaceIds",
                  (ValueStringList.to_query
                     v.deregistered_network_interface_ids)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.group_ip_address
              (fun f -> ("group_ip_address", (String.to_json f)));
           Some
             ("deregistered_network_interface_ids",
               (ValueStringList.to_json v.deregistered_network_interface_ids));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        deregistered_network_interface_ids =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "deregistered_network_interface_ids")));
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json)
      }
  end
module AuthorizationRuleSet =
  struct
    type t = AuthorizationRule.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map AuthorizationRule.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list AuthorizationRule.to_query v
    let to_json v = `List (List.map AuthorizationRule.to_json v)
    let of_json j = Json.to_list AuthorizationRule.of_json j
  end
module TransitGatewayMulticastDomainAssociationList =
  struct
    type t = TransitGatewayMulticastDomainAssociation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TransitGatewayMulticastDomainAssociation.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list TransitGatewayMulticastDomainAssociation.to_query v
    let to_json v =
      `List (List.map TransitGatewayMulticastDomainAssociation.to_json v)
    let of_json j =
      Json.to_list TransitGatewayMulticastDomainAssociation.of_json j
  end
module TrafficMirrorSessionFieldList =
  struct
    type t = TrafficMirrorSessionField.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map TrafficMirrorSessionField.parse (Xml.members "member" xml))
    let to_query v = Query.to_query_list TrafficMirrorSessionField.to_query v
    let to_json v = `List (List.map TrafficMirrorSessionField.to_json v)
    let of_json j = Json.to_list TrafficMirrorSessionField.of_json j
  end
module SuccessfulInstanceCreditSpecificationSet =
  struct
    type t = SuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map SuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list SuccessfulInstanceCreditSpecificationItem.to_query
        v
    let to_json v =
      `List (List.map SuccessfulInstanceCreditSpecificationItem.to_json v)
    let of_json j =
      Json.to_list SuccessfulInstanceCreditSpecificationItem.of_json j
  end
module UnsuccessfulInstanceCreditSpecificationSet =
  struct
    type t = UnsuccessfulInstanceCreditSpecificationItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map UnsuccessfulInstanceCreditSpecificationItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list
        UnsuccessfulInstanceCreditSpecificationItem.to_query v
    let to_json v =
      `List (List.map UnsuccessfulInstanceCreditSpecificationItem.to_json v)
    let of_json j =
      Json.to_list UnsuccessfulInstanceCreditSpecificationItem.of_json j
  end
module ReservedInstancesOfferingList =
  struct
    type t = ReservedInstancesOffering.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReservedInstancesOffering.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReservedInstancesOffering.to_query v
    let to_json v = `List (List.map ReservedInstancesOffering.to_json v)
    let of_json j = Json.to_list ReservedInstancesOffering.of_json j
  end
module ScheduledInstanceAvailabilitySet =
  struct
    type t = ScheduledInstanceAvailability.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ScheduledInstanceAvailability.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ScheduledInstanceAvailability.to_query v
    let to_json v = `List (List.map ScheduledInstanceAvailability.to_json v)
    let of_json j = Json.to_list ScheduledInstanceAvailability.of_json j
  end
module ReservationList =
  struct
    type t = Reservation.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Reservation.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Reservation.to_query v
    let to_json v = `List (List.map Reservation.to_json v)
    let of_json j = Json.to_list Reservation.of_json j
  end
module LocalGatewayVirtualInterfaceGroupIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module PublicIpv4PoolSet =
  struct
    type t = PublicIpv4Pool.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map PublicIpv4Pool.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list PublicIpv4Pool.to_query v
    let to_json v = `List (List.map PublicIpv4Pool.to_json v)
    let of_json j = Json.to_list PublicIpv4Pool.of_json j
  end
module VpcList =
  struct
    type t = Vpc.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Vpc.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Vpc.to_query v
    let to_json v = `List (List.map Vpc.to_json v)
    let of_json j = Json.to_list Vpc.of_json j
  end
module LocalGatewaySet =
  struct
    type t = LocalGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map LocalGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGateway.to_query v
    let to_json v = `List (List.map LocalGateway.to_json v)
    let of_json j = Json.to_list LocalGateway.of_json j
  end
module PrefixListResourceIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SubnetList =
  struct
    type t = Subnet.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map Subnet.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list Subnet.to_query v
    let to_json v = `List (List.map Subnet.to_json v)
    let of_json j = Json.to_list Subnet.of_json j
  end
module ElasticGpuSet =
  struct
    type t = ElasticGpus.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map ElasticGpus.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ElasticGpus.to_query v
    let to_json v = `List (List.map ElasticGpus.to_json v)
    let of_json j = Json.to_list ElasticGpus.of_json j
  end
module VpcClassicLinkList =
  struct
    type t = VpcClassicLink.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map VpcClassicLink.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list VpcClassicLink.to_query v
    let to_json v = `List (List.map VpcClassicLink.to_json v)
    let of_json j = Json.to_list VpcClassicLink.of_json j
  end
module ImportImageTaskList =
  struct
    type t = ImportImageTask.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageTask.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImportImageTask.to_query v
    let to_json v = `List (List.map ImportImageTask.to_json v)
    let of_json j = Json.to_list ImportImageTask.of_json j
  end
module FlowLogResourceIds =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module FlowLogsResourceType =
  struct
    type t =
      | VPC 
      | Subnet 
      | NetworkInterface 
    let str_to_t =
      [("NetworkInterface", NetworkInterface);
      ("Subnet", Subnet);
      ("VPC", VPC)]
    let t_to_str =
      [(NetworkInterface, "NetworkInterface");
      (Subnet, "Subnet");
      (VPC, "VPC")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module VpcTenancy =
  struct
    type t =
      | Default 
    let str_to_t = [("default", Default)]
    let t_to_str = [(Default, "default")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module FpgaImageIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module DhcpOptionsIdStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "DhcpOptionsId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module SpotPriceHistoryList =
  struct
    type t = SpotPrice.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map SpotPrice.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list SpotPrice.to_query v
    let to_json v = `List (List.map SpotPrice.to_json v)
    let of_json j = Json.to_list SpotPrice.of_json j
  end
module ReasonCodesList =
  struct
    type t = ReportInstanceReasonCodes.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ReportInstanceReasonCodes.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ReportInstanceReasonCodes.to_query v
    let to_json v = `List (List.map ReportInstanceReasonCodes.to_json v)
    let of_json j = Json.to_list ReportInstanceReasonCodes.of_json j
  end
module ReportStatusType =
  struct
    type t =
      | Ok 
      | Impaired 
    let str_to_t = [("impaired", Impaired); ("ok", Ok)]
    let t_to_str = [(Impaired, "impaired"); (Ok, "ok")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module InstanceCreditSpecificationListRequest =
  struct
    type t = InstanceCreditSpecificationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map InstanceCreditSpecificationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list InstanceCreditSpecificationRequest.to_query v
    let to_json v =
      `List (List.map InstanceCreditSpecificationRequest.to_json v)
    let of_json j = Json.to_list InstanceCreditSpecificationRequest.of_json j
  end
module VersionStringList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module NetworkInterfaceCreationType =
  struct
    type t =
      | Efa 
    let str_to_t = [("efa", Efa)]
    let t_to_str = [(Efa, "efa")]
    let to_string e = Util.of_option_exn (Util.list_find t_to_str e)
    let of_string s = Util.of_option_exn (Util.list_find str_to_t s)
    let make v () = v
    let parse xml =
      Util.option_bind (String.parse xml)
        (fun s -> Util.list_find str_to_t s)
    let to_query v =
      Query.Value (Some (Util.of_option_exn (Util.list_find t_to_str v)))
    let to_json v =
      String.to_json (Util.of_option_exn (Util.list_find t_to_str v))
    let of_json j =
      Util.of_option_exn (Util.list_find str_to_t (String.of_json j))
  end
module HostReservationIdSet =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module ScheduledInstanceRecurrenceRequest =
  struct
    type t =
      {
      frequency: String.t option ;
      interval: Integer.t option ;
      occurrence_days: OccurrenceDayRequestSet.t ;
      occurrence_relative_to_end: Boolean.t option ;
      occurrence_unit: String.t option }
    let make ?frequency  ?interval  ?(occurrence_days= []) 
      ?occurrence_relative_to_end  ?occurrence_unit  () =
      {
        frequency;
        interval;
        occurrence_days;
        occurrence_relative_to_end;
        occurrence_unit
      }
    let parse xml =
      Some
        {
          frequency =
            (Util.option_bind (Xml.member "Frequency" xml) String.parse);
          interval =
            (Util.option_bind (Xml.member "Interval" xml) Integer.parse);
          occurrence_days =
            (Util.of_option []
               (Util.option_bind (Xml.member "OccurrenceDay" xml)
                  OccurrenceDayRequestSet.parse));
          occurrence_relative_to_end =
            (Util.option_bind (Xml.member "OccurrenceRelativeToEnd" xml)
               Boolean.parse);
          occurrence_unit =
            (Util.option_bind (Xml.member "OccurrenceUnit" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> Query.Pair ("OccurrenceUnit", (String.to_query f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f ->
                Query.Pair ("OccurrenceRelativeToEnd", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OccurrenceDay",
                  (OccurrenceDayRequestSet.to_query v.occurrence_days)));
           Util.option_map v.interval
             (fun f -> Query.Pair ("Interval", (Integer.to_query f)));
           Util.option_map v.frequency
             (fun f -> Query.Pair ("Frequency", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.occurrence_unit
              (fun f -> ("occurrence_unit", (String.to_json f)));
           Util.option_map v.occurrence_relative_to_end
             (fun f -> ("occurrence_relative_to_end", (Boolean.to_json f)));
           Some
             ("occurrence_days",
               (OccurrenceDayRequestSet.to_json v.occurrence_days));
           Util.option_map v.interval
             (fun f -> ("interval", (Integer.to_json f)));
           Util.option_map v.frequency
             (fun f -> ("frequency", (String.to_json f)))])
    let of_json j =
      {
        frequency =
          (Util.option_map (Json.lookup j "frequency") String.of_json);
        interval =
          (Util.option_map (Json.lookup j "interval") Integer.of_json);
        occurrence_days =
          (OccurrenceDayRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "occurrence_days")));
        occurrence_relative_to_end =
          (Util.option_map (Json.lookup j "occurrence_relative_to_end")
             Boolean.of_json);
        occurrence_unit =
          (Util.option_map (Json.lookup j "occurrence_unit") String.of_json)
      }
  end
module SlotDateTimeRangeRequest =
  struct
    type t = {
      earliest_time: DateTime.t ;
      latest_time: DateTime.t }
    let make ~earliest_time  ~latest_time  () =
      { earliest_time; latest_time }
    let parse xml =
      Some
        {
          earliest_time =
            (Xml.required "EarliestTime"
               (Util.option_bind (Xml.member "EarliestTime" xml)
                  DateTime.parse));
          latest_time =
            (Xml.required "LatestTime"
               (Util.option_bind (Xml.member "LatestTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("LatestTime", (DateTime.to_query v.latest_time)));
           Some
             (Query.Pair
                ("EarliestTime", (DateTime.to_query v.earliest_time)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("latest_time", (DateTime.to_json v.latest_time));
           Some ("earliest_time", (DateTime.to_json v.earliest_time))])
    let of_json j =
      {
        earliest_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "earliest_time")));
        latest_time =
          (DateTime.of_json
             (Util.of_option_exn (Json.lookup j "latest_time")))
      }
  end
module ImageDiskContainerList =
  struct
    type t = ImageDiskContainer.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImageDiskContainer.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list ImageDiskContainer.to_query v
    let to_json v = `List (List.map ImageDiskContainer.to_json v)
    let of_json j = Json.to_list ImageDiskContainer.of_json j
  end
module ImportImageLicenseSpecificationListRequest =
  struct
    type t = ImportImageLicenseConfigurationRequest.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map ImportImageLicenseConfigurationRequest.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list ImportImageLicenseConfigurationRequest.to_query v
    let to_json v =
      `List (List.map ImportImageLicenseConfigurationRequest.to_json v)
    let of_json j =
      Json.to_list ImportImageLicenseConfigurationRequest.of_json j
  end
module LocalGatewayRouteList =
  struct
    type t = LocalGatewayRoute.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map LocalGatewayRoute.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list LocalGatewayRoute.to_query v
    let to_json v = `List (List.map LocalGatewayRoute.to_json v)
    let of_json j = Json.to_list LocalGatewayRoute.of_json j
  end
module ScheduledInstancesLaunchSpecification =
  struct
    type t =
      {
      block_device_mappings: ScheduledInstancesBlockDeviceMappingSet.t ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: ScheduledInstancesIamInstanceProfile.t option ;
      image_id: String.t ;
      instance_type: String.t option ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      monitoring: ScheduledInstancesMonitoring.t option ;
      network_interfaces: ScheduledInstancesNetworkInterfaceSet.t ;
      placement: ScheduledInstancesPlacement.t option ;
      ramdisk_id: String.t option ;
      security_group_ids: ScheduledInstancesSecurityGroupIdSet.t ;
      subnet_id: String.t option ;
      user_data: String.t option }
    let make ?(block_device_mappings= [])  ?ebs_optimized 
      ?iam_instance_profile  ~image_id  ?instance_type  ?kernel_id  ?key_name
       ?monitoring  ?(network_interfaces= [])  ?placement  ?ramdisk_id 
      ?(security_group_ids= [])  ?subnet_id  ?user_data  () =
      {
        block_device_mappings;
        ebs_optimized;
        iam_instance_profile;
        image_id;
        instance_type;
        kernel_id;
        key_name;
        monitoring;
        network_interfaces;
        placement;
        ramdisk_id;
        security_group_ids;
        subnet_id;
        user_data
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  ScheduledInstancesBlockDeviceMappingSet.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "IamInstanceProfile" xml)
               ScheduledInstancesIamInstanceProfile.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml) String.parse);
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               ScheduledInstancesMonitoring.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterface" xml)
                  ScheduledInstancesNetworkInterfaceSet.parse));
          placement =
            (Util.option_bind (Xml.member "Placement" xml)
               ScheduledInstancesPlacement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ScheduledInstancesSecurityGroupIdSet.parse));
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ScheduledInstancesSecurityGroupIdSet.to_query
                     v.security_group_ids)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f ->
                Query.Pair
                  ("Placement", (ScheduledInstancesPlacement.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (ScheduledInstancesNetworkInterfaceSet.to_query
                     v.network_interfaces)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (ScheduledInstancesMonitoring.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (ScheduledInstancesIamInstanceProfile.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (ScheduledInstancesBlockDeviceMappingSet.to_query
                     v.block_device_mappings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ScheduledInstancesSecurityGroupIdSet.to_json
                  v.security_group_ids));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (ScheduledInstancesPlacement.to_json f)));
           Some
             ("network_interfaces",
               (ScheduledInstancesNetworkInterfaceSet.to_json
                  v.network_interfaces));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (ScheduledInstancesMonitoring.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (ScheduledInstancesIamInstanceProfile.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some
             ("block_device_mappings",
               (ScheduledInstancesBlockDeviceMappingSet.to_json
                  v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (ScheduledInstancesBlockDeviceMappingSet.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             ScheduledInstancesIamInstanceProfile.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             ScheduledInstancesMonitoring.of_json);
        network_interfaces =
          (ScheduledInstancesNetworkInterfaceSet.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        placement =
          (Util.option_map (Json.lookup j "placement")
             ScheduledInstancesPlacement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        security_group_ids =
          (ScheduledInstancesSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json)
      }
  end
module ExportImageTaskIdList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map String.parse (Xml.members "ExportImageTaskId" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module RegisterInstanceTagAttributeRequest =
  struct
    type t =
      {
      include_all_tags_of_instance: Boolean.t option ;
      instance_tag_keys: InstanceTagKeySet.t }
    let make ?include_all_tags_of_instance  ?(instance_tag_keys= [])  () =
      { include_all_tags_of_instance; instance_tag_keys }
    let parse xml =
      Some
        {
          include_all_tags_of_instance =
            (Util.option_bind (Xml.member "IncludeAllTagsOfInstance" xml)
               Boolean.parse);
          instance_tag_keys =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceTagKey" xml)
                  InstanceTagKeySet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceTagKey",
                   (InstanceTagKeySet.to_query v.instance_tag_keys)));
           Util.option_map v.include_all_tags_of_instance
             (fun f ->
                Query.Pair ("IncludeAllTagsOfInstance", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_tag_keys",
                (InstanceTagKeySet.to_json v.instance_tag_keys));
           Util.option_map v.include_all_tags_of_instance
             (fun f -> ("include_all_tags_of_instance", (Boolean.to_json f)))])
    let of_json j =
      {
        include_all_tags_of_instance =
          (Util.option_map (Json.lookup j "include_all_tags_of_instance")
             Boolean.of_json);
        instance_tag_keys =
          (InstanceTagKeySet.of_json
             (Util.of_option_exn (Json.lookup j "instance_tag_keys")))
      }
  end
module NatGatewayList =
  struct
    type t = NatGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map NatGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list NatGateway.to_query v
    let to_json v = `List (List.map NatGateway.to_json v)
    let of_json j = Json.to_list NatGateway.of_json j
  end
module InstanceUsageSet =
  struct
    type t = InstanceUsage.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map InstanceUsage.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list InstanceUsage.to_query v
    let to_json v = `List (List.map InstanceUsage.to_json v)
    let of_json j = Json.to_list InstanceUsage.of_json j
  end
module DescribeFastSnapshotRestoreSuccessSet =
  struct
    type t = DescribeFastSnapshotRestoreSuccessItem.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map DescribeFastSnapshotRestoreSuccessItem.parse
           (Xml.members "item" xml))
    let to_query v =
      Query.to_query_list DescribeFastSnapshotRestoreSuccessItem.to_query v
    let to_json v =
      `List (List.map DescribeFastSnapshotRestoreSuccessItem.to_json v)
    let of_json j =
      Json.to_list DescribeFastSnapshotRestoreSuccessItem.of_json j
  end
module ReservedInstanceLimitPrice =
  struct
    type t =
      {
      amount: Double.t option ;
      currency_code: CurrencyCodeValues.t option }
    let make ?amount  ?currency_code  () = { amount; currency_code }
    let parse xml =
      Some
        {
          amount = (Util.option_bind (Xml.member "amount" xml) Double.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f ->
                 Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.amount
             (fun f -> Query.Pair ("Amount", (Double.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.currency_code
              (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.amount (fun f -> ("amount", (Double.to_json f)))])
    let of_json j =
      {
        amount = (Util.option_map (Json.lookup j "amount") Double.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json)
      }
  end
module ConnectionNotificationIdsList =
  struct
    type t = String.t list
    let make elems () = elems
    let parse xml =
      Util.option_all (List.map String.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list String.to_query v
    let to_json v = `List (List.map String.to_json v)
    let of_json j = Json.to_list String.of_json j
  end
module EgressOnlyInternetGatewayList =
  struct
    type t = EgressOnlyInternetGateway.t list
    let make elems () = elems
    let parse xml =
      Util.option_all
        (List.map EgressOnlyInternetGateway.parse (Xml.members "item" xml))
    let to_query v = Query.to_query_list EgressOnlyInternetGateway.to_query v
    let to_json v = `List (List.map EgressOnlyInternetGateway.to_json v)
    let of_json j = Json.to_list EgressOnlyInternetGateway.of_json j
  end
module LoadPermissionModifications =
  struct
    type t =
      {
      add: LoadPermissionListRequest.t ;
      remove: LoadPermissionListRequest.t }
    let make ?(add= [])  ?(remove= [])  () = { add; remove }
    let parse xml =
      Some
        {
          add =
            (Util.of_option []
               (Util.option_bind (Xml.member "Add" xml)
                  LoadPermissionListRequest.parse));
          remove =
            (Util.of_option []
               (Util.option_bind (Xml.member "Remove" xml)
                  LoadPermissionListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Remove", (LoadPermissionListRequest.to_query v.remove)));
           Some
             (Query.Pair ("Add", (LoadPermissionListRequest.to_query v.add)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("remove", (LoadPermissionListRequest.to_json v.remove));
           Some ("add", (LoadPermissionListRequest.to_json v.add))])
    let of_json j =
      {
        add =
          (LoadPermissionListRequest.of_json
             (Util.of_option_exn (Json.lookup j "add")));
        remove =
          (LoadPermissionListRequest.of_json
             (Util.of_option_exn (Json.lookup j "remove")))
      }
  end
module DescribeCapacityReservationsRequest =
  struct
    type t =
      {
      capacity_reservation_ids: CapacityReservationIdSet.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(capacity_reservation_ids= [])  ?next_token  ?max_results 
      ?(filters= [])  ?dry_run  () =
      { capacity_reservation_ids; next_token; max_results; filters; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  CapacityReservationIdSet.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (CapacityReservationIdSet.to_query
                     v.capacity_reservation_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("capacity_reservation_ids",
               (CapacityReservationIdSet.to_json v.capacity_reservation_ids))])
    let of_json j =
      {
        capacity_reservation_ids =
          (CapacityReservationIdSet.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteNetworkAclRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_acl_id: String.t }
    let make ?dry_run  ~network_acl_id  () = { dry_run; network_acl_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module CreateImageRequest =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      name: String.t ;
      no_reboot: Boolean.t option }
    let make ?(block_device_mappings= [])  ?description  ?dry_run 
      ~instance_id  ~name  ?no_reboot  () =
      {
        block_device_mappings;
        description;
        dry_run;
        instance_id;
        name;
        no_reboot
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          no_reboot =
            (Util.option_bind (Xml.member "noReboot" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.no_reboot
              (fun f -> Query.Pair ("NoReboot", (Boolean.to_query f)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.no_reboot
              (fun f -> ("no_reboot", (Boolean.to_json f)));
           Some ("name", (String.to_json v.name));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        no_reboot =
          (Util.option_map (Json.lookup j "no_reboot") Boolean.of_json)
      }
  end
module CreateCapacityReservationRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      instance_type: String.t ;
      instance_platform: CapacityReservationInstancePlatform.t ;
      availability_zone: String.t option ;
      availability_zone_id: String.t option ;
      tenancy: CapacityReservationTenancy.t option ;
      instance_count: Integer.t ;
      ebs_optimized: Boolean.t option ;
      ephemeral_storage: Boolean.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      instance_match_criteria: InstanceMatchCriteria.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?client_token  ~instance_type  ~instance_platform 
      ?availability_zone  ?availability_zone_id  ?tenancy  ~instance_count 
      ?ebs_optimized  ?ephemeral_storage  ?end_date  ?end_date_type 
      ?instance_match_criteria  ?(tag_specifications= [])  ?dry_run  () =
      {
        client_token;
        instance_type;
        instance_platform;
        availability_zone;
        availability_zone_id;
        tenancy;
        instance_count;
        ebs_optimized;
        ephemeral_storage;
        end_date;
        end_date_type;
        instance_match_criteria;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          instance_type =
            (Xml.required "InstanceType"
               (Util.option_bind (Xml.member "InstanceType" xml) String.parse));
          instance_platform =
            (Xml.required "InstancePlatform"
               (Util.option_bind (Xml.member "InstancePlatform" xml)
                  CapacityReservationInstancePlatform.parse));
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "AvailabilityZoneId" xml)
               String.parse);
          tenancy =
            (Util.option_bind (Xml.member "Tenancy" xml)
               CapacityReservationTenancy.parse);
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          ebs_optimized =
            (Util.option_bind (Xml.member "EbsOptimized" xml) Boolean.parse);
          ephemeral_storage =
            (Util.option_bind (Xml.member "EphemeralStorage" xml)
               Boolean.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "EndDateType" xml)
               EndDateType.parse);
          instance_match_criteria =
            (Util.option_bind (Xml.member "InstanceMatchCriteria" xml)
               InstanceMatchCriteria.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.instance_match_criteria
             (fun f ->
                Query.Pair
                  ("InstanceMatchCriteria",
                    (InstanceMatchCriteria.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.ephemeral_storage
             (fun f -> Query.Pair ("EphemeralStorage", (Boolean.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Util.option_map v.tenancy
             (fun f ->
                Query.Pair
                  ("Tenancy", (CapacityReservationTenancy.to_query f)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancePlatform",
                  (CapacityReservationInstancePlatform.to_query
                     v.instance_platform)));
           Some
             (Query.Pair ("InstanceType", (String.to_query v.instance_type)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.instance_match_criteria
             (fun f ->
                ("instance_match_criteria",
                  (InstanceMatchCriteria.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.ephemeral_storage
             (fun f -> ("ephemeral_storage", (Boolean.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (CapacityReservationTenancy.to_json f)));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some
             ("instance_platform",
               (CapacityReservationInstancePlatform.to_json
                  v.instance_platform));
           Some ("instance_type", (String.to_json v.instance_type));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_type =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "instance_type")));
        instance_platform =
          (CapacityReservationInstancePlatform.of_json
             (Util.of_option_exn (Json.lookup j "instance_platform")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        tenancy =
          (Util.option_map (Json.lookup j "tenancy")
             CapacityReservationTenancy.of_json);
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        ephemeral_storage =
          (Util.option_map (Json.lookup j "ephemeral_storage")
             Boolean.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        instance_match_criteria =
          (Util.option_map (Json.lookup j "instance_match_criteria")
             InstanceMatchCriteria.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorFilterResult =
  struct
    type t =
      {
      traffic_mirror_filter: TrafficMirrorFilter.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_filter  ?client_token  () =
      { traffic_mirror_filter; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter
             (fun f ->
                ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter =
          (Util.option_map (Json.lookup j "traffic_mirror_filter")
             TrafficMirrorFilter.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeTagsResult =
  struct
    type t = {
      next_token: String.t option ;
      tags: TagDescriptionList.t }
    let make ?next_token  ?(tags= [])  () = { next_token; tags }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml)
                  TagDescriptionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("TagSet", (TagDescriptionList.to_query v.tags)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagDescriptionList.to_json v.tags));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        tags =
          (TagDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptionsList.t ;
      next_token: String.t option }
    let make ?(dhcp_options= [])  ?next_token  () =
      { dhcp_options; next_token }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.of_option []
               (Util.option_bind (Xml.member "dhcpOptionsSet" xml)
                  DhcpOptionsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("DhcpOptionsSet", (DhcpOptionsList.to_query v.dhcp_options)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("dhcp_options", (DhcpOptionsList.to_json v.dhcp_options))])
    let of_json j =
      {
        dhcp_options =
          (DhcpOptionsList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpnGatewaysResult =
  struct
    type t = {
      vpn_gateways: VpnGatewayList.t }
    let make ?(vpn_gateways= [])  () = { vpn_gateways }
    let parse xml =
      Some
        {
          vpn_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnGatewaySet" xml)
                  VpnGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnGatewaySet", (VpnGatewayList.to_query v.vpn_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_gateways", (VpnGatewayList.to_json v.vpn_gateways))])
    let of_json j =
      {
        vpn_gateways =
          (VpnGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateways")))
      }
  end
module GetTransitGatewayAttachmentPropagationsResult =
  struct
    type t =
      {
      transit_gateway_attachment_propagations:
        TransitGatewayAttachmentPropagationList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_attachment_propagations= [])  ?next_token  ()
      = { transit_gateway_attachment_propagations; next_token }
    let parse xml =
      Some
        {
          transit_gateway_attachment_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayAttachmentPropagations" xml)
                  TransitGatewayAttachmentPropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentPropagations",
                  (TransitGatewayAttachmentPropagationList.to_query
                     v.transit_gateway_attachment_propagations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachment_propagations",
               (TransitGatewayAttachmentPropagationList.to_json
                  v.transit_gateway_attachment_propagations))])
    let of_json j =
      {
        transit_gateway_attachment_propagations =
          (TransitGatewayAttachmentPropagationList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_propagations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetTransitGatewayPrefixListReferencesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeCapacityReservationsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      capacity_reservations: CapacityReservationSet.t }
    let make ?next_token  ?(capacity_reservations= [])  () =
      { next_token; capacity_reservations }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "capacityReservationSet" xml)
                  CapacityReservationSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CapacityReservationSet",
                   (CapacityReservationSet.to_query v.capacity_reservations)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("capacity_reservations",
                (CapacityReservationSet.to_json v.capacity_reservations));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        capacity_reservations =
          (CapacityReservationSet.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservations")))
      }
  end
module DescribeElasticGpusRequest =
  struct
    type t =
      {
      elastic_gpu_ids: ElasticGpuIdSet.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(elastic_gpu_ids= [])  ?dry_run  ?(filters= [])  ?max_results 
      ?next_token  () =
      { elastic_gpu_ids; dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          elastic_gpu_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuId" xml)
                  ElasticGpuIdSet.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ElasticGpuId",
                  (ElasticGpuIdSet.to_query v.elastic_gpu_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("elastic_gpu_ids", (ElasticGpuIdSet.to_json v.elastic_gpu_ids))])
    let of_json j =
      {
        elastic_gpu_ids =
          (ElasticGpuIdSet.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteLocalGatewayRouteTableVpcAssociationRequest =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_vpc_association_id  ?dry_run  () =
      { local_gateway_route_table_vpc_association_id; dry_run }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_id =
            (Xml.required "LocalGatewayRouteTableVpcAssociationId"
               (Util.option_bind
                  (Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationId",
                  (String.to_query
                     v.local_gateway_route_table_vpc_association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_route_table_vpc_association_id",
               (String.to_json v.local_gateway_route_table_vpc_association_id))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_vpc_association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AuthorizeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      ip_permissions: IpPermissionList.t ;
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      to_port: Integer.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option }
    let make ?dry_run  ~group_id  ?(ip_permissions= [])  ?cidr_ip  ?from_port
       ?ip_protocol  ?to_port  ?source_security_group_name 
      ?source_security_group_owner_id  () =
      {
        dry_run;
        group_id;
        ip_permissions;
        cidr_ip;
        from_port;
        ip_protocol;
        to_port;
        source_security_group_name;
        source_security_group_owner_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Query.Pair
                   ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json)
      }
  end
module DescribeReservedInstancesModificationsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      reserved_instances_modifications: ReservedInstancesModificationList.t }
    let make ?next_token  ?(reserved_instances_modifications= [])  () =
      { next_token; reserved_instances_modifications }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          reserved_instances_modifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesModificationsSet" xml)
                  ReservedInstancesModificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesModificationsSet",
                   (ReservedInstancesModificationList.to_query
                      v.reserved_instances_modifications)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_modifications",
                (ReservedInstancesModificationList.to_json
                   v.reserved_instances_modifications));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        reserved_instances_modifications =
          (ReservedInstancesModificationList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modifications")))
      }
  end
module CreateNetworkAclEntryRequest =
  struct
    type t =
      {
      cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      network_acl_id: String.t ;
      port_range: PortRange.t option ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      rule_number: Integer.t }
    let make ?cidr_block  ?dry_run  ~egress  ?icmp_type_code 
      ?ipv6_cidr_block  ~network_acl_id  ?port_range  ~protocol  ~rule_action
       ~rule_number  () =
      {
        cidr_block;
        dry_run;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        network_acl_id;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module DescribeTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token  () =
      { dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePlacementGroupsResult =
  struct
    type t = {
      placement_groups: PlacementGroupList.t }
    let make ?(placement_groups= [])  () = { placement_groups }
    let parse xml =
      Some
        {
          placement_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "placementGroupSet" xml)
                  PlacementGroupList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PlacementGroupSet",
                   (PlacementGroupList.to_query v.placement_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("placement_groups",
                (PlacementGroupList.to_json v.placement_groups))])
    let of_json j =
      {
        placement_groups =
          (PlacementGroupList.of_json
             (Util.of_option_exn (Json.lookup j "placement_groups")))
      }
  end
module GetTransitGatewayRouteTablePropagationsResult =
  struct
    type t =
      {
      transit_gateway_route_table_propagations:
        TransitGatewayRouteTablePropagationList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_route_table_propagations= [])  ?next_token  ()
      = { transit_gateway_route_table_propagations; next_token }
    let parse xml =
      Some
        {
          transit_gateway_route_table_propagations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayRouteTablePropagations" xml)
                  TransitGatewayRouteTablePropagationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTablePropagations",
                  (TransitGatewayRouteTablePropagationList.to_query
                     v.transit_gateway_route_table_propagations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_table_propagations",
               (TransitGatewayRouteTablePropagationList.to_json
                  v.transit_gateway_route_table_propagations))])
    let of_json j =
      {
        transit_gateway_route_table_propagations =
          (TransitGatewayRouteTablePropagationList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_propagations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateSubnetRequest =
  struct
    type t =
      {
      tag_specifications: TagSpecificationList.t ;
      availability_zone: String.t option ;
      availability_zone_id: String.t option ;
      cidr_block: String.t ;
      ipv6_cidr_block: String.t option ;
      outpost_arn: String.t option ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ?(tag_specifications= [])  ?availability_zone 
      ?availability_zone_id  ~cidr_block  ?ipv6_cidr_block  ?outpost_arn 
      ~vpc_id  ?dry_run  () =
      {
        tag_specifications;
        availability_zone;
        availability_zone_id;
        cidr_block;
        ipv6_cidr_block;
        outpost_arn;
        vpc_id;
        dry_run
      }
    let parse xml =
      Some
        {
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          availability_zone_id =
            (Util.option_bind (Xml.member "AvailabilityZoneId" xml)
               String.parse);
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "Ipv6CidrBlock" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "OutpostArn" xml) String.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)));
           Util.option_map v.availability_zone_id
             (fun f -> Query.Pair ("AvailabilityZoneId", (String.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block));
           Util.option_map v.availability_zone_id
             (fun f -> ("availability_zone_id", (String.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications))])
    let of_json j =
      {
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        availability_zone_id =
          (Util.option_map (Json.lookup j "availability_zone_id")
             String.of_json);
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeletePlacementGroupRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      group_name: String.t }
    let make ?dry_run  ~group_name  () = { dry_run; group_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Xml.required "groupName"
               (Util.option_bind (Xml.member "groupName" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_name", (String.to_json v.group_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")))
      }
  end
module DescribeKeyPairsResult =
  struct
    type t = {
      key_pairs: KeyPairList.t }
    let make ?(key_pairs= [])  () = { key_pairs }
    let parse xml =
      Some
        {
          key_pairs =
            (Util.of_option []
               (Util.option_bind (Xml.member "keySet" xml) KeyPairList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("KeySet", (KeyPairList.to_query v.key_pairs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("key_pairs", (KeyPairList.to_json v.key_pairs))])
    let of_json j =
      {
        key_pairs =
          (KeyPairList.of_json
             (Util.of_option_exn (Json.lookup j "key_pairs")))
      }
  end
module CreateLaunchTemplateResult =
  struct
    type t =
      {
      launch_template: LaunchTemplate.t option ;
      warning: ValidationWarning.t option }
    let make ?launch_template  ?warning  () = { launch_template; warning }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse);
          warning =
            (Util.option_bind (Xml.member "warning" xml)
               ValidationWarning.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.warning
              (fun f ->
                 Query.Pair ("Warning", (ValidationWarning.to_query f)));
           Util.option_map v.launch_template
             (fun f ->
                Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.warning
              (fun f -> ("warning", (ValidationWarning.to_json f)));
           Util.option_map v.launch_template
             (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json);
        warning =
          (Util.option_map (Json.lookup j "warning")
             ValidationWarning.of_json)
      }
  end
module DescribeFleetHistoryResult =
  struct
    type t =
      {
      history_records: HistoryRecordSet.t ;
      last_evaluated_time: DateTime.t option ;
      next_token: String.t option ;
      fleet_id: String.t option ;
      start_time: DateTime.t option }
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?fleet_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        fleet_id;
        start_time
      }
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecordSet.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecordSet.to_query v.history_records)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records",
               (HistoryRecordSet.to_json v.history_records))])
    let of_json j =
      {
        history_records =
          (HistoryRecordSet.of_json
             (Util.of_option_exn (Json.lookup j "history_records")));
        last_evaluated_time =
          (Util.option_map (Json.lookup j "last_evaluated_time")
             DateTime.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module DescribeHostReservationsResult =
  struct
    type t =
      {
      host_reservation_set: HostReservationSet.t ;
      next_token: String.t option }
    let make ?(host_reservation_set= [])  ?next_token  () =
      { host_reservation_set; next_token }
    let parse xml =
      Some
        {
          host_reservation_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostReservationSet" xml)
                  HostReservationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("HostReservationSet",
                  (HostReservationSet.to_query v.host_reservation_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("host_reservation_set",
               (HostReservationSet.to_json v.host_reservation_set))])
    let of_json j =
      {
        host_reservation_set =
          (HostReservationSet.of_json
             (Util.of_option_exn (Json.lookup j "host_reservation_set")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyImageAttributeRequest =
  struct
    type t =
      {
      attribute: String.t option ;
      description: AttributeValue.t option ;
      image_id: String.t ;
      launch_permission: LaunchPermissionModifications.t option ;
      operation_type: OperationType.t option ;
      product_codes: ProductCodeStringList.t ;
      user_groups: UserGroupStringList.t ;
      user_ids: UserIdStringList.t ;
      value: String.t option ;
      dry_run: Boolean.t option }
    let make ?attribute  ?description  ~image_id  ?launch_permission 
      ?operation_type  ?(product_codes= [])  ?(user_groups= [])  ?(user_ids=
      [])  ?value  ?dry_run  () =
      {
        attribute;
        description;
        image_id;
        launch_permission;
        operation_type;
        product_codes;
        user_groups;
        user_ids;
        value;
        dry_run
      }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml)
               AttributeValue.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          launch_permission =
            (Util.option_bind (Xml.member "LaunchPermission" xml)
               LaunchPermissionModifications.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductCode" xml)
                  ProductCodeStringList.parse));
          user_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  UserGroupStringList.parse));
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          value = (Util.option_bind (Xml.member "Value" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.value
             (fun f -> Query.Pair ("Value", (String.to_query f)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Some
             (Query.Pair
                ("UserGroup", (UserGroupStringList.to_query v.user_groups)));
           Some
             (Query.Pair
                ("ProductCode",
                  (ProductCodeStringList.to_query v.product_codes)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.launch_permission
             (fun f ->
                Query.Pair
                  ("LaunchPermission",
                    (LaunchPermissionModifications.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attribute
             (fun f -> Query.Pair ("Attribute", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Some ("user_groups", (UserGroupStringList.to_json v.user_groups));
           Some
             ("product_codes",
               (ProductCodeStringList.to_json v.product_codes));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.launch_permission
             (fun f ->
                ("launch_permission",
                  (LaunchPermissionModifications.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (String.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        launch_permission =
          (Util.option_map (Json.lookup j "launch_permission")
             LaunchPermissionModifications.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        product_codes =
          (ProductCodeStringList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        user_groups =
          (UserGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_groups")));
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        value = (Util.option_map (Json.lookup j "value") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceAttributeRequest =
  struct
    type t =
      {
      attribute: InstanceAttributeName.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ~attribute  ?dry_run  ~instance_id  () =
      { attribute; dry_run; instance_id }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Attribute", (InstanceAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attribute", (InstanceAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DeprovisionByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ResetNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      network_interface_id: String.t ;
      source_dest_check: String.t option }
    let make ?dry_run  ~network_interface_id  ?source_dest_check  () =
      { dry_run; network_interface_id; source_dest_check }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> Query.Pair ("SourceDestCheck", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f -> ("source_dest_check", (String.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check") String.of_json)
      }
  end
module ReleaseHostsRequest =
  struct
    type t = {
      host_ids: RequestHostIdList.t }
    let make ~host_ids  () = { host_ids }
    let parse xml =
      Some
        {
          host_ids =
            (Xml.required "hostId"
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("host_ids", (RequestHostIdList.to_json v.host_ids))])
    let of_json j =
      {
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")))
      }
  end
module CreateTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      vpc_id: String.t ;
      subnet_ids: TransitGatewaySubnetIdList.t ;
      options: CreateTransitGatewayVpcAttachmentRequestOptions.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ~vpc_id  ~subnet_ids  ?options 
      ?(tag_specifications= [])  ?dry_run  () =
      {
        transit_gateway_id;
        vpc_id;
        subnet_ids;
        options;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          subnet_ids =
            (Xml.required "SubnetIds"
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  TransitGatewaySubnetIdList.parse));
          options =
            (Util.option_bind (Xml.member "Options" xml)
               CreateTransitGatewayVpcAttachmentRequestOptions.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (CreateTransitGatewayVpcAttachmentRequestOptions.to_query
                       f)));
           Some
             (Query.Pair
                ("SubnetIds",
                  (TransitGatewaySubnetIdList.to_query v.subnet_ids)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.options
             (fun f ->
                ("options",
                  (CreateTransitGatewayVpcAttachmentRequestOptions.to_json f)));
           Some
             ("subnet_ids",
               (TransitGatewaySubnetIdList.to_json v.subnet_ids));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        subnet_ids =
          (TransitGatewaySubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        options =
          (Util.option_map (Json.lookup j "options")
             CreateTransitGatewayVpcAttachmentRequestOptions.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewaysRequest =
  struct
    type t =
      {
      local_gateway_ids: LocalGatewayIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { local_gateway_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          local_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LocalGatewayId" xml)
                  LocalGatewayIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayId",
                  (LocalGatewayIdSet.to_query v.local_gateway_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_ids",
               (LocalGatewayIdSet.to_json v.local_gateway_ids))])
    let of_json j =
      {
        local_gateway_ids =
          (LocalGatewayIdSet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyReservedInstancesRequest =
  struct
    type t =
      {
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      client_token: String.t option ;
      target_configurations: ReservedInstancesConfigurationList.t }
    let make ~reserved_instances_ids  ?client_token  ~target_configurations 
      () = { reserved_instances_ids; client_token; target_configurations }
    let parse xml =
      Some
        {
          reserved_instances_ids =
            (Xml.required "ReservedInstancesId"
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          target_configurations =
            (Xml.required "ReservedInstancesConfigurationSetItemType"
               (Util.option_bind
                  (Xml.member "ReservedInstancesConfigurationSetItemType" xml)
                  ReservedInstancesConfigurationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesConfigurationSetItemType",
                   (ReservedInstancesConfigurationList.to_query
                      v.target_configurations)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (ReservedInstancesConfigurationList.to_json
                   v.target_configurations));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids))])
    let of_json j =
      {
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        target_configurations =
          (ReservedInstancesConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module DescribeVpcEndpointConnectionsResult =
  struct
    type t =
      {
      vpc_endpoint_connections: VpcEndpointConnectionSet.t ;
      next_token: String.t option }
    let make ?(vpc_endpoint_connections= [])  ?next_token  () =
      { vpc_endpoint_connections; next_token }
    let parse xml =
      Some
        {
          vpc_endpoint_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointConnectionSet" xml)
                  VpcEndpointConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointConnectionSet",
                  (VpcEndpointConnectionSet.to_query
                     v.vpc_endpoint_connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_endpoint_connections",
               (VpcEndpointConnectionSet.to_json v.vpc_endpoint_connections))])
    let of_json j =
      {
        vpc_endpoint_connections =
          (VpcEndpointConnectionSet.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateRouteTableRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      route_table_id: String.t ;
      subnet_id: String.t option ;
      gateway_id: String.t option }
    let make ?dry_run  ~route_table_id  ?subnet_id  ?gateway_id  () =
      { dry_run; route_table_id; subnet_id; gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "GatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.gateway_id
              (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json)
      }
  end
module CreateLocalGatewayRouteTableVpcAssociationRequest =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t ;
      vpc_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_id  ~vpc_id  ?(tag_specifications=
      [])  ?dry_run  () =
      { local_gateway_route_table_id; vpc_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateAddressResult =
  struct
    type t = {
      association_id: String.t option }
    let make ?association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_id
              (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json)
      }
  end
module CreateCustomerGatewayRequest =
  struct
    type t =
      {
      bgp_asn: Integer.t ;
      public_ip: String.t option ;
      certificate_arn: String.t option ;
      type_: GatewayType.t ;
      tag_specifications: TagSpecificationList.t ;
      device_name: String.t option ;
      dry_run: Boolean.t option }
    let make ~bgp_asn  ?public_ip  ?certificate_arn  ~type_ 
      ?(tag_specifications= [])  ?device_name  ?dry_run  () =
      {
        bgp_asn;
        public_ip;
        certificate_arn;
        type_;
        tag_specifications;
        device_name;
        dry_run
      }
    let parse xml =
      Some
        {
          bgp_asn =
            (Xml.required "BgpAsn"
               (Util.option_bind (Xml.member "BgpAsn" xml) Integer.parse));
          public_ip =
            (Util.option_bind (Xml.member "IpAddress" xml) String.parse);
          certificate_arn =
            (Util.option_bind (Xml.member "CertificateArn" xml) String.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          device_name =
            (Util.option_bind (Xml.member "DeviceName" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.device_name
             (fun f -> Query.Pair ("DeviceName", (String.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("IpAddress", (String.to_query f)));
           Some (Query.Pair ("BgpAsn", (Integer.to_query v.bgp_asn)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.device_name
             (fun f -> ("device_name", (String.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Some ("bgp_asn", (Integer.to_json v.bgp_asn))])
    let of_json j =
      {
        bgp_asn =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "bgp_asn")));
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        device_name =
          (Util.option_map (Json.lookup j "device_name") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcEndpointConnectionNotificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?connection_notification_id  ?(filters= []) 
      ?max_results  ?next_token  () =
      { dry_run; connection_notification_id; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_id =
            (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.connection_notification_id
             (fun f ->
                Query.Pair ("ConnectionNotificationId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.connection_notification_id
             (fun f -> ("connection_notification_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_id =
          (Util.option_map (Json.lookup j "connection_notification_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSecurityGroupsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      group_ids: GroupIdStringList.t ;
      group_names: GroupNameStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(group_ids= [])  ?(group_names= [])  ?dry_run 
      ?next_token  ?max_results  () =
      { filters; group_ids; group_names; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupName" xml)
                  GroupNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("GroupName", (GroupNameStringList.to_query v.group_names)));
           Some
             (Query.Pair
                ("GroupId", (GroupIdStringList.to_query v.group_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Some ("group_ids", (GroupIdStringList.to_json v.group_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        group_ids =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")));
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeExportImageTasksResult =
  struct
    type t =
      {
      export_image_tasks: ExportImageTaskList.t ;
      next_token: String.t option }
    let make ?(export_image_tasks= [])  ?next_token  () =
      { export_image_tasks; next_token }
    let parse xml =
      Some
        {
          export_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportImageTaskSet" xml)
                  ExportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ExportImageTaskSet",
                  (ExportImageTaskList.to_query v.export_image_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("export_image_tasks",
               (ExportImageTaskList.to_json v.export_image_tasks))])
    let of_json j =
      {
        export_image_tasks =
          (ExportImageTaskList.of_json
             (Util.of_option_exn (Json.lookup j "export_image_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ExportImageRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      description: String.t option ;
      disk_image_format: DiskImageFormat.t ;
      dry_run: Boolean.t option ;
      image_id: String.t ;
      s3_export_location: ExportTaskS3LocationRequest.t ;
      role_name: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?client_token  ?description  ~disk_image_format  ?dry_run 
      ~image_id  ~s3_export_location  ?role_name  ?(tag_specifications= []) 
      () =
      {
        client_token;
        description;
        disk_image_format;
        dry_run;
        image_id;
        s3_export_location;
        role_name;
        tag_specifications
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_image_format =
            (Xml.required "DiskImageFormat"
               (Util.option_bind (Xml.member "DiskImageFormat" xml)
                  DiskImageFormat.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          s3_export_location =
            (Xml.required "S3ExportLocation"
               (Util.option_bind (Xml.member "S3ExportLocation" xml)
                  ExportTaskS3LocationRequest.parse));
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Some
             (Query.Pair
                ("S3ExportLocation",
                  (ExportTaskS3LocationRequest.to_query v.s3_export_location)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskImageFormat",
                  (DiskImageFormat.to_query v.disk_image_format)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Some
             ("s3_export_location",
               (ExportTaskS3LocationRequest.to_json v.s3_export_location));
           Some ("image_id", (String.to_json v.image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("disk_image_format",
               (DiskImageFormat.to_json v.disk_image_format));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_format =
          (DiskImageFormat.of_json
             (Util.of_option_exn (Json.lookup j "disk_image_format")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        s3_export_location =
          (ExportTaskS3LocationRequest.of_json
             (Util.of_option_exn (Json.lookup j "s3_export_location")));
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module RequestSpotInstancesRequest =
  struct
    type t =
      {
      availability_zone_group: String.t option ;
      block_duration_minutes: Integer.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      instance_count: Integer.t option ;
      launch_group: String.t option ;
      launch_specification: RequestSpotLaunchSpecification.t option ;
      spot_price: String.t option ;
      type_: SpotInstanceType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      tag_specifications: TagSpecificationList.t ;
      instance_interruption_behavior: InstanceInterruptionBehavior.t option }
    let make ?availability_zone_group  ?block_duration_minutes  ?client_token
       ?dry_run  ?instance_count  ?launch_group  ?launch_specification 
      ?spot_price  ?type_  ?valid_from  ?valid_until  ?(tag_specifications=
      [])  ?instance_interruption_behavior  () =
      {
        availability_zone_group;
        block_duration_minutes;
        client_token;
        dry_run;
        instance_count;
        launch_group;
        launch_specification;
        spot_price;
        type_;
        valid_from;
        valid_until;
        tag_specifications;
        instance_interruption_behavior
      }
    let parse xml =
      Some
        {
          availability_zone_group =
            (Util.option_bind (Xml.member "availabilityZoneGroup" xml)
               String.parse);
          block_duration_minutes =
            (Util.option_bind (Xml.member "blockDurationMinutes" xml)
               Integer.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_count =
            (Util.option_bind (Xml.member "instanceCount" xml) Integer.parse);
          launch_group =
            (Util.option_bind (Xml.member "launchGroup" xml) String.parse);
          launch_specification =
            (Util.option_bind (Xml.member "LaunchSpecification" xml)
               RequestSpotLaunchSpecification.parse);
          spot_price =
            (Util.option_bind (Xml.member "spotPrice" xml) String.parse);
          type_ =
            (Util.option_bind (Xml.member "type" xml) SpotInstanceType.parse);
          valid_from =
            (Util.option_bind (Xml.member "validFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "validUntil" xml) DateTime.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          instance_interruption_behavior =
            (Util.option_bind (Xml.member "InstanceInterruptionBehavior" xml)
               InstanceInterruptionBehavior.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 Query.Pair
                   ("InstanceInterruptionBehavior",
                     (InstanceInterruptionBehavior.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (SpotInstanceType.to_query f)));
           Util.option_map v.spot_price
             (fun f -> Query.Pair ("SpotPrice", (String.to_query f)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification",
                    (RequestSpotLaunchSpecification.to_query f)));
           Util.option_map v.launch_group
             (fun f -> Query.Pair ("LaunchGroup", (String.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.block_duration_minutes
             (fun f ->
                Query.Pair ("BlockDurationMinutes", (Integer.to_query f)));
           Util.option_map v.availability_zone_group
             (fun f ->
                Query.Pair ("AvailabilityZoneGroup", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_interruption_behavior
              (fun f ->
                 ("instance_interruption_behavior",
                   (InstanceInterruptionBehavior.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (SpotInstanceType.to_json f)));
           Util.option_map v.spot_price
             (fun f -> ("spot_price", (String.to_json f)));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification",
                  (RequestSpotLaunchSpecification.to_json f)));
           Util.option_map v.launch_group
             (fun f -> ("launch_group", (String.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.block_duration_minutes
             (fun f -> ("block_duration_minutes", (Integer.to_json f)));
           Util.option_map v.availability_zone_group
             (fun f -> ("availability_zone_group", (String.to_json f)))])
    let of_json j =
      {
        availability_zone_group =
          (Util.option_map (Json.lookup j "availability_zone_group")
             String.of_json);
        block_duration_minutes =
          (Util.option_map (Json.lookup j "block_duration_minutes")
             Integer.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        launch_group =
          (Util.option_map (Json.lookup j "launch_group") String.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             RequestSpotLaunchSpecification.of_json);
        spot_price =
          (Util.option_map (Json.lookup j "spot_price") String.of_json);
        type_ =
          (Util.option_map (Json.lookup j "type_") SpotInstanceType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        instance_interruption_behavior =
          (Util.option_map (Json.lookup j "instance_interruption_behavior")
             InstanceInterruptionBehavior.of_json)
      }
  end
module GetAssociatedEnclaveCertificateIamRolesResult =
  struct
    type t = {
      associated_roles: AssociatedRolesList.t }
    let make ?(associated_roles= [])  () = { associated_roles }
    let parse xml =
      Some
        {
          associated_roles =
            (Util.of_option []
               (Util.option_bind (Xml.member "associatedRoleSet" xml)
                  AssociatedRolesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociatedRoleSet",
                   (AssociatedRolesList.to_query v.associated_roles)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("associated_roles",
                (AssociatedRolesList.to_json v.associated_roles))])
    let of_json j =
      {
        associated_roles =
          (AssociatedRolesList.of_json
             (Util.of_option_exn (Json.lookup j "associated_roles")))
      }
  end
module CreateFlowLogsResult =
  struct
    type t =
      {
      client_token: String.t option ;
      flow_log_ids: ValueStringList.t ;
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?client_token  ?(flow_log_ids= [])  ?(unsuccessful= [])  () =
      { client_token; flow_log_ids; unsuccessful }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogIdSet" xml)
                  ValueStringList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("FlowLogIdSet", (ValueStringList.to_query v.flow_log_ids)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful));
           Some ("flow_log_ids", (ValueStringList.to_json v.flow_log_ids));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        flow_log_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module CreateNetworkInterfaceResult =
  struct
    type t = {
      network_interface: NetworkInterface.t option }
    let make ?network_interface  () = { network_interface }
    let parse xml =
      Some
        {
          network_interface =
            (Util.option_bind (Xml.member "networkInterface" xml)
               NetworkInterface.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f ->
                 Query.Pair
                   ("NetworkInterface", (NetworkInterface.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface
              (fun f -> ("network_interface", (NetworkInterface.to_json f)))])
    let of_json j =
      {
        network_interface =
          (Util.option_map (Json.lookup j "network_interface")
             NetworkInterface.of_json)
      }
  end
module RestoreAddressToClassicResult =
  struct
    type t = {
      public_ip: String.t option ;
      status: Status.t option }
    let make ?public_ip  ?status  () = { public_ip; status }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        status = (Util.option_map (Json.lookup j "status") Status.of_json)
      }
  end
module DescribeTransitGatewayRouteTablesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_ids: TransitGatewayRouteTableIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_route_table_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableIds" xml)
                  TransitGatewayRouteTableIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableIds",
                  (TransitGatewayRouteTableIdStringList.to_query
                     v.transit_gateway_route_table_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_ids",
               (TransitGatewayRouteTableIdStringList.to_json
                  v.transit_gateway_route_table_ids))])
    let of_json j =
      {
        transit_gateway_route_table_ids =
          (TransitGatewayRouteTableIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateIamInstanceProfileRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module RejectTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~association_id  ?dry_run  () =
      { client_vpn_endpoint_id; association_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteVpnGatewayRequest =
  struct
    type t = {
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_gateway_id  ?dry_run  () = { vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id))])
    let of_json j =
      {
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTrafficMirrorFiltersResult =
  struct
    type t =
      {
      traffic_mirror_filters: TrafficMirrorFilterSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_filters= [])  ?next_token  () =
      { traffic_mirror_filters; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorFilterSet" xml)
                  TrafficMirrorFilterSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterSet",
                  (TrafficMirrorFilterSet.to_query v.traffic_mirror_filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_filters",
               (TrafficMirrorFilterSet.to_json v.traffic_mirror_filters))])
    let of_json j =
      {
        traffic_mirror_filters =
          (TrafficMirrorFilterSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTrafficMirrorTargetsRequest =
  struct
    type t =
      {
      traffic_mirror_target_ids: TrafficMirrorTargetIdList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_target_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_target_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_target_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  TrafficMirrorTargetIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (TrafficMirrorTargetIdList.to_query
                     v.traffic_mirror_target_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_target_ids",
               (TrafficMirrorTargetIdList.to_json v.traffic_mirror_target_ids))])
    let of_json j =
      {
        traffic_mirror_target_ids =
          (TrafficMirrorTargetIdList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnassignPrivateIpAddressesRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t }
    let make ~network_interface_id  ~private_ip_addresses  () =
      { network_interface_id; private_ip_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Xml.required "privateIpAddress"
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrivateIpAddress",
                   (PrivateIpAddressStringList.to_query
                      v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("private_ip_addresses",
                (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")))
      }
  end
module DeleteTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclAssociationResult =
  struct
    type t = {
      new_association_id: String.t option }
    let make ?new_association_id  () = { new_association_id }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.new_association_id
              (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json)
      }
  end
module AttachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CreateManagedPrefixListResult =
  struct
    type t = {
      prefix_list: ManagedPrefixList.t option }
    let make ?prefix_list  () = { prefix_list }
    let parse xml =
      Some
        {
          prefix_list =
            (Util.option_bind (Xml.member "prefixList" xml)
               ManagedPrefixList.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f ->
                 Query.Pair ("PrefixList", (ManagedPrefixList.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f -> ("prefix_list", (ManagedPrefixList.to_json f)))])
    let of_json j =
      {
        prefix_list =
          (Util.option_map (Json.lookup j "prefix_list")
             ManagedPrefixList.of_json)
      }
  end
module DeleteSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteRouteTableRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ?dry_run  ~route_table_id  () = { dry_run; route_table_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module GetDefaultCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_family: UnlimitedSupportedInstanceFamily.t }
    let make ?dry_run  ~instance_family  () = { dry_run; instance_family }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_family =
            (Xml.required "InstanceFamily"
               (Util.option_bind (Xml.member "InstanceFamily" xml)
                  UnlimitedSupportedInstanceFamily.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceFamily",
                   (UnlimitedSupportedInstanceFamily.to_query
                      v.instance_family)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_family",
                (UnlimitedSupportedInstanceFamily.to_json v.instance_family));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_family =
          (UnlimitedSupportedInstanceFamily.of_json
             (Util.of_option_exn (Json.lookup j "instance_family")))
      }
  end
module DisassociateVpcCidrBlockRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module AssociateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?(subnet_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        subnet_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_ids: SpotFleetRequestIdList.t ;
      terminate_instances: Boolean.t }
    let make ?dry_run  ~spot_fleet_request_ids  ~terminate_instances  () =
      { dry_run; spot_fleet_request_ids; terminate_instances }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_ids =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  SpotFleetRequestIdList.parse));
          terminate_instances =
            (Xml.required "terminateInstances"
               (Util.option_bind (Xml.member "terminateInstances" xml)
                  Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TerminateInstances",
                   (Boolean.to_query v.terminate_instances)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (SpotFleetRequestIdList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminate_instances",
                (Boolean.to_json v.terminate_instances));
           Some
             ("spot_fleet_request_ids",
               (SpotFleetRequestIdList.to_json v.spot_fleet_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_ids =
          (SpotFleetRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")));
        terminate_instances =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "terminate_instances")))
      }
  end
module GetManagedPrefixListEntriesResult =
  struct
    type t = {
      entries: PrefixListEntrySet.t ;
      next_token: String.t option }
    let make ?(entries= [])  ?next_token  () = { entries; next_token }
    let parse xml =
      Some
        {
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "entrySet" xml)
                  PrefixListEntrySet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("EntrySet", (PrefixListEntrySet.to_query v.entries)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("entries", (PrefixListEntrySet.to_json v.entries))])
    let of_json j =
      {
        entries =
          (PrefixListEntrySet.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeIpv6PoolsRequest =
  struct
    type t =
      {
      pool_ids: Ipv6PoolIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option ;
      filters: FilterList.t }
    let make ?(pool_ids= [])  ?next_token  ?max_results  ?dry_run  ?(filters=
      [])  () = { pool_ids; next_token; max_results; dry_run; filters }
    let parse xml =
      Some
        {
          pool_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolId" xml)
                  Ipv6PoolIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("PoolId", (Ipv6PoolIdList.to_query v.pool_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("pool_ids", (Ipv6PoolIdList.to_json v.pool_ids))])
    let of_json j =
      {
        pool_ids =
          (Ipv6PoolIdList.of_json
             (Util.of_option_exn (Json.lookup j "pool_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module ModifyManagedPrefixListResult =
  struct
    type t = {
      prefix_list: ManagedPrefixList.t option }
    let make ?prefix_list  () = { prefix_list }
    let parse xml =
      Some
        {
          prefix_list =
            (Util.option_bind (Xml.member "prefixList" xml)
               ManagedPrefixList.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f ->
                 Query.Pair ("PrefixList", (ManagedPrefixList.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f -> ("prefix_list", (ManagedPrefixList.to_json f)))])
    let of_json j =
      {
        prefix_list =
          (Util.option_map (Json.lookup j "prefix_list")
             ManagedPrefixList.of_json)
      }
  end
module DescribeTransitGatewaysResult =
  struct
    type t =
      {
      transit_gateways: TransitGatewayList.t ;
      next_token: String.t option }
    let make ?(transit_gateways= [])  ?next_token  () =
      { transit_gateways; next_token }
    let parse xml =
      Some
        {
          transit_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewaySet" xml)
                  TransitGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewaySet",
                  (TransitGatewayList.to_query v.transit_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateways",
               (TransitGatewayList.to_json v.transit_gateways))])
    let of_json j =
      {
        transit_gateways =
          (TransitGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointServiceConfigurationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelBundleTaskRequest =
  struct
    type t = {
      bundle_id: String.t ;
      dry_run: Boolean.t option }
    let make ~bundle_id  ?dry_run  () = { bundle_id; dry_run }
    let parse xml =
      Some
        {
          bundle_id =
            (Xml.required "BundleId"
               (Util.option_bind (Xml.member "BundleId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("BundleId", (String.to_query v.bundle_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("bundle_id", (String.to_json v.bundle_id))])
    let of_json j =
      {
        bundle_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "bundle_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CopyImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module RegisterInstanceEventNotificationAttributesResult =
  struct
    type t =
      {
      instance_tag_attribute: InstanceTagNotificationAttribute.t option }
    let make ?instance_tag_attribute  () = { instance_tag_attribute }
    let parse xml =
      Some
        {
          instance_tag_attribute =
            (Util.option_bind (Xml.member "instanceTagAttribute" xml)
               InstanceTagNotificationAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 Query.Pair
                   ("InstanceTagAttribute",
                     (InstanceTagNotificationAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 ("instance_tag_attribute",
                   (InstanceTagNotificationAttribute.to_json f)))])
    let of_json j =
      {
        instance_tag_attribute =
          (Util.option_map (Json.lookup j "instance_tag_attribute")
             InstanceTagNotificationAttribute.of_json)
      }
  end
module CreateClientVpnEndpointRequest =
  struct
    type t =
      {
      client_cidr_block: String.t ;
      server_certificate_arn: String.t ;
      authentication_options: ClientVpnAuthenticationRequestList.t ;
      connection_log_options: ConnectionLogOptions.t ;
      dns_servers: ValueStringList.t ;
      transport_protocol: TransportProtocol.t option ;
      vpn_port: Integer.t option ;
      description: String.t option ;
      split_tunnel: Boolean.t option ;
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      security_group_ids: ClientVpnSecurityGroupIdSet.t ;
      vpc_id: String.t option ;
      self_service_portal: SelfServicePortal.t option ;
      client_connect_options: ClientConnectOptions.t option }
    let make ~client_cidr_block  ~server_certificate_arn 
      ~authentication_options  ~connection_log_options  ?(dns_servers= []) 
      ?transport_protocol  ?vpn_port  ?description  ?split_tunnel  ?dry_run 
      ?client_token  ?(tag_specifications= [])  ?(security_group_ids= []) 
      ?vpc_id  ?self_service_portal  ?client_connect_options  () =
      {
        client_cidr_block;
        server_certificate_arn;
        authentication_options;
        connection_log_options;
        dns_servers;
        transport_protocol;
        vpn_port;
        description;
        split_tunnel;
        dry_run;
        client_token;
        tag_specifications;
        security_group_ids;
        vpc_id;
        self_service_portal;
        client_connect_options
      }
    let parse xml =
      Some
        {
          client_cidr_block =
            (Xml.required "ClientCidrBlock"
               (Util.option_bind (Xml.member "ClientCidrBlock" xml)
                  String.parse));
          server_certificate_arn =
            (Xml.required "ServerCertificateArn"
               (Util.option_bind (Xml.member "ServerCertificateArn" xml)
                  String.parse));
          authentication_options =
            (Xml.required "Authentication"
               (Util.option_bind (Xml.member "Authentication" xml)
                  ClientVpnAuthenticationRequestList.parse));
          connection_log_options =
            (Xml.required "ConnectionLogOptions"
               (Util.option_bind (Xml.member "ConnectionLogOptions" xml)
                  ConnectionLogOptions.parse));
          dns_servers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DnsServers" xml)
                  ValueStringList.parse));
          transport_protocol =
            (Util.option_bind (Xml.member "TransportProtocol" xml)
               TransportProtocol.parse);
          vpn_port =
            (Util.option_bind (Xml.member "VpnPort" xml) Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          split_tunnel =
            (Util.option_bind (Xml.member "SplitTunnel" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ClientVpnSecurityGroupIdSet.parse));
          vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse);
          self_service_portal =
            (Util.option_bind (Xml.member "SelfServicePortal" xml)
               SelfServicePortal.parse);
          client_connect_options =
            (Util.option_bind (Xml.member "ClientConnectOptions" xml)
               ClientConnectOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 Query.Pair
                   ("ClientConnectOptions",
                     (ClientConnectOptions.to_query f)));
           Util.option_map v.self_service_portal
             (fun f ->
                Query.Pair
                  ("SelfServicePortal", (SelfServicePortal.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.vpn_port
             (fun f -> Query.Pair ("VpnPort", (Integer.to_query f)));
           Util.option_map v.transport_protocol
             (fun f ->
                Query.Pair
                  ("TransportProtocol", (TransportProtocol.to_query f)));
           Some
             (Query.Pair
                ("DnsServers", (ValueStringList.to_query v.dns_servers)));
           Some
             (Query.Pair
                ("ConnectionLogOptions",
                  (ConnectionLogOptions.to_query v.connection_log_options)));
           Some
             (Query.Pair
                ("Authentication",
                  (ClientVpnAuthenticationRequestList.to_query
                     v.authentication_options)));
           Some
             (Query.Pair
                ("ServerCertificateArn",
                  (String.to_query v.server_certificate_arn)));
           Some
             (Query.Pair
                ("ClientCidrBlock", (String.to_query v.client_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 ("client_connect_options", (ClientConnectOptions.to_json f)));
           Util.option_map v.self_service_portal
             (fun f -> ("self_service_portal", (SelfServicePortal.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.vpn_port
             (fun f -> ("vpn_port", (Integer.to_json f)));
           Util.option_map v.transport_protocol
             (fun f -> ("transport_protocol", (TransportProtocol.to_json f)));
           Some ("dns_servers", (ValueStringList.to_json v.dns_servers));
           Some
             ("connection_log_options",
               (ConnectionLogOptions.to_json v.connection_log_options));
           Some
             ("authentication_options",
               (ClientVpnAuthenticationRequestList.to_json
                  v.authentication_options));
           Some
             ("server_certificate_arn",
               (String.to_json v.server_certificate_arn));
           Some ("client_cidr_block", (String.to_json v.client_cidr_block))])
    let of_json j =
      {
        client_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_cidr_block")));
        server_certificate_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "server_certificate_arn")));
        authentication_options =
          (ClientVpnAuthenticationRequestList.of_json
             (Util.of_option_exn (Json.lookup j "authentication_options")));
        connection_log_options =
          (ConnectionLogOptions.of_json
             (Util.of_option_exn (Json.lookup j "connection_log_options")));
        dns_servers =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "dns_servers")));
        transport_protocol =
          (Util.option_map (Json.lookup j "transport_protocol")
             TransportProtocol.of_json);
        vpn_port =
          (Util.option_map (Json.lookup j "vpn_port") Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        self_service_portal =
          (Util.option_map (Json.lookup j "self_service_portal")
             SelfServicePortal.of_json);
        client_connect_options =
          (Util.option_map (Json.lookup j "client_connect_options")
             ClientConnectOptions.of_json)
      }
  end
module CreateInstanceExportTaskResult =
  struct
    type t = {
      export_task: ExportTask.t option }
    let make ?export_task  () = { export_task }
    let parse xml =
      Some
        {
          export_task =
            (Util.option_bind (Xml.member "exportTask" xml) ExportTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> Query.Pair ("ExportTask", (ExportTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.export_task
              (fun f -> ("export_task", (ExportTask.to_json f)))])
    let of_json j =
      {
        export_task =
          (Util.option_map (Json.lookup j "export_task") ExportTask.of_json)
      }
  end
module DisableTransitGatewayRouteTablePropagationResult =
  struct
    type t = {
      propagation: TransitGatewayPropagation.t option }
    let make ?propagation  () = { propagation }
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let of_json j =
      {
        propagation =
          (Util.option_map (Json.lookup j "propagation")
             TransitGatewayPropagation.of_json)
      }
  end
module DeleteTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?dry_run  () =
      { transit_gateway_route_table_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcClassicLinkDnsSupportResult =
  struct
    type t =
      {
      next_token: String.t option ;
      vpcs: ClassicLinkDnsSupportList.t }
    let make ?next_token  ?(vpcs= [])  () = { next_token; vpcs }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcs" xml)
                  ClassicLinkDnsSupportList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Vpcs", (ClassicLinkDnsSupportList.to_query v.vpcs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (ClassicLinkDnsSupportList.to_json v.vpcs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpcs =
          (ClassicLinkDnsSupportList.of_json
             (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module ModifyLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      default_version: String.t option }
    let make ?dry_run  ?client_token  ?launch_template_id 
      ?launch_template_name  ?default_version  () =
      {
        dry_run;
        client_token;
        launch_template_id;
        launch_template_name;
        default_version
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          default_version =
            (Util.option_bind (Xml.member "SetDefaultVersion" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.default_version
              (fun f -> Query.Pair ("SetDefaultVersion", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.default_version
              (fun f -> ("default_version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        default_version =
          (Util.option_map (Json.lookup j "default_version") String.of_json)
      }
  end
module DisassociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option ;
      cidr_block_association: VpcCidrBlockAssociation.t option ;
      vpc_id: String.t option }
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             VpcIpv6CidrBlockAssociation.of_json);
        cidr_block_association =
          (Util.option_map (Json.lookup j "cidr_block_association")
             VpcCidrBlockAssociation.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module DescribeImportSnapshotTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      import_task_ids: ImportSnapshotTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(import_task_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; import_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse));
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportSnapshotTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportSnapshotTaskIdList.to_query v.import_task_ids)));
           Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("import_task_ids",
               (ImportSnapshotTaskIdList.to_json v.import_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        import_task_ids =
          (ImportSnapshotTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeManagedPrefixListsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      prefix_lists: ManagedPrefixListSet.t }
    let make ?next_token  ?(prefix_lists= [])  () =
      { next_token; prefix_lists }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          prefix_lists =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListSet" xml)
                  ManagedPrefixListSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListSet",
                   (ManagedPrefixListSet.to_query v.prefix_lists)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("prefix_lists", (ManagedPrefixListSet.to_json v.prefix_lists));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_lists =
          (ManagedPrefixListSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_lists")))
      }
  end
module RequestSpotFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_fleet_request_config: SpotFleetRequestConfigData.t }
    let make ?dry_run  ~spot_fleet_request_config  () =
      { dry_run; spot_fleet_request_config }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_fleet_request_config =
            (Xml.required "spotFleetRequestConfig"
               (Util.option_bind (Xml.member "spotFleetRequestConfig" xml)
                  SpotFleetRequestConfigData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfig",
                   (SpotFleetRequestConfigData.to_query
                      v.spot_fleet_request_config)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_config",
                (SpotFleetRequestConfigData.to_json
                   v.spot_fleet_request_config));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_fleet_request_config =
          (SpotFleetRequestConfigData.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_config")))
      }
  end
module DescribeReservedInstancesListingsResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module ModifyVpnTunnelCertificateRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      vpn_tunnel_outside_ip_address: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ~vpn_tunnel_outside_ip_address  ?dry_run  ()
      = { vpn_connection_id; vpn_tunnel_outside_ip_address; dry_run }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          vpn_tunnel_outside_ip_address =
            (Xml.required "VpnTunnelOutsideIpAddress"
               (Util.option_bind (Xml.member "VpnTunnelOutsideIpAddress" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnTunnelOutsideIpAddress",
                  (String.to_query v.vpn_tunnel_outside_ip_address)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_tunnel_outside_ip_address",
               (String.to_json v.vpn_tunnel_outside_ip_address));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_tunnel_outside_ip_address =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "vpn_tunnel_outside_ip_address")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnRoutesRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { client_vpn_endpoint_id; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: VpcEndpointIdList.t }
    let make ?dry_run  ~vpc_endpoint_ids  () = { dry_run; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  VpcEndpointIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (VpcEndpointIdList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (VpcEndpointIdList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (VpcEndpointIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module CreateVpcEndpointServiceConfigurationResult =
  struct
    type t =
      {
      service_configuration: ServiceConfiguration.t option ;
      client_token: String.t option }
    let make ?service_configuration  ?client_token  () =
      { service_configuration; client_token }
    let parse xml =
      Some
        {
          service_configuration =
            (Util.option_bind (Xml.member "serviceConfiguration" xml)
               ServiceConfiguration.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.service_configuration
             (fun f ->
                Query.Pair
                  ("ServiceConfiguration", (ServiceConfiguration.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.service_configuration
             (fun f ->
                ("service_configuration", (ServiceConfiguration.to_json f)))])
    let of_json j =
      {
        service_configuration =
          (Util.option_map (Json.lookup j "service_configuration")
             ServiceConfiguration.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module SearchLocalGatewayRoutesRequest =
  struct
    type t =
      {
      local_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~local_gateway_route_table_id  ~filters  ?max_results 
      ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          filters =
            (Xml.required "Filter"
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id))])
    let of_json j =
      {
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteNetworkAclEntryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      network_acl_id: String.t ;
      rule_number: Integer.t }
    let make ?dry_run  ~egress  ~network_acl_id  ~rule_number  () =
      { dry_run; egress; network_acl_id; rule_number }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module DeregisterInstanceEventNotificationAttributesResult =
  struct
    type t =
      {
      instance_tag_attribute: InstanceTagNotificationAttribute.t option }
    let make ?instance_tag_attribute  () = { instance_tag_attribute }
    let parse xml =
      Some
        {
          instance_tag_attribute =
            (Util.option_bind (Xml.member "instanceTagAttribute" xml)
               InstanceTagNotificationAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 Query.Pair
                   ("InstanceTagAttribute",
                     (InstanceTagNotificationAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 ("instance_tag_attribute",
                   (InstanceTagNotificationAttribute.to_json f)))])
    let of_json j =
      {
        instance_tag_attribute =
          (Util.option_map (Json.lookup j "instance_tag_attribute")
             InstanceTagNotificationAttribute.of_json)
      }
  end
module AllocateAddressResult =
  struct
    type t =
      {
      public_ip: String.t option ;
      allocation_id: String.t option ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      domain: DomainType.t option ;
      customer_owned_ip: String.t option ;
      customer_owned_ipv4_pool: String.t option ;
      carrier_ip: String.t option }
    let make ?public_ip  ?allocation_id  ?public_ipv4_pool 
      ?network_border_group  ?domain  ?customer_owned_ip 
      ?customer_owned_ipv4_pool  ?carrier_ip  () =
      {
        public_ip;
        allocation_id;
        public_ipv4_pool;
        network_border_group;
        domain;
        customer_owned_ip;
        customer_owned_ipv4_pool;
        carrier_ip
      }
    let parse xml =
      Some
        {
          public_ip =
            (Util.option_bind (Xml.member "publicIp" xml) String.parse);
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          public_ipv4_pool =
            (Util.option_bind (Xml.member "publicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "networkBorderGroup" xml)
               String.parse);
          domain =
            (Util.option_bind (Xml.member "domain" xml) DomainType.parse);
          customer_owned_ip =
            (Util.option_bind (Xml.member "customerOwnedIp" xml) String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "customerOwnedIpv4Pool" xml)
               String.parse);
          carrier_ip =
            (Util.option_bind (Xml.member "carrierIp" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> Query.Pair ("CarrierIp", (String.to_query f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f ->
                Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.customer_owned_ip
             (fun f -> Query.Pair ("CustomerOwnedIp", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.carrier_ip
              (fun f -> ("carrier_ip", (String.to_json f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.customer_owned_ip
             (fun f -> ("customer_owned_ip", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)))])
    let of_json j =
      {
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        customer_owned_ip =
          (Util.option_map (Json.lookup j "customer_owned_ip") String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json);
        carrier_ip =
          (Util.option_map (Json.lookup j "carrier_ip") String.of_json)
      }
  end
module DescribeClientVpnTargetNetworksRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      association_ids: ValueStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(association_ids= [])  ?max_results 
      ?next_token  ?(filters= [])  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        association_ids;
        max_results;
        next_token;
        filters;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          association_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationIds" xml)
                  ValueStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("AssociationIds",
                  (ValueStringList.to_query v.association_ids)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("association_ids", (ValueStringList.to_json v.association_ids));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        association_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "association_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyTrafficMirrorFilterRuleResult =
  struct
    type t = {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option }
    let make ?traffic_mirror_filter_rule  () = { traffic_mirror_filter_rule }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRule",
                     (TrafficMirrorFilterRule.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule
              (fun f ->
                 ("traffic_mirror_filter_rule",
                   (TrafficMirrorFilterRule.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule")
             TrafficMirrorFilterRule.of_json)
      }
  end
module CreateDefaultVpcResult =
  struct
    type t = {
      vpc: Vpc.t option }
    let make ?vpc  () = { vpc }
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let of_json j =
      { vpc = (Util.option_map (Json.lookup j "vpc") Vpc.of_json) }
  end
module CreateVpcEndpointConnectionNotificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t option ;
      vpc_endpoint_id: String.t option ;
      connection_notification_arn: String.t ;
      connection_events: ValueStringList.t ;
      client_token: String.t option }
    let make ?dry_run  ?service_id  ?vpc_endpoint_id 
      ~connection_notification_arn  ~connection_events  ?client_token  () =
      {
        dry_run;
        service_id;
        vpc_endpoint_id;
        connection_notification_arn;
        connection_events;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Util.option_bind (Xml.member "ServiceId" xml) String.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "VpcEndpointId" xml) String.parse);
          connection_notification_arn =
            (Xml.required "ConnectionNotificationArn"
               (Util.option_bind (Xml.member "ConnectionNotificationArn" xml)
                  String.parse));
          connection_events =
            (Xml.required "ConnectionEvents"
               (Util.option_bind (Xml.member "ConnectionEvents" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionEvents",
                  (ValueStringList.to_query v.connection_events)));
           Some
             (Query.Pair
                ("ConnectionNotificationArn",
                  (String.to_query v.connection_notification_arn)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.service_id
             (fun f -> Query.Pair ("ServiceId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some
             ("connection_events",
               (ValueStringList.to_json v.connection_events));
           Some
             ("connection_notification_arn",
               (String.to_json v.connection_notification_arn));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.service_id
             (fun f -> ("service_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (Util.option_map (Json.lookup j "service_id") String.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        connection_notification_arn =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_arn")));
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module ExportClientVpnClientConfigurationRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module TerminateInstancesResult =
  struct
    type t = {
      terminating_instances: InstanceStateChangeList.t }
    let make ?(terminating_instances= [])  () = { terminating_instances }
    let parse xml =
      Some
        {
          terminating_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.terminating_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminating_instances",
                (InstanceStateChangeList.to_json v.terminating_instances))])
    let of_json j =
      {
        terminating_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "terminating_instances")))
      }
  end
module CreateClientVpnRouteRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      destination_cidr_block: String.t ;
      target_vpc_subnet_id: String.t ;
      description: String.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~destination_cidr_block 
      ~target_vpc_subnet_id  ?description  ?client_token  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        destination_cidr_block;
        target_vpc_subnet_id;
        description;
        client_token;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          target_vpc_subnet_id =
            (Xml.required "TargetVpcSubnetId"
               (Util.option_bind (Xml.member "TargetVpcSubnetId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetVpcSubnetId",
                  (String.to_query v.target_vpc_subnet_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("target_vpc_subnet_id",
               (String.to_json v.target_vpc_subnet_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        target_vpc_subnet_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_vpc_subnet_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateManagedPrefixListRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_name: String.t ;
      entries: AddPrefixListEntries.t ;
      max_entries: Integer.t ;
      tag_specifications: TagSpecificationList.t ;
      address_family: String.t ;
      client_token: String.t option }
    let make ?dry_run  ~prefix_list_name  ?(entries= [])  ~max_entries 
      ?(tag_specifications= [])  ~address_family  ?client_token  () =
      {
        dry_run;
        prefix_list_name;
        entries;
        max_entries;
        tag_specifications;
        address_family;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_name =
            (Xml.required "PrefixListName"
               (Util.option_bind (Xml.member "PrefixListName" xml)
                  String.parse));
          entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "Entry" xml)
                  AddPrefixListEntries.parse));
          max_entries =
            (Xml.required "MaxEntries"
               (Util.option_bind (Xml.member "MaxEntries" xml) Integer.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          address_family =
            (Xml.required "AddressFamily"
               (Util.option_bind (Xml.member "AddressFamily" xml)
                  String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AddressFamily", (String.to_query v.address_family)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("MaxEntries", (Integer.to_query v.max_entries)));
           Some
             (Query.Pair ("Entry", (AddPrefixListEntries.to_query v.entries)));
           Some
             (Query.Pair
                ("PrefixListName", (String.to_query v.prefix_list_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some ("address_family", (String.to_json v.address_family));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("max_entries", (Integer.to_json v.max_entries));
           Some ("entries", (AddPrefixListEntries.to_json v.entries));
           Some ("prefix_list_name", (String.to_json v.prefix_list_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_name")));
        entries =
          (AddPrefixListEntries.of_json
             (Util.of_option_exn (Json.lookup j "entries")));
        max_entries =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_entries")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        address_family =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "address_family")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module ExportClientVpnClientCertificateRevocationListResult =
  struct
    type t =
      {
      certificate_revocation_list: String.t option ;
      status: ClientCertificateRevocationListStatus.t option }
    let make ?certificate_revocation_list  ?status  () =
      { certificate_revocation_list; status }
    let parse xml =
      Some
        {
          certificate_revocation_list =
            (Util.option_bind (Xml.member "certificateRevocationList" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientCertificateRevocationListStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status",
                     (ClientCertificateRevocationListStatus.to_query f)));
           Util.option_map v.certificate_revocation_list
             (fun f ->
                Query.Pair ("CertificateRevocationList", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status",
                   (ClientCertificateRevocationListStatus.to_json f)));
           Util.option_map v.certificate_revocation_list
             (fun f -> ("certificate_revocation_list", (String.to_json f)))])
    let of_json j =
      {
        certificate_revocation_list =
          (Util.option_map (Json.lookup j "certificate_revocation_list")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientCertificateRevocationListStatus.of_json)
      }
  end
module TerminateClientVpnConnectionsResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      username: String.t option ;
      connection_statuses: TerminateConnectionStatusSet.t }
    let make ?client_vpn_endpoint_id  ?username  ?(connection_statuses= []) 
      () = { client_vpn_endpoint_id; username; connection_statuses }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          username =
            (Util.option_bind (Xml.member "username" xml) String.parse);
          connection_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionStatuses" xml)
                  TerminateConnectionStatusSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionStatuses",
                   (TerminateConnectionStatusSet.to_query
                      v.connection_statuses)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_statuses",
                (TerminateConnectionStatusSet.to_json v.connection_statuses));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        connection_statuses =
          (TerminateConnectionStatusSet.of_json
             (Util.of_option_exn (Json.lookup j "connection_statuses")))
      }
  end
module CreateTransitGatewayPrefixListReferenceResult =
  struct
    type t =
      {
      transit_gateway_prefix_list_reference:
        TransitGatewayPrefixListReference.t option }
    let make ?transit_gateway_prefix_list_reference  () =
      { transit_gateway_prefix_list_reference }
    let parse xml =
      Some
        {
          transit_gateway_prefix_list_reference =
            (Util.option_bind
               (Xml.member "transitGatewayPrefixListReference" xml)
               TransitGatewayPrefixListReference.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPrefixListReference",
                     (TransitGatewayPrefixListReference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 ("transit_gateway_prefix_list_reference",
                   (TransitGatewayPrefixListReference.to_json f)))])
    let of_json j =
      {
        transit_gateway_prefix_list_reference =
          (Util.option_map
             (Json.lookup j "transit_gateway_prefix_list_reference")
             TransitGatewayPrefixListReference.of_json)
      }
  end
module DescribeInstanceTypeOfferingsResult =
  struct
    type t =
      {
      instance_type_offerings: InstanceTypeOfferingsList.t ;
      next_token: String.t option }
    let make ?(instance_type_offerings= [])  ?next_token  () =
      { instance_type_offerings; next_token }
    let parse xml =
      Some
        {
          instance_type_offerings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeOfferingSet" xml)
                  InstanceTypeOfferingsList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeOfferingSet",
                  (InstanceTypeOfferingsList.to_query
                     v.instance_type_offerings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_type_offerings",
               (InstanceTypeOfferingsList.to_json v.instance_type_offerings))])
    let of_json j =
      {
        instance_type_offerings =
          (InstanceTypeOfferingsList.of_json
             (Util.of_option_exn (Json.lookup j "instance_type_offerings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeInstanceStatusResult =
  struct
    type t =
      {
      instance_statuses: InstanceStatusList.t ;
      next_token: String.t option }
    let make ?(instance_statuses= [])  ?next_token  () =
      { instance_statuses; next_token }
    let parse xml =
      Some
        {
          instance_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceStatusSet" xml)
                  InstanceStatusList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceStatusSet",
                  (InstanceStatusList.to_query v.instance_statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_statuses",
               (InstanceStatusList.to_json v.instance_statuses))])
    let of_json j =
      {
        instance_statuses =
          (InstanceStatusList.of_json
             (Util.of_option_exn (Json.lookup j "instance_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module RejectTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DeleteInternetGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t }
    let make ?dry_run  ~internet_gateway_id  () =
      { dry_run; internet_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InternetGatewayId",
                   (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")))
      }
  end
module CreateVpnConnectionRouteRequest =
  struct
    type t = {
      destination_cidr_block: String.t ;
      vpn_connection_id: String.t }
    let make ~destination_cidr_block  ~vpn_connection_id  () =
      { destination_cidr_block; vpn_connection_id }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")))
      }
  end
module ModifyFleetResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ConfirmProductInstanceRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      product_code: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~product_code  ?dry_run  () =
      { instance_id; product_code; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          product_code =
            (Xml.required "ProductCode"
               (Util.option_bind (Xml.member "ProductCode" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("ProductCode", (String.to_query v.product_code)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("product_code", (String.to_json v.product_code));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        product_code =
          (String.of_json (Util.of_option_exn (Json.lookup j "product_code")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceEventNotificationAttributesResult =
  struct
    type t =
      {
      instance_tag_attribute: InstanceTagNotificationAttribute.t option }
    let make ?instance_tag_attribute  () = { instance_tag_attribute }
    let parse xml =
      Some
        {
          instance_tag_attribute =
            (Util.option_bind (Xml.member "instanceTagAttribute" xml)
               InstanceTagNotificationAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 Query.Pair
                   ("InstanceTagAttribute",
                     (InstanceTagNotificationAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 ("instance_tag_attribute",
                   (InstanceTagNotificationAttribute.to_json f)))])
    let of_json j =
      {
        instance_tag_attribute =
          (Util.option_map (Json.lookup j "instance_tag_attribute")
             InstanceTagNotificationAttribute.of_json)
      }
  end
module GetGroupsForCapacityReservationRequest =
  struct
    type t =
      {
      capacity_reservation_id: String.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?next_token  ?max_results  ?dry_run 
      () = { capacity_reservation_id; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module StartVpcEndpointServicePrivateDnsVerificationRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      service_id: String.t }
    let make ?dry_run  ~service_id  () = { dry_run; service_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")))
      }
  end
module CreateFpgaImageResult =
  struct
    type t =
      {
      fpga_image_id: String.t option ;
      fpga_image_global_id: String.t option }
    let make ?fpga_image_id  ?fpga_image_global_id  () =
      { fpga_image_id; fpga_image_global_id }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse);
          fpga_image_global_id =
            (Util.option_bind (Xml.member "fpgaImageGlobalId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> Query.Pair ("FpgaImageGlobalId", (String.to_query f)));
           Util.option_map v.fpga_image_id
             (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_global_id
              (fun f -> ("fpga_image_global_id", (String.to_json f)));
           Util.option_map v.fpga_image_id
             (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json);
        fpga_image_global_id =
          (Util.option_map (Json.lookup j "fpga_image_global_id")
             String.of_json)
      }
  end
module GetTransitGatewayPrefixListReferencesResult =
  struct
    type t =
      {
      transit_gateway_prefix_list_references:
        TransitGatewayPrefixListReferenceSet.t ;
      next_token: String.t option }
    let make ?(transit_gateway_prefix_list_references= [])  ?next_token  () =
      { transit_gateway_prefix_list_references; next_token }
    let parse xml =
      Some
        {
          transit_gateway_prefix_list_references =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayPrefixListReferenceSet" xml)
                  TransitGatewayPrefixListReferenceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayPrefixListReferenceSet",
                  (TransitGatewayPrefixListReferenceSet.to_query
                     v.transit_gateway_prefix_list_references)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_prefix_list_references",
               (TransitGatewayPrefixListReferenceSet.to_json
                  v.transit_gateway_prefix_list_references))])
    let of_json j =
      {
        transit_gateway_prefix_list_references =
          (TransitGatewayPrefixListReferenceSet.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_prefix_list_references")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeImagesResult =
  struct
    type t = {
      images: ImageList.t }
    let make ?(images= [])  () = { images }
    let parse xml =
      Some
        {
          images =
            (Util.of_option []
               (Util.option_bind (Xml.member "imagesSet" xml) ImageList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("ImagesSet", (ImageList.to_query v.images)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt [Some ("images", (ImageList.to_json v.images))])
    let of_json j =
      {
        images =
          (ImageList.of_json (Util.of_option_exn (Json.lookup j "images")))
      }
  end
module CopyFpgaImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      source_fpga_image_id: String.t ;
      description: String.t option ;
      name: String.t option ;
      source_region: String.t ;
      client_token: String.t option }
    let make ?dry_run  ~source_fpga_image_id  ?description  ?name 
      ~source_region  ?client_token  () =
      {
        dry_run;
        source_fpga_image_id;
        description;
        name;
        source_region;
        client_token
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          source_fpga_image_id =
            (Xml.required "SourceFpgaImageId"
               (Util.option_bind (Xml.member "SourceFpgaImageId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("SourceFpgaImageId",
                  (String.to_query v.source_fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("source_fpga_image_id",
               (String.to_json v.source_fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        source_fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_fpga_image_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DeleteVpcEndpointServiceConfigurationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_ids: VpcEndpointServiceIdList.t }
    let make ?dry_run  ~service_ids  () = { dry_run; service_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_ids =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml)
                  VpcEndpointServiceIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ServiceId",
                   (VpcEndpointServiceIdList.to_query v.service_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("service_ids",
                (VpcEndpointServiceIdList.to_json v.service_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_ids =
          (VpcEndpointServiceIdList.of_json
             (Util.of_option_exn (Json.lookup j "service_ids")))
      }
  end
module CreateReservedInstancesListingRequest =
  struct
    type t =
      {
      client_token: String.t ;
      instance_count: Integer.t ;
      price_schedules: PriceScheduleSpecificationList.t ;
      reserved_instances_id: String.t }
    let make ~client_token  ~instance_count  ~price_schedules 
      ~reserved_instances_id  () =
      { client_token; instance_count; price_schedules; reserved_instances_id
      }
    let parse xml =
      Some
        {
          client_token =
            (Xml.required "clientToken"
               (Util.option_bind (Xml.member "clientToken" xml) String.parse));
          instance_count =
            (Xml.required "instanceCount"
               (Util.option_bind (Xml.member "instanceCount" xml)
                  Integer.parse));
          price_schedules =
            (Xml.required "priceSchedules"
               (Util.option_bind (Xml.member "priceSchedules" xml)
                  PriceScheduleSpecificationList.parse));
          reserved_instances_id =
            (Xml.required "reservedInstancesId"
               (Util.option_bind (Xml.member "reservedInstancesId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesId",
                   (String.to_query v.reserved_instances_id)));
           Some
             (Query.Pair
                ("PriceSchedules",
                  (PriceScheduleSpecificationList.to_query v.price_schedules)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)));
           Some
             (Query.Pair ("ClientToken", (String.to_query v.client_token)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_id",
                (String.to_json v.reserved_instances_id));
           Some
             ("price_schedules",
               (PriceScheduleSpecificationList.to_json v.price_schedules));
           Some ("instance_count", (Integer.to_json v.instance_count));
           Some ("client_token", (String.to_json v.client_token))])
    let of_json j =
      {
        client_token =
          (String.of_json (Util.of_option_exn (Json.lookup j "client_token")));
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        price_schedules =
          (PriceScheduleSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "price_schedules")));
        reserved_instances_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_id")))
      }
  end
module DescribeImportSnapshotTasksResult =
  struct
    type t =
      {
      import_snapshot_tasks: ImportSnapshotTaskList.t ;
      next_token: String.t option }
    let make ?(import_snapshot_tasks= [])  ?next_token  () =
      { import_snapshot_tasks; next_token }
    let parse xml =
      Some
        {
          import_snapshot_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importSnapshotTaskSet" xml)
                  ImportSnapshotTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportSnapshotTaskSet",
                  (ImportSnapshotTaskList.to_query v.import_snapshot_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_snapshot_tasks",
               (ImportSnapshotTaskList.to_json v.import_snapshot_tasks))])
    let of_json j =
      {
        import_snapshot_tasks =
          (ImportSnapshotTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_snapshot_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTrafficMirrorFilterRuleResult =
  struct
    type t =
      {
      traffic_mirror_filter_rule: TrafficMirrorFilterRule.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_filter_rule  ?client_token  () =
      { traffic_mirror_filter_rule; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule =
            (Util.option_bind (Xml.member "trafficMirrorFilterRule" xml)
               TrafficMirrorFilterRule.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                Query.Pair
                  ("TrafficMirrorFilterRule",
                    (TrafficMirrorFilterRule.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_filter_rule
             (fun f ->
                ("traffic_mirror_filter_rule",
                  (TrafficMirrorFilterRule.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule")
             TrafficMirrorFilterRule.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeNetworkInterfacePermissionsResult =
  struct
    type t =
      {
      network_interface_permissions: NetworkInterfacePermissionList.t ;
      next_token: String.t option }
    let make ?(network_interface_permissions= [])  ?next_token  () =
      { network_interface_permissions; next_token }
    let parse xml =
      Some
        {
          network_interface_permissions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "networkInterfacePermissions" xml)
                  NetworkInterfacePermissionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissions",
                  (NetworkInterfacePermissionList.to_query
                     v.network_interface_permissions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interface_permissions",
               (NetworkInterfacePermissionList.to_json
                  v.network_interface_permissions))])
    let of_json j =
      {
        network_interface_permissions =
          (NetworkInterfacePermissionList.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permissions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTransitGatewayResult =
  struct
    type t = {
      transit_gateway: TransitGateway.t option }
    let make ?transit_gateway  () = { transit_gateway }
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let of_json j =
      {
        transit_gateway =
          (Util.option_map (Json.lookup j "transit_gateway")
             TransitGateway.of_json)
      }
  end
module DeleteVpnConnectionRequest =
  struct
    type t = {
      vpn_connection_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ?dry_run  () =
      { vpn_connection_id; dry_run }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorTargetRequest =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      network_load_balancer_arn: String.t option ;
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ?network_interface_id  ?network_load_balancer_arn  ?description 
      ?(tag_specifications= [])  ?dry_run  ?client_token  () =
      {
        network_interface_id;
        network_load_balancer_arn;
        description;
        tag_specifications;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
               String.parse);
          network_load_balancer_arn =
            (Util.option_bind (Xml.member "NetworkLoadBalancerArn" xml)
               String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.network_load_balancer_arn
             (fun f ->
                Query.Pair ("NetworkLoadBalancerArn", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.network_load_balancer_arn
             (fun f -> ("network_load_balancer_arn", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        network_load_balancer_arn =
          (Util.option_map (Json.lookup j "network_load_balancer_arn")
             String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module CancelSpotInstanceRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t }
    let make ?dry_run  ~spot_instance_request_ids  () =
      { dry_run; spot_instance_request_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Xml.required "SpotInstanceRequestId"
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestId",
                   (SpotInstanceRequestIdList.to_query
                      v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_request_ids",
                (SpotInstanceRequestIdList.to_json
                   v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")))
      }
  end
module AssociateTransitGatewayRouteTableResult =
  struct
    type t = {
      association: TransitGatewayAssociation.t option }
    let make ?association  () = { association }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAssociation.of_json)
      }
  end
module DescribeSpotPriceHistoryRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      availability_zone: String.t option ;
      dry_run: Boolean.t option ;
      end_time: DateTime.t option ;
      instance_types: InstanceTypeList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      product_descriptions: ProductDescriptionList.t ;
      start_time: DateTime.t option }
    let make ?(filters= [])  ?availability_zone  ?dry_run  ?end_time 
      ?(instance_types= [])  ?max_results  ?next_token 
      ?(product_descriptions= [])  ?start_time  () =
      {
        filters;
        availability_zone;
        dry_run;
        end_time;
        instance_types;
        max_results;
        next_token;
        product_descriptions;
        start_time
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          availability_zone =
            (Util.option_bind (Xml.member "availabilityZone" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceType" xml)
                  InstanceTypeList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          product_descriptions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductDescription" xml)
                  ProductDescriptionList.parse));
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("ProductDescription",
                  (ProductDescriptionList.to_query v.product_descriptions)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceType",
                  (InstanceTypeList.to_query v.instance_types)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Some
             ("product_descriptions",
               (ProductDescriptionList.to_json v.product_descriptions));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_types", (InstanceTypeList.to_json v.instance_types));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        instance_types =
          (InstanceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        product_descriptions =
          (ProductDescriptionList.of_json
             (Util.of_option_exn (Json.lookup j "product_descriptions")));
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module CancelImportTaskResult =
  struct
    type t =
      {
      import_task_id: String.t option ;
      previous_state: String.t option ;
      state: String.t option }
    let make ?import_task_id  ?previous_state  ?state  () =
      { import_task_id; previous_state; state }
    let parse xml =
      Some
        {
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          previous_state =
            (Util.option_bind (Xml.member "previousState" xml) String.parse);
          state = (Util.option_bind (Xml.member "state" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.state
              (fun f -> Query.Pair ("State", (String.to_query f)));
           Util.option_map v.previous_state
             (fun f -> Query.Pair ("PreviousState", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.state (fun f -> ("state", (String.to_json f)));
           Util.option_map v.previous_state
             (fun f -> ("previous_state", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)))])
    let of_json j =
      {
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        previous_state =
          (Util.option_map (Json.lookup j "previous_state") String.of_json);
        state = (Util.option_map (Json.lookup j "state") String.of_json)
      }
  end
module DisassociateSubnetCidrBlockRequest =
  struct
    type t = {
      association_id: String.t }
    let make ~association_id  () = { association_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module ModifyTrafficMirrorFilterNetworkServicesResult =
  struct
    type t = {
      traffic_mirror_filter: TrafficMirrorFilter.t option }
    let make ?traffic_mirror_filter  () = { traffic_mirror_filter }
    let parse xml =
      Some
        {
          traffic_mirror_filter =
            (Util.option_bind (Xml.member "trafficMirrorFilter" xml)
               TrafficMirrorFilter.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilter", (TrafficMirrorFilter.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter
              (fun f ->
                 ("traffic_mirror_filter", (TrafficMirrorFilter.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter =
          (Util.option_map (Json.lookup j "traffic_mirror_filter")
             TrafficMirrorFilter.of_json)
      }
  end
module ResetInstanceAttributeRequest =
  struct
    type t =
      {
      attribute: InstanceAttributeName.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ~attribute  ?dry_run  ~instance_id  () =
      { attribute; dry_run; instance_id }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "attribute"
               (Util.option_bind (Xml.member "attribute" xml)
                  InstanceAttributeName.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Attribute", (InstanceAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attribute", (InstanceAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (InstanceAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module CopySnapshotResult =
  struct
    type t = {
      snapshot_id: String.t option ;
      tags: TagList.t }
    let make ?snapshot_id  ?(tags= [])  () = { snapshot_id; tags }
    let parse xml =
      Some
        {
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)))])
    let of_json j =
      {
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AllocateHostsResult =
  struct
    type t = {
      host_ids: ResponseHostIdList.t }
    let make ?(host_ids= [])  () = { host_ids }
    let parse xml =
      Some
        {
          host_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostIdSet" xml)
                  ResponseHostIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("HostIdSet", (ResponseHostIdList.to_query v.host_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("host_ids", (ResponseHostIdList.to_json v.host_ids))])
    let of_json j =
      {
        host_ids =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")))
      }
  end
module DeleteTrafficMirrorTargetRequest =
  struct
    type t = {
      traffic_mirror_target_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_target_id  ?dry_run  () =
      { traffic_mirror_target_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Xml.required "TrafficMirrorTargetId"
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (String.to_query v.traffic_mirror_target_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_target_id",
               (String.to_json v.traffic_mirror_target_id))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AdvertiseByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module SearchTransitGatewayMulticastGroupsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnGatewayResult =
  struct
    type t = {
      vpn_gateway: VpnGateway.t option }
    let make ?vpn_gateway  () = { vpn_gateway }
    let parse xml =
      Some
        {
          vpn_gateway =
            (Util.option_bind (Xml.member "vpnGateway" xml) VpnGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> Query.Pair ("VpnGateway", (VpnGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_gateway
              (fun f -> ("vpn_gateway", (VpnGateway.to_json f)))])
    let of_json j =
      {
        vpn_gateway =
          (Util.option_map (Json.lookup j "vpn_gateway") VpnGateway.of_json)
      }
  end
module CreateCapacityReservationResult =
  struct
    type t = {
      capacity_reservation: CapacityReservation.t option }
    let make ?capacity_reservation  () = { capacity_reservation }
    let parse xml =
      Some
        {
          capacity_reservation =
            (Util.option_bind (Xml.member "capacityReservation" xml)
               CapacityReservation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 Query.Pair
                   ("CapacityReservation", (CapacityReservation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.capacity_reservation
              (fun f ->
                 ("capacity_reservation", (CapacityReservation.to_json f)))])
    let of_json j =
      {
        capacity_reservation =
          (Util.option_map (Json.lookup j "capacity_reservation")
             CapacityReservation.of_json)
      }
  end
module CreateLaunchTemplateVersionResult =
  struct
    type t =
      {
      launch_template_version: LaunchTemplateVersion.t option ;
      warning: ValidationWarning.t option }
    let make ?launch_template_version  ?warning  () =
      { launch_template_version; warning }
    let parse xml =
      Some
        {
          launch_template_version =
            (Util.option_bind (Xml.member "launchTemplateVersion" xml)
               LaunchTemplateVersion.parse);
          warning =
            (Util.option_bind (Xml.member "warning" xml)
               ValidationWarning.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.warning
              (fun f ->
                 Query.Pair ("Warning", (ValidationWarning.to_query f)));
           Util.option_map v.launch_template_version
             (fun f ->
                Query.Pair
                  ("LaunchTemplateVersion",
                    (LaunchTemplateVersion.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.warning
              (fun f -> ("warning", (ValidationWarning.to_json f)));
           Util.option_map v.launch_template_version
             (fun f ->
                ("launch_template_version",
                  (LaunchTemplateVersion.to_json f)))])
    let of_json j =
      {
        launch_template_version =
          (Util.option_map (Json.lookup j "launch_template_version")
             LaunchTemplateVersion.of_json);
        warning =
          (Util.option_map (Json.lookup j "warning")
             ValidationWarning.of_json)
      }
  end
module DescribeHostsResult =
  struct
    type t = {
      hosts: HostList.t ;
      next_token: String.t option }
    let make ?(hosts= [])  ?next_token  () = { hosts; next_token }
    let parse xml =
      Some
        {
          hosts =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostSet" xml) HostList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("HostSet", (HostList.to_query v.hosts)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("hosts", (HostList.to_json v.hosts))])
    let of_json j =
      {
        hosts =
          (HostList.of_json (Util.of_option_exn (Json.lookup j "hosts")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCustomerGatewaysRequest =
  struct
    type t =
      {
      customer_gateway_ids: CustomerGatewayIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(customer_gateway_ids= [])  ?(filters= [])  ?dry_run  () =
      { customer_gateway_ids; filters; dry_run }
    let parse xml =
      Some
        {
          customer_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  CustomerGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (CustomerGatewayIdStringList.to_query
                     v.customer_gateway_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("customer_gateway_ids",
               (CustomerGatewayIdStringList.to_json v.customer_gateway_ids))])
    let of_json j =
      {
        customer_gateway_ids =
          (CustomerGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option }
    let make ?associations  () = { associations }
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let of_json j =
      {
        associations =
          (Util.option_map (Json.lookup j "associations")
             TransitGatewayMulticastDomainAssociations.of_json)
      }
  end
module DescribeLaunchTemplatesResult =
  struct
    type t =
      {
      launch_templates: LaunchTemplateSet.t ;
      next_token: String.t option }
    let make ?(launch_templates= [])  ?next_token  () =
      { launch_templates; next_token }
    let parse xml =
      Some
        {
          launch_templates =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplates" xml)
                  LaunchTemplateSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplates",
                  (LaunchTemplateSet.to_query v.launch_templates)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_templates",
               (LaunchTemplateSet.to_json v.launch_templates))])
    let of_json j =
      {
        launch_templates =
          (LaunchTemplateSet.of_json
             (Util.of_option_exn (Json.lookup j "launch_templates")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePrefixListsResult =
  struct
    type t = {
      next_token: String.t option ;
      prefix_lists: PrefixListSet.t }
    let make ?next_token  ?(prefix_lists= [])  () =
      { next_token; prefix_lists }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          prefix_lists =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListSet" xml)
                  PrefixListSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListSet", (PrefixListSet.to_query v.prefix_lists)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("prefix_lists", (PrefixListSet.to_json v.prefix_lists));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_lists =
          (PrefixListSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_lists")))
      }
  end
module GetTransitGatewayAttachmentPropagationsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?(tag_specifications= [])  ?dry_run  () =
      { transit_gateway_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLocalGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      local_gateway_route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~local_gateway_route_table_id  ?dry_run
       () = { destination_cidr_block; local_gateway_route_table_id; dry_run }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTrafficMirrorSessionsRequest =
  struct
    type t =
      {
      traffic_mirror_session_ids: TrafficMirrorSessionIdList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_session_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_session_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  TrafficMirrorSessionIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (TrafficMirrorSessionIdList.to_query
                     v.traffic_mirror_session_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_session_ids",
               (TrafficMirrorSessionIdList.to_json
                  v.traffic_mirror_session_ids))])
    let of_json j =
      {
        traffic_mirror_session_ids =
          (TrafficMirrorSessionIdList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeprovisionByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module DescribeVpnConnectionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpn_connection_ids: VpnConnectionIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(vpn_connection_ids= [])  ?dry_run  () =
      { filters; vpn_connection_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpn_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  VpnConnectionIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId",
                  (VpnConnectionIdStringList.to_query v.vpn_connection_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_connection_ids",
               (VpnConnectionIdStringList.to_json v.vpn_connection_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpn_connection_ids =
          (VpnConnectionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstancePlacementResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyVolumeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_id: String.t ;
      size: Integer.t option ;
      volume_type: VolumeType.t option ;
      iops: Integer.t option }
    let make ?dry_run  ~volume_id  ?size  ?volume_type  ?iops  () =
      { dry_run; volume_id; size; volume_type; iops }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          size = (Util.option_bind (Xml.member "Size" xml) Integer.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iops
              (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Integer.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Integer.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        size = (Util.option_map (Json.lookup j "size") Integer.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json)
      }
  end
module GetDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option }
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let of_json j =
      {
        instance_family_credit_specification =
          (Util.option_map
             (Json.lookup j "instance_family_credit_specification")
             InstanceFamilyCreditSpecification.of_json)
      }
  end
module DeleteLaunchTemplateResult =
  struct
    type t = {
      launch_template: LaunchTemplate.t option }
    let make ?launch_template  () = { launch_template }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json)
      }
  end
module DescribeSpotFleetInstancesResponse =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t option }
    let make ?(active_instances= [])  ?next_token  ?spot_fleet_request_id  ()
      = { active_instances; next_token; spot_fleet_request_id }
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let of_json j =
      {
        active_instances =
          (ActiveInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "active_instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module DescribeSnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t ;
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~snapshot_id  ?dry_run  () =
      { attribute; snapshot_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse));
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some
             (Query.Pair
                ("Attribute", (SnapshotAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("attribute", (SnapshotAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DetachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~instance_id  ~vpc_id  () =
      { dry_run; instance_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module AttachClassicLinkVpcRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      groups: GroupIdStringList.t ;
      instance_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~groups  ~instance_id  ~vpc_id  () =
      { dry_run; groups; instance_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Xml.required "SecurityGroupId"
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  GroupIdStringList.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("SecurityGroupId", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module ModifyInstanceAttributeRequest =
  struct
    type t =
      {
      source_dest_check: AttributeBooleanValue.t option ;
      attribute: InstanceAttributeName.t option ;
      block_device_mappings: InstanceBlockDeviceMappingSpecificationList.t ;
      disable_api_termination: AttributeBooleanValue.t option ;
      dry_run: Boolean.t option ;
      ebs_optimized: AttributeBooleanValue.t option ;
      ena_support: AttributeBooleanValue.t option ;
      groups: GroupIdStringList.t ;
      instance_id: String.t ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      instance_type: AttributeValue.t option ;
      kernel: AttributeValue.t option ;
      ramdisk: AttributeValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      user_data: BlobAttributeValue.t option ;
      value: String.t option }
    let make ?source_dest_check  ?attribute  ?(block_device_mappings= []) 
      ?disable_api_termination  ?dry_run  ?ebs_optimized  ?ena_support 
      ?(groups= [])  ~instance_id  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?kernel  ?ramdisk  ?sriov_net_support  ?user_data 
      ?value  () =
      {
        source_dest_check;
        attribute;
        block_device_mappings;
        disable_api_termination;
        dry_run;
        ebs_optimized;
        ena_support;
        groups;
        instance_id;
        instance_initiated_shutdown_behavior;
        instance_type;
        kernel;
        ramdisk;
        sriov_net_support;
        user_data;
        value
      }
    let parse xml =
      Some
        {
          source_dest_check =
            (Util.option_bind (Xml.member "SourceDestCheck" xml)
               AttributeBooleanValue.parse);
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               InstanceAttributeName.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingSpecificationList.parse));
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml)
               AttributeBooleanValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  GroupIdStringList.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               BlobAttributeValue.parse);
          value = (Util.option_bind (Xml.member "value" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.value
              (fun f -> Query.Pair ("Value", (String.to_query f)));
           Util.option_map v.user_data
             (fun f ->
                Query.Pair ("UserData", (BlobAttributeValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair ("GroupId", (GroupIdStringList.to_query v.groups)));
           Util.option_map v.ena_support
             (fun f ->
                Query.Pair ("EnaSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingSpecificationList.to_query
                     v.block_device_mappings)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (InstanceAttributeName.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.value (fun f -> ("value", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (BlobAttributeValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk
             (fun f -> ("ramdisk", (AttributeValue.to_json f)));
           Util.option_map v.kernel
             (fun f -> ("kernel", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("groups", (GroupIdStringList.to_json v.groups));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingSpecificationList.to_json
                  v.block_device_mappings));
           Util.option_map v.attribute
             (fun f -> ("attribute", (InstanceAttributeName.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             InstanceAttributeName.of_json);
        block_device_mappings =
          (InstanceBlockDeviceMappingSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support")
             AttributeBooleanValue.of_json);
        groups =
          (GroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel =
          (Util.option_map (Json.lookup j "kernel") AttributeValue.of_json);
        ramdisk =
          (Util.option_map (Json.lookup j "ramdisk") AttributeValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data")
             BlobAttributeValue.of_json);
        value = (Util.option_map (Json.lookup j "value") String.of_json)
      }
  end
module DescribeFpgaImageAttributeResult =
  struct
    type t = {
      fpga_image_attribute: FpgaImageAttribute.t option }
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let of_json j =
      {
        fpga_image_attribute =
          (Util.option_map (Json.lookup j "fpga_image_attribute")
             FpgaImageAttribute.of_json)
      }
  end
module CreateSnapshotsRequest =
  struct
    type t =
      {
      description: String.t option ;
      instance_specification: InstanceSpecification.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      copy_tags_from_source: CopyTagsFromSource.t option }
    let make ?description  ~instance_specification  ?(tag_specifications= [])
       ?dry_run  ?copy_tags_from_source  () =
      {
        description;
        instance_specification;
        tag_specifications;
        dry_run;
        copy_tags_from_source
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          instance_specification =
            (Xml.required "InstanceSpecification"
               (Util.option_bind (Xml.member "InstanceSpecification" xml)
                  InstanceSpecification.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          copy_tags_from_source =
            (Util.option_bind (Xml.member "CopyTagsFromSource" xml)
               CopyTagsFromSource.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.copy_tags_from_source
              (fun f ->
                 Query.Pair
                   ("CopyTagsFromSource", (CopyTagsFromSource.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("InstanceSpecification",
                  (InstanceSpecification.to_query v.instance_specification)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.copy_tags_from_source
              (fun f ->
                 ("copy_tags_from_source", (CopyTagsFromSource.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("instance_specification",
               (InstanceSpecification.to_json v.instance_specification));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        instance_specification =
          (InstanceSpecification.of_json
             (Util.of_option_exn (Json.lookup j "instance_specification")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        copy_tags_from_source =
          (Util.option_map (Json.lookup j "copy_tags_from_source")
             CopyTagsFromSource.of_json)
      }
  end
module CreateDefaultSubnetResult =
  struct
    type t = {
      subnet: Subnet.t option }
    let make ?subnet  () = { subnet }
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let of_json j =
      { subnet = (Util.option_map (Json.lookup j "subnet") Subnet.of_json) }
  end
module AssociateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AttachVpnGatewayRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~vpn_gateway_id  ?dry_run  () =
      { vpc_id; vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceTypeOfferingsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      location_type: LocationType.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?location_type  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; location_type; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          location_type =
            (Util.option_bind (Xml.member "LocationType" xml)
               LocationType.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.location_type
             (fun f -> Query.Pair ("LocationType", (LocationType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.location_type
             (fun f -> ("location_type", (LocationType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        location_type =
          (Util.option_map (Json.lookup j "location_type")
             LocationType.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteEgressOnlyInternetGatewayResult =
  struct
    type t = {
      return_code: Boolean.t option }
    let make ?return_code  () = { return_code }
    let parse xml =
      Some
        {
          return_code =
            (Util.option_bind (Xml.member "returnCode" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> Query.Pair ("ReturnCode", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_code
              (fun f -> ("return_code", (Boolean.to_json f)))])
    let of_json j =
      {
        return_code =
          (Util.option_map (Json.lookup j "return_code") Boolean.of_json)
      }
  end
module ResetSnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t ;
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~snapshot_id  ?dry_run  () =
      { attribute; snapshot_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  SnapshotAttributeName.parse));
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Some
             (Query.Pair
                ("Attribute", (SnapshotAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Some ("attribute", (SnapshotAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (SnapshotAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAvailabilityZonesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      zone_names: ZoneNameStringList.t ;
      zone_ids: ZoneIdStringList.t ;
      all_availability_zones: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(zone_names= [])  ?(zone_ids= []) 
      ?all_availability_zones  ?dry_run  () =
      { filters; zone_names; zone_ids; all_availability_zones; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          zone_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ZoneName" xml)
                  ZoneNameStringList.parse));
          zone_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ZoneId" xml)
                  ZoneIdStringList.parse));
          all_availability_zones =
            (Util.option_bind (Xml.member "AllAvailabilityZones" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.all_availability_zones
             (fun f ->
                Query.Pair ("AllAvailabilityZones", (Boolean.to_query f)));
           Some
             (Query.Pair ("ZoneId", (ZoneIdStringList.to_query v.zone_ids)));
           Some
             (Query.Pair
                ("ZoneName", (ZoneNameStringList.to_query v.zone_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.all_availability_zones
             (fun f -> ("all_availability_zones", (Boolean.to_json f)));
           Some ("zone_ids", (ZoneIdStringList.to_json v.zone_ids));
           Some ("zone_names", (ZoneNameStringList.to_json v.zone_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        zone_names =
          (ZoneNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "zone_names")));
        zone_ids =
          (ZoneIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "zone_ids")));
        all_availability_zones =
          (Util.option_map (Json.lookup j "all_availability_zones")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module StopInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      hibernate: Boolean.t option ;
      dry_run: Boolean.t option ;
      force: Boolean.t option }
    let make ~instance_ids  ?hibernate  ?dry_run  ?force  () =
      { instance_ids; hibernate; dry_run; force }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          hibernate =
            (Util.option_bind (Xml.member "Hibernate" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.hibernate
             (fun f -> Query.Pair ("Hibernate", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.hibernate
             (fun f -> ("hibernate", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        hibernate =
          (Util.option_map (Json.lookup j "hibernate") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeTransitGatewayMulticastDomainsResult =
  struct
    type t =
      {
      transit_gateway_multicast_domains: TransitGatewayMulticastDomainList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_multicast_domains= [])  ?next_token  () =
      { transit_gateway_multicast_domains; next_token }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domains =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayMulticastDomains" xml)
                  TransitGatewayMulticastDomainList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomains",
                  (TransitGatewayMulticastDomainList.to_query
                     v.transit_gateway_multicast_domains)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_multicast_domains",
               (TransitGatewayMulticastDomainList.to_json
                  v.transit_gateway_multicast_domains))])
    let of_json j =
      {
        transit_gateway_multicast_domains =
          (TransitGatewayMulticastDomainList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domains")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribePrincipalIdFormatResult =
  struct
    type t =
      {
      principals: PrincipalIdFormatList.t ;
      next_token: String.t option }
    let make ?(principals= [])  ?next_token  () = { principals; next_token }
    let parse xml =
      Some
        {
          principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "principalSet" xml)
                  PrincipalIdFormatList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PrincipalSet",
                  (PrincipalIdFormatList.to_query v.principals)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("principals", (PrincipalIdFormatList.to_json v.principals))])
    let of_json j =
      {
        principals =
          (PrincipalIdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "principals")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeregisterTransitGatewayMulticastGroupSourcesRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: TransitGatewayNetworkInterfaceIdList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  TransitGatewayNetworkInterfaceIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (TransitGatewayNetworkInterfaceIdList.to_query
                     v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (TransitGatewayNetworkInterfaceIdList.to_json
                  v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (TransitGatewayNetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?(instance_ids= [])  ?dry_run  ?max_results 
      ?next_token  () =
      { filters; instance_ids; dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpnGatewaysRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpn_gateway_ids: VpnGatewayIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(vpn_gateway_ids= [])  ?dry_run  () =
      { filters; vpn_gateway_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpn_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpnGatewayId" xml)
                  VpnGatewayIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpnGatewayId",
                  (VpnGatewayIdStringList.to_query v.vpn_gateway_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("vpn_gateway_ids",
               (VpnGatewayIdStringList.to_json v.vpn_gateway_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpn_gateway_ids =
          (VpnGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcEndpointConnectionsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DescribeSpotFleetRequestsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_ids: SpotFleetRequestIdList.t }
    let make ?dry_run  ?max_results  ?next_token  ?(spot_fleet_request_ids=
      [])  () = { dry_run; max_results; next_token; spot_fleet_request_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  SpotFleetRequestIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestId",
                   (SpotFleetRequestIdList.to_query v.spot_fleet_request_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_ids",
                (SpotFleetRequestIdList.to_json v.spot_fleet_request_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_ids =
          (SpotFleetRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_ids")))
      }
  end
module DescribeVpcEndpointServicePermissionsResult =
  struct
    type t =
      {
      allowed_principals: AllowedPrincipalSet.t ;
      next_token: String.t option }
    let make ?(allowed_principals= [])  ?next_token  () =
      { allowed_principals; next_token }
    let parse xml =
      Some
        {
          allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "allowedPrincipals" xml)
                  AllowedPrincipalSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AllowedPrincipals",
                  (AllowedPrincipalSet.to_query v.allowed_principals)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("allowed_principals",
               (AllowedPrincipalSet.to_json v.allowed_principals))])
    let of_json j =
      {
        allowed_principals =
          (AllowedPrincipalSet.of_json
             (Util.of_option_exn (Json.lookup j "allowed_principals")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTransitGatewayPrefixListReferenceRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      prefix_list_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~prefix_list_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        prefix_list_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeByoipCidrsResult =
  struct
    type t = {
      byoip_cidrs: ByoipCidrSet.t ;
      next_token: String.t option }
    let make ?(byoip_cidrs= [])  ?next_token  () =
      { byoip_cidrs; next_token }
    let parse xml =
      Some
        {
          byoip_cidrs =
            (Util.of_option []
               (Util.option_bind (Xml.member "byoipCidrSet" xml)
                  ByoipCidrSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ByoipCidrSet", (ByoipCidrSet.to_query v.byoip_cidrs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("byoip_cidrs", (ByoipCidrSet.to_json v.byoip_cidrs))])
    let of_json j =
      {
        byoip_cidrs =
          (ByoipCidrSet.of_json
             (Util.of_option_exn (Json.lookup j "byoip_cidrs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCoipPoolsResult =
  struct
    type t = {
      coip_pools: CoipPoolSet.t ;
      next_token: String.t option }
    let make ?(coip_pools= [])  ?next_token  () = { coip_pools; next_token }
    let parse xml =
      Some
        {
          coip_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipPoolSet" xml)
                  CoipPoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("CoipPoolSet", (CoipPoolSet.to_query v.coip_pools)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("coip_pools", (CoipPoolSet.to_json v.coip_pools))])
    let of_json j =
      {
        coip_pools =
          (CoipPoolSet.of_json
             (Util.of_option_exn (Json.lookup j "coip_pools")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module RevokeSecurityGroupEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t ;
      ip_permissions: IpPermissionList.t ;
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      ip_protocol: String.t option ;
      to_port: Integer.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option }
    let make ?dry_run  ~group_id  ?(ip_permissions= [])  ?cidr_ip  ?from_port
       ?ip_protocol  ?to_port  ?source_security_group_name 
      ?source_security_group_owner_id  () =
      {
        dry_run;
        group_id;
        ip_permissions;
        cidr_ip;
        from_port;
        ip_protocol;
        to_port;
        source_security_group_name;
        source_security_group_owner_id
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipPermissions" xml)
                  IpPermissionList.parse));
          cidr_ip = (Util.option_bind (Xml.member "cidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "fromPort" xml) Integer.parse);
          ip_protocol =
            (Util.option_bind (Xml.member "ipProtocol" xml) String.parse);
          to_port =
            (Util.option_bind (Xml.member "toPort" xml) Integer.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "sourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "sourceSecurityGroupOwnerId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 Query.Pair
                   ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_security_group_owner_id
              (fun f ->
                 ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Some ("group_id", (String.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json)
      }
  end
module DeleteFleetsResult =
  struct
    type t =
      {
      successful_fleet_deletions: DeleteFleetSuccessSet.t ;
      unsuccessful_fleet_deletions: DeleteFleetErrorSet.t }
    let make ?(successful_fleet_deletions= []) 
      ?(unsuccessful_fleet_deletions= [])  () =
      { successful_fleet_deletions; unsuccessful_fleet_deletions }
    let parse xml =
      Some
        {
          successful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulFleetDeletionSet" xml)
                  DeleteFleetSuccessSet.parse));
          unsuccessful_fleet_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetDeletionSet" xml)
                  DeleteFleetErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetDeletionSet",
                   (DeleteFleetErrorSet.to_query
                      v.unsuccessful_fleet_deletions)));
           Some
             (Query.Pair
                ("SuccessfulFleetDeletionSet",
                  (DeleteFleetSuccessSet.to_query
                     v.successful_fleet_deletions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_deletions",
                (DeleteFleetErrorSet.to_json v.unsuccessful_fleet_deletions));
           Some
             ("successful_fleet_deletions",
               (DeleteFleetSuccessSet.to_json v.successful_fleet_deletions))])
    let of_json j =
      {
        successful_fleet_deletions =
          (DeleteFleetSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful_fleet_deletions")));
        unsuccessful_fleet_deletions =
          (DeleteFleetErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_fleet_deletions")))
      }
  end
module DisableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: DisableFastSnapshotRestoreSuccessSet.t ;
      unsuccessful: DisableFastSnapshotRestoreErrorSet.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  DisableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  DisableFastSnapshotRestoreErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (DisableFastSnapshotRestoreErrorSet.to_query
                      v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (DisableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (DisableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (DisableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let of_json j =
      {
        successful =
          (DisableFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (DisableFastSnapshotRestoreErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module GetEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module DeleteTrafficMirrorFilterResult =
  struct
    type t = {
      traffic_mirror_filter_id: String.t option }
    let make ?traffic_mirror_filter_id  () = { traffic_mirror_filter_id }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f ->
                 Query.Pair ("TrafficMirrorFilterId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_id
              (fun f -> ("traffic_mirror_filter_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json)
      }
  end
module DescribeReservedInstancesModificationsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      reserved_instances_modification_ids:
        ReservedInstancesModificationIdStringList.t ;
      next_token: String.t option }
    let make ?(filters= [])  ?(reserved_instances_modification_ids= []) 
      ?next_token  () =
      { filters; reserved_instances_modification_ids; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          reserved_instances_modification_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesModificationId" xml)
                  ReservedInstancesModificationIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesModificationId",
                  (ReservedInstancesModificationIdStringList.to_query
                     v.reserved_instances_modification_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_modification_ids",
               (ReservedInstancesModificationIdStringList.to_json
                  v.reserved_instances_modification_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        reserved_instances_modification_ids =
          (ReservedInstancesModificationIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_modification_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeInstanceTypesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_types: RequestInstanceTypeList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(instance_types= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; instance_types; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceType" xml)
                  RequestInstanceTypeList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("InstanceType",
                  (RequestInstanceTypeList.to_query v.instance_types)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("instance_types",
               (RequestInstanceTypeList.to_json v.instance_types));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_types =
          (RequestInstanceTypeList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteNatGatewayRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      nat_gateway_id: String.t }
    let make ?dry_run  ~nat_gateway_id  () = { dry_run; nat_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          nat_gateway_id =
            (Xml.required "NatGatewayId"
               (Util.option_bind (Xml.member "NatGatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NatGatewayId", (String.to_query v.nat_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("nat_gateway_id", (String.to_json v.nat_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        nat_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_id")))
      }
  end
module DescribeSpotInstanceRequestsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      spot_instance_request_ids: SpotInstanceRequestIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(spot_instance_request_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; spot_instance_request_ids; next_token; max_results
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          spot_instance_request_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SpotInstanceRequestId" xml)
                  SpotInstanceRequestIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotInstanceRequestId",
                  (SpotInstanceRequestIdList.to_query
                     v.spot_instance_request_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_instance_request_ids",
               (SpotInstanceRequestIdList.to_json v.spot_instance_request_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        spot_instance_request_ids =
          (SpotInstanceRequestIdList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_request_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribePlacementGroupsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      group_names: PlacementGroupStringList.t ;
      group_ids: PlacementGroupIdStringList.t }
    let make ?(filters= [])  ?dry_run  ?(group_names= [])  ?(group_ids= []) 
      () = { filters; dry_run; group_names; group_ids }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupName" xml)
                  PlacementGroupStringList.parse));
          group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "GroupId" xml)
                  PlacementGroupIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("GroupId",
                   (PlacementGroupIdStringList.to_query v.group_ids)));
           Some
             (Query.Pair
                ("GroupName",
                  (PlacementGroupStringList.to_query v.group_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("group_ids", (PlacementGroupIdStringList.to_json v.group_ids));
           Some
             ("group_names",
               (PlacementGroupStringList.to_json v.group_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_names =
          (PlacementGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        group_ids =
          (PlacementGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_ids")))
      }
  end
module AssignIpv6AddressesRequest =
  struct
    type t =
      {
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t }
    let make ?ipv6_address_count  ?(ipv6_addresses= []) 
      ~network_interface_id  () =
      { ipv6_address_count; ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (Ipv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Some
             ("ipv6_addresses", (Ipv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)))])
    let of_json j =
      {
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module DescribeVpcEndpointServicesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_names: ValueStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(service_names= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; service_names; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "ServiceName" xml)
                  ValueStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ServiceName", (ValueStringList.to_query v.service_names)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("service_names", (ValueStringList.to_json v.service_names));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeScheduledInstancesResult =
  struct
    type t =
      {
      next_token: String.t option ;
      scheduled_instance_set: ScheduledInstanceSet.t }
    let make ?next_token  ?(scheduled_instance_set= [])  () =
      { next_token; scheduled_instance_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  ScheduledInstanceSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (ScheduledInstanceSet.to_query v.scheduled_instance_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (ScheduledInstanceSet.to_json v.scheduled_instance_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_set =
          (ScheduledInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_set")))
      }
  end
module ModifyInstanceMetadataOptionsResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      instance_metadata_options: InstanceMetadataOptionsResponse.t option }
    let make ?instance_id  ?instance_metadata_options  () =
      { instance_id; instance_metadata_options }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_metadata_options =
            (Util.option_bind (Xml.member "instanceMetadataOptions" xml)
               InstanceMetadataOptionsResponse.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 Query.Pair
                   ("InstanceMetadataOptions",
                     (InstanceMetadataOptionsResponse.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_metadata_options
              (fun f ->
                 ("instance_metadata_options",
                   (InstanceMetadataOptionsResponse.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_metadata_options =
          (Util.option_map (Json.lookup j "instance_metadata_options")
             InstanceMetadataOptionsResponse.of_json)
      }
  end
module DescribeFlowLogsResult =
  struct
    type t = {
      flow_logs: FlowLogSet.t ;
      next_token: String.t option }
    let make ?(flow_logs= [])  ?next_token  () = { flow_logs; next_token }
    let parse xml =
      Some
        {
          flow_logs =
            (Util.of_option []
               (Util.option_bind (Xml.member "flowLogSet" xml)
                  FlowLogSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("FlowLogSet", (FlowLogSet.to_query v.flow_logs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("flow_logs", (FlowLogSet.to_json v.flow_logs))])
    let of_json j =
      {
        flow_logs =
          (FlowLogSet.of_json
             (Util.of_option_exn (Json.lookup j "flow_logs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateVpcEndpointServiceConfigurationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      acceptance_required: Boolean.t option ;
      private_dns_name: String.t option ;
      network_load_balancer_arns: ValueStringList.t ;
      gateway_load_balancer_arns: ValueStringList.t ;
      client_token: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?acceptance_required  ?private_dns_name 
      ?(network_load_balancer_arns= [])  ?(gateway_load_balancer_arns= []) 
      ?client_token  ?(tag_specifications= [])  () =
      {
        dry_run;
        acceptance_required;
        private_dns_name;
        network_load_balancer_arns;
        gateway_load_balancer_arns;
        client_token;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "AcceptanceRequired" xml)
               Boolean.parse);
          private_dns_name =
            (Util.option_bind (Xml.member "PrivateDnsName" xml) String.parse);
          network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkLoadBalancerArn" xml)
                  ValueStringList.parse));
          gateway_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "GatewayLoadBalancerArn" xml)
                  ValueStringList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("GatewayLoadBalancerArn",
                  (ValueStringList.to_query v.gateway_load_balancer_arns)));
           Some
             (Query.Pair
                ("NetworkLoadBalancerArn",
                  (ValueStringList.to_query v.network_load_balancer_arns)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("gateway_load_balancer_arns",
               (ValueStringList.to_json v.gateway_load_balancer_arns));
           Some
             ("network_load_balancer_arns",
               (ValueStringList.to_json v.network_load_balancer_arns));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_load_balancer_arns")));
        gateway_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "gateway_load_balancer_arns")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeBundleTasksResult =
  struct
    type t = {
      bundle_tasks: BundleTaskList.t }
    let make ?(bundle_tasks= [])  () = { bundle_tasks }
    let parse xml =
      Some
        {
          bundle_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "bundleInstanceTasksSet" xml)
                  BundleTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("BundleInstanceTasksSet",
                   (BundleTaskList.to_query v.bundle_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("bundle_tasks", (BundleTaskList.to_json v.bundle_tasks))])
    let of_json j =
      {
        bundle_tasks =
          (BundleTaskList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_tasks")))
      }
  end
module DescribeInstanceCreditSpecificationsResult =
  struct
    type t =
      {
      instance_credit_specifications: InstanceCreditSpecificationList.t ;
      next_token: String.t option }
    let make ?(instance_credit_specifications= [])  ?next_token  () =
      { instance_credit_specifications; next_token }
    let parse xml =
      Some
        {
          instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "instanceCreditSpecificationSet" xml)
                  InstanceCreditSpecificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceCreditSpecificationSet",
                  (InstanceCreditSpecificationList.to_query
                     v.instance_credit_specifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_credit_specifications",
               (InstanceCreditSpecificationList.to_json
                  v.instance_credit_specifications))])
    let of_json j =
      {
        instance_credit_specifications =
          (InstanceCreditSpecificationList.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_credit_specifications")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ExportClientVpnClientCertificateRevocationListRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSubnetsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      subnet_ids: SubnetIdStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(subnet_ids= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { filters; subnet_ids; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  SubnetIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetId", (SubnetIdStringList.to_query v.subnet_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (SubnetIdStringList.to_json v.subnet_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        subnet_ids =
          (SubnetIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module GetCoipPoolUsageResult =
  struct
    type t =
      {
      coip_pool_id: String.t option ;
      coip_address_usages: CoipAddressUsageSet.t ;
      local_gateway_route_table_id: String.t option }
    let make ?coip_pool_id  ?(coip_address_usages= []) 
      ?local_gateway_route_table_id  () =
      { coip_pool_id; coip_address_usages; local_gateway_route_table_id }
    let parse xml =
      Some
        {
          coip_pool_id =
            (Util.option_bind (Xml.member "coipPoolId" xml) String.parse);
          coip_address_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "coipAddressUsageSet" xml)
                  CoipAddressUsageSet.parse));
          local_gateway_route_table_id =
            (Util.option_bind (Xml.member "localGatewayRouteTableId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f ->
                 Query.Pair ("LocalGatewayRouteTableId", (String.to_query f)));
           Some
             (Query.Pair
                ("CoipAddressUsageSet",
                  (CoipAddressUsageSet.to_query v.coip_address_usages)));
           Util.option_map v.coip_pool_id
             (fun f -> Query.Pair ("CoipPoolId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_id
              (fun f -> ("local_gateway_route_table_id", (String.to_json f)));
           Some
             ("coip_address_usages",
               (CoipAddressUsageSet.to_json v.coip_address_usages));
           Util.option_map v.coip_pool_id
             (fun f -> ("coip_pool_id", (String.to_json f)))])
    let of_json j =
      {
        coip_pool_id =
          (Util.option_map (Json.lookup j "coip_pool_id") String.of_json);
        coip_address_usages =
          (CoipAddressUsageSet.of_json
             (Util.of_option_exn (Json.lookup j "coip_address_usages")));
        local_gateway_route_table_id =
          (Util.option_map (Json.lookup j "local_gateway_route_table_id")
             String.of_json)
      }
  end
module ImportKeyPairResult =
  struct
    type t =
      {
      key_fingerprint: String.t option ;
      key_name: String.t option ;
      key_pair_id: String.t option ;
      tags: TagList.t }
    let make ?key_fingerprint  ?key_name  ?key_pair_id  ?(tags= [])  () =
      { key_fingerprint; key_name; key_pair_id; tags }
    let parse xml =
      Some
        {
          key_fingerprint =
            (Util.option_bind (Xml.member "keyFingerprint" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "keyName" xml) String.parse);
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.key_fingerprint
             (fun f -> Query.Pair ("KeyFingerprint", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.key_fingerprint
             (fun f -> ("key_fingerprint", (String.to_json f)))])
    let of_json j =
      {
        key_fingerprint =
          (Util.option_map (Json.lookup j "key_fingerprint") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module AcceptReservedInstancesExchangeQuoteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instance_ids: ReservedInstanceIdSet.t ;
      target_configurations: TargetConfigurationRequestSet.t }
    let make ?dry_run  ~reserved_instance_ids  ?(target_configurations= []) 
      () = { dry_run; reserved_instance_ids; target_configurations }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instance_ids =
            (Xml.required "ReservedInstanceId"
               (Util.option_bind (Xml.member "ReservedInstanceId" xml)
                  ReservedInstanceIdSet.parse));
          target_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetConfiguration" xml)
                  TargetConfigurationRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetConfiguration",
                   (TargetConfigurationRequestSet.to_query
                      v.target_configurations)));
           Some
             (Query.Pair
                ("ReservedInstanceId",
                  (ReservedInstanceIdSet.to_query v.reserved_instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (TargetConfigurationRequestSet.to_json
                   v.target_configurations));
           Some
             ("reserved_instance_ids",
               (ReservedInstanceIdSet.to_json v.reserved_instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instance_ids =
          (ReservedInstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instance_ids")));
        target_configurations =
          (TargetConfigurationRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module DescribeLocalGatewayRouteTableVpcAssociationsRequest =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association_ids:
        LocalGatewayRouteTableVpcAssociationIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_route_table_vpc_association_ids= [])  ?(filters=
      [])  ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_vpc_association_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayRouteTableVpcAssociationId" xml)
                  LocalGatewayRouteTableVpcAssociationIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationId",
                  (LocalGatewayRouteTableVpcAssociationIdSet.to_query
                     v.local_gateway_route_table_vpc_association_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_vpc_association_ids",
               (LocalGatewayRouteTableVpcAssociationIdSet.to_json
                  v.local_gateway_route_table_vpc_association_ids))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association_ids =
          (LocalGatewayRouteTableVpcAssociationIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_vpc_association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeStaleSecurityGroupsResult =
  struct
    type t =
      {
      next_token: String.t option ;
      stale_security_group_set: StaleSecurityGroupSet.t }
    let make ?next_token  ?(stale_security_group_set= [])  () =
      { next_token; stale_security_group_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          stale_security_group_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "staleSecurityGroupSet" xml)
                  StaleSecurityGroupSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("StaleSecurityGroupSet",
                   (StaleSecurityGroupSet.to_query v.stale_security_group_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stale_security_group_set",
                (StaleSecurityGroupSet.to_json v.stale_security_group_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        stale_security_group_set =
          (StaleSecurityGroupSet.of_json
             (Util.of_option_exn (Json.lookup j "stale_security_group_set")))
      }
  end
module CreateKeyPairRequest =
  struct
    type t =
      {
      key_name: String.t ;
      dry_run: Boolean.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ~key_name  ?dry_run  ?(tag_specifications= [])  () =
      { key_name; dry_run; tag_specifications }
    let parse xml =
      Some
        {
          key_name =
            (Xml.required "KeyName"
               (Util.option_bind (Xml.member "KeyName" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("key_name", (String.to_json v.key_name))])
    let of_json j =
      {
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DisassociateAddressRequest =
  struct
    type t =
      {
      association_id: String.t option ;
      public_ip: String.t option ;
      dry_run: Boolean.t option }
    let make ?association_id  ?public_ip  ?dry_run  () =
      { association_id; public_ip; dry_run }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "AssociationId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSecurityGroupReferencesResult =
  struct
    type t = {
      security_group_reference_set: SecurityGroupReferences.t }
    let make ?(security_group_reference_set= [])  () =
      { security_group_reference_set }
    let parse xml =
      Some
        {
          security_group_reference_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupReferenceSet" xml)
                  SecurityGroupReferences.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupReferenceSet",
                   (SecurityGroupReferences.to_query
                      v.security_group_reference_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_reference_set",
                (SecurityGroupReferences.to_json
                   v.security_group_reference_set))])
    let of_json j =
      {
        security_group_reference_set =
          (SecurityGroupReferences.of_json
             (Util.of_option_exn
                (Json.lookup j "security_group_reference_set")))
      }
  end
module ReplaceRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      dry_run: Boolean.t option ;
      vpc_endpoint_id: String.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      local_target: Boolean.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      carrier_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      route_table_id: String.t ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?dry_run  ?vpc_endpoint_id 
      ?egress_only_internet_gateway_id  ?gateway_id  ?instance_id 
      ?local_target  ?nat_gateway_id  ?transit_gateway_id  ?local_gateway_id 
      ?carrier_gateway_id  ?network_interface_id  ~route_table_id 
      ?vpc_peering_connection_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        dry_run;
        vpc_endpoint_id;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        local_target;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        carrier_gateway_id;
        network_interface_id;
        route_table_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "DestinationPrefixListId" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "VpcEndpointId" xml) String.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          local_target =
            (Util.option_bind (Xml.member "LocalTarget" xml) Boolean.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "LocalGatewayId" xml) String.parse);
          carrier_gateway_id =
            (Util.option_bind (Xml.member "CarrierGatewayId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> Query.Pair ("CarrierGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.local_target
             (fun f -> Query.Pair ("LocalTarget", (Boolean.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> ("carrier_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.local_target
             (fun f -> ("local_target", (Boolean.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        local_target =
          (Util.option_map (Json.lookup j "local_target") Boolean.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        carrier_gateway_id =
          (Util.option_map (Json.lookup j "carrier_gateway_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module GetConsoleOutputRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      dry_run: Boolean.t option ;
      latest: Boolean.t option }
    let make ~instance_id  ?dry_run  ?latest  () =
      { instance_id; dry_run; latest }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          latest = (Util.option_bind (Xml.member "Latest" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.latest
              (fun f -> Query.Pair ("Latest", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.latest
              (fun f -> ("latest", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        latest = (Util.option_map (Json.lookup j "latest") Boolean.of_json)
      }
  end
module CreateTransitGatewayRouteTableRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?(tag_specifications= [])  ?dry_run  () =
      { transit_gateway_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecifications" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecifications",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module KeyPair =
  struct
    type t =
      {
      key_fingerprint: String.t ;
      key_material: String.t ;
      key_name: String.t ;
      key_pair_id: String.t option ;
      tags: TagList.t }
    let make ~key_fingerprint  ~key_material  ~key_name  ?key_pair_id 
      ?(tags= [])  () =
      { key_fingerprint; key_material; key_name; key_pair_id; tags }
    let parse xml =
      Some
        {
          key_fingerprint =
            (Xml.required "keyFingerprint"
               (Util.option_bind (Xml.member "keyFingerprint" xml)
                  String.parse));
          key_material =
            (Xml.required "keyMaterial"
               (Util.option_bind (Xml.member "keyMaterial" xml) String.parse));
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          key_pair_id =
            (Util.option_bind (Xml.member "keyPairId" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Some
             (Query.Pair ("KeyMaterial", (String.to_query v.key_material)));
           Some
             (Query.Pair
                ("KeyFingerprint", (String.to_query v.key_fingerprint)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)));
           Some ("key_name", (String.to_json v.key_name));
           Some ("key_material", (String.to_json v.key_material));
           Some ("key_fingerprint", (String.to_json v.key_fingerprint))])
    let of_json j =
      {
        key_fingerprint =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "key_fingerprint")));
        key_material =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_material")));
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module ModifyVpcEndpointServicePermissionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      add_allowed_principals: ValueStringList.t ;
      remove_allowed_principals: ValueStringList.t }
    let make ?dry_run  ~service_id  ?(add_allowed_principals= []) 
      ?(remove_allowed_principals= [])  () =
      {
        dry_run;
        service_id;
        add_allowed_principals;
        remove_allowed_principals
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          add_allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddAllowedPrincipals" xml)
                  ValueStringList.parse));
          remove_allowed_principals =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveAllowedPrincipals" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveAllowedPrincipals",
                   (ValueStringList.to_query v.remove_allowed_principals)));
           Some
             (Query.Pair
                ("AddAllowedPrincipals",
                  (ValueStringList.to_query v.add_allowed_principals)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_allowed_principals",
                (ValueStringList.to_json v.remove_allowed_principals));
           Some
             ("add_allowed_principals",
               (ValueStringList.to_json v.add_allowed_principals));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        add_allowed_principals =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "add_allowed_principals")));
        remove_allowed_principals =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "remove_allowed_principals")))
      }
  end
module RestoreAddressToClassicRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module AssignPrivateIpAddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      assigned_private_ip_addresses: AssignedPrivateIpAddressList.t }
    let make ?network_interface_id  ?(assigned_private_ip_addresses= [])  ()
      = { network_interface_id; assigned_private_ip_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          assigned_private_ip_addresses =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "assignedPrivateIpAddressesSet" xml)
                  AssignedPrivateIpAddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssignedPrivateIpAddressesSet",
                   (AssignedPrivateIpAddressList.to_query
                      v.assigned_private_ip_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("assigned_private_ip_addresses",
                (AssignedPrivateIpAddressList.to_json
                   v.assigned_private_ip_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        assigned_private_ip_addresses =
          (AssignedPrivateIpAddressList.of_json
             (Util.of_option_exn
                (Json.lookup j "assigned_private_ip_addresses")))
      }
  end
module DescribeIdentityIdFormatRequest =
  struct
    type t = {
      principal_arn: String.t ;
      resource: String.t option }
    let make ~principal_arn  ?resource  () = { principal_arn; resource }
    let parse xml =
      Some
        {
          principal_arn =
            (Xml.required "principalArn"
               (Util.option_bind (Xml.member "principalArn" xml) String.parse));
          resource =
            (Util.option_bind (Xml.member "resource" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> Query.Pair ("Resource", (String.to_query f)));
           Some
             (Query.Pair ("PrincipalArn", (String.to_query v.principal_arn)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> ("resource", (String.to_json f)));
           Some ("principal_arn", (String.to_json v.principal_arn))])
    let of_json j =
      {
        principal_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "principal_arn")));
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json)
      }
  end
module DeleteVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module ModifyInstanceEventStartTimeResult =
  struct
    type t = {
      event: InstanceStatusEvent.t option }
    let make ?event  () = { event }
    let parse xml =
      Some
        {
          event =
            (Util.option_bind (Xml.member "event" xml)
               InstanceStatusEvent.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f ->
                 Query.Pair ("Event", (InstanceStatusEvent.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.event
              (fun f -> ("event", (InstanceStatusEvent.to_json f)))])
    let of_json j =
      {
        event =
          (Util.option_map (Json.lookup j "event")
             InstanceStatusEvent.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      registered_multicast_group_members:
        TransitGatewayMulticastRegisteredGroupMembers.t option }
    let make ?registered_multicast_group_members  () =
      { registered_multicast_group_members }
    let parse xml =
      Some
        {
          registered_multicast_group_members =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupMembers" xml)
               TransitGatewayMulticastRegisteredGroupMembers.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupMembers",
                     (TransitGatewayMulticastRegisteredGroupMembers.to_query
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_members
              (fun f ->
                 ("registered_multicast_group_members",
                   (TransitGatewayMulticastRegisteredGroupMembers.to_json f)))])
    let of_json j =
      {
        registered_multicast_group_members =
          (Util.option_map
             (Json.lookup j "registered_multicast_group_members")
             TransitGatewayMulticastRegisteredGroupMembers.of_json)
      }
  end
module CreateCustomerGatewayResult =
  struct
    type t = {
      customer_gateway: CustomerGateway.t option }
    let make ?customer_gateway  () = { customer_gateway }
    let parse xml =
      Some
        {
          customer_gateway =
            (Util.option_bind (Xml.member "customerGateway" xml)
               CustomerGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f ->
                 Query.Pair ("CustomerGateway", (CustomerGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_gateway
              (fun f -> ("customer_gateway", (CustomerGateway.to_json f)))])
    let of_json j =
      {
        customer_gateway =
          (Util.option_map (Json.lookup j "customer_gateway")
             CustomerGateway.of_json)
      }
  end
module ModifyReservedInstancesResult =
  struct
    type t = {
      reserved_instances_modification_id: String.t option }
    let make ?reserved_instances_modification_id  () =
      { reserved_instances_modification_id }
    let parse xml =
      Some
        {
          reserved_instances_modification_id =
            (Util.option_bind
               (Xml.member "reservedInstancesModificationId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesModificationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_modification_id
              (fun f ->
                 ("reserved_instances_modification_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_modification_id =
          (Util.option_map
             (Json.lookup j "reserved_instances_modification_id")
             String.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVpcAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_associations:
        LocalGatewayRouteTableVpcAssociationSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_route_table_vpc_associations= [])  ?next_token 
      () = { local_gateway_route_table_vpc_associations; next_token }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayRouteTableVpcAssociationSet" xml)
                  LocalGatewayRouteTableVpcAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVpcAssociationSet",
                  (LocalGatewayRouteTableVpcAssociationSet.to_query
                     v.local_gateway_route_table_vpc_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_vpc_associations",
               (LocalGatewayRouteTableVpcAssociationSet.to_json
                  v.local_gateway_route_table_vpc_associations))])
    let of_json j =
      {
        local_gateway_route_table_vpc_associations =
          (LocalGatewayRouteTableVpcAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_vpc_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateLocalGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      local_gateway_route_table_id: String.t ;
      local_gateway_virtual_interface_group_id: String.t ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~local_gateway_route_table_id 
      ~local_gateway_virtual_interface_group_id  ?dry_run  () =
      {
        destination_cidr_block;
        local_gateway_route_table_id;
        local_gateway_virtual_interface_group_id;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          local_gateway_route_table_id =
            (Xml.required "LocalGatewayRouteTableId"
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  String.parse));
          local_gateway_virtual_interface_group_id =
            (Xml.required "LocalGatewayVirtualInterfaceGroupId"
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupId",
                  (String.to_query v.local_gateway_virtual_interface_group_id)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (String.to_query v.local_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("local_gateway_virtual_interface_group_id",
               (String.to_json v.local_gateway_virtual_interface_group_id));
           Some
             ("local_gateway_route_table_id",
               (String.to_json v.local_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        local_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_id")));
        local_gateway_virtual_interface_group_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_group_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIamInstanceProfileAssociationsRequest =
  struct
    type t =
      {
      association_ids: AssociationIdList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(association_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () = { association_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          association_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AssociationId" xml)
                  AssociationIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("AssociationId",
                  (AssociationIdList.to_query v.association_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("association_ids",
               (AssociationIdList.to_json v.association_ids))])
    let of_json j =
      {
        association_ids =
          (AssociationIdList.of_json
             (Util.of_option_exn (Json.lookup j "association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifySnapshotAttributeRequest =
  struct
    type t =
      {
      attribute: SnapshotAttributeName.t option ;
      create_volume_permission: CreateVolumePermissionModifications.t option ;
      group_names: GroupNameStringList.t ;
      operation_type: OperationType.t option ;
      snapshot_id: String.t ;
      user_ids: UserIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?attribute  ?create_volume_permission  ?(group_names= []) 
      ?operation_type  ~snapshot_id  ?(user_ids= [])  ?dry_run  () =
      {
        attribute;
        create_volume_permission;
        group_names;
        operation_type;
        snapshot_id;
        user_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               SnapshotAttributeName.parse);
          create_volume_permission =
            (Util.option_bind (Xml.member "CreateVolumePermission" xml)
               CreateVolumePermissionModifications.parse);
          group_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  GroupNameStringList.parse));
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Some
             (Query.Pair
                ("UserGroup", (GroupNameStringList.to_query v.group_names)));
           Util.option_map v.create_volume_permission
             (fun f ->
                Query.Pair
                  ("CreateVolumePermission",
                    (CreateVolumePermissionModifications.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (SnapshotAttributeName.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Some ("snapshot_id", (String.to_json v.snapshot_id));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Some ("group_names", (GroupNameStringList.to_json v.group_names));
           Util.option_map v.create_volume_permission
             (fun f ->
                ("create_volume_permission",
                  (CreateVolumePermissionModifications.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (SnapshotAttributeName.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             SnapshotAttributeName.of_json);
        create_volume_permission =
          (Util.option_map (Json.lookup j "create_volume_permission")
             CreateVolumePermissionModifications.of_json);
        group_names =
          (GroupNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "group_names")));
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVolumeResult =
  struct
    type t = {
      volume_modification: VolumeModification.t option }
    let make ?volume_modification  () = { volume_modification }
    let parse xml =
      Some
        {
          volume_modification =
            (Util.option_bind (Xml.member "volumeModification" xml)
               VolumeModification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 Query.Pair
                   ("VolumeModification", (VolumeModification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_modification
              (fun f ->
                 ("volume_modification", (VolumeModification.to_json f)))])
    let of_json j =
      {
        volume_modification =
          (Util.option_map (Json.lookup j "volume_modification")
             VolumeModification.of_json)
      }
  end
module ReleaseAddressRequest =
  struct
    type t =
      {
      allocation_id: String.t option ;
      public_ip: String.t option ;
      network_border_group: String.t option ;
      dry_run: Boolean.t option }
    let make ?allocation_id  ?public_ip  ?network_border_group  ?dry_run  ()
      = { allocation_id; public_ip; network_border_group; dry_run }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "NetworkBorderGroup" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportSnapshotResult =
  struct
    type t =
      {
      description: String.t option ;
      import_task_id: String.t option ;
      snapshot_task_detail: SnapshotTaskDetail.t option ;
      tags: TagList.t }
    let make ?description  ?import_task_id  ?snapshot_task_detail  ?(tags=
      [])  () = { description; import_task_id; snapshot_task_detail; tags }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          snapshot_task_detail =
            (Util.option_bind (Xml.member "snapshotTaskDetail" xml)
               SnapshotTaskDetail.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                Query.Pair
                  ("SnapshotTaskDetail", (SnapshotTaskDetail.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.snapshot_task_detail
             (fun f ->
                ("snapshot_task_detail", (SnapshotTaskDetail.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        snapshot_task_detail =
          (Util.option_map (Json.lookup j "snapshot_task_detail")
             SnapshotTaskDetail.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeVolumesResult =
  struct
    type t = {
      volumes: VolumeList.t ;
      next_token: String.t option }
    let make ?(volumes= [])  ?next_token  () = { volumes; next_token }
    let parse xml =
      Some
        {
          volumes =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeSet" xml)
                  VolumeList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VolumeSet", (VolumeList.to_query v.volumes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("volumes", (VolumeList.to_json v.volumes))])
    let of_json j =
      {
        volumes =
          (VolumeList.of_json (Util.of_option_exn (Json.lookup j "volumes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableFastSnapshotRestoresRequest =
  struct
    type t =
      {
      availability_zones: AvailabilityZoneStringList.t ;
      source_snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~availability_zones  ~source_snapshot_ids  ?dry_run  () =
      { availability_zones; source_snapshot_ids; dry_run }
    let parse xml =
      Some
        {
          availability_zones =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  AvailabilityZoneStringList.parse));
          source_snapshot_ids =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SourceSnapshotId",
                  (SnapshotIdStringList.to_query v.source_snapshot_ids)));
           Some
             (Query.Pair
                ("AvailabilityZone",
                  (AvailabilityZoneStringList.to_query v.availability_zones)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("source_snapshot_ids",
               (SnapshotIdStringList.to_json v.source_snapshot_ids));
           Some
             ("availability_zones",
               (AvailabilityZoneStringList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        source_snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnConnectionsResult =
  struct
    type t =
      {
      connections: ClientVpnConnectionSet.t ;
      next_token: String.t option }
    let make ?(connections= [])  ?next_token  () =
      { connections; next_token }
    let parse xml =
      Some
        {
          connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "connections" xml)
                  ClientVpnConnectionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Connections",
                  (ClientVpnConnectionSet.to_query v.connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connections", (ClientVpnConnectionSet.to_json v.connections))])
    let of_json j =
      {
        connections =
          (ClientVpnConnectionSet.of_json
             (Util.of_option_exn (Json.lookup j "connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeFleetInstancesResult =
  struct
    type t =
      {
      active_instances: ActiveInstanceSet.t ;
      next_token: String.t option ;
      fleet_id: String.t option }
    let make ?(active_instances= [])  ?next_token  ?fleet_id  () =
      { active_instances; next_token; fleet_id }
    let parse xml =
      Some
        {
          active_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "activeInstanceSet" xml)
                  ActiveInstanceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> Query.Pair ("FleetId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ActiveInstanceSet",
                  (ActiveInstanceSet.to_query v.active_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fleet_id
              (fun f -> ("fleet_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("active_instances",
               (ActiveInstanceSet.to_json v.active_instances))])
    let of_json j =
      {
        active_instances =
          (ActiveInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "active_instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json)
      }
  end
module AttachNetworkInterfaceResult =
  struct
    type t =
      {
      attachment_id: String.t option ;
      network_card_index: Integer.t option }
    let make ?attachment_id  ?network_card_index  () =
      { attachment_id; network_card_index }
    let parse xml =
      Some
        {
          attachment_id =
            (Util.option_bind (Xml.member "attachmentId" xml) String.parse);
          network_card_index =
            (Util.option_bind (Xml.member "networkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Util.option_map v.attachment_id
             (fun f -> Query.Pair ("AttachmentId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Util.option_map v.attachment_id
             (fun f -> ("attachment_id", (String.to_json f)))])
    let of_json j =
      {
        attachment_id =
          (Util.option_map (Json.lookup j "attachment_id") String.of_json);
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module CreateTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t ;
      traffic_direction: TrafficDirection.t ;
      rule_number: Integer.t ;
      rule_action: TrafficMirrorRuleAction.t ;
      destination_port_range: TrafficMirrorPortRangeRequest.t option ;
      source_port_range: TrafficMirrorPortRangeRequest.t option ;
      protocol: Integer.t option ;
      destination_cidr_block: String.t ;
      source_cidr_block: String.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~traffic_mirror_filter_id  ~traffic_direction  ~rule_number 
      ~rule_action  ?destination_port_range  ?source_port_range  ?protocol 
      ~destination_cidr_block  ~source_cidr_block  ?description  ?dry_run 
      ?client_token  () =
      {
        traffic_mirror_filter_id;
        traffic_direction;
        rule_number;
        rule_action;
        destination_port_range;
        source_port_range;
        protocol;
        destination_cidr_block;
        source_cidr_block;
        description;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          traffic_direction =
            (Xml.required "TrafficDirection"
               (Util.option_bind (Xml.member "TrafficDirection" xml)
                  TrafficDirection.parse));
          rule_number =
            (Xml.required "RuleNumber"
               (Util.option_bind (Xml.member "RuleNumber" xml) Integer.parse));
          rule_action =
            (Xml.required "RuleAction"
               (Util.option_bind (Xml.member "RuleAction" xml)
                  TrafficMirrorRuleAction.parse));
          destination_port_range =
            (Util.option_bind (Xml.member "DestinationPortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          source_port_range =
            (Util.option_bind (Xml.member "SourcePortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          protocol =
            (Util.option_bind (Xml.member "Protocol" xml) Integer.parse);
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          source_cidr_block =
            (Xml.required "SourceCidrBlock"
               (Util.option_bind (Xml.member "SourceCidrBlock" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("SourceCidrBlock", (String.to_query v.source_cidr_block)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Some
             (Query.Pair
                ("RuleAction",
                  (TrafficMirrorRuleAction.to_query v.rule_action)));
           Some (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair
                ("TrafficDirection",
                  (TrafficDirection.to_query v.traffic_direction)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("source_cidr_block", (String.to_json v.source_cidr_block));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Some
             ("rule_action", (TrafficMirrorRuleAction.to_json v.rule_action));
           Some ("rule_number", (Integer.to_json v.rule_number));
           Some
             ("traffic_direction",
               (TrafficDirection.to_json v.traffic_direction));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        traffic_direction =
          (TrafficDirection.of_json
             (Util.of_option_exn (Json.lookup j "traffic_direction")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")));
        rule_action =
          (TrafficMirrorRuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        source_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_cidr_block")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeVolumesModificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      volume_ids: VolumeIdStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(volume_ids= [])  ?(filters= [])  ?next_token 
      ?max_results  () =
      { dry_run; volume_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeLocalGatewayRouteTablesResult =
  struct
    type t =
      {
      local_gateway_route_tables: LocalGatewayRouteTableSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_route_tables= [])  ?next_token  () =
      { local_gateway_route_tables; next_token }
    let parse xml =
      Some
        {
          local_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewayRouteTableSet" xml)
                  LocalGatewayRouteTableSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableSet",
                  (LocalGatewayRouteTableSet.to_query
                     v.local_gateway_route_tables)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_tables",
               (LocalGatewayRouteTableSet.to_json
                  v.local_gateway_route_tables))])
    let of_json j =
      {
        local_gateway_route_tables =
          (LocalGatewayRouteTableSet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateway_route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeReservedInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      offering_class: OfferingClassType.t option ;
      reserved_instances_ids: ReservedInstancesIdStringList.t ;
      dry_run: Boolean.t option ;
      offering_type: OfferingTypeValues.t option }
    let make ?(filters= [])  ?offering_class  ?(reserved_instances_ids= []) 
      ?dry_run  ?offering_type  () =
      {
        filters;
        offering_class;
        reserved_instances_ids;
        dry_run;
        offering_type
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          offering_class =
            (Util.option_bind (Xml.member "OfferingClass" xml)
               OfferingClassType.parse);
          reserved_instances_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  ReservedInstancesIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f ->
                 Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesId",
                  (ReservedInstancesIdStringList.to_query
                     v.reserved_instances_ids)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_ids",
               (ReservedInstancesIdStringList.to_json
                  v.reserved_instances_ids));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        reserved_instances_ids =
          (ReservedInstancesIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json)
      }
  end
module DescribeVpcClassicLinkRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      vpc_ids: VpcClassicLinkIdList.t }
    let make ?(filters= [])  ?dry_run  ?(vpc_ids= [])  () =
      { filters; dry_run; vpc_ids }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcClassicLinkIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcId", (VpcClassicLinkIdList.to_query v.vpc_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_ids", (VpcClassicLinkIdList.to_json v.vpc_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_ids =
          (VpcClassicLinkIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")))
      }
  end
module EnableVpcClassicLinkDnsSupportRequest =
  struct
    type t = {
      vpc_id: String.t option }
    let make ?vpc_id  () = { vpc_id }
    let parse xml =
      Some
        { vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      { vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json) }
  end
module ModifyVpnTunnelOptionsResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DeleteTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DescribeRegionsResult =
  struct
    type t = {
      regions: RegionList.t }
    let make ?(regions= [])  () = { regions }
    let parse xml =
      Some
        {
          regions =
            (Util.of_option []
               (Util.option_bind (Xml.member "regionInfo" xml)
                  RegionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("RegionInfo", (RegionList.to_query v.regions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("regions", (RegionList.to_json v.regions))])
    let of_json j =
      {
        regions =
          (RegionList.of_json (Util.of_option_exn (Json.lookup j "regions")))
      }
  end
module CreateVpnConnectionRequest =
  struct
    type t =
      {
      customer_gateway_id: String.t ;
      type_: String.t ;
      vpn_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      dry_run: Boolean.t option ;
      options: VpnConnectionOptionsSpecification.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ~customer_gateway_id  ~type_  ?vpn_gateway_id 
      ?transit_gateway_id  ?dry_run  ?options  ?(tag_specifications= [])  ()
      =
      {
        customer_gateway_id;
        type_;
        vpn_gateway_id;
        transit_gateway_id;
        dry_run;
        options;
        tag_specifications
      }
    let parse xml =
      Some
        {
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse));
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) String.parse));
          vpn_gateway_id =
            (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          options =
            (Util.option_bind (Xml.member "options" xml)
               VpnConnectionOptionsSpecification.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options", (VpnConnectionOptionsSpecification.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Some (Query.Pair ("Type", (String.to_query v.type_)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.options
             (fun f ->
                ("options", (VpnConnectionOptionsSpecification.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Some ("type_", (String.to_json v.type_));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id))])
    let of_json j =
      {
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        type_ = (String.of_json (Util.of_option_exn (Json.lookup j "type_")));
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             VpnConnectionOptionsSpecification.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module ExportImageResult =
  struct
    type t =
      {
      description: String.t option ;
      disk_image_format: DiskImageFormat.t option ;
      export_image_task_id: String.t option ;
      image_id: String.t option ;
      role_name: String.t option ;
      progress: String.t option ;
      s3_export_location: ExportTaskS3Location.t option ;
      status: String.t option ;
      status_message: String.t option ;
      tags: TagList.t }
    let make ?description  ?disk_image_format  ?export_image_task_id 
      ?image_id  ?role_name  ?progress  ?s3_export_location  ?status 
      ?status_message  ?(tags= [])  () =
      {
        description;
        disk_image_format;
        export_image_task_id;
        image_id;
        role_name;
        progress;
        s3_export_location;
        status;
        status_message;
        tags
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_image_format =
            (Util.option_bind (Xml.member "diskImageFormat" xml)
               DiskImageFormat.parse);
          export_image_task_id =
            (Util.option_bind (Xml.member "exportImageTaskId" xml)
               String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "roleName" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          s3_export_location =
            (Util.option_bind (Xml.member "s3ExportLocation" xml)
               ExportTaskS3Location.parse);
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Util.option_map v.s3_export_location
             (fun f ->
                Query.Pair
                  ("S3ExportLocation", (ExportTaskS3Location.to_query f)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.export_image_task_id
             (fun f -> Query.Pair ("ExportImageTaskId", (String.to_query f)));
           Util.option_map v.disk_image_format
             (fun f ->
                Query.Pair ("DiskImageFormat", (DiskImageFormat.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Util.option_map v.s3_export_location
             (fun f ->
                ("s3_export_location", (ExportTaskS3Location.to_json f)));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.export_image_task_id
             (fun f -> ("export_image_task_id", (String.to_json f)));
           Util.option_map v.disk_image_format
             (fun f -> ("disk_image_format", (DiskImageFormat.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_image_format =
          (Util.option_map (Json.lookup j "disk_image_format")
             DiskImageFormat.of_json);
        export_image_task_id =
          (Util.option_map (Json.lookup j "export_image_task_id")
             String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        s3_export_location =
          (Util.option_map (Json.lookup j "s3_export_location")
             ExportTaskS3Location.of_json);
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DeleteClientVpnEndpointRequest =
  struct
    type t = {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  () =
      { client_vpn_endpoint_id; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetAssociatedIpv6PoolCidrsResult =
  struct
    type t =
      {
      ipv6_cidr_associations: Ipv6CidrAssociationSet.t ;
      next_token: String.t option }
    let make ?(ipv6_cidr_associations= [])  ?next_token  () =
      { ipv6_cidr_associations; next_token }
    let parse xml =
      Some
        {
          ipv6_cidr_associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6CidrAssociationSet" xml)
                  Ipv6CidrAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6CidrAssociationSet",
                  (Ipv6CidrAssociationSet.to_query v.ipv6_cidr_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("ipv6_cidr_associations",
               (Ipv6CidrAssociationSet.to_json v.ipv6_cidr_associations))])
    let of_json j =
      {
        ipv6_cidr_associations =
          (Ipv6CidrAssociationSet.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_cidr_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AllocateHostsRequest =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      availability_zone: String.t ;
      client_token: String.t option ;
      instance_type: String.t option ;
      instance_family: String.t option ;
      quantity: Integer.t ;
      tag_specifications: TagSpecificationList.t ;
      host_recovery: HostRecovery.t option }
    let make ?auto_placement  ~availability_zone  ?client_token 
      ?instance_type  ?instance_family  ~quantity  ?(tag_specifications= []) 
      ?host_recovery  () =
      {
        auto_placement;
        availability_zone;
        client_token;
        instance_type;
        instance_family;
        quantity;
        tag_specifications;
        host_recovery
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "InstanceFamily" xml) String.parse);
          quantity =
            (Xml.required "quantity"
               (Util.option_bind (Xml.member "quantity" xml) Integer.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "HostRecovery" xml)
               HostRecovery.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_recovery
              (fun f ->
                 Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("Quantity", (Integer.to_query v.quantity)));
           Util.option_map v.instance_family
             (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_recovery
              (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("quantity", (Integer.to_json v.quantity));
           Util.option_map v.instance_family
             (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json);
        quantity =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "quantity")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json)
      }
  end
module ModifyCapacityReservationRequest =
  struct
    type t =
      {
      capacity_reservation_id: String.t ;
      instance_count: Integer.t option ;
      end_date: DateTime.t option ;
      end_date_type: EndDateType.t option ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?instance_count  ?end_date 
      ?end_date_type  ?dry_run  () =
      {
        capacity_reservation_id;
        instance_count;
        end_date;
        end_date_type;
        dry_run
      }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          end_date =
            (Util.option_bind (Xml.member "EndDate" xml) DateTime.parse);
          end_date_type =
            (Util.option_bind (Xml.member "EndDateType" xml)
               EndDateType.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.end_date_type
             (fun f -> Query.Pair ("EndDateType", (EndDateType.to_query f)));
           Util.option_map v.end_date
             (fun f -> Query.Pair ("EndDate", (DateTime.to_query f)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.end_date_type
             (fun f -> ("end_date_type", (EndDateType.to_json f)));
           Util.option_map v.end_date
             (fun f -> ("end_date", (DateTime.to_json f)));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        end_date =
          (Util.option_map (Json.lookup j "end_date") DateTime.of_json);
        end_date_type =
          (Util.option_map (Json.lookup j "end_date_type")
             EndDateType.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDhcpOptionsResult =
  struct
    type t = {
      dhcp_options: DhcpOptions.t option }
    let make ?dhcp_options  () = { dhcp_options }
    let parse xml =
      Some
        {
          dhcp_options =
            (Util.option_bind (Xml.member "dhcpOptions" xml)
               DhcpOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> Query.Pair ("DhcpOptions", (DhcpOptions.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dhcp_options
              (fun f -> ("dhcp_options", (DhcpOptions.to_json f)))])
    let of_json j =
      {
        dhcp_options =
          (Util.option_map (Json.lookup j "dhcp_options") DhcpOptions.of_json)
      }
  end
module ProvisionByoipCidrRequest =
  struct
    type t =
      {
      cidr: String.t ;
      cidr_authorization_context: CidrAuthorizationContext.t option ;
      publicly_advertisable: Boolean.t option ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      pool_tag_specifications: TagSpecificationList.t }
    let make ~cidr  ?cidr_authorization_context  ?publicly_advertisable 
      ?description  ?dry_run  ?(pool_tag_specifications= [])  () =
      {
        cidr;
        cidr_authorization_context;
        publicly_advertisable;
        description;
        dry_run;
        pool_tag_specifications
      }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          cidr_authorization_context =
            (Util.option_bind (Xml.member "CidrAuthorizationContext" xml)
               CidrAuthorizationContext.parse);
          publicly_advertisable =
            (Util.option_bind (Xml.member "PubliclyAdvertisable" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          pool_tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolTagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PoolTagSpecification",
                   (TagSpecificationList.to_query v.pool_tag_specifications)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.publicly_advertisable
             (fun f ->
                Query.Pair ("PubliclyAdvertisable", (Boolean.to_query f)));
           Util.option_map v.cidr_authorization_context
             (fun f ->
                Query.Pair
                  ("CidrAuthorizationContext",
                    (CidrAuthorizationContext.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("pool_tag_specifications",
                (TagSpecificationList.to_json v.pool_tag_specifications));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.publicly_advertisable
             (fun f -> ("publicly_advertisable", (Boolean.to_json f)));
           Util.option_map v.cidr_authorization_context
             (fun f ->
                ("cidr_authorization_context",
                  (CidrAuthorizationContext.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        cidr_authorization_context =
          (Util.option_map (Json.lookup j "cidr_authorization_context")
             CidrAuthorizationContext.of_json);
        publicly_advertisable =
          (Util.option_map (Json.lookup j "publicly_advertisable")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        pool_tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "pool_tag_specifications")))
      }
  end
module ConfirmProductInstanceResult =
  struct
    type t = {
      owner_id: String.t option ;
      return: Boolean.t option }
    let make ?owner_id  ?return  () = { owner_id; return }
    let parse xml =
      Some
        {
          owner_id =
            (Util.option_bind (Xml.member "ownerId" xml) String.parse);
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)));
           Util.option_map v.owner_id
             (fun f -> Query.Pair ("OwnerId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)));
           Util.option_map v.owner_id
             (fun f -> ("owner_id", (String.to_json f)))])
    let of_json j =
      {
        owner_id =
          (Util.option_map (Json.lookup j "owner_id") String.of_json);
        return = (Util.option_map (Json.lookup j "return") Boolean.of_json)
      }
  end
module ModifyTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      add_subnet_ids: TransitGatewaySubnetIdList.t ;
      remove_subnet_ids: TransitGatewaySubnetIdList.t ;
      options: ModifyTransitGatewayVpcAttachmentRequestOptions.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?(add_subnet_ids= []) 
      ?(remove_subnet_ids= [])  ?options  ?dry_run  () =
      {
        transit_gateway_attachment_id;
        add_subnet_ids;
        remove_subnet_ids;
        options;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          add_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSubnetIds" xml)
                  TransitGatewaySubnetIdList.parse));
          remove_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSubnetIds" xml)
                  TransitGatewaySubnetIdList.parse));
          options =
            (Util.option_bind (Xml.member "Options" xml)
               ModifyTransitGatewayVpcAttachmentRequestOptions.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options",
                    (ModifyTransitGatewayVpcAttachmentRequestOptions.to_query
                       f)));
           Some
             (Query.Pair
                ("RemoveSubnetIds",
                  (TransitGatewaySubnetIdList.to_query v.remove_subnet_ids)));
           Some
             (Query.Pair
                ("AddSubnetIds",
                  (TransitGatewaySubnetIdList.to_query v.add_subnet_ids)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.options
             (fun f ->
                ("options",
                  (ModifyTransitGatewayVpcAttachmentRequestOptions.to_json f)));
           Some
             ("remove_subnet_ids",
               (TransitGatewaySubnetIdList.to_json v.remove_subnet_ids));
           Some
             ("add_subnet_ids",
               (TransitGatewaySubnetIdList.to_json v.add_subnet_ids));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        add_subnet_ids =
          (TransitGatewaySubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "add_subnet_ids")));
        remove_subnet_ids =
          (TransitGatewaySubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "remove_subnet_ids")));
        options =
          (Util.option_map (Json.lookup j "options")
             ModifyTransitGatewayVpcAttachmentRequestOptions.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      dry_run: Boolean.t option ;
      vpc_endpoint_id: String.t option ;
      egress_only_internet_gateway_id: String.t option ;
      gateway_id: String.t option ;
      instance_id: String.t option ;
      nat_gateway_id: String.t option ;
      transit_gateway_id: String.t option ;
      local_gateway_id: String.t option ;
      carrier_gateway_id: String.t option ;
      network_interface_id: String.t option ;
      route_table_id: String.t ;
      vpc_peering_connection_id: String.t option }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?dry_run  ?vpc_endpoint_id 
      ?egress_only_internet_gateway_id  ?gateway_id  ?instance_id 
      ?nat_gateway_id  ?transit_gateway_id  ?local_gateway_id 
      ?carrier_gateway_id  ?network_interface_id  ~route_table_id 
      ?vpc_peering_connection_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        dry_run;
        vpc_endpoint_id;
        egress_only_internet_gateway_id;
        gateway_id;
        instance_id;
        nat_gateway_id;
        transit_gateway_id;
        local_gateway_id;
        carrier_gateway_id;
        network_interface_id;
        route_table_id;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "DestinationPrefixListId" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_endpoint_id =
            (Util.option_bind (Xml.member "VpcEndpointId" xml) String.parse);
          egress_only_internet_gateway_id =
            (Util.option_bind (Xml.member "egressOnlyInternetGatewayId" xml)
               String.parse);
          gateway_id =
            (Util.option_bind (Xml.member "gatewayId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse);
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          local_gateway_id =
            (Util.option_bind (Xml.member "LocalGatewayId" xml) String.parse);
          carrier_gateway_id =
            (Util.option_bind (Xml.member "CarrierGatewayId" xml)
               String.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse));
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> Query.Pair ("CarrierGatewayId", (String.to_query f)));
           Util.option_map v.local_gateway_id
             (fun f -> Query.Pair ("LocalGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Util.option_map v.nat_gateway_id
             (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.gateway_id
             (fun f -> Query.Pair ("GatewayId", (String.to_query f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                Query.Pair
                  ("EgressOnlyInternetGatewayId", (String.to_query f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> Query.Pair ("VpcEndpointId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.carrier_gateway_id
             (fun f -> ("carrier_gateway_id", (String.to_json f)));
           Util.option_map v.local_gateway_id
             (fun f -> ("local_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Util.option_map v.nat_gateway_id
             (fun f -> ("nat_gateway_id", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.gateway_id
             (fun f -> ("gateway_id", (String.to_json f)));
           Util.option_map v.egress_only_internet_gateway_id
             (fun f ->
                ("egress_only_internet_gateway_id", (String.to_json f)));
           Util.option_map v.vpc_endpoint_id
             (fun f -> ("vpc_endpoint_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_id =
          (Util.option_map (Json.lookup j "vpc_endpoint_id") String.of_json);
        egress_only_internet_gateway_id =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway_id")
             String.of_json);
        gateway_id =
          (Util.option_map (Json.lookup j "gateway_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json);
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        local_gateway_id =
          (Util.option_map (Json.lookup j "local_gateway_id") String.of_json);
        carrier_gateway_id =
          (Util.option_map (Json.lookup j "carrier_gateway_id")
             String.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module DisableEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAddressesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      public_ips: PublicIpStringList.t ;
      allocation_ids: AllocationIdList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(public_ips= [])  ?(allocation_ids= []) 
      ?dry_run  () = { filters; public_ips; allocation_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "PublicIp" xml)
                  PublicIpStringList.parse));
          allocation_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AllocationId" xml)
                  AllocationIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AllocationId",
                  (AllocationIdList.to_query v.allocation_ids)));
           Some
             (Query.Pair
                ("PublicIp", (PublicIpStringList.to_query v.public_ips)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("allocation_ids", (AllocationIdList.to_json v.allocation_ids));
           Some ("public_ips", (PublicIpStringList.to_json v.public_ips));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        public_ips =
          (PublicIpStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")));
        allocation_ids =
          (AllocationIdList.of_json
             (Util.of_option_exn (Json.lookup j "allocation_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option }
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table =
          (Util.option_map (Json.lookup j "transit_gateway_route_table")
             TransitGatewayRouteTable.of_json)
      }
  end
module AssociateVpcCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: VpcIpv6CidrBlockAssociation.t option ;
      cidr_block_association: VpcCidrBlockAssociation.t option ;
      vpc_id: String.t option }
    let make ?ipv6_cidr_block_association  ?cidr_block_association  ?vpc_id 
      () = { ipv6_cidr_block_association; cidr_block_association; vpc_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               VpcIpv6CidrBlockAssociation.parse);
          cidr_block_association =
            (Util.option_bind (Xml.member "cidrBlockAssociation" xml)
               VpcCidrBlockAssociation.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                Query.Pair
                  ("CidrBlockAssociation",
                    (VpcCidrBlockAssociation.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (VpcIpv6CidrBlockAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.cidr_block_association
             (fun f ->
                ("cidr_block_association",
                  (VpcCidrBlockAssociation.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (VpcIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             VpcIpv6CidrBlockAssociation.of_json);
        cidr_block_association =
          (Util.option_map (Json.lookup j "cidr_block_association")
             VpcCidrBlockAssociation.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json)
      }
  end
module ModifyVpcPeeringConnectionOptionsRequest =
  struct
    type t =
      {
      accepter_peering_connection_options:
        PeeringConnectionOptionsRequest.t option ;
      dry_run: Boolean.t option ;
      requester_peering_connection_options:
        PeeringConnectionOptionsRequest.t option ;
      vpc_peering_connection_id: String.t }
    let make ?accepter_peering_connection_options  ?dry_run 
      ?requester_peering_connection_options  ~vpc_peering_connection_id  () =
      {
        accepter_peering_connection_options;
        dry_run;
        requester_peering_connection_options;
        vpc_peering_connection_id
      }
    let parse xml =
      Some
        {
          accepter_peering_connection_options =
            (Util.option_bind
               (Xml.member "AccepterPeeringConnectionOptions" xml)
               PeeringConnectionOptionsRequest.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          requester_peering_connection_options =
            (Util.option_bind
               (Xml.member "RequesterPeeringConnectionOptions" xml)
               PeeringConnectionOptionsRequest.parse);
          vpc_peering_connection_id =
            (Xml.required "VpcPeeringConnectionId"
               (Util.option_bind (Xml.member "VpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.requester_peering_connection_options
             (fun f ->
                Query.Pair
                  ("RequesterPeeringConnectionOptions",
                    (PeeringConnectionOptionsRequest.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                Query.Pair
                  ("AccepterPeeringConnectionOptions",
                    (PeeringConnectionOptionsRequest.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.requester_peering_connection_options
             (fun f ->
                ("requester_peering_connection_options",
                  (PeeringConnectionOptionsRequest.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                ("accepter_peering_connection_options",
                  (PeeringConnectionOptionsRequest.to_json f)))])
    let of_json j =
      {
        accepter_peering_connection_options =
          (Util.option_map
             (Json.lookup j "accepter_peering_connection_options")
             PeeringConnectionOptionsRequest.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        requester_peering_connection_options =
          (Util.option_map
             (Json.lookup j "requester_peering_connection_options")
             PeeringConnectionOptionsRequest.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module DeregisterTransitGatewayMulticastGroupMembersRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: TransitGatewayNetworkInterfaceIdList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  TransitGatewayNetworkInterfaceIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (TransitGatewayNetworkInterfaceIdList.to_query
                     v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (TransitGatewayNetworkInterfaceIdList.to_json
                  v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (TransitGatewayNetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DetachVolumeRequest =
  struct
    type t =
      {
      device: String.t option ;
      force: Boolean.t option ;
      instance_id: String.t option ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ?device  ?force  ?instance_id  ~volume_id  ?dry_run  () =
      { device; force; instance_id; volume_id; dry_run }
    let parse xml =
      Some
        {
          device = (Util.option_bind (Xml.member "Device" xml) String.parse);
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.force
             (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.device
             (fun f -> Query.Pair ("Device", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.device (fun f -> ("device", (String.to_json f)))])
    let of_json j =
      {
        device = (Util.option_map (Json.lookup j "device") String.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetManagedPrefixListAssociationsResult =
  struct
    type t =
      {
      prefix_list_associations: PrefixListAssociationSet.t ;
      next_token: String.t option }
    let make ?(prefix_list_associations= [])  ?next_token  () =
      { prefix_list_associations; next_token }
    let parse xml =
      Some
        {
          prefix_list_associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "prefixListAssociationSet" xml)
                  PrefixListAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PrefixListAssociationSet",
                  (PrefixListAssociationSet.to_query
                     v.prefix_list_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("prefix_list_associations",
               (PrefixListAssociationSet.to_json v.prefix_list_associations))])
    let of_json j =
      {
        prefix_list_associations =
          (PrefixListAssociationSet.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeAddressesResult =
  struct
    type t = {
      addresses: AddressList.t }
    let make ?(addresses= [])  () = { addresses }
    let parse xml =
      Some
        {
          addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "addressesSet" xml)
                  AddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AddressesSet", (AddressList.to_query v.addresses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("addresses", (AddressList.to_json v.addresses))])
    let of_json j =
      {
        addresses =
          (AddressList.of_json
             (Util.of_option_exn (Json.lookup j "addresses")))
      }
  end
module DescribeInstanceTypesResult =
  struct
    type t =
      {
      instance_types: InstanceTypeInfoList.t ;
      next_token: String.t option }
    let make ?(instance_types= [])  ?next_token  () =
      { instance_types; next_token }
    let parse xml =
      Some
        {
          instance_types =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceTypeSet" xml)
                  InstanceTypeInfoList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceTypeSet",
                  (InstanceTypeInfoList.to_query v.instance_types)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("instance_types",
               (InstanceTypeInfoList.to_json v.instance_types))])
    let of_json j =
      {
        instance_types =
          (InstanceTypeInfoList.of_json
             (Util.of_option_exn (Json.lookup j "instance_types")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateNatGatewayRequest =
  struct
    type t =
      {
      allocation_id: String.t ;
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      subnet_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ~allocation_id  ?client_token  ?dry_run  ~subnet_id 
      ?(tag_specifications= [])  () =
      { allocation_id; client_token; dry_run; subnet_id; tag_specifications }
    let parse xml =
      Some
        {
          allocation_id =
            (Xml.required "AllocationId"
               (Util.option_bind (Xml.member "AllocationId" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair ("AllocationId", (String.to_query v.allocation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("allocation_id", (String.to_json v.allocation_id))])
    let of_json j =
      {
        allocation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "allocation_id")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module CreateSubnetResult =
  struct
    type t = {
      subnet: Subnet.t option }
    let make ?subnet  () = { subnet }
    let parse xml =
      Some
        { subnet = (Util.option_bind (Xml.member "subnet" xml) Subnet.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> Query.Pair ("Subnet", (Subnet.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet
              (fun f -> ("subnet", (Subnet.to_json f)))])
    let of_json j =
      { subnet = (Util.option_map (Json.lookup j "subnet") Subnet.of_json) }
  end
module DescribeClientVpnRoutesResult =
  struct
    type t = {
      routes: ClientVpnRouteSet.t ;
      next_token: String.t option }
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routes" xml)
                  ClientVpnRouteSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("Routes", (ClientVpnRouteSet.to_query v.routes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (ClientVpnRouteSet.to_json v.routes))])
    let of_json j =
      {
        routes =
          (ClientVpnRouteSet.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceCapacityReservationAttributesRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      capacity_reservation_specification: CapacityReservationSpecification.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~capacity_reservation_specification  ?dry_run  ()
      = { instance_id; capacity_reservation_specification; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          capacity_reservation_specification =
            (Xml.required "CapacityReservationSpecification"
               (Util.option_bind
                  (Xml.member "CapacityReservationSpecification" xml)
                  CapacityReservationSpecification.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationSpecification",
                  (CapacityReservationSpecification.to_query
                     v.capacity_reservation_specification)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("capacity_reservation_specification",
               (CapacityReservationSpecification.to_json
                  v.capacity_reservation_specification));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        capacity_reservation_specification =
          (CapacityReservationSpecification.of_json
             (Util.of_option_exn
                (Json.lookup j "capacity_reservation_specification")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ApplySecurityGroupsToClientVpnTargetNetworkResult =
  struct
    type t = {
      security_group_ids: ClientVpnSecurityGroupIdSet.t }
    let make ?(security_group_ids= [])  () = { security_group_ids }
    let parse xml =
      Some
        {
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupIds" xml)
                  ClientVpnSecurityGroupIdSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SecurityGroupIds",
                   (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("security_group_ids",
                (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids))])
    let of_json j =
      {
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")))
      }
  end
module DescribeVpnConnectionsResult =
  struct
    type t = {
      vpn_connections: VpnConnectionList.t }
    let make ?(vpn_connections= [])  () = { vpn_connections }
    let parse xml =
      Some
        {
          vpn_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpnConnectionSet" xml)
                  VpnConnectionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionSet",
                   (VpnConnectionList.to_query v.vpn_connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpn_connections",
                (VpnConnectionList.to_json v.vpn_connections))])
    let of_json j =
      {
        vpn_connections =
          (VpnConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connections")))
      }
  end
module AssociateSubnetCidrBlockRequest =
  struct
    type t = {
      ipv6_cidr_block: String.t ;
      subnet_id: String.t }
    let make ~ipv6_cidr_block  ~subnet_id  () =
      { ipv6_cidr_block; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block =
            (Xml.required "ipv6CidrBlock"
               (Util.option_bind (Xml.member "ipv6CidrBlock" xml)
                  String.parse));
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some
             (Query.Pair
                ("Ipv6CidrBlock", (String.to_query v.ipv6_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("subnet_id", (String.to_json v.subnet_id));
           Some ("ipv6_cidr_block", (String.to_json v.ipv6_cidr_block))])
    let of_json j =
      {
        ipv6_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_cidr_block")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")))
      }
  end
module GetHostReservationPurchasePreviewRequest =
  struct
    type t = {
      host_id_set: RequestHostIdSet.t ;
      offering_id: String.t }
    let make ~host_id_set  ~offering_id  () = { host_id_set; offering_id }
    let parse xml =
      Some
        {
          host_id_set =
            (Xml.required "HostIdSet"
               (Util.option_bind (Xml.member "HostIdSet" xml)
                  RequestHostIdSet.parse));
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Some
             (Query.Pair
                ("HostIdSet", (RequestHostIdSet.to_query v.host_id_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_id", (String.to_json v.offering_id));
           Some ("host_id_set", (RequestHostIdSet.to_json v.host_id_set))])
    let of_json j =
      {
        host_id_set =
          (RequestHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")))
      }
  end
module DeleteVpcEndpointConnectionNotificationsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AcceptTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module ModifyIdentityIdFormatRequest =
  struct
    type t =
      {
      principal_arn: String.t ;
      resource: String.t ;
      use_long_ids: Boolean.t }
    let make ~principal_arn  ~resource  ~use_long_ids  () =
      { principal_arn; resource; use_long_ids }
    let parse xml =
      Some
        {
          principal_arn =
            (Xml.required "principalArn"
               (Util.option_bind (Xml.member "principalArn" xml) String.parse));
          resource =
            (Xml.required "resource"
               (Util.option_bind (Xml.member "resource" xml) String.parse));
          use_long_ids =
            (Xml.required "useLongIds"
               (Util.option_bind (Xml.member "useLongIds" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UseLongIds", (Boolean.to_query v.use_long_ids)));
           Some (Query.Pair ("Resource", (String.to_query v.resource)));
           Some
             (Query.Pair ("PrincipalArn", (String.to_query v.principal_arn)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("use_long_ids", (Boolean.to_json v.use_long_ids));
           Some ("resource", (String.to_json v.resource));
           Some ("principal_arn", (String.to_json v.principal_arn))])
    let of_json j =
      {
        principal_arn =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "principal_arn")));
        resource =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource")));
        use_long_ids =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "use_long_ids")))
      }
  end
module CreateLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option }
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association")
             LocalGatewayRouteTableVpcAssociation.of_json)
      }
  end
module ModifyClientVpnEndpointRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      server_certificate_arn: String.t option ;
      connection_log_options: ConnectionLogOptions.t option ;
      dns_servers: DnsServersOptionsModifyStructure.t option ;
      vpn_port: Integer.t option ;
      description: String.t option ;
      split_tunnel: Boolean.t option ;
      dry_run: Boolean.t option ;
      security_group_ids: ClientVpnSecurityGroupIdSet.t ;
      vpc_id: String.t option ;
      self_service_portal: SelfServicePortal.t option ;
      client_connect_options: ClientConnectOptions.t option }
    let make ~client_vpn_endpoint_id  ?server_certificate_arn 
      ?connection_log_options  ?dns_servers  ?vpn_port  ?description 
      ?split_tunnel  ?dry_run  ?(security_group_ids= [])  ?vpc_id 
      ?self_service_portal  ?client_connect_options  () =
      {
        client_vpn_endpoint_id;
        server_certificate_arn;
        connection_log_options;
        dns_servers;
        vpn_port;
        description;
        split_tunnel;
        dry_run;
        security_group_ids;
        vpc_id;
        self_service_portal;
        client_connect_options
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          server_certificate_arn =
            (Util.option_bind (Xml.member "ServerCertificateArn" xml)
               String.parse);
          connection_log_options =
            (Util.option_bind (Xml.member "ConnectionLogOptions" xml)
               ConnectionLogOptions.parse);
          dns_servers =
            (Util.option_bind (Xml.member "DnsServers" xml)
               DnsServersOptionsModifyStructure.parse);
          vpn_port =
            (Util.option_bind (Xml.member "VpnPort" xml) Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          split_tunnel =
            (Util.option_bind (Xml.member "SplitTunnel" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ClientVpnSecurityGroupIdSet.parse));
          vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse);
          self_service_portal =
            (Util.option_bind (Xml.member "SelfServicePortal" xml)
               SelfServicePortal.parse);
          client_connect_options =
            (Util.option_bind (Xml.member "ClientConnectOptions" xml)
               ClientConnectOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 Query.Pair
                   ("ClientConnectOptions",
                     (ClientConnectOptions.to_query f)));
           Util.option_map v.self_service_portal
             (fun f ->
                Query.Pair
                  ("SelfServicePortal", (SelfServicePortal.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.split_tunnel
             (fun f -> Query.Pair ("SplitTunnel", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.vpn_port
             (fun f -> Query.Pair ("VpnPort", (Integer.to_query f)));
           Util.option_map v.dns_servers
             (fun f ->
                Query.Pair
                  ("DnsServers",
                    (DnsServersOptionsModifyStructure.to_query f)));
           Util.option_map v.connection_log_options
             (fun f ->
                Query.Pair
                  ("ConnectionLogOptions", (ConnectionLogOptions.to_query f)));
           Util.option_map v.server_certificate_arn
             (fun f ->
                Query.Pair ("ServerCertificateArn", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_connect_options
              (fun f ->
                 ("client_connect_options", (ClientConnectOptions.to_json f)));
           Util.option_map v.self_service_portal
             (fun f -> ("self_service_portal", (SelfServicePortal.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some
             ("security_group_ids",
               (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.split_tunnel
             (fun f -> ("split_tunnel", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.vpn_port
             (fun f -> ("vpn_port", (Integer.to_json f)));
           Util.option_map v.dns_servers
             (fun f ->
                ("dns_servers", (DnsServersOptionsModifyStructure.to_json f)));
           Util.option_map v.connection_log_options
             (fun f ->
                ("connection_log_options", (ConnectionLogOptions.to_json f)));
           Util.option_map v.server_certificate_arn
             (fun f -> ("server_certificate_arn", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        server_certificate_arn =
          (Util.option_map (Json.lookup j "server_certificate_arn")
             String.of_json);
        connection_log_options =
          (Util.option_map (Json.lookup j "connection_log_options")
             ConnectionLogOptions.of_json);
        dns_servers =
          (Util.option_map (Json.lookup j "dns_servers")
             DnsServersOptionsModifyStructure.of_json);
        vpn_port =
          (Util.option_map (Json.lookup j "vpn_port") Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        split_tunnel =
          (Util.option_map (Json.lookup j "split_tunnel") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        self_service_portal =
          (Util.option_map (Json.lookup j "self_service_portal")
             SelfServicePortal.of_json);
        client_connect_options =
          (Util.option_map (Json.lookup j "client_connect_options")
             ClientConnectOptions.of_json)
      }
  end
module GetPasswordDataResult =
  struct
    type t =
      {
      instance_id: String.t ;
      password_data: String.t ;
      timestamp: DateTime.t }
    let make ~instance_id  ~password_data  ~timestamp  () =
      { instance_id; password_data; timestamp }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          password_data =
            (Xml.required "passwordData"
               (Util.option_bind (Xml.member "passwordData" xml) String.parse));
          timestamp =
            (Xml.required "timestamp"
               (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Timestamp", (DateTime.to_query v.timestamp)));
           Some
             (Query.Pair ("PasswordData", (String.to_query v.password_data)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("timestamp", (DateTime.to_json v.timestamp));
           Some ("password_data", (String.to_json v.password_data));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        password_data =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "password_data")));
        timestamp =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "timestamp")))
      }
  end
module DescribeClientVpnTargetNetworksResult =
  struct
    type t =
      {
      client_vpn_target_networks: TargetNetworkSet.t ;
      next_token: String.t option }
    let make ?(client_vpn_target_networks= [])  ?next_token  () =
      { client_vpn_target_networks; next_token }
    let parse xml =
      Some
        {
          client_vpn_target_networks =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnTargetNetworks" xml)
                  TargetNetworkSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnTargetNetworks",
                  (TargetNetworkSet.to_query v.client_vpn_target_networks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_target_networks",
               (TargetNetworkSet.to_json v.client_vpn_target_networks))])
    let of_json j =
      {
        client_vpn_target_networks =
          (TargetNetworkSet.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_target_networks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTransitGatewayPrefixListReferenceRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      prefix_list_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~prefix_list_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        prefix_list_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeRegionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      region_names: RegionNameStringList.t ;
      dry_run: Boolean.t option ;
      all_regions: Boolean.t option }
    let make ?(filters= [])  ?(region_names= [])  ?dry_run  ?all_regions  ()
      = { filters; region_names; dry_run; all_regions }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          region_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "RegionName" xml)
                  RegionNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          all_regions =
            (Util.option_bind (Xml.member "AllRegions" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.all_regions
              (fun f -> Query.Pair ("AllRegions", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RegionName",
                  (RegionNameStringList.to_query v.region_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.all_regions
              (fun f -> ("all_regions", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("region_names", (RegionNameStringList.to_json v.region_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        region_names =
          (RegionNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "region_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        all_regions =
          (Util.option_map (Json.lookup j "all_regions") Boolean.of_json)
      }
  end
module DescribeVpcEndpointServicePermissionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ~service_id  ?(filters= [])  ?max_results  ?next_token
       () = { dry_run; service_id; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointServicePermissionsResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module ModifySubnetAttributeRequest =
  struct
    type t =
      {
      assign_ipv6_address_on_creation: AttributeBooleanValue.t option ;
      map_public_ip_on_launch: AttributeBooleanValue.t option ;
      subnet_id: String.t ;
      map_customer_owned_ip_on_launch: AttributeBooleanValue.t option ;
      customer_owned_ipv4_pool: String.t option }
    let make ?assign_ipv6_address_on_creation  ?map_public_ip_on_launch 
      ~subnet_id  ?map_customer_owned_ip_on_launch  ?customer_owned_ipv4_pool
       () =
      {
        assign_ipv6_address_on_creation;
        map_public_ip_on_launch;
        subnet_id;
        map_customer_owned_ip_on_launch;
        customer_owned_ipv4_pool
      }
    let parse xml =
      Some
        {
          assign_ipv6_address_on_creation =
            (Util.option_bind (Xml.member "AssignIpv6AddressOnCreation" xml)
               AttributeBooleanValue.parse);
          map_public_ip_on_launch =
            (Util.option_bind (Xml.member "MapPublicIpOnLaunch" xml)
               AttributeBooleanValue.parse);
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          map_customer_owned_ip_on_launch =
            (Util.option_bind (Xml.member "MapCustomerOwnedIpOnLaunch" xml)
               AttributeBooleanValue.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "CustomerOwnedIpv4Pool" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f ->
                 Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.map_customer_owned_ip_on_launch
             (fun f ->
                Query.Pair
                  ("MapCustomerOwnedIpOnLaunch",
                    (AttributeBooleanValue.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.map_public_ip_on_launch
             (fun f ->
                Query.Pair
                  ("MapPublicIpOnLaunch", (AttributeBooleanValue.to_query f)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                Query.Pair
                  ("AssignIpv6AddressOnCreation",
                    (AttributeBooleanValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.customer_owned_ipv4_pool
              (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.map_customer_owned_ip_on_launch
             (fun f ->
                ("map_customer_owned_ip_on_launch",
                  (AttributeBooleanValue.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.map_public_ip_on_launch
             (fun f ->
                ("map_public_ip_on_launch",
                  (AttributeBooleanValue.to_json f)));
           Util.option_map v.assign_ipv6_address_on_creation
             (fun f ->
                ("assign_ipv6_address_on_creation",
                  (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        assign_ipv6_address_on_creation =
          (Util.option_map (Json.lookup j "assign_ipv6_address_on_creation")
             AttributeBooleanValue.of_json);
        map_public_ip_on_launch =
          (Util.option_map (Json.lookup j "map_public_ip_on_launch")
             AttributeBooleanValue.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        map_customer_owned_ip_on_launch =
          (Util.option_map (Json.lookup j "map_customer_owned_ip_on_launch")
             AttributeBooleanValue.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json)
      }
  end
module DisableFastSnapshotRestoresRequest =
  struct
    type t =
      {
      availability_zones: AvailabilityZoneStringList.t ;
      source_snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~availability_zones  ~source_snapshot_ids  ?dry_run  () =
      { availability_zones; source_snapshot_ids; dry_run }
    let parse xml =
      Some
        {
          availability_zones =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  AvailabilityZoneStringList.parse));
          source_snapshot_ids =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SourceSnapshotId",
                  (SnapshotIdStringList.to_query v.source_snapshot_ids)));
           Some
             (Query.Pair
                ("AvailabilityZone",
                  (AvailabilityZoneStringList.to_query v.availability_zones)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("source_snapshot_ids",
               (SnapshotIdStringList.to_json v.source_snapshot_ids));
           Some
             ("availability_zones",
               (AvailabilityZoneStringList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneStringList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")));
        source_snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportInstanceResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module RegisterImageRequest =
  struct
    type t =
      {
      image_location: String.t option ;
      architecture: ArchitectureValues.t option ;
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      ena_support: Boolean.t option ;
      kernel_id: String.t option ;
      name: String.t ;
      billing_products: BillingProductList.t ;
      ramdisk_id: String.t option ;
      root_device_name: String.t option ;
      sriov_net_support: String.t option ;
      virtualization_type: String.t option }
    let make ?image_location  ?architecture  ?(block_device_mappings= []) 
      ?description  ?dry_run  ?ena_support  ?kernel_id  ~name 
      ?(billing_products= [])  ?ramdisk_id  ?root_device_name 
      ?sriov_net_support  ?virtualization_type  () =
      {
        image_location;
        architecture;
        block_device_mappings;
        description;
        dry_run;
        ena_support;
        kernel_id;
        name;
        billing_products;
        ramdisk_id;
        root_device_name;
        sriov_net_support;
        virtualization_type
      }
    let parse xml =
      Some
        {
          image_location =
            (Util.option_bind (Xml.member "ImageLocation" xml) String.parse);
          architecture =
            (Util.option_bind (Xml.member "architecture" xml)
               ArchitectureValues.parse);
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml) Boolean.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernelId" xml) String.parse);
          name =
            (Xml.required "name"
               (Util.option_bind (Xml.member "name" xml) String.parse));
          billing_products =
            (Util.of_option []
               (Util.option_bind (Xml.member "BillingProduct" xml)
                  BillingProductList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdiskId" xml) String.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml) String.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml) String.parse);
          virtualization_type =
            (Util.option_bind (Xml.member "virtualizationType" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.virtualization_type
              (fun f ->
                 Query.Pair ("VirtualizationType", (String.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f -> Query.Pair ("SriovNetSupport", (String.to_query f)));
           Util.option_map v.root_device_name
             (fun f -> Query.Pair ("RootDeviceName", (String.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Some
             (Query.Pair
                ("BillingProduct",
                  (BillingProductList.to_query v.billing_products)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Util.option_map v.ena_support
             (fun f -> Query.Pair ("EnaSupport", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)));
           Util.option_map v.architecture
             (fun f ->
                Query.Pair ("Architecture", (ArchitectureValues.to_query f)));
           Util.option_map v.image_location
             (fun f -> Query.Pair ("ImageLocation", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.virtualization_type
              (fun f -> ("virtualization_type", (String.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (String.to_json f)));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (String.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Some
             ("billing_products",
               (BillingProductList.to_json v.billing_products));
           Some ("name", (String.to_json v.name));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings));
           Util.option_map v.architecture
             (fun f -> ("architecture", (ArchitectureValues.to_json f)));
           Util.option_map v.image_location
             (fun f -> ("image_location", (String.to_json f)))])
    let of_json j =
      {
        image_location =
          (Util.option_map (Json.lookup j "image_location") String.of_json);
        architecture =
          (Util.option_map (Json.lookup j "architecture")
             ArchitectureValues.of_json);
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support") Boolean.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        billing_products =
          (BillingProductList.of_json
             (Util.of_option_exn (Json.lookup j "billing_products")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name") String.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support") String.of_json);
        virtualization_type =
          (Util.option_map (Json.lookup j "virtualization_type")
             String.of_json)
      }
  end
module CreateSecurityGroupRequest =
  struct
    type t =
      {
      description: String.t ;
      group_name: String.t ;
      vpc_id: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~description  ~group_name  ?vpc_id  ?(tag_specifications= []) 
      ?dry_run  () =
      { description; group_name; vpc_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          description =
            (Xml.required "GroupDescription"
               (Util.option_bind (Xml.member "GroupDescription" xml)
                  String.parse));
          group_name =
            (Xml.required "GroupName"
               (Util.option_bind (Xml.member "GroupName" xml) String.parse));
          vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)));
           Some
             (Query.Pair
                ("GroupDescription", (String.to_query v.description)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Some ("group_name", (String.to_json v.group_name));
           Some ("description", (String.to_json v.description))])
    let of_json j =
      {
        description =
          (String.of_json (Util.of_option_exn (Json.lookup j "description")));
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceEventNotificationAttributesRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableVpcClassicLinkDnsSupportRequest =
  struct
    type t = {
      vpc_id: String.t option }
    let make ?vpc_id  () = { vpc_id }
    let parse xml =
      Some
        { vpc_id = (Util.option_bind (Xml.member "VpcId" xml) String.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_id
              (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      { vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json) }
  end
module DescribeVpcPeeringConnectionsResult =
  struct
    type t =
      {
      vpc_peering_connections: VpcPeeringConnectionList.t ;
      next_token: String.t option }
    let make ?(vpc_peering_connections= [])  ?next_token  () =
      { vpc_peering_connections; next_token }
    let parse xml =
      Some
        {
          vpc_peering_connections =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcPeeringConnectionSet" xml)
                  VpcPeeringConnectionList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionSet",
                  (VpcPeeringConnectionList.to_query
                     v.vpc_peering_connections)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_peering_connections",
               (VpcPeeringConnectionList.to_json v.vpc_peering_connections))])
    let of_json j =
      {
        vpc_peering_connections =
          (VpcPeeringConnectionList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connections")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkAclsResult =
  struct
    type t = {
      network_acls: NetworkAclList.t ;
      next_token: String.t option }
    let make ?(network_acls= [])  ?next_token  () =
      { network_acls; next_token }
    let parse xml =
      Some
        {
          network_acls =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkAclSet" xml)
                  NetworkAclList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkAclSet", (NetworkAclList.to_query v.network_acls)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("network_acls", (NetworkAclList.to_json v.network_acls))])
    let of_json j =
      {
        network_acls =
          (NetworkAclList.of_json
             (Util.of_option_exn (Json.lookup j "network_acls")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTrafficMirrorTargetResult =
  struct
    type t = {
      traffic_mirror_target_id: String.t option }
    let make ?traffic_mirror_target_id  () = { traffic_mirror_target_id }
    let parse xml =
      Some
        {
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "trafficMirrorTargetId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f ->
                 Query.Pair ("TrafficMirrorTargetId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_target_id
              (fun f -> ("traffic_mirror_target_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json)
      }
  end
module DeleteTrafficMirrorFilterRequest =
  struct
    type t = {
      traffic_mirror_filter_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_id  ?dry_run  () =
      { traffic_mirror_filter_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsResult =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_associations:
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.t ;
      next_token: String.t option }
    let make
      ?(local_gateway_route_table_virtual_interface_group_associations= []) 
      ?next_token  () =
      {
        local_gateway_route_table_virtual_interface_group_associations;
        next_token
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member
                     "localGatewayRouteTableVirtualInterfaceGroupAssociationSet"
                     xml)
                  LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet",
                  (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_query
                     v.local_gateway_route_table_virtual_interface_group_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_route_table_virtual_interface_group_associations",
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.to_json
                  v.local_gateway_route_table_virtual_interface_group_associations))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_associations =
          (LocalGatewayRouteTableVirtualInterfaceGroupAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_virtual_interface_group_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateEnclaveCertificateIamRoleRequest =
  struct
    type t =
      {
      certificate_arn: String.t option ;
      role_arn: String.t option ;
      dry_run: Boolean.t option }
    let make ?certificate_arn  ?role_arn  ?dry_run  () =
      { certificate_arn; role_arn; dry_run }
    let parse xml =
      Some
        {
          certificate_arn =
            (Util.option_bind (Xml.member "CertificateArn" xml) String.parse);
          role_arn =
            (Util.option_bind (Xml.member "RoleArn" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.role_arn
             (fun f -> Query.Pair ("RoleArn", (String.to_query f)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.role_arn
             (fun f -> ("role_arn", (String.to_json f)));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)))])
    let of_json j =
      {
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        role_arn =
          (Util.option_map (Json.lookup j "role_arn") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeManagedPrefixListsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      prefix_list_ids: ValueStringList.t }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token 
      ?(prefix_list_ids= [])  () =
      { dry_run; filters; max_results; next_token; prefix_list_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrefixListId" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListId",
                   (ValueStringList.to_query v.prefix_list_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("prefix_list_ids",
                (ValueStringList.to_json v.prefix_list_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_list_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")))
      }
  end
module EnableEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module PurchaseHostReservationRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      currency_code: CurrencyCodeValues.t option ;
      host_id_set: RequestHostIdSet.t ;
      limit_price: String.t option ;
      offering_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?client_token  ?currency_code  ~host_id_set  ?limit_price 
      ~offering_id  ?(tag_specifications= [])  () =
      {
        client_token;
        currency_code;
        host_id_set;
        limit_price;
        offering_id;
        tag_specifications
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          currency_code =
            (Util.option_bind (Xml.member "CurrencyCode" xml)
               CurrencyCodeValues.parse);
          host_id_set =
            (Xml.required "HostIdSet"
               (Util.option_bind (Xml.member "HostIdSet" xml)
                  RequestHostIdSet.parse));
          limit_price =
            (Util.option_bind (Xml.member "LimitPrice" xml) String.parse);
          offering_id =
            (Xml.required "OfferingId"
               (Util.option_bind (Xml.member "OfferingId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("OfferingId", (String.to_query v.offering_id)));
           Util.option_map v.limit_price
             (fun f -> Query.Pair ("LimitPrice", (String.to_query f)));
           Some
             (Query.Pair
                ("HostIdSet", (RequestHostIdSet.to_query v.host_id_set)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("offering_id", (String.to_json v.offering_id));
           Util.option_map v.limit_price
             (fun f -> ("limit_price", (String.to_json f)));
           Some ("host_id_set", (RequestHostIdSet.to_json v.host_id_set));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        host_id_set =
          (RequestHostIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_id_set")));
        limit_price =
          (Util.option_map (Json.lookup j "limit_price") String.of_json);
        offering_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "offering_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module CancelConversionRequest =
  struct
    type t =
      {
      conversion_task_id: String.t ;
      dry_run: Boolean.t option ;
      reason_message: String.t option }
    let make ~conversion_task_id  ?dry_run  ?reason_message  () =
      { conversion_task_id; dry_run; reason_message }
    let parse xml =
      Some
        {
          conversion_task_id =
            (Xml.required "conversionTaskId"
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          reason_message =
            (Util.option_bind (Xml.member "reasonMessage" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> Query.Pair ("ReasonMessage", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId", (String.to_query v.conversion_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reason_message
              (fun f -> ("reason_message", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("conversion_task_id", (String.to_json v.conversion_task_id))])
    let of_json j =
      {
        conversion_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reason_message =
          (Util.option_map (Json.lookup j "reason_message") String.of_json)
      }
  end
module AssociateClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      subnet_id: String.t ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~subnet_id  ?client_token  ?dry_run  ()
      = { client_vpn_endpoint_id; subnet_id; client_token; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AttachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeFleetHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      event_type: FleetEventType.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_id: String.t ;
      start_time: DateTime.t }
    let make ?dry_run  ?event_type  ?max_results  ?next_token  ~fleet_id 
      ~start_time  () =
      { dry_run; event_type; max_results; next_token; fleet_id; start_time }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          event_type =
            (Util.option_bind (Xml.member "EventType" xml)
               FleetEventType.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          start_time =
            (Xml.required "StartTime"
               (Util.option_bind (Xml.member "StartTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (FleetEventType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("start_time", (DateTime.to_json v.start_time));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (FleetEventType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type")
             FleetEventType.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")))
      }
  end
module DescribeFleetsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_ids: FleetIdSet.t ;
      filters: FilterList.t }
    let make ?dry_run  ?max_results  ?next_token  ?(fleet_ids= []) 
      ?(filters= [])  () =
      { dry_run; max_results; next_token; fleet_ids; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FleetId" xml) FleetIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("FleetId", (FleetIdSet.to_query v.fleet_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("fleet_ids", (FleetIdSet.to_json v.fleet_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_ids =
          (FleetIdSet.of_json
             (Util.of_option_exn (Json.lookup j "fleet_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeLaunchTemplatesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_ids: LaunchTemplateIdStringList.t ;
      launch_template_names: LaunchTemplateNameStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(launch_template_ids= [])  ?(launch_template_names=
      [])  ?(filters= [])  ?next_token  ?max_results  () =
      {
        dry_run;
        launch_template_ids;
        launch_template_names;
        filters;
        next_token;
        max_results
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateId" xml)
                  LaunchTemplateIdStringList.parse));
          launch_template_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateName" xml)
                  LaunchTemplateNameStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LaunchTemplateName",
                  (LaunchTemplateNameStringList.to_query
                     v.launch_template_names)));
           Some
             (Query.Pair
                ("LaunchTemplateId",
                  (LaunchTemplateIdStringList.to_query v.launch_template_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("launch_template_names",
               (LaunchTemplateNameStringList.to_json v.launch_template_names));
           Some
             ("launch_template_ids",
               (LaunchTemplateIdStringList.to_json v.launch_template_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_ids =
          (LaunchTemplateIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_ids")));
        launch_template_names =
          (LaunchTemplateNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_names")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CancelSpotFleetRequestsResponse =
  struct
    type t =
      {
      successful_fleet_requests: CancelSpotFleetRequestsSuccessSet.t ;
      unsuccessful_fleet_requests: CancelSpotFleetRequestsErrorSet.t }
    let make ?(successful_fleet_requests= [])  ?(unsuccessful_fleet_requests=
      [])  () = { successful_fleet_requests; unsuccessful_fleet_requests }
    let parse xml =
      Some
        {
          successful_fleet_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "successfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsSuccessSet.parse));
          unsuccessful_fleet_requests =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulFleetRequestSet" xml)
                  CancelSpotFleetRequestsErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulFleetRequestSet",
                   (CancelSpotFleetRequestsErrorSet.to_query
                      v.unsuccessful_fleet_requests)));
           Some
             (Query.Pair
                ("SuccessfulFleetRequestSet",
                  (CancelSpotFleetRequestsSuccessSet.to_query
                     v.successful_fleet_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_fleet_requests",
                (CancelSpotFleetRequestsErrorSet.to_json
                   v.unsuccessful_fleet_requests));
           Some
             ("successful_fleet_requests",
               (CancelSpotFleetRequestsSuccessSet.to_json
                  v.successful_fleet_requests))])
    let of_json j =
      {
        successful_fleet_requests =
          (CancelSpotFleetRequestsSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful_fleet_requests")));
        unsuccessful_fleet_requests =
          (CancelSpotFleetRequestsErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_fleet_requests")))
      }
  end
module CreateSnapshotRequest =
  struct
    type t =
      {
      description: String.t option ;
      volume_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ~volume_id  ?(tag_specifications= [])  ?dry_run 
      () = { description; volume_id; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAccountAttributesResult =
  struct
    type t = {
      account_attributes: AccountAttributeList.t }
    let make ?(account_attributes= [])  () = { account_attributes }
    let parse xml =
      Some
        {
          account_attributes =
            (Util.of_option []
               (Util.option_bind (Xml.member "accountAttributeSet" xml)
                  AccountAttributeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AccountAttributeSet",
                   (AccountAttributeList.to_query v.account_attributes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("account_attributes",
                (AccountAttributeList.to_json v.account_attributes))])
    let of_json j =
      {
        account_attributes =
          (AccountAttributeList.of_json
             (Util.of_option_exn (Json.lookup j "account_attributes")))
      }
  end
module CreateTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module ReplaceRouteTableAssociationResult =
  struct
    type t =
      {
      new_association_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?new_association_id  ?association_state  () =
      { new_association_id; association_state }
    let parse xml =
      Some
        {
          new_association_id =
            (Util.option_bind (Xml.member "newAssociationId" xml)
               String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.new_association_id
             (fun f -> Query.Pair ("NewAssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.new_association_id
             (fun f -> ("new_association_id", (String.to_json f)))])
    let of_json j =
      {
        new_association_id =
          (Util.option_map (Json.lookup j "new_association_id")
             String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module GetCapacityReservationUsageRequest =
  struct
    type t =
      {
      capacity_reservation_id: String.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?next_token  ?max_results  ?dry_run 
      () = { capacity_reservation_id; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVolumeStatusRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      volume_ids: VolumeIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?(volume_ids= []) 
      ?dry_run  () =
      { filters; max_results; next_token; volume_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAggregateIdFormatRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetAssociatedIpv6PoolCidrsRequest =
  struct
    type t =
      {
      pool_id: String.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~pool_id  ?next_token  ?max_results  ?dry_run  () =
      { pool_id; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          pool_id =
            (Xml.required "PoolId"
               (Util.option_bind (Xml.member "PoolId" xml) String.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("PoolId", (String.to_query v.pool_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("pool_id", (String.to_json v.pool_id))])
    let of_json j =
      {
        pool_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "pool_id")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateLocalGatewayRouteResult =
  struct
    type t = {
      route: LocalGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route") LocalGatewayRoute.of_json)
      }
  end
module DeleteTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ?(tags= [])  () =
      { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "resourceId"
               (Util.option_bind (Xml.member "resourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DeregisterInstanceEventNotificationAttributesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_tag_attribute: DeregisterInstanceTagAttributeRequest.t option }
    let make ?dry_run  ?instance_tag_attribute  () =
      { dry_run; instance_tag_attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_tag_attribute =
            (Util.option_bind (Xml.member "InstanceTagAttribute" xml)
               DeregisterInstanceTagAttributeRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 Query.Pair
                   ("InstanceTagAttribute",
                     (DeregisterInstanceTagAttributeRequest.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 ("instance_tag_attribute",
                   (DeregisterInstanceTagAttributeRequest.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tag_attribute =
          (Util.option_map (Json.lookup j "instance_tag_attribute")
             DeregisterInstanceTagAttributeRequest.of_json)
      }
  end
module ModifyVpcPeeringConnectionOptionsResult =
  struct
    type t =
      {
      accepter_peering_connection_options: PeeringConnectionOptions.t option ;
      requester_peering_connection_options: PeeringConnectionOptions.t option }
    let make ?accepter_peering_connection_options 
      ?requester_peering_connection_options  () =
      {
        accepter_peering_connection_options;
        requester_peering_connection_options
      }
    let parse xml =
      Some
        {
          accepter_peering_connection_options =
            (Util.option_bind
               (Xml.member "accepterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse);
          requester_peering_connection_options =
            (Util.option_bind
               (Xml.member "requesterPeeringConnectionOptions" xml)
               PeeringConnectionOptions.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 Query.Pair
                   ("RequesterPeeringConnectionOptions",
                     (PeeringConnectionOptions.to_query f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                Query.Pair
                  ("AccepterPeeringConnectionOptions",
                    (PeeringConnectionOptions.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.requester_peering_connection_options
              (fun f ->
                 ("requester_peering_connection_options",
                   (PeeringConnectionOptions.to_json f)));
           Util.option_map v.accepter_peering_connection_options
             (fun f ->
                ("accepter_peering_connection_options",
                  (PeeringConnectionOptions.to_json f)))])
    let of_json j =
      {
        accepter_peering_connection_options =
          (Util.option_map
             (Json.lookup j "accepter_peering_connection_options")
             PeeringConnectionOptions.of_json);
        requester_peering_connection_options =
          (Util.option_map
             (Json.lookup j "requester_peering_connection_options")
             PeeringConnectionOptions.of_json)
      }
  end
module ImportClientVpnClientCertificateRevocationListRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      certificate_revocation_list: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~certificate_revocation_list  ?dry_run 
      () = { client_vpn_endpoint_id; certificate_revocation_list; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          certificate_revocation_list =
            (Xml.required "CertificateRevocationList"
               (Util.option_bind (Xml.member "CertificateRevocationList" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CertificateRevocationList",
                  (String.to_query v.certificate_revocation_list)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("certificate_revocation_list",
               (String.to_json v.certificate_revocation_list));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        certificate_revocation_list =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "certificate_revocation_list")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyTrafficMirrorFilterNetworkServicesRequest =
  struct
    type t =
      {
      traffic_mirror_filter_id: String.t ;
      add_network_services: TrafficMirrorNetworkServiceList.t ;
      remove_network_services: TrafficMirrorNetworkServiceList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_id  ?(add_network_services= []) 
      ?(remove_network_services= [])  ?dry_run  () =
      {
        traffic_mirror_filter_id;
        add_network_services;
        remove_network_services;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          add_network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddNetworkService" xml)
                  TrafficMirrorNetworkServiceList.parse));
          remove_network_services =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveNetworkService" xml)
                  TrafficMirrorNetworkServiceList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveNetworkService",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.remove_network_services)));
           Some
             (Query.Pair
                ("AddNetworkService",
                  (TrafficMirrorNetworkServiceList.to_query
                     v.add_network_services)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_network_services",
               (TrafficMirrorNetworkServiceList.to_json
                  v.remove_network_services));
           Some
             ("add_network_services",
               (TrafficMirrorNetworkServiceList.to_json
                  v.add_network_services));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id))])
    let of_json j =
      {
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        add_network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "add_network_services")));
        remove_network_services =
          (TrafficMirrorNetworkServiceList.of_json
             (Util.of_option_exn (Json.lookup j "remove_network_services")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      peer_owner_id: String.t option ;
      peer_vpc_id: String.t option ;
      vpc_id: String.t option ;
      peer_region: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?peer_owner_id  ?peer_vpc_id  ?vpc_id  ?peer_region 
      ?(tag_specifications= [])  () =
      {
        dry_run;
        peer_owner_id;
        peer_vpc_id;
        vpc_id;
        peer_region;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          peer_owner_id =
            (Util.option_bind (Xml.member "peerOwnerId" xml) String.parse);
          peer_vpc_id =
            (Util.option_bind (Xml.member "peerVpcId" xml) String.parse);
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          peer_region =
            (Util.option_bind (Xml.member "PeerRegion" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.peer_region
             (fun f -> Query.Pair ("PeerRegion", (String.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)));
           Util.option_map v.peer_vpc_id
             (fun f -> Query.Pair ("PeerVpcId", (String.to_query f)));
           Util.option_map v.peer_owner_id
             (fun f -> Query.Pair ("PeerOwnerId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.peer_region
             (fun f -> ("peer_region", (String.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)));
           Util.option_map v.peer_vpc_id
             (fun f -> ("peer_vpc_id", (String.to_json f)));
           Util.option_map v.peer_owner_id
             (fun f -> ("peer_owner_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        peer_owner_id =
          (Util.option_map (Json.lookup j "peer_owner_id") String.of_json);
        peer_vpc_id =
          (Util.option_map (Json.lookup j "peer_vpc_id") String.of_json);
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        peer_region =
          (Util.option_map (Json.lookup j "peer_region") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeVpcsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      vpc_ids: VpcIdStringList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?(vpc_ids= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { filters; vpc_ids; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcId" xml)
                  VpcIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (VpcIdStringList.to_query v.vpc_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_ids", (VpcIdStringList.to_json v.vpc_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        vpc_ids =
          (VpcIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module SendDiagnosticInterruptRequest =
  struct
    type t = {
      instance_id: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?dry_run  () = { instance_id; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RevokeClientVpnIngressResult =
  struct
    type t = {
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module DeleteTrafficMirrorFilterRuleResult =
  struct
    type t = {
      traffic_mirror_filter_rule_id: String.t option }
    let make ?traffic_mirror_filter_rule_id  () =
      { traffic_mirror_filter_rule_id }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Util.option_bind (Xml.member "trafficMirrorFilterRuleId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorFilterRuleId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_filter_rule_id
              (fun f -> ("traffic_mirror_filter_rule_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_rule_id")
             String.of_json)
      }
  end
module DescribeVpcClassicLinkDnsSupportRequest =
  struct
    type t =
      {
      max_results: Integer.t option ;
      next_token: String.t option ;
      vpc_ids: VpcClassicLinkIdList.t }
    let make ?max_results  ?next_token  ?(vpc_ids= [])  () =
      { max_results; next_token; vpc_ids }
    let parse xml =
      Some
        {
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          vpc_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcIds" xml)
                  VpcClassicLinkIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcIds", (VpcClassicLinkIdList.to_query v.vpc_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_ids", (VpcClassicLinkIdList.to_json v.vpc_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)))])
    let of_json j =
      {
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpc_ids =
          (VpcClassicLinkIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_ids")))
      }
  end
module ModifyDefaultCreditSpecificationResult =
  struct
    type t =
      {
      instance_family_credit_specification:
        InstanceFamilyCreditSpecification.t option }
    let make ?instance_family_credit_specification  () =
      { instance_family_credit_specification }
    let parse xml =
      Some
        {
          instance_family_credit_specification =
            (Util.option_bind
               (Xml.member "instanceFamilyCreditSpecification" xml)
               InstanceFamilyCreditSpecification.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 Query.Pair
                   ("InstanceFamilyCreditSpecification",
                     (InstanceFamilyCreditSpecification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family_credit_specification
              (fun f ->
                 ("instance_family_credit_specification",
                   (InstanceFamilyCreditSpecification.to_json f)))])
    let of_json j =
      {
        instance_family_credit_specification =
          (Util.option_map
             (Json.lookup j "instance_family_credit_specification")
             InstanceFamilyCreditSpecification.of_json)
      }
  end
module BundleInstanceRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      storage: Storage.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ~storage  ?dry_run  () =
      { instance_id; storage; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          storage =
            (Xml.required "Storage"
               (Util.option_bind (Xml.member "Storage" xml) Storage.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Storage", (Storage.to_query v.storage)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("storage", (Storage.to_json v.storage));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        storage =
          (Storage.of_json (Util.of_option_exn (Json.lookup j "storage")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayRequest =
  struct
    type t = {
      transit_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?dry_run  () =
      { transit_gateway_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportInstanceRequest =
  struct
    type t =
      {
      description: String.t option ;
      disk_images: DiskImageList.t ;
      dry_run: Boolean.t option ;
      launch_specification: ImportInstanceLaunchSpecification.t option ;
      platform: PlatformValues.t }
    let make ?description  ?(disk_images= [])  ?dry_run 
      ?launch_specification  ~platform  () =
      { description; disk_images; dry_run; launch_specification; platform }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          disk_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "diskImage" xml)
                  DiskImageList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          launch_specification =
            (Util.option_bind (Xml.member "launchSpecification" xml)
               ImportInstanceLaunchSpecification.parse);
          platform =
            (Xml.required "platform"
               (Util.option_bind (Xml.member "platform" xml)
                  PlatformValues.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Platform", (PlatformValues.to_query v.platform)));
           Util.option_map v.launch_specification
             (fun f ->
                Query.Pair
                  ("LaunchSpecification",
                    (ImportInstanceLaunchSpecification.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskImage", (DiskImageList.to_query v.disk_images)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("platform", (PlatformValues.to_json v.platform));
           Util.option_map v.launch_specification
             (fun f ->
                ("launch_specification",
                  (ImportInstanceLaunchSpecification.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("disk_images", (DiskImageList.to_json v.disk_images));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_images =
          (DiskImageList.of_json
             (Util.of_option_exn (Json.lookup j "disk_images")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_specification =
          (Util.option_map (Json.lookup j "launch_specification")
             ImportInstanceLaunchSpecification.of_json);
        platform =
          (PlatformValues.of_json
             (Util.of_option_exn (Json.lookup j "platform")))
      }
  end
module ImportVolumeRequest =
  struct
    type t =
      {
      availability_zone: String.t ;
      description: String.t option ;
      dry_run: Boolean.t option ;
      image: DiskImageDetail.t ;
      volume: VolumeDetail.t }
    let make ~availability_zone  ?description  ?dry_run  ~image  ~volume  ()
      = { availability_zone; description; dry_run; image; volume }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "availabilityZone"
               (Util.option_bind (Xml.member "availabilityZone" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          image =
            (Xml.required "image"
               (Util.option_bind (Xml.member "image" xml)
                  DiskImageDetail.parse));
          volume =
            (Xml.required "volume"
               (Util.option_bind (Xml.member "volume" xml) VolumeDetail.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Volume", (VolumeDetail.to_query v.volume)));
           Some (Query.Pair ("Image", (DiskImageDetail.to_query v.image)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume", (VolumeDetail.to_json v.volume));
           Some ("image", (DiskImageDetail.to_json v.image));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        image =
          (DiskImageDetail.of_json
             (Util.of_option_exn (Json.lookup j "image")));
        volume =
          (VolumeDetail.of_json (Util.of_option_exn (Json.lookup j "volume")))
      }
  end
module DescribeInstanceStatusRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option ;
      include_all_instances: Boolean.t option }
    let make ?(filters= [])  ?(instance_ids= [])  ?max_results  ?next_token 
      ?dry_run  ?include_all_instances  () =
      {
        filters;
        instance_ids;
        max_results;
        next_token;
        dry_run;
        include_all_instances
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          include_all_instances =
            (Util.option_bind (Xml.member "includeAllInstances" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f ->
                 Query.Pair ("IncludeAllInstances", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.include_all_instances
              (fun f -> ("include_all_instances", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        include_all_instances =
          (Util.option_map (Json.lookup j "include_all_instances")
             Boolean.of_json)
      }
  end
module ModifyClientVpnEndpointResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelImportTaskRequest =
  struct
    type t =
      {
      cancel_reason: String.t option ;
      dry_run: Boolean.t option ;
      import_task_id: String.t option }
    let make ?cancel_reason  ?dry_run  ?import_task_id  () =
      { cancel_reason; dry_run; import_task_id }
    let parse xml =
      Some
        {
          cancel_reason =
            (Util.option_bind (Xml.member "CancelReason" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          import_task_id =
            (Util.option_bind (Xml.member "ImportTaskId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.import_task_id
              (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cancel_reason
             (fun f -> Query.Pair ("CancelReason", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.import_task_id
              (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cancel_reason
             (fun f -> ("cancel_reason", (String.to_json f)))])
    let of_json j =
      {
        cancel_reason =
          (Util.option_map (Json.lookup j "cancel_reason") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json)
      }
  end
module DescribeVpcEndpointsResult =
  struct
    type t = {
      vpc_endpoints: VpcEndpointSet.t ;
      next_token: String.t option }
    let make ?(vpc_endpoints= [])  ?next_token  () =
      { vpc_endpoints; next_token }
    let parse xml =
      Some
        {
          vpc_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcEndpointSet" xml)
                  VpcEndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointSet", (VpcEndpointSet.to_query v.vpc_endpoints)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpc_endpoints", (VpcEndpointSet.to_json v.vpc_endpoints))])
    let of_json j =
      {
        vpc_endpoints =
          (VpcEndpointSet.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoints")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeClassicLinkInstancesResult =
  struct
    type t =
      {
      instances: ClassicLinkInstanceList.t ;
      next_token: String.t option }
    let make ?(instances= [])  ?next_token  () = { instances; next_token }
    let parse xml =
      Some
        {
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  ClassicLinkInstanceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InstancesSet",
                  (ClassicLinkInstanceList.to_query v.instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("instances", (ClassicLinkInstanceList.to_json v.instances))])
    let of_json j =
      {
        instances =
          (ClassicLinkInstanceList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetHostReservationPurchasePreviewResult =
  struct
    type t =
      {
      currency_code: CurrencyCodeValues.t option ;
      purchase: PurchaseSet.t ;
      total_hourly_price: String.t option ;
      total_upfront_price: String.t option }
    let make ?currency_code  ?(purchase= [])  ?total_hourly_price 
      ?total_upfront_price  () =
      { currency_code; purchase; total_hourly_price; total_upfront_price }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        purchase =
          (PurchaseSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase")));
        total_hourly_price =
          (Util.option_map (Json.lookup j "total_hourly_price")
             String.of_json);
        total_upfront_price =
          (Util.option_map (Json.lookup j "total_upfront_price")
             String.of_json)
      }
  end
module DescribeTransitGatewayAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_attachments: TransitGatewayAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_attachments= [])  ?next_token  () =
      { transit_gateway_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_attachments =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayAttachments" xml)
                  TransitGatewayAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachments",
                  (TransitGatewayAttachmentList.to_query
                     v.transit_gateway_attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_attachments",
               (TransitGatewayAttachmentList.to_json
                  v.transit_gateway_attachments))])
    let of_json j =
      {
        transit_gateway_attachments =
          (TransitGatewayAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTransitGatewayRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      description: String.t option ;
      options: ModifyTransitGatewayOptions.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ?description  ?options  ?dry_run  () =
      { transit_gateway_id; description; options; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          options =
            (Util.option_bind (Xml.member "Options" xml)
               ModifyTransitGatewayOptions.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options", (ModifyTransitGatewayOptions.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.options
             (fun f -> ("options", (ModifyTransitGatewayOptions.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             ModifyTransitGatewayOptions.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateInternetGatewayRequest =
  struct
    type t =
      {
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?(tag_specifications= [])  ?dry_run  () =
      { tag_specifications; dry_run }
    let parse xml =
      Some
        {
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications))])
    let of_json j =
      {
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeImageAttributeRequest =
  struct
    type t =
      {
      attribute: ImageAttributeName.t ;
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~image_id  ?dry_run  () =
      { attribute; image_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ImageAttributeName.parse));
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("Attribute", (ImageAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Some ("attribute", (ImageAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (ImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnConnectionRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      transit_gateway_id: String.t option ;
      customer_gateway_id: String.t option ;
      vpn_gateway_id: String.t option ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ?transit_gateway_id  ?customer_gateway_id 
      ?vpn_gateway_id  ?dry_run  () =
      {
        vpn_connection_id;
        transit_gateway_id;
        customer_gateway_id;
        vpn_gateway_id;
        dry_run
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          transit_gateway_id =
            (Util.option_bind (Xml.member "TransitGatewayId" xml)
               String.parse);
          customer_gateway_id =
            (Util.option_bind (Xml.member "CustomerGatewayId" xml)
               String.parse);
          vpn_gateway_id =
            (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> Query.Pair ("VpnGatewayId", (String.to_query f)));
           Util.option_map v.customer_gateway_id
             (fun f -> Query.Pair ("CustomerGatewayId", (String.to_query f)));
           Util.option_map v.transit_gateway_id
             (fun f -> Query.Pair ("TransitGatewayId", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.vpn_gateway_id
             (fun f -> ("vpn_gateway_id", (String.to_json f)));
           Util.option_map v.customer_gateway_id
             (fun f -> ("customer_gateway_id", (String.to_json f)));
           Util.option_map v.transit_gateway_id
             (fun f -> ("transit_gateway_id", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        transit_gateway_id =
          (Util.option_map (Json.lookup j "transit_gateway_id")
             String.of_json);
        customer_gateway_id =
          (Util.option_map (Json.lookup j "customer_gateway_id")
             String.of_json);
        vpn_gateway_id =
          (Util.option_map (Json.lookup j "vpn_gateway_id") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnTunnelCertificateResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DescribeSnapshotsResult =
  struct
    type t = {
      snapshots: SnapshotList.t ;
      next_token: String.t option }
    let make ?(snapshots= [])  ?next_token  () = { snapshots; next_token }
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("SnapshotSet", (SnapshotList.to_query v.snapshots)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("snapshots", (SnapshotList.to_json v.snapshots))])
    let of_json j =
      {
        snapshots =
          (SnapshotList.of_json
             (Util.of_option_exn (Json.lookup j "snapshots")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module AssociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module EnableVolumeIORequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      volume_id: String.t }
    let make ?dry_run  ~volume_id  () = { dry_run; volume_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          volume_id =
            (Xml.required "volumeId"
               (Util.option_bind (Xml.member "volumeId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")))
      }
  end
module CreateTrafficMirrorFilterRequest =
  struct
    type t =
      {
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ?description  ?(tag_specifications= [])  ?dry_run  ?client_token
       () = { description; tag_specifications; dry_run; client_token }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeTransitGatewayMulticastDomainsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_ids:
        TransitGatewayMulticastDomainIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_multicast_domain_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayMulticastDomainIds" xml)
                  TransitGatewayMulticastDomainIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomainIds",
                  (TransitGatewayMulticastDomainIdStringList.to_query
                     v.transit_gateway_multicast_domain_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_multicast_domain_ids",
               (TransitGatewayMulticastDomainIdStringList.to_json
                  v.transit_gateway_multicast_domain_ids))])
    let of_json j =
      {
        transit_gateway_multicast_domain_ids =
          (TransitGatewayMulticastDomainIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domain_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option }
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain =
          (Util.option_map (Json.lookup j "transit_gateway_multicast_domain")
             TransitGatewayMulticastDomain.of_json)
      }
  end
module PurchaseScheduledInstancesResult =
  struct
    type t = {
      scheduled_instance_set: PurchasedScheduledInstanceSet.t }
    let make ?(scheduled_instance_set= [])  () = { scheduled_instance_set }
    let parse xml =
      Some
        {
          scheduled_instance_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "scheduledInstanceSet" xml)
                  PurchasedScheduledInstanceSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceSet",
                   (PurchasedScheduledInstanceSet.to_query
                      v.scheduled_instance_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_set",
                (PurchasedScheduledInstanceSet.to_json
                   v.scheduled_instance_set))])
    let of_json j =
      {
        scheduled_instance_set =
          (PurchasedScheduledInstanceSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_set")))
      }
  end
module CreateFleetResult =
  struct
    type t =
      {
      fleet_id: String.t option ;
      errors: CreateFleetErrorsSet.t ;
      instances: CreateFleetInstancesSet.t }
    let make ?fleet_id  ?(errors= [])  ?(instances= [])  () =
      { fleet_id; errors; instances }
    let parse xml =
      Some
        {
          fleet_id =
            (Util.option_bind (Xml.member "fleetId" xml) String.parse);
          errors =
            (Util.of_option []
               (Util.option_bind (Xml.member "errorSet" xml)
                  CreateFleetErrorsSet.parse));
          instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetInstanceSet" xml)
                  CreateFleetInstancesSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FleetInstanceSet",
                   (CreateFleetInstancesSet.to_query v.instances)));
           Some
             (Query.Pair
                ("ErrorSet", (CreateFleetErrorsSet.to_query v.errors)));
           Util.option_map v.fleet_id
             (fun f -> Query.Pair ("FleetId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instances", (CreateFleetInstancesSet.to_json v.instances));
           Some ("errors", (CreateFleetErrorsSet.to_json v.errors));
           Util.option_map v.fleet_id
             (fun f -> ("fleet_id", (String.to_json f)))])
    let of_json j =
      {
        fleet_id =
          (Util.option_map (Json.lookup j "fleet_id") String.of_json);
        errors =
          (CreateFleetErrorsSet.of_json
             (Util.of_option_exn (Json.lookup j "errors")));
        instances =
          (CreateFleetInstancesSet.of_json
             (Util.of_option_exn (Json.lookup j "instances")))
      }
  end
module CreateCarrierGatewayResult =
  struct
    type t = {
      carrier_gateway: CarrierGateway.t option }
    let make ?carrier_gateway  () = { carrier_gateway }
    let parse xml =
      Some
        {
          carrier_gateway =
            (Util.option_bind (Xml.member "carrierGateway" xml)
               CarrierGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.carrier_gateway
              (fun f ->
                 Query.Pair ("CarrierGateway", (CarrierGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.carrier_gateway
              (fun f -> ("carrier_gateway", (CarrierGateway.to_json f)))])
    let of_json j =
      {
        carrier_gateway =
          (Util.option_map (Json.lookup j "carrier_gateway")
             CarrierGateway.of_json)
      }
  end
module CreateSnapshotsResult =
  struct
    type t = {
      snapshots: SnapshotSet.t }
    let make ?(snapshots= [])  () = { snapshots }
    let parse xml =
      Some
        {
          snapshots =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotSet" xml)
                  SnapshotSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("SnapshotSet", (SnapshotSet.to_query v.snapshots)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("snapshots", (SnapshotSet.to_json v.snapshots))])
    let of_json j =
      {
        snapshots =
          (SnapshotSet.of_json
             (Util.of_option_exn (Json.lookup j "snapshots")))
      }
  end
module DescribeTrafficMirrorTargetsResult =
  struct
    type t =
      {
      traffic_mirror_targets: TrafficMirrorTargetSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_targets= [])  ?next_token  () =
      { traffic_mirror_targets; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_targets =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorTargetSet" xml)
                  TrafficMirrorTargetSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetSet",
                  (TrafficMirrorTargetSet.to_query v.traffic_mirror_targets)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_targets",
               (TrafficMirrorTargetSet.to_json v.traffic_mirror_targets))])
    let of_json j =
      {
        traffic_mirror_targets =
          (TrafficMirrorTargetSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_targets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      attribute: NetworkInterfaceAttribute.t option ;
      dry_run: Boolean.t option ;
      network_interface_id: String.t }
    let make ?attribute  ?dry_run  ~network_interface_id  () =
      { attribute; dry_run; network_interface_id }
    let parse xml =
      Some
        {
          attribute =
            (Util.option_bind (Xml.member "attribute" xml)
               NetworkInterfaceAttribute.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair
                  ("Attribute", (NetworkInterfaceAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (NetworkInterfaceAttribute.to_json f)))])
    let of_json j =
      {
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             NetworkInterfaceAttribute.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module EnableVpcClassicLinkDnsSupportResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t ;
      traffic_direction: TrafficDirection.t option ;
      rule_number: Integer.t option ;
      rule_action: TrafficMirrorRuleAction.t option ;
      destination_port_range: TrafficMirrorPortRangeRequest.t option ;
      source_port_range: TrafficMirrorPortRangeRequest.t option ;
      protocol: Integer.t option ;
      destination_cidr_block: String.t option ;
      source_cidr_block: String.t option ;
      description: String.t option ;
      remove_fields: TrafficMirrorFilterRuleFieldList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_rule_id  ?traffic_direction  ?rule_number
       ?rule_action  ?destination_port_range  ?source_port_range  ?protocol 
      ?destination_cidr_block  ?source_cidr_block  ?description 
      ?(remove_fields= [])  ?dry_run  () =
      {
        traffic_mirror_filter_rule_id;
        traffic_direction;
        rule_number;
        rule_action;
        destination_port_range;
        source_port_range;
        protocol;
        destination_cidr_block;
        source_cidr_block;
        description;
        remove_fields;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Xml.required "TrafficMirrorFilterRuleId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterRuleId" xml)
                  String.parse));
          traffic_direction =
            (Util.option_bind (Xml.member "TrafficDirection" xml)
               TrafficDirection.parse);
          rule_number =
            (Util.option_bind (Xml.member "RuleNumber" xml) Integer.parse);
          rule_action =
            (Util.option_bind (Xml.member "RuleAction" xml)
               TrafficMirrorRuleAction.parse);
          destination_port_range =
            (Util.option_bind (Xml.member "DestinationPortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          source_port_range =
            (Util.option_bind (Xml.member "SourcePortRange" xml)
               TrafficMirrorPortRangeRequest.parse);
          protocol =
            (Util.option_bind (Xml.member "Protocol" xml) Integer.parse);
          destination_cidr_block =
            (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
               String.parse);
          source_cidr_block =
            (Util.option_bind (Xml.member "SourceCidrBlock" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          remove_fields =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveField" xml)
                  TrafficMirrorFilterRuleFieldList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveField",
                  (TrafficMirrorFilterRuleFieldList.to_query v.remove_fields)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.source_cidr_block
             (fun f -> Query.Pair ("SourceCidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)));
           Util.option_map v.protocol
             (fun f -> Query.Pair ("Protocol", (Integer.to_query f)));
           Util.option_map v.source_port_range
             (fun f ->
                Query.Pair
                  ("SourcePortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.destination_port_range
             (fun f ->
                Query.Pair
                  ("DestinationPortRange",
                    (TrafficMirrorPortRangeRequest.to_query f)));
           Util.option_map v.rule_action
             (fun f ->
                Query.Pair
                  ("RuleAction", (TrafficMirrorRuleAction.to_query f)));
           Util.option_map v.rule_number
             (fun f -> Query.Pair ("RuleNumber", (Integer.to_query f)));
           Util.option_map v.traffic_direction
             (fun f ->
                Query.Pair
                  ("TrafficDirection", (TrafficDirection.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterRuleId",
                  (String.to_query v.traffic_mirror_filter_rule_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_fields",
               (TrafficMirrorFilterRuleFieldList.to_json v.remove_fields));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.source_cidr_block
             (fun f -> ("source_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)));
           Util.option_map v.protocol
             (fun f -> ("protocol", (Integer.to_json f)));
           Util.option_map v.source_port_range
             (fun f ->
                ("source_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.destination_port_range
             (fun f ->
                ("destination_port_range",
                  (TrafficMirrorPortRangeRequest.to_json f)));
           Util.option_map v.rule_action
             (fun f -> ("rule_action", (TrafficMirrorRuleAction.to_json f)));
           Util.option_map v.rule_number
             (fun f -> ("rule_number", (Integer.to_json f)));
           Util.option_map v.traffic_direction
             (fun f -> ("traffic_direction", (TrafficDirection.to_json f)));
           Some
             ("traffic_mirror_filter_rule_id",
               (String.to_json v.traffic_mirror_filter_rule_id))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "traffic_mirror_filter_rule_id")));
        traffic_direction =
          (Util.option_map (Json.lookup j "traffic_direction")
             TrafficDirection.of_json);
        rule_number =
          (Util.option_map (Json.lookup j "rule_number") Integer.of_json);
        rule_action =
          (Util.option_map (Json.lookup j "rule_action")
             TrafficMirrorRuleAction.of_json);
        destination_port_range =
          (Util.option_map (Json.lookup j "destination_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        source_port_range =
          (Util.option_map (Json.lookup j "source_port_range")
             TrafficMirrorPortRangeRequest.of_json);
        protocol =
          (Util.option_map (Json.lookup j "protocol") Integer.of_json);
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        source_cidr_block =
          (Util.option_map (Json.lookup j "source_cidr_block") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        remove_fields =
          (TrafficMirrorFilterRuleFieldList.of_json
             (Util.of_option_exn (Json.lookup j "remove_fields")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~transit_gateway_route_table_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        destination_cidr_block;
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateClientVpnEndpointResult =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t option ;
      status: ClientVpnEndpointStatus.t option ;
      dns_name: String.t option }
    let make ?client_vpn_endpoint_id  ?status  ?dns_name  () =
      { client_vpn_endpoint_id; status; dns_name }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Util.option_bind (Xml.member "clientVpnEndpointId" xml)
               String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse);
          dns_name =
            (Util.option_bind (Xml.member "dnsName" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> Query.Pair ("DnsName", (String.to_query f)));
           Util.option_map v.status
             (fun f ->
                Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f ->
                Query.Pair ("ClientVpnEndpointId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dns_name
              (fun f -> ("dns_name", (String.to_json f)));
           Util.option_map v.status
             (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)));
           Util.option_map v.client_vpn_endpoint_id
             (fun f -> ("client_vpn_endpoint_id", (String.to_json f)))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (Util.option_map (Json.lookup j "client_vpn_endpoint_id")
             String.of_json);
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json);
        dns_name =
          (Util.option_map (Json.lookup j "dns_name") String.of_json)
      }
  end
module StartVpcEndpointServicePrivateDnsVerificationResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module CreateVpcEndpointResult =
  struct
    type t =
      {
      vpc_endpoint: VpcEndpoint.t option ;
      client_token: String.t option }
    let make ?vpc_endpoint  ?client_token  () =
      { vpc_endpoint; client_token }
    let parse xml =
      Some
        {
          vpc_endpoint =
            (Util.option_bind (Xml.member "vpcEndpoint" xml)
               VpcEndpoint.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.vpc_endpoint
             (fun f -> Query.Pair ("VpcEndpoint", (VpcEndpoint.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.vpc_endpoint
             (fun f -> ("vpc_endpoint", (VpcEndpoint.to_json f)))])
    let of_json j =
      {
        vpc_endpoint =
          (Util.option_map (Json.lookup j "vpc_endpoint") VpcEndpoint.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeMovingAddressesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      public_ips: ValueStringList.t }
    let make ?(filters= [])  ?dry_run  ?max_results  ?next_token 
      ?(public_ips= [])  () =
      { filters; dry_run; max_results; next_token; public_ips }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          public_ips =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIp" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PublicIp", (ValueStringList.to_query v.public_ips)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ips", (ValueStringList.to_json v.public_ips));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        public_ips =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "public_ips")))
      }
  end
module MoveAddressToVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      public_ip: String.t }
    let make ?dry_run  ~public_ip  () = { dry_run; public_ip }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          public_ip =
            (Xml.required "publicIp"
               (Util.option_bind (Xml.member "publicIp" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("PublicIp", (String.to_query v.public_ip)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("public_ip", (String.to_json v.public_ip));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        public_ip =
          (String.of_json (Util.of_option_exn (Json.lookup j "public_ip")))
      }
  end
module DescribeVolumesModificationsResult =
  struct
    type t =
      {
      volumes_modifications: VolumeModificationList.t ;
      next_token: String.t option }
    let make ?(volumes_modifications= [])  ?next_token  () =
      { volumes_modifications; next_token }
    let parse xml =
      Some
        {
          volumes_modifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeModificationSet" xml)
                  VolumeModificationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VolumeModificationSet",
                  (VolumeModificationList.to_query v.volumes_modifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("volumes_modifications",
               (VolumeModificationList.to_json v.volumes_modifications))])
    let of_json j =
      {
        volumes_modifications =
          (VolumeModificationList.of_json
             (Util.of_option_exn (Json.lookup j "volumes_modifications")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupSourcesRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: TransitGatewayNetworkInterfaceIdList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  TransitGatewayNetworkInterfaceIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (TransitGatewayNetworkInterfaceIdList.to_query
                     v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (TransitGatewayNetworkInterfaceIdList.to_json
                  v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (TransitGatewayNetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ResetEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module ResetImageAttributeRequest =
  struct
    type t =
      {
      attribute: ResetImageAttributeName.t ;
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~image_id  ?dry_run  () =
      { attribute; image_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  ResetImageAttributeName.parse));
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)));
           Some
             (Query.Pair
                ("Attribute", (ResetImageAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id));
           Some ("attribute", (ResetImageAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (ResetImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      vpc_endpoint_ids: VpcEndpointIdList.t }
    let make ?dry_run  ~service_id  ~vpc_endpoint_ids  () =
      { dry_run; service_id; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  VpcEndpointIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (VpcEndpointIdList.to_query v.vpc_endpoint_ids)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (VpcEndpointIdList.to_json v.vpc_endpoint_ids));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        vpc_endpoint_ids =
          (VpcEndpointIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module DeleteManagedPrefixListRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      prefix_list_id: String.t }
    let make ?dry_run  ~prefix_list_id  () = { dry_run; prefix_list_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListId", (String.to_query v.prefix_list_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")))
      }
  end
module SearchTransitGatewayRoutesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~filters  ?max_results 
      ?dry_run  () =
      { transit_gateway_route_table_id; filters; max_results; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Xml.required "Filter"
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelCapacityReservationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CopySnapshotRequest =
  struct
    type t =
      {
      description: String.t option ;
      destination_region: String.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      presigned_url: String.t option ;
      source_region: String.t ;
      source_snapshot_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ?destination_region  ?encrypted  ?kms_key_id 
      ?presigned_url  ~source_region  ~source_snapshot_id 
      ?(tag_specifications= [])  ?dry_run  () =
      {
        description;
        destination_region;
        encrypted;
        kms_key_id;
        presigned_url;
        source_region;
        source_snapshot_id;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          destination_region =
            (Util.option_bind (Xml.member "destinationRegion" xml)
               String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          presigned_url =
            (Util.option_bind (Xml.member "presignedUrl" xml) String.parse);
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          source_snapshot_id =
            (Xml.required "SourceSnapshotId"
               (Util.option_bind (Xml.member "SourceSnapshotId" xml)
                  String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("SourceSnapshotId", (String.to_query v.source_snapshot_id)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Util.option_map v.presigned_url
             (fun f -> Query.Pair ("PresignedUrl", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.destination_region
             (fun f -> Query.Pair ("DestinationRegion", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("source_snapshot_id", (String.to_json v.source_snapshot_id));
           Some ("source_region", (String.to_json v.source_region));
           Util.option_map v.presigned_url
             (fun f -> ("presigned_url", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.destination_region
             (fun f -> ("destination_region", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        destination_region =
          (Util.option_map (Json.lookup j "destination_region")
             String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        presigned_url =
          (Util.option_map (Json.lookup j "presigned_url") String.of_json);
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        source_snapshot_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_snapshot_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_configurations: NewDhcpConfigurationList.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_configurations  ?(tag_specifications= [])  ?dry_run  () =
      { dhcp_configurations; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          dhcp_configurations =
            (Xml.required "dhcpConfiguration"
               (Util.option_bind (Xml.member "dhcpConfiguration" xml)
                  NewDhcpConfigurationList.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("DhcpConfiguration",
                  (NewDhcpConfigurationList.to_query v.dhcp_configurations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("dhcp_configurations",
               (NewDhcpConfigurationList.to_json v.dhcp_configurations))])
    let of_json j =
      {
        dhcp_configurations =
          (NewDhcpConfigurationList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_configurations")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsIngressResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DescribeVpcAttributeRequest =
  struct
    type t =
      {
      attribute: VpcAttributeName.t ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~vpc_id  ?dry_run  () =
      { attribute; vpc_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  VpcAttributeName.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("Attribute", (VpcAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("attribute", (VpcAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (VpcAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetConsoleScreenshotResult =
  struct
    type t = {
      image_data: String.t option ;
      instance_id: String.t option }
    let make ?image_data  ?instance_id  () = { image_data; instance_id }
    let parse xml =
      Some
        {
          image_data =
            (Util.option_bind (Xml.member "imageData" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.image_data
             (fun f -> Query.Pair ("ImageData", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_id
              (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.image_data
             (fun f -> ("image_data", (String.to_json f)))])
    let of_json j =
      {
        image_data =
          (Util.option_map (Json.lookup j "image_data") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json)
      }
  end
module DescribeNetworkInterfacesResult =
  struct
    type t =
      {
      network_interfaces: NetworkInterfaceList.t ;
      next_token: String.t option }
    let make ?(network_interfaces= [])  ?next_token  () =
      { network_interfaces; next_token }
    let parse xml =
      Some
        {
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterfaceSet" xml)
                  NetworkInterfaceList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceSet",
                  (NetworkInterfaceList.to_query v.network_interfaces)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interfaces",
               (NetworkInterfaceList.to_json v.network_interfaces))])
    let of_json j =
      {
        network_interfaces =
          (NetworkInterfaceList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateVpcRequest =
  struct
    type t =
      {
      cidr_block: String.t ;
      amazon_provided_ipv6_cidr_block: Boolean.t option ;
      ipv6_pool: String.t option ;
      ipv6_cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      instance_tenancy: Tenancy.t option ;
      ipv6_cidr_block_network_border_group: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ~cidr_block  ?amazon_provided_ipv6_cidr_block  ?ipv6_pool 
      ?ipv6_cidr_block  ?dry_run  ?instance_tenancy 
      ?ipv6_cidr_block_network_border_group  ?(tag_specifications= [])  () =
      {
        cidr_block;
        amazon_provided_ipv6_cidr_block;
        ipv6_pool;
        ipv6_cidr_block;
        dry_run;
        instance_tenancy;
        ipv6_cidr_block_network_border_group;
        tag_specifications
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Xml.required "CidrBlock"
               (Util.option_bind (Xml.member "CidrBlock" xml) String.parse));
          amazon_provided_ipv6_cidr_block =
            (Util.option_bind (Xml.member "amazonProvidedIpv6CidrBlock" xml)
               Boolean.parse);
          ipv6_pool =
            (Util.option_bind (Xml.member "Ipv6Pool" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "Ipv6CidrBlock" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          ipv6_cidr_block_network_border_group =
            (Util.option_bind
               (Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
               String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.ipv6_cidr_block_network_border_group
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockNetworkBorderGroup", (String.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.ipv6_pool
             (fun f -> Query.Pair ("Ipv6Pool", (String.to_query f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                Query.Pair
                  ("AmazonProvidedIpv6CidrBlock", (Boolean.to_query f)));
           Some (Query.Pair ("CidrBlock", (String.to_query v.cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.ipv6_cidr_block_network_border_group
             (fun f ->
                ("ipv6_cidr_block_network_border_group", (String.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.ipv6_pool
             (fun f -> ("ipv6_pool", (String.to_json f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                ("amazon_provided_ipv6_cidr_block", (Boolean.to_json f)));
           Some ("cidr_block", (String.to_json v.cidr_block))])
    let of_json j =
      {
        cidr_block =
          (String.of_json (Util.of_option_exn (Json.lookup j "cidr_block")));
        amazon_provided_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "amazon_provided_ipv6_cidr_block")
             Boolean.of_json);
        ipv6_pool =
          (Util.option_map (Json.lookup j "ipv6_pool") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        ipv6_cidr_block_network_border_group =
          (Util.option_map
             (Json.lookup j "ipv6_cidr_block_network_border_group")
             String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeVpcEndpointConnectionNotificationsResult =
  struct
    type t =
      {
      connection_notification_set: ConnectionNotificationSet.t ;
      next_token: String.t option }
    let make ?(connection_notification_set= [])  ?next_token  () =
      { connection_notification_set; next_token }
    let parse xml =
      Some
        {
          connection_notification_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "connectionNotificationSet" xml)
                  ConnectionNotificationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionNotificationSet",
                  (ConnectionNotificationSet.to_query
                     v.connection_notification_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("connection_notification_set",
               (ConnectionNotificationSet.to_json
                  v.connection_notification_set))])
    let of_json j =
      {
        connection_notification_set =
          (ConnectionNotificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_set")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ResetFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: ResetFpgaImageAttributeName.t option }
    let make ?dry_run  ~fpga_image_id  ?attribute  () =
      { dry_run; fpga_image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               ResetFpgaImageAttributeName.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 Query.Pair
                   ("Attribute", (ResetFpgaImageAttributeName.to_query f)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.attribute
              (fun f ->
                 ("attribute", (ResetFpgaImageAttributeName.to_json f)));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             ResetFpgaImageAttributeName.of_json)
      }
  end
module DeleteManagedPrefixListResult =
  struct
    type t = {
      prefix_list: ManagedPrefixList.t option }
    let make ?prefix_list  () = { prefix_list }
    let parse xml =
      Some
        {
          prefix_list =
            (Util.option_bind (Xml.member "prefixList" xml)
               ManagedPrefixList.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f ->
                 Query.Pair ("PrefixList", (ManagedPrefixList.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f -> ("prefix_list", (ManagedPrefixList.to_json f)))])
    let of_json j =
      {
        prefix_list =
          (Util.option_map (Json.lookup j "prefix_list")
             ManagedPrefixList.of_json)
      }
  end
module DescribeClientVpnConnectionsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?(filters= [])  ?next_token 
      ?max_results  ?dry_run  () =
      { client_vpn_endpoint_id; filters; next_token; max_results; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module CreateNetworkAclRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ~vpc_id  ?(tag_specifications= [])  () =
      { dry_run; vpc_id; tag_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module CopyImageRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      name: String.t ;
      source_image_id: String.t ;
      source_region: String.t ;
      dry_run: Boolean.t option }
    let make ?client_token  ?description  ?encrypted  ?kms_key_id  ~name 
      ~source_image_id  ~source_region  ?dry_run  () =
      {
        client_token;
        description;
        encrypted;
        kms_key_id;
        name;
        source_image_id;
        source_region;
        dry_run
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          name =
            (Xml.required "Name"
               (Util.option_bind (Xml.member "Name" xml) String.parse));
          source_image_id =
            (Xml.required "SourceImageId"
               (Util.option_bind (Xml.member "SourceImageId" xml)
                  String.parse));
          source_region =
            (Xml.required "SourceRegion"
               (Util.option_bind (Xml.member "SourceRegion" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("SourceRegion", (String.to_query v.source_region)));
           Some
             (Query.Pair
                ("SourceImageId", (String.to_query v.source_image_id)));
           Some (Query.Pair ("Name", (String.to_query v.name)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("source_region", (String.to_json v.source_region));
           Some ("source_image_id", (String.to_json v.source_image_id));
           Some ("name", (String.to_json v.name));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        name = (String.of_json (Util.of_option_exn (Json.lookup j "name")));
        source_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_image_id")));
        source_region =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "source_region")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RejectTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module DeleteCarrierGatewayRequest =
  struct
    type t = {
      carrier_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~carrier_gateway_id  ?dry_run  () =
      { carrier_gateway_id; dry_run }
    let parse xml =
      Some
        {
          carrier_gateway_id =
            (Xml.required "CarrierGatewayId"
               (Util.option_bind (Xml.member "CarrierGatewayId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CarrierGatewayId", (String.to_query v.carrier_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("carrier_gateway_id", (String.to_json v.carrier_gateway_id))])
    let of_json j =
      {
        carrier_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "carrier_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeNetworkInterfaceAttributeResult =
  struct
    type t =
      {
      attachment: NetworkInterfaceAttachment.t option ;
      description: AttributeValue.t option ;
      groups: GroupIdentifierList.t ;
      network_interface_id: String.t option ;
      source_dest_check: AttributeBooleanValue.t option }
    let make ?attachment  ?description  ?(groups= [])  ?network_interface_id 
      ?source_dest_check  () =
      {
        attachment;
        description;
        groups;
        network_interface_id;
        source_dest_check
      }
    let parse xml =
      Some
        {
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachment.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 Query.Pair
                   ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment", (NetworkInterfaceAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Some ("groups", (GroupIdentifierList.to_json v.groups));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attachment
             (fun f -> ("attachment", (NetworkInterfaceAttachment.to_json f)))])
    let of_json j =
      {
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachment.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json)
      }
  end
module DescribeReservedInstancesResult =
  struct
    type t = {
      reserved_instances: ReservedInstancesList.t }
    let make ?(reserved_instances= [])  () = { reserved_instances }
    let parse xml =
      Some
        {
          reserved_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstancesSet" xml)
                  ReservedInstancesList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesSet",
                   (ReservedInstancesList.to_query v.reserved_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances",
                (ReservedInstancesList.to_json v.reserved_instances))])
    let of_json j =
      {
        reserved_instances =
          (ReservedInstancesList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances")))
      }
  end
module DescribeSecurityGroupReferencesRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      group_id: GroupIds.t }
    let make ?dry_run  ~group_id  () = { dry_run; group_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Xml.required "GroupId"
               (Util.option_bind (Xml.member "GroupId" xml) GroupIds.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("GroupId", (GroupIds.to_query v.group_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("group_id", (GroupIds.to_json v.group_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (GroupIds.of_json (Util.of_option_exn (Json.lookup j "group_id")))
      }
  end
module CreateNatGatewayResult =
  struct
    type t =
      {
      client_token: String.t option ;
      nat_gateway: NatGateway.t option }
    let make ?client_token  ?nat_gateway  () = { client_token; nat_gateway }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          nat_gateway =
            (Util.option_bind (Xml.member "natGateway" xml) NatGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> Query.Pair ("NatGateway", (NatGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway
              (fun f -> ("nat_gateway", (NatGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        nat_gateway =
          (Util.option_map (Json.lookup j "nat_gateway") NatGateway.of_json)
      }
  end
module DescribePrincipalIdFormatRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(resources= [])  ?max_results  ?next_token  () =
      { dry_run; resources; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          resources =
            (Util.of_option []
               (Util.option_bind (Xml.member "Resource" xml)
                  ResourceList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair ("Resource", (ResourceList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("resources", (ResourceList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTransitGatewayPeeringAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_peering_attachments:
        TransitGatewayPeeringAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_peering_attachments= [])  ?next_token  () =
      { transit_gateway_peering_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayPeeringAttachments" xml)
                  TransitGatewayPeeringAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayPeeringAttachments",
                  (TransitGatewayPeeringAttachmentList.to_query
                     v.transit_gateway_peering_attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_peering_attachments",
               (TransitGatewayPeeringAttachmentList.to_json
                  v.transit_gateway_peering_attachments))])
    let of_json j =
      {
        transit_gateway_peering_attachments =
          (TransitGatewayPeeringAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_peering_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AcceptTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelSpotInstanceRequestsResult =
  struct
    type t =
      {
      cancelled_spot_instance_requests: CancelledSpotInstanceRequestList.t }
    let make ?(cancelled_spot_instance_requests= [])  () =
      { cancelled_spot_instance_requests }
    let parse xml =
      Some
        {
          cancelled_spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  CancelledSpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (CancelledSpotInstanceRequestList.to_query
                      v.cancelled_spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("cancelled_spot_instance_requests",
                (CancelledSpotInstanceRequestList.to_json
                   v.cancelled_spot_instance_requests))])
    let of_json j =
      {
        cancelled_spot_instance_requests =
          (CancelledSpotInstanceRequestList.of_json
             (Util.of_option_exn
                (Json.lookup j "cancelled_spot_instance_requests")))
      }
  end
module CreateSpotDatafeedSubscriptionResult =
  struct
    type t = {
      spot_datafeed_subscription: SpotDatafeedSubscription.t option }
    let make ?spot_datafeed_subscription  () = { spot_datafeed_subscription }
    let parse xml =
      Some
        {
          spot_datafeed_subscription =
            (Util.option_bind (Xml.member "spotDatafeedSubscription" xml)
               SpotDatafeedSubscription.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 Query.Pair
                   ("SpotDatafeedSubscription",
                     (SpotDatafeedSubscription.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_datafeed_subscription
              (fun f ->
                 ("spot_datafeed_subscription",
                   (SpotDatafeedSubscription.to_json f)))])
    let of_json j =
      {
        spot_datafeed_subscription =
          (Util.option_map (Json.lookup j "spot_datafeed_subscription")
             SpotDatafeedSubscription.of_json)
      }
  end
module DeleteTransitGatewayRouteRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      destination_cidr_block: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~destination_cidr_block 
      ?dry_run  () =
      { transit_gateway_route_table_id; destination_cidr_block; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVpcEndpointServiceConfigurationsResult =
  struct
    type t =
      {
      service_configurations: ServiceConfigurationSet.t ;
      next_token: String.t option }
    let make ?(service_configurations= [])  ?next_token  () =
      { service_configurations; next_token }
    let parse xml =
      Some
        {
          service_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceConfigurationSet" xml)
                  ServiceConfigurationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceConfigurationSet",
                  (ServiceConfigurationSet.to_query v.service_configurations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_configurations",
               (ServiceConfigurationSet.to_json v.service_configurations))])
    let of_json j =
      {
        service_configurations =
          (ServiceConfigurationSet.of_json
             (Util.of_option_exn (Json.lookup j "service_configurations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateFpgaImageRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      input_storage_location: StorageLocation.t ;
      logs_storage_location: StorageLocation.t option ;
      description: String.t option ;
      name: String.t option ;
      client_token: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ~input_storage_location  ?logs_storage_location 
      ?description  ?name  ?client_token  ?(tag_specifications= [])  () =
      {
        dry_run;
        input_storage_location;
        logs_storage_location;
        description;
        name;
        client_token;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          input_storage_location =
            (Xml.required "InputStorageLocation"
               (Util.option_bind (Xml.member "InputStorageLocation" xml)
                  StorageLocation.parse));
          logs_storage_location =
            (Util.option_bind (Xml.member "LogsStorageLocation" xml)
               StorageLocation.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.name
             (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.logs_storage_location
             (fun f ->
                Query.Pair
                  ("LogsStorageLocation", (StorageLocation.to_query f)));
           Some
             (Query.Pair
                ("InputStorageLocation",
                  (StorageLocation.to_query v.input_storage_location)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.logs_storage_location
             (fun f -> ("logs_storage_location", (StorageLocation.to_json f)));
           Some
             ("input_storage_location",
               (StorageLocation.to_json v.input_storage_location));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        input_storage_location =
          (StorageLocation.of_json
             (Util.of_option_exn (Json.lookup j "input_storage_location")));
        logs_storage_location =
          (Util.option_map (Json.lookup j "logs_storage_location")
             StorageLocation.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeBundleTasksRequest =
  struct
    type t =
      {
      bundle_ids: BundleIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(bundle_ids= [])  ?(filters= [])  ?dry_run  () =
      { bundle_ids; filters; dry_run }
    let parse xml =
      Some
        {
          bundle_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "BundleId" xml)
                  BundleIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("BundleId", (BundleIdStringList.to_query v.bundle_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("bundle_ids", (BundleIdStringList.to_json v.bundle_ids))])
    let of_json j =
      {
        bundle_ids =
          (BundleIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "bundle_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeConversionTasksResult =
  struct
    type t = {
      conversion_tasks: DescribeConversionTaskList.t }
    let make ?(conversion_tasks= [])  () = { conversion_tasks }
    let parse xml =
      Some
        {
          conversion_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTasks" xml)
                  DescribeConversionTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConversionTasks",
                   (DescribeConversionTaskList.to_query v.conversion_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("conversion_tasks",
                (DescribeConversionTaskList.to_json v.conversion_tasks))])
    let of_json j =
      {
        conversion_tasks =
          (DescribeConversionTaskList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_tasks")))
      }
  end
module DescribeLocalGatewayRouteTablesRequest =
  struct
    type t =
      {
      local_gateway_route_table_ids: LocalGatewayRouteTableIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_route_table_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "LocalGatewayRouteTableId" xml)
                  LocalGatewayRouteTableIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableId",
                  (LocalGatewayRouteTableIdSet.to_query
                     v.local_gateway_route_table_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_ids",
               (LocalGatewayRouteTableIdSet.to_json
                  v.local_gateway_route_table_ids))])
    let of_json j =
      {
        local_gateway_route_table_ids =
          (LocalGatewayRouteTableIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_route_table_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateDefaultVpcRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTransitGatewayVpcAttachmentsResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachments: TransitGatewayVpcAttachmentList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_vpc_attachments= [])  ?next_token  () =
      { transit_gateway_vpc_attachments; next_token }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachments =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "transitGatewayVpcAttachments" xml)
                  TransitGatewayVpcAttachmentList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayVpcAttachments",
                  (TransitGatewayVpcAttachmentList.to_query
                     v.transit_gateway_vpc_attachments)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_vpc_attachments",
               (TransitGatewayVpcAttachmentList.to_json
                  v.transit_gateway_vpc_attachments))])
    let of_json j =
      {
        transit_gateway_vpc_attachments =
          (TransitGatewayVpcAttachmentList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_vpc_attachments")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateInstanceExportTaskRequest =
  struct
    type t =
      {
      description: String.t option ;
      export_to_s3_task: ExportToS3TaskSpecification.t ;
      instance_id: String.t ;
      target_environment: ExportEnvironment.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?description  ~export_to_s3_task  ~instance_id 
      ~target_environment  ?(tag_specifications= [])  () =
      {
        description;
        export_to_s3_task;
        instance_id;
        target_environment;
        tag_specifications
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          export_to_s3_task =
            (Xml.required "exportToS3"
               (Util.option_bind (Xml.member "exportToS3" xml)
                  ExportToS3TaskSpecification.parse));
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          target_environment =
            (Xml.required "targetEnvironment"
               (Util.option_bind (Xml.member "targetEnvironment" xml)
                  ExportEnvironment.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("TargetEnvironment",
                  (ExportEnvironment.to_query v.target_environment)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("ExportToS3",
                  (ExportToS3TaskSpecification.to_query v.export_to_s3_task)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("target_environment",
               (ExportEnvironment.to_json v.target_environment));
           Some ("instance_id", (String.to_json v.instance_id));
           Some
             ("export_to_s3_task",
               (ExportToS3TaskSpecification.to_json v.export_to_s3_task));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        export_to_s3_task =
          (ExportToS3TaskSpecification.of_json
             (Util.of_option_exn (Json.lookup j "export_to_s3_task")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        target_environment =
          (ExportEnvironment.of_json
             (Util.of_option_exn (Json.lookup j "target_environment")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module GetReservedInstancesExchangeQuoteResult =
  struct
    type t =
      {
      currency_code: String.t option ;
      is_valid_exchange: Boolean.t option ;
      output_reserved_instances_will_expire_at: DateTime.t option ;
      payment_due: String.t option ;
      reserved_instance_value_rollup: ReservationValue.t option ;
      reserved_instance_value_set: ReservedInstanceReservationValueSet.t ;
      target_configuration_value_rollup: ReservationValue.t option ;
      target_configuration_value_set: TargetReservationValueSet.t ;
      validation_failure_reason: String.t option }
    let make ?currency_code  ?is_valid_exchange 
      ?output_reserved_instances_will_expire_at  ?payment_due 
      ?reserved_instance_value_rollup  ?(reserved_instance_value_set= []) 
      ?target_configuration_value_rollup  ?(target_configuration_value_set=
      [])  ?validation_failure_reason  () =
      {
        currency_code;
        is_valid_exchange;
        output_reserved_instances_will_expire_at;
        payment_due;
        reserved_instance_value_rollup;
        reserved_instance_value_set;
        target_configuration_value_rollup;
        target_configuration_value_set;
        validation_failure_reason
      }
    let parse xml =
      Some
        {
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml) String.parse);
          is_valid_exchange =
            (Util.option_bind (Xml.member "isValidExchange" xml)
               Boolean.parse);
          output_reserved_instances_will_expire_at =
            (Util.option_bind
               (Xml.member "outputReservedInstancesWillExpireAt" xml)
               DateTime.parse);
          payment_due =
            (Util.option_bind (Xml.member "paymentDue" xml) String.parse);
          reserved_instance_value_rollup =
            (Util.option_bind (Xml.member "reservedInstanceValueRollup" xml)
               ReservationValue.parse);
          reserved_instance_value_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservedInstanceValueSet" xml)
                  ReservedInstanceReservationValueSet.parse));
          target_configuration_value_rollup =
            (Util.option_bind
               (Xml.member "targetConfigurationValueRollup" xml)
               ReservationValue.parse);
          target_configuration_value_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "targetConfigurationValueSet" xml)
                  TargetReservationValueSet.parse));
          validation_failure_reason =
            (Util.option_bind (Xml.member "validationFailureReason" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f ->
                 Query.Pair ("ValidationFailureReason", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetConfigurationValueSet",
                  (TargetReservationValueSet.to_query
                     v.target_configuration_value_set)));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                Query.Pair
                  ("TargetConfigurationValueRollup",
                    (ReservationValue.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstanceValueSet",
                  (ReservedInstanceReservationValueSet.to_query
                     v.reserved_instance_value_set)));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                Query.Pair
                  ("ReservedInstanceValueRollup",
                    (ReservationValue.to_query f)));
           Util.option_map v.payment_due
             (fun f -> Query.Pair ("PaymentDue", (String.to_query f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                Query.Pair
                  ("OutputReservedInstancesWillExpireAt",
                    (DateTime.to_query f)));
           Util.option_map v.is_valid_exchange
             (fun f -> Query.Pair ("IsValidExchange", (Boolean.to_query f)));
           Util.option_map v.currency_code
             (fun f -> Query.Pair ("CurrencyCode", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.validation_failure_reason
              (fun f -> ("validation_failure_reason", (String.to_json f)));
           Some
             ("target_configuration_value_set",
               (TargetReservationValueSet.to_json
                  v.target_configuration_value_set));
           Util.option_map v.target_configuration_value_rollup
             (fun f ->
                ("target_configuration_value_rollup",
                  (ReservationValue.to_json f)));
           Some
             ("reserved_instance_value_set",
               (ReservedInstanceReservationValueSet.to_json
                  v.reserved_instance_value_set));
           Util.option_map v.reserved_instance_value_rollup
             (fun f ->
                ("reserved_instance_value_rollup",
                  (ReservationValue.to_json f)));
           Util.option_map v.payment_due
             (fun f -> ("payment_due", (String.to_json f)));
           Util.option_map v.output_reserved_instances_will_expire_at
             (fun f ->
                ("output_reserved_instances_will_expire_at",
                  (DateTime.to_json f)));
           Util.option_map v.is_valid_exchange
             (fun f -> ("is_valid_exchange", (Boolean.to_json f)));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (String.to_json f)))])
    let of_json j =
      {
        currency_code =
          (Util.option_map (Json.lookup j "currency_code") String.of_json);
        is_valid_exchange =
          (Util.option_map (Json.lookup j "is_valid_exchange")
             Boolean.of_json);
        output_reserved_instances_will_expire_at =
          (Util.option_map
             (Json.lookup j "output_reserved_instances_will_expire_at")
             DateTime.of_json);
        payment_due =
          (Util.option_map (Json.lookup j "payment_due") String.of_json);
        reserved_instance_value_rollup =
          (Util.option_map (Json.lookup j "reserved_instance_value_rollup")
             ReservationValue.of_json);
        reserved_instance_value_set =
          (ReservedInstanceReservationValueSet.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instance_value_set")));
        target_configuration_value_rollup =
          (Util.option_map
             (Json.lookup j "target_configuration_value_rollup")
             ReservationValue.of_json);
        target_configuration_value_set =
          (TargetReservationValueSet.of_json
             (Util.of_option_exn
                (Json.lookup j "target_configuration_value_set")));
        validation_failure_reason =
          (Util.option_map (Json.lookup j "validation_failure_reason")
             String.of_json)
      }
  end
module SearchTransitGatewayRoutesResult =
  struct
    type t =
      {
      routes: TransitGatewayRouteList.t ;
      additional_routes_available: Boolean.t option }
    let make ?(routes= [])  ?additional_routes_available  () =
      { routes; additional_routes_available }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  TransitGatewayRouteList.parse));
          additional_routes_available =
            (Util.option_bind (Xml.member "additionalRoutesAvailable" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f ->
                 Query.Pair
                   ("AdditionalRoutesAvailable", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (TransitGatewayRouteList.to_query v.routes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.additional_routes_available
              (fun f -> ("additional_routes_available", (Boolean.to_json f)));
           Some ("routes", (TransitGatewayRouteList.to_json v.routes))])
    let of_json j =
      {
        routes =
          (TransitGatewayRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        additional_routes_available =
          (Util.option_map (Json.lookup j "additional_routes_available")
             Boolean.of_json)
      }
  end
module CreateSecurityGroupResult =
  struct
    type t = {
      group_id: String.t ;
      tags: TagList.t }
    let make ~group_id  ?(tags= [])  () = { group_id; tags }
    let parse xml =
      Some
        {
          group_id =
            (Xml.required "groupId"
               (Util.option_bind (Xml.member "groupId" xml) String.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some (Query.Pair ("GroupId", (String.to_query v.group_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("group_id", (String.to_json v.group_id))])
    let of_json j =
      {
        group_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_id")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeSpotFleetRequestHistoryResponse =
  struct
    type t =
      {
      history_records: HistoryRecords.t ;
      last_evaluated_time: DateTime.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t option ;
      start_time: DateTime.t option }
    let make ?(history_records= [])  ?last_evaluated_time  ?next_token 
      ?spot_fleet_request_id  ?start_time  () =
      {
        history_records;
        last_evaluated_time;
        next_token;
        spot_fleet_request_id;
        start_time
      }
    let parse xml =
      Some
        {
          history_records =
            (Util.of_option []
               (Util.option_bind (Xml.member "historyRecordSet" xml)
                  HistoryRecords.parse));
          last_evaluated_time =
            (Util.option_bind (Xml.member "lastEvaluatedTime" xml)
               DateTime.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse);
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> Query.Pair ("SpotFleetRequestId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.last_evaluated_time
             (fun f ->
                Query.Pair ("LastEvaluatedTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("HistoryRecordSet",
                  (HistoryRecords.to_query v.history_records)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.start_time
              (fun f -> ("start_time", (DateTime.to_json f)));
           Util.option_map v.spot_fleet_request_id
             (fun f -> ("spot_fleet_request_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.last_evaluated_time
             (fun f -> ("last_evaluated_time", (DateTime.to_json f)));
           Some
             ("history_records", (HistoryRecords.to_json v.history_records))])
    let of_json j =
      {
        history_records =
          (HistoryRecords.of_json
             (Util.of_option_exn (Json.lookup j "history_records")));
        last_evaluated_time =
          (Util.option_map (Json.lookup j "last_evaluated_time")
             DateTime.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json);
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json)
      }
  end
module CancelReservedInstancesListingRequest =
  struct
    type t = {
      reserved_instances_listing_id: String.t }
    let make ~reserved_instances_listing_id  () =
      { reserved_instances_listing_id }
    let parse xml =
      Some
        {
          reserved_instances_listing_id =
            (Xml.required "reservedInstancesListingId"
               (Util.option_bind
                  (Xml.member "reservedInstancesListingId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingId",
                   (String.to_query v.reserved_instances_listing_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listing_id",
                (String.to_json v.reserved_instances_listing_id))])
    let of_json j =
      {
        reserved_instances_listing_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listing_id")))
      }
  end
module DescribeFpgaImagesResult =
  struct
    type t = {
      fpga_images: FpgaImageList.t ;
      next_token: String.t option }
    let make ?(fpga_images= [])  ?next_token  () =
      { fpga_images; next_token }
    let parse xml =
      Some
        {
          fpga_images =
            (Util.of_option []
               (Util.option_bind (Xml.member "fpgaImageSet" xml)
                  FpgaImageList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FpgaImageSet", (FpgaImageList.to_query v.fpga_images)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("fpga_images", (FpgaImageList.to_json v.fpga_images))])
    let of_json j =
      {
        fpga_images =
          (FpgaImageList.of_json
             (Util.of_option_exn (Json.lookup j "fpga_images")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSnapshotsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      owner_ids: OwnerStringList.t ;
      restorable_by_user_ids: RestorableByStringList.t ;
      snapshot_ids: SnapshotIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?(owner_ids= []) 
      ?(restorable_by_user_ids= [])  ?(snapshot_ids= [])  ?dry_run  () =
      {
        filters;
        max_results;
        next_token;
        owner_ids;
        restorable_by_user_ids;
        snapshot_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          owner_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          restorable_by_user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RestorableBy" xml)
                  RestorableByStringList.parse));
          snapshot_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SnapshotId" xml)
                  SnapshotIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SnapshotId",
                  (SnapshotIdStringList.to_query v.snapshot_ids)));
           Some
             (Query.Pair
                ("RestorableBy",
                  (RestorableByStringList.to_query v.restorable_by_user_ids)));
           Some
             (Query.Pair ("Owner", (OwnerStringList.to_query v.owner_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("snapshot_ids", (SnapshotIdStringList.to_json v.snapshot_ids));
           Some
             ("restorable_by_user_ids",
               (RestorableByStringList.to_json v.restorable_by_user_ids));
           Some ("owner_ids", (OwnerStringList.to_json v.owner_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        owner_ids =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owner_ids")));
        restorable_by_user_ids =
          (RestorableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "restorable_by_user_ids")));
        snapshot_ids =
          (SnapshotIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyAvailabilityZoneGroupRequest =
  struct
    type t =
      {
      group_name: String.t ;
      opt_in_status: ModifyAvailabilityZoneOptInStatus.t ;
      dry_run: Boolean.t option }
    let make ~group_name  ~opt_in_status  ?dry_run  () =
      { group_name; opt_in_status; dry_run }
    let parse xml =
      Some
        {
          group_name =
            (Xml.required "GroupName"
               (Util.option_bind (Xml.member "GroupName" xml) String.parse));
          opt_in_status =
            (Xml.required "OptInStatus"
               (Util.option_bind (Xml.member "OptInStatus" xml)
                  ModifyAvailabilityZoneOptInStatus.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("OptInStatus",
                  (ModifyAvailabilityZoneOptInStatus.to_query v.opt_in_status)));
           Some (Query.Pair ("GroupName", (String.to_query v.group_name)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("opt_in_status",
               (ModifyAvailabilityZoneOptInStatus.to_json v.opt_in_status));
           Some ("group_name", (String.to_json v.group_name))])
    let of_json j =
      {
        group_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "group_name")));
        opt_in_status =
          (ModifyAvailabilityZoneOptInStatus.of_json
             (Util.of_option_exn (Json.lookup j "opt_in_status")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstanceMetadataOptionsRequest =
  struct
    type t =
      {
      instance_id: String.t ;
      http_tokens: HttpTokensState.t option ;
      http_put_response_hop_limit: Integer.t option ;
      http_endpoint: InstanceMetadataEndpointState.t option ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?http_tokens  ?http_put_response_hop_limit 
      ?http_endpoint  ?dry_run  () =
      {
        instance_id;
        http_tokens;
        http_put_response_hop_limit;
        http_endpoint;
        dry_run
      }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          http_tokens =
            (Util.option_bind (Xml.member "HttpTokens" xml)
               HttpTokensState.parse);
          http_put_response_hop_limit =
            (Util.option_bind (Xml.member "HttpPutResponseHopLimit" xml)
               Integer.parse);
          http_endpoint =
            (Util.option_bind (Xml.member "HttpEndpoint" xml)
               InstanceMetadataEndpointState.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.http_endpoint
             (fun f ->
                Query.Pair
                  ("HttpEndpoint",
                    (InstanceMetadataEndpointState.to_query f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f ->
                Query.Pair ("HttpPutResponseHopLimit", (Integer.to_query f)));
           Util.option_map v.http_tokens
             (fun f ->
                Query.Pair ("HttpTokens", (HttpTokensState.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.http_endpoint
             (fun f ->
                ("http_endpoint", (InstanceMetadataEndpointState.to_json f)));
           Util.option_map v.http_put_response_hop_limit
             (fun f -> ("http_put_response_hop_limit", (Integer.to_json f)));
           Util.option_map v.http_tokens
             (fun f -> ("http_tokens", (HttpTokensState.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        http_tokens =
          (Util.option_map (Json.lookup j "http_tokens")
             HttpTokensState.of_json);
        http_put_response_hop_limit =
          (Util.option_map (Json.lookup j "http_put_response_hop_limit")
             Integer.of_json);
        http_endpoint =
          (Util.option_map (Json.lookup j "http_endpoint")
             InstanceMetadataEndpointState.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclEntryRequest =
  struct
    type t =
      {
      cidr_block: String.t option ;
      dry_run: Boolean.t option ;
      egress: Boolean.t ;
      icmp_type_code: IcmpTypeCode.t option ;
      ipv6_cidr_block: String.t option ;
      network_acl_id: String.t ;
      port_range: PortRange.t option ;
      protocol: String.t ;
      rule_action: RuleAction.t ;
      rule_number: Integer.t }
    let make ?cidr_block  ?dry_run  ~egress  ?icmp_type_code 
      ?ipv6_cidr_block  ~network_acl_id  ?port_range  ~protocol  ~rule_action
       ~rule_number  () =
      {
        cidr_block;
        dry_run;
        egress;
        icmp_type_code;
        ipv6_cidr_block;
        network_acl_id;
        port_range;
        protocol;
        rule_action;
        rule_number
      }
    let parse xml =
      Some
        {
          cidr_block =
            (Util.option_bind (Xml.member "cidrBlock" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          egress =
            (Xml.required "egress"
               (Util.option_bind (Xml.member "egress" xml) Boolean.parse));
          icmp_type_code =
            (Util.option_bind (Xml.member "Icmp" xml) IcmpTypeCode.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "ipv6CidrBlock" xml) String.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse));
          port_range =
            (Util.option_bind (Xml.member "portRange" xml) PortRange.parse);
          protocol =
            (Xml.required "protocol"
               (Util.option_bind (Xml.member "protocol" xml) String.parse));
          rule_action =
            (Xml.required "ruleAction"
               (Util.option_bind (Xml.member "ruleAction" xml)
                  RuleAction.parse));
          rule_number =
            (Xml.required "ruleNumber"
               (Util.option_bind (Xml.member "ruleNumber" xml) Integer.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("RuleNumber", (Integer.to_query v.rule_number)));
           Some
             (Query.Pair ("RuleAction", (RuleAction.to_query v.rule_action)));
           Some (Query.Pair ("Protocol", (String.to_query v.protocol)));
           Util.option_map v.port_range
             (fun f -> Query.Pair ("PortRange", (PortRange.to_query f)));
           Some
             (Query.Pair ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.ipv6_cidr_block
             (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.icmp_type_code
             (fun f -> Query.Pair ("Icmp", (IcmpTypeCode.to_query f)));
           Some (Query.Pair ("Egress", (Boolean.to_query v.egress)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("rule_number", (Integer.to_json v.rule_number));
           Some ("rule_action", (RuleAction.to_json v.rule_action));
           Some ("protocol", (String.to_json v.protocol));
           Util.option_map v.port_range
             (fun f -> ("port_range", (PortRange.to_json f)));
           Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.ipv6_cidr_block
             (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.icmp_type_code
             (fun f -> ("icmp_type_code", (IcmpTypeCode.to_json f)));
           Some ("egress", (Boolean.to_json v.egress));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)))])
    let of_json j =
      {
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress =
          (Boolean.of_json (Util.of_option_exn (Json.lookup j "egress")));
        icmp_type_code =
          (Util.option_map (Json.lookup j "icmp_type_code")
             IcmpTypeCode.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")));
        port_range =
          (Util.option_map (Json.lookup j "port_range") PortRange.of_json);
        protocol =
          (String.of_json (Util.of_option_exn (Json.lookup j "protocol")));
        rule_action =
          (RuleAction.of_json
             (Util.of_option_exn (Json.lookup j "rule_action")));
        rule_number =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "rule_number")))
      }
  end
module UnassignIpv6AddressesResult =
  struct
    type t =
      {
      network_interface_id: String.t option ;
      unassigned_ipv6_addresses: Ipv6AddressList.t }
    let make ?network_interface_id  ?(unassigned_ipv6_addresses= [])  () =
      { network_interface_id; unassigned_ipv6_addresses }
    let parse xml =
      Some
        {
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          unassigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "unassignedIpv6Addresses" xml)
                  Ipv6AddressList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnassignedIpv6Addresses",
                   (Ipv6AddressList.to_query v.unassigned_ipv6_addresses)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unassigned_ipv6_addresses",
                (Ipv6AddressList.to_json v.unassigned_ipv6_addresses));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)))])
    let of_json j =
      {
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        unassigned_ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "unassigned_ipv6_addresses")))
      }
  end
module DescribeFlowLogsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filter: FilterList.t ;
      flow_log_ids: FlowLogIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filter= [])  ?(flow_log_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filter; flow_log_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          flow_log_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  FlowLogIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("FlowLogId", (FlowLogIdList.to_query v.flow_log_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("flow_log_ids", (FlowLogIdList.to_json v.flow_log_ids));
           Some ("filter", (FilterList.to_json v.filter));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        flow_log_ids =
          (FlowLogIdList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableFastSnapshotRestoresResult =
  struct
    type t =
      {
      successful: EnableFastSnapshotRestoreSuccessSet.t ;
      unsuccessful: EnableFastSnapshotRestoreErrorSet.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  EnableFastSnapshotRestoreSuccessSet.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  EnableFastSnapshotRestoreErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (EnableFastSnapshotRestoreErrorSet.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful",
                  (EnableFastSnapshotRestoreSuccessSet.to_query v.successful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful",
                (EnableFastSnapshotRestoreErrorSet.to_json v.unsuccessful));
           Some
             ("successful",
               (EnableFastSnapshotRestoreSuccessSet.to_json v.successful))])
    let of_json j =
      {
        successful =
          (EnableFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (EnableFastSnapshotRestoreErrorSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AssignPrivateIpAddressesRequest =
  struct
    type t =
      {
      allow_reassignment: Boolean.t option ;
      network_interface_id: String.t ;
      private_ip_addresses: PrivateIpAddressStringList.t ;
      secondary_private_ip_address_count: Integer.t option }
    let make ?allow_reassignment  ~network_interface_id 
      ?(private_ip_addresses= [])  ?secondary_private_ip_address_count  () =
      {
        allow_reassignment;
        network_interface_id;
        private_ip_addresses;
        secondary_private_ip_address_count
      }
    let parse xml =
      Some
        {
          allow_reassignment =
            (Util.option_bind (Xml.member "allowReassignment" xml)
               Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddress" xml)
                  PrivateIpAddressStringList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.secondary_private_ip_address_count
              (fun f ->
                 Query.Pair
                   ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddress",
                  (PrivateIpAddressStringList.to_query v.private_ip_addresses)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Util.option_map v.allow_reassignment
             (fun f -> Query.Pair ("AllowReassignment", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.secondary_private_ip_address_count
              (fun f ->
                 ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressStringList.to_json v.private_ip_addresses));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Util.option_map v.allow_reassignment
             (fun f -> ("allow_reassignment", (Boolean.to_json f)))])
    let of_json j =
      {
        allow_reassignment =
          (Util.option_map (Json.lookup j "allow_reassignment")
             Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        private_ip_addresses =
          (PrivateIpAddressStringList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json)
      }
  end
module EnableTransitGatewayRouteTablePropagationRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RunScheduledInstancesResult =
  struct
    type t = {
      instance_id_set: InstanceIdSet.t }
    let make ?(instance_id_set= [])  () = { instance_id_set }
    let parse xml =
      Some
        {
          instance_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceIdSet" xml)
                  InstanceIdSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceIdSet",
                   (InstanceIdSet.to_query v.instance_id_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_id_set", (InstanceIdSet.to_json v.instance_id_set))])
    let of_json j =
      {
        instance_id_set =
          (InstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_id_set")))
      }
  end
module DescribeStaleSecurityGroupsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      vpc_id: String.t }
    let make ?dry_run  ?max_results  ?next_token  ~vpc_id  () =
      { dry_run; max_results; next_token; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeRouteTablesResult =
  struct
    type t = {
      route_tables: RouteTableList.t ;
      next_token: String.t option }
    let make ?(route_tables= [])  ?next_token  () =
      { route_tables; next_token }
    let parse xml =
      Some
        {
          route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeTableSet" xml)
                  RouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableSet", (RouteTableList.to_query v.route_tables)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("route_tables", (RouteTableList.to_json v.route_tables))])
    let of_json j =
      {
        route_tables =
          (RouteTableList.of_json
             (Util.of_option_exn (Json.lookup j "route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotDatafeedSubscriptionRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSnapshotAttributeResult =
  struct
    type t =
      {
      create_volume_permissions: CreateVolumePermissionList.t ;
      product_codes: ProductCodeList.t ;
      snapshot_id: String.t option }
    let make ?(create_volume_permissions= [])  ?(product_codes= []) 
      ?snapshot_id  () =
      { create_volume_permissions; product_codes; snapshot_id }
    let parse xml =
      Some
        {
          create_volume_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "createVolumePermission" xml)
                  CreateVolumePermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          snapshot_id =
            (Util.option_bind (Xml.member "snapshotId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("CreateVolumePermission",
                  (CreateVolumePermissionList.to_query
                     v.create_volume_permissions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.snapshot_id
              (fun f -> ("snapshot_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("create_volume_permissions",
               (CreateVolumePermissionList.to_json
                  v.create_volume_permissions))])
    let of_json j =
      {
        create_volume_permissions =
          (CreateVolumePermissionList.of_json
             (Util.of_option_exn (Json.lookup j "create_volume_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json)
      }
  end
module WithdrawByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module DeleteTransitGatewayResult =
  struct
    type t = {
      transit_gateway: TransitGateway.t option }
    let make ?transit_gateway  () = { transit_gateway }
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let of_json j =
      {
        transit_gateway =
          (Util.option_map (Json.lookup j "transit_gateway")
             TransitGateway.of_json)
      }
  end
module DisassociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option ;
      subnet_id: String.t option }
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             SubnetIpv6CidrBlockAssociation.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module ModifyVpcEndpointConnectionNotificationResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module DescribeLocalGatewayRouteTableVirtualInterfaceGroupAssociationsRequest =
  struct
    type t =
      {
      local_gateway_route_table_virtual_interface_group_association_ids:
        LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make
      ?(local_gateway_route_table_virtual_interface_group_association_ids=
      [])  ?(filters= [])  ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_route_table_virtual_interface_group_association_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_route_table_virtual_interface_group_association_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member
                     "LocalGatewayRouteTableVirtualInterfaceGroupAssociationId"
                     xml)
                  LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayRouteTableVirtualInterfaceGroupAssociationId",
                  (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_query
                     v.local_gateway_route_table_virtual_interface_group_association_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_route_table_virtual_interface_group_association_ids",
               (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.to_json
                  v.local_gateway_route_table_virtual_interface_group_association_ids))])
    let of_json j =
      {
        local_gateway_route_table_virtual_interface_group_association_ids =
          (LocalGatewayRouteTableVirtualInterfaceGroupAssociationIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "local_gateway_route_table_virtual_interface_group_association_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReleaseHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t ;
      unsuccessful: UnsuccessfulItemList.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let of_json j =
      {
        successful =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (UnsuccessfulItemList.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module EnableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CreateDefaultSubnetRequest =
  struct
    type t = {
      availability_zone: String.t ;
      dry_run: Boolean.t option }
    let make ~availability_zone  ?dry_run  () =
      { availability_zone; dry_run }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateNetworkInterfacePermissionRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      aws_account_id: String.t option ;
      aws_service: String.t option ;
      permission: InterfacePermissionType.t ;
      dry_run: Boolean.t option }
    let make ~network_interface_id  ?aws_account_id  ?aws_service 
      ~permission  ?dry_run  () =
      {
        network_interface_id;
        aws_account_id;
        aws_service;
        permission;
        dry_run
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "NetworkInterfaceId"
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  String.parse));
          aws_account_id =
            (Util.option_bind (Xml.member "AwsAccountId" xml) String.parse);
          aws_service =
            (Util.option_bind (Xml.member "AwsService" xml) String.parse);
          permission =
            (Xml.required "Permission"
               (Util.option_bind (Xml.member "Permission" xml)
                  InterfacePermissionType.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("Permission",
                  (InterfacePermissionType.to_query v.permission)));
           Util.option_map v.aws_service
             (fun f -> Query.Pair ("AwsService", (String.to_query f)));
           Util.option_map v.aws_account_id
             (fun f -> Query.Pair ("AwsAccountId", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("permission", (InterfacePermissionType.to_json v.permission));
           Util.option_map v.aws_service
             (fun f -> ("aws_service", (String.to_json f)));
           Util.option_map v.aws_account_id
             (fun f -> ("aws_account_id", (String.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        aws_account_id =
          (Util.option_map (Json.lookup j "aws_account_id") String.of_json);
        aws_service =
          (Util.option_map (Json.lookup j "aws_service") String.of_json);
        permission =
          (InterfacePermissionType.of_json
             (Util.of_option_exn (Json.lookup j "permission")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseReservedInstancesOfferingResult =
  struct
    type t = {
      reserved_instances_id: String.t option }
    let make ?reserved_instances_id  () = { reserved_instances_id }
    let parse xml =
      Some
        {
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f ->
                 Query.Pair ("ReservedInstancesId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_id
              (fun f -> ("reserved_instances_id", (String.to_json f)))])
    let of_json j =
      {
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json)
      }
  end
module ModifyVpcAttributeRequest =
  struct
    type t =
      {
      enable_dns_hostnames: AttributeBooleanValue.t option ;
      enable_dns_support: AttributeBooleanValue.t option ;
      vpc_id: String.t }
    let make ?enable_dns_hostnames  ?enable_dns_support  ~vpc_id  () =
      { enable_dns_hostnames; enable_dns_support; vpc_id }
    let parse xml =
      Some
        {
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "EnableDnsHostnames" xml)
               AttributeBooleanValue.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "EnableDnsSupport" xml)
               AttributeBooleanValue.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.enable_dns_support
             (fun f ->
                Query.Pair
                  ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                Query.Pair
                  ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.enable_dns_support
             (fun f ->
                ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json);
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module RejectVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DescribeIamInstanceProfileAssociationsResult =
  struct
    type t =
      {
      iam_instance_profile_associations: IamInstanceProfileAssociationSet.t ;
      next_token: String.t option }
    let make ?(iam_instance_profile_associations= [])  ?next_token  () =
      { iam_instance_profile_associations; next_token }
    let parse xml =
      Some
        {
          iam_instance_profile_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "iamInstanceProfileAssociationSet" xml)
                  IamInstanceProfileAssociationSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("IamInstanceProfileAssociationSet",
                  (IamInstanceProfileAssociationSet.to_query
                     v.iam_instance_profile_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("iam_instance_profile_associations",
               (IamInstanceProfileAssociationSet.to_json
                  v.iam_instance_profile_associations))])
    let of_json j =
      {
        iam_instance_profile_associations =
          (IamInstanceProfileAssociationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "iam_instance_profile_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module TerminateInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateRouteResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteVpcEndpointsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DescribeLaunchTemplateVersionsResult =
  struct
    type t =
      {
      launch_template_versions: LaunchTemplateVersionSet.t ;
      next_token: String.t option }
    let make ?(launch_template_versions= [])  ?next_token  () =
      { launch_template_versions; next_token }
    let parse xml =
      Some
        {
          launch_template_versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchTemplateVersionSet" xml)
                  LaunchTemplateVersionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateVersionSet",
                  (LaunchTemplateVersionSet.to_query
                     v.launch_template_versions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("launch_template_versions",
               (LaunchTemplateVersionSet.to_json v.launch_template_versions))])
    let of_json j =
      {
        launch_template_versions =
          (LaunchTemplateVersionSet.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_versions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeCarrierGatewaysResult =
  struct
    type t =
      {
      carrier_gateways: CarrierGatewaySet.t ;
      next_token: String.t option }
    let make ?(carrier_gateways= [])  ?next_token  () =
      { carrier_gateways; next_token }
    let parse xml =
      Some
        {
          carrier_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "carrierGatewaySet" xml)
                  CarrierGatewaySet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("CarrierGatewaySet",
                  (CarrierGatewaySet.to_query v.carrier_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("carrier_gateways",
               (CarrierGatewaySet.to_json v.carrier_gateways))])
    let of_json j =
      {
        carrier_gateways =
          (CarrierGatewaySet.of_json
             (Util.of_option_exn (Json.lookup j "carrier_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetGroupsForCapacityReservationResult =
  struct
    type t =
      {
      next_token: String.t option ;
      capacity_reservation_groups: CapacityReservationGroupSet.t }
    let make ?next_token  ?(capacity_reservation_groups= [])  () =
      { next_token; capacity_reservation_groups }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservation_groups =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "capacityReservationGroupSet" xml)
                  CapacityReservationGroupSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CapacityReservationGroupSet",
                   (CapacityReservationGroupSet.to_query
                      v.capacity_reservation_groups)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("capacity_reservation_groups",
                (CapacityReservationGroupSet.to_json
                   v.capacity_reservation_groups));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        capacity_reservation_groups =
          (CapacityReservationGroupSet.of_json
             (Util.of_option_exn
                (Json.lookup j "capacity_reservation_groups")))
      }
  end
module CreatePlacementGroupResult =
  struct
    type t = {
      placement_group: PlacementGroup.t option }
    let make ?placement_group  () = { placement_group }
    let parse xml =
      Some
        {
          placement_group =
            (Util.option_bind (Xml.member "placementGroup" xml)
               PlacementGroup.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.placement_group
              (fun f ->
                 Query.Pair ("PlacementGroup", (PlacementGroup.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.placement_group
              (fun f -> ("placement_group", (PlacementGroup.to_json f)))])
    let of_json j =
      {
        placement_group =
          (Util.option_map (Json.lookup j "placement_group")
             PlacementGroup.of_json)
      }
  end
module CreateVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_type: VpcEndpointType.t option ;
      vpc_id: String.t ;
      service_name: String.t ;
      policy_document: String.t option ;
      route_table_ids: VpcEndpointRouteTableIdList.t ;
      subnet_ids: VpcEndpointSubnetIdList.t ;
      security_group_ids: VpcEndpointSecurityGroupIdList.t ;
      client_token: String.t option ;
      private_dns_enabled: Boolean.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?vpc_endpoint_type  ~vpc_id  ~service_name 
      ?policy_document  ?(route_table_ids= [])  ?(subnet_ids= []) 
      ?(security_group_ids= [])  ?client_token  ?private_dns_enabled 
      ?(tag_specifications= [])  () =
      {
        dry_run;
        vpc_endpoint_type;
        vpc_id;
        service_name;
        policy_document;
        route_table_ids;
        subnet_ids;
        security_group_ids;
        client_token;
        private_dns_enabled;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_type =
            (Util.option_bind (Xml.member "VpcEndpointType" xml)
               VpcEndpointType.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          service_name =
            (Xml.required "ServiceName"
               (Util.option_bind (Xml.member "ServiceName" xml) String.parse));
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  VpcEndpointRouteTableIdList.parse));
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetId" xml)
                  VpcEndpointSubnetIdList.parse));
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  VpcEndpointSecurityGroupIdList.parse));
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          private_dns_enabled =
            (Util.option_bind (Xml.member "PrivateDnsEnabled" xml)
               Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.private_dns_enabled
             (fun f -> Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (VpcEndpointSecurityGroupIdList.to_query
                     v.security_group_ids)));
           Some
             (Query.Pair
                ("SubnetId", (VpcEndpointSubnetIdList.to_query v.subnet_ids)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (VpcEndpointRouteTableIdList.to_query v.route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Some
             (Query.Pair ("ServiceName", (String.to_query v.service_name)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.vpc_endpoint_type
             (fun f ->
                Query.Pair ("VpcEndpointType", (VpcEndpointType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.private_dns_enabled
             (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Some
             ("security_group_ids",
               (VpcEndpointSecurityGroupIdList.to_json v.security_group_ids));
           Some
             ("subnet_ids", (VpcEndpointSubnetIdList.to_json v.subnet_ids));
           Some
             ("route_table_ids",
               (VpcEndpointRouteTableIdList.to_json v.route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Some ("service_name", (String.to_json v.service_name));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.vpc_endpoint_type
             (fun f -> ("vpc_endpoint_type", (VpcEndpointType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_type =
          (Util.option_map (Json.lookup j "vpc_endpoint_type")
             VpcEndpointType.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        service_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_name")));
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        route_table_ids =
          (VpcEndpointRouteTableIdList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        subnet_ids =
          (VpcEndpointSubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        security_group_ids =
          (VpcEndpointSecurityGroupIdList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DeleteDhcpOptionsRequest =
  struct
    type t = {
      dhcp_options_id: String.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_options_id  ?dry_run  () = { dhcp_options_id; dry_run }
    let parse xml =
      Some
        {
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id))])
    let of_json j =
      {
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptTransitGatewayPeeringAttachmentResult =
  struct
    type t =
      {
      transit_gateway_peering_attachment:
        TransitGatewayPeeringAttachment.t option }
    let make ?transit_gateway_peering_attachment  () =
      { transit_gateway_peering_attachment }
    let parse xml =
      Some
        {
          transit_gateway_peering_attachment =
            (Util.option_bind
               (Xml.member "transitGatewayPeeringAttachment" xml)
               TransitGatewayPeeringAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPeeringAttachment",
                     (TransitGatewayPeeringAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_peering_attachment
              (fun f ->
                 ("transit_gateway_peering_attachment",
                   (TransitGatewayPeeringAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_peering_attachment =
          (Util.option_map
             (Json.lookup j "transit_gateway_peering_attachment")
             TransitGatewayPeeringAttachment.of_json)
      }
  end
module DescribeVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token  () =
      { dry_run; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeTransitGatewayPeeringAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module SearchTransitGatewayMulticastGroupsResult =
  struct
    type t =
      {
      multicast_groups: TransitGatewayMulticastGroupList.t ;
      next_token: String.t option }
    let make ?(multicast_groups= [])  ?next_token  () =
      { multicast_groups; next_token }
    let parse xml =
      Some
        {
          multicast_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "multicastGroups" xml)
                  TransitGatewayMulticastGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastGroups",
                  (TransitGatewayMulticastGroupList.to_query
                     v.multicast_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_groups",
               (TransitGatewayMulticastGroupList.to_json v.multicast_groups))])
    let of_json j =
      {
        multicast_groups =
          (TransitGatewayMulticastGroupList.of_json
             (Util.of_option_exn (Json.lookup j "multicast_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeScheduledInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      scheduled_instance_ids: ScheduledInstanceIdRequestSet.t ;
      slot_start_time_range: SlotStartTimeRangeRequest.t option }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token 
      ?(scheduled_instance_ids= [])  ?slot_start_time_range  () =
      {
        dry_run;
        filters;
        max_results;
        next_token;
        scheduled_instance_ids;
        slot_start_time_range
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          scheduled_instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ScheduledInstanceId" xml)
                  ScheduledInstanceIdRequestSet.parse));
          slot_start_time_range =
            (Util.option_bind (Xml.member "SlotStartTimeRange" xml)
               SlotStartTimeRangeRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.slot_start_time_range
              (fun f ->
                 Query.Pair
                   ("SlotStartTimeRange",
                     (SlotStartTimeRangeRequest.to_query f)));
           Some
             (Query.Pair
                ("ScheduledInstanceId",
                  (ScheduledInstanceIdRequestSet.to_query
                     v.scheduled_instance_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.slot_start_time_range
              (fun f ->
                 ("slot_start_time_range",
                   (SlotStartTimeRangeRequest.to_json f)));
           Some
             ("scheduled_instance_ids",
               (ScheduledInstanceIdRequestSet.to_json
                  v.scheduled_instance_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_ids =
          (ScheduledInstanceIdRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_ids")));
        slot_start_time_range =
          (Util.option_map (Json.lookup j "slot_start_time_range")
             SlotStartTimeRangeRequest.of_json)
      }
  end
module DeleteSecurityGroupRequest =
  struct
    type t =
      {
      group_id: String.t option ;
      group_name: String.t option ;
      dry_run: Boolean.t option }
    let make ?group_id  ?group_name  ?dry_run  () =
      { group_id; group_name; dry_run }
    let parse xml =
      Some
        {
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)))])
    let of_json j =
      {
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeLocalGatewayVirtualInterfacesResult =
  struct
    type t =
      {
      local_gateway_virtual_interfaces: LocalGatewayVirtualInterfaceSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_virtual_interfaces= [])  ?next_token  () =
      { local_gateway_virtual_interfaces; next_token }
    let parse xml =
      Some
        {
          local_gateway_virtual_interfaces =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceSet" xml)
                  LocalGatewayVirtualInterfaceSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceSet",
                  (LocalGatewayVirtualInterfaceSet.to_query
                     v.local_gateway_virtual_interfaces)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interfaces",
               (LocalGatewayVirtualInterfaceSet.to_json
                  v.local_gateway_virtual_interfaces))])
    let of_json j =
      {
        local_gateway_virtual_interfaces =
          (LocalGatewayVirtualInterfaceSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interfaces")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteEgressOnlyInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_id: String.t }
    let make ?dry_run  ~egress_only_internet_gateway_id  () =
      { dry_run; egress_only_internet_gateway_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          egress_only_internet_gateway_id =
            (Xml.required "EgressOnlyInternetGatewayId"
               (Util.option_bind
                  (Xml.member "EgressOnlyInternetGatewayId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("EgressOnlyInternetGatewayId",
                   (String.to_query v.egress_only_internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("egress_only_internet_gateway_id",
                (String.to_json v.egress_only_internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateway_id")))
      }
  end
module RunInstancesRequest =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingRequestList.t ;
      image_id: String.t option ;
      instance_type: InstanceType.t option ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      kernel_id: String.t option ;
      key_name: String.t option ;
      max_count: Integer.t ;
      min_count: Integer.t ;
      monitoring: RunInstancesMonitoringEnabled.t option ;
      placement: Placement.t option ;
      ramdisk_id: String.t option ;
      security_group_ids: SecurityGroupIdStringList.t ;
      security_groups: SecurityGroupStringList.t ;
      subnet_id: String.t option ;
      user_data: String.t option ;
      additional_info: String.t option ;
      client_token: String.t option ;
      disable_api_termination: Boolean.t option ;
      dry_run: Boolean.t option ;
      ebs_optimized: Boolean.t option ;
      iam_instance_profile: IamInstanceProfileSpecification.t option ;
      instance_initiated_shutdown_behavior: ShutdownBehavior.t option ;
      network_interfaces: InstanceNetworkInterfaceSpecificationList.t ;
      private_ip_address: String.t option ;
      elastic_gpu_specification: ElasticGpuSpecifications.t ;
      elastic_inference_accelerators: ElasticInferenceAccelerators.t ;
      tag_specifications: TagSpecificationList.t ;
      launch_template: LaunchTemplateSpecification.t option ;
      instance_market_options: InstanceMarketOptionsRequest.t option ;
      credit_specification: CreditSpecificationRequest.t option ;
      cpu_options: CpuOptionsRequest.t option ;
      capacity_reservation_specification:
        CapacityReservationSpecification.t option ;
      hibernation_options: HibernationOptionsRequest.t option ;
      license_specifications: LicenseSpecificationListRequest.t ;
      metadata_options: InstanceMetadataOptionsRequest.t option ;
      enclave_options: EnclaveOptionsRequest.t option }
    let make ?(block_device_mappings= [])  ?image_id  ?instance_type 
      ?ipv6_address_count  ?(ipv6_addresses= [])  ?kernel_id  ?key_name 
      ~max_count  ~min_count  ?monitoring  ?placement  ?ramdisk_id 
      ?(security_group_ids= [])  ?(security_groups= [])  ?subnet_id 
      ?user_data  ?additional_info  ?client_token  ?disable_api_termination 
      ?dry_run  ?ebs_optimized  ?iam_instance_profile 
      ?instance_initiated_shutdown_behavior  ?(network_interfaces= []) 
      ?private_ip_address  ?(elastic_gpu_specification= []) 
      ?(elastic_inference_accelerators= [])  ?(tag_specifications= []) 
      ?launch_template  ?instance_market_options  ?credit_specification 
      ?cpu_options  ?capacity_reservation_specification  ?hibernation_options
       ?(license_specifications= [])  ?metadata_options  ?enclave_options  ()
      =
      {
        block_device_mappings;
        image_id;
        instance_type;
        ipv6_address_count;
        ipv6_addresses;
        kernel_id;
        key_name;
        max_count;
        min_count;
        monitoring;
        placement;
        ramdisk_id;
        security_group_ids;
        security_groups;
        subnet_id;
        user_data;
        additional_info;
        client_token;
        disable_api_termination;
        dry_run;
        ebs_optimized;
        iam_instance_profile;
        instance_initiated_shutdown_behavior;
        network_interfaces;
        private_ip_address;
        elastic_gpu_specification;
        elastic_inference_accelerators;
        tag_specifications;
        launch_template;
        instance_market_options;
        credit_specification;
        cpu_options;
        capacity_reservation_specification;
        hibernation_options;
        license_specifications;
        metadata_options;
        enclave_options
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "BlockDeviceMapping" xml)
                  BlockDeviceMappingRequestList.parse));
          image_id =
            (Util.option_bind (Xml.member "ImageId" xml) String.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          ipv6_address_count =
            (Util.option_bind (Xml.member "Ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "Ipv6Address" xml)
                  InstanceIpv6AddressList.parse));
          kernel_id =
            (Util.option_bind (Xml.member "KernelId" xml) String.parse);
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          max_count =
            (Xml.required "MaxCount"
               (Util.option_bind (Xml.member "MaxCount" xml) Integer.parse));
          min_count =
            (Xml.required "MinCount"
               (Util.option_bind (Xml.member "MinCount" xml) Integer.parse));
          monitoring =
            (Util.option_bind (Xml.member "Monitoring" xml)
               RunInstancesMonitoringEnabled.parse);
          placement =
            (Util.option_bind (Xml.member "Placement" xml) Placement.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "RamdiskId" xml) String.parse);
          security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroup" xml)
                  SecurityGroupStringList.parse));
          subnet_id =
            (Util.option_bind (Xml.member "SubnetId" xml) String.parse);
          user_data =
            (Util.option_bind (Xml.member "UserData" xml) String.parse);
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml) Boolean.parse);
          iam_instance_profile =
            (Util.option_bind (Xml.member "iamInstanceProfile" xml)
               IamInstanceProfileSpecification.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               ShutdownBehavior.parse);
          network_interfaces =
            (Util.of_option []
               (Util.option_bind (Xml.member "networkInterface" xml)
                  InstanceNetworkInterfaceSpecificationList.parse));
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          elastic_gpu_specification =
            (Util.of_option []
               (Util.option_bind (Xml.member "ElasticGpuSpecification" xml)
                  ElasticGpuSpecifications.parse));
          elastic_inference_accelerators =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ElasticInferenceAccelerator" xml)
                  ElasticInferenceAccelerators.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          launch_template =
            (Util.option_bind (Xml.member "LaunchTemplate" xml)
               LaunchTemplateSpecification.parse);
          instance_market_options =
            (Util.option_bind (Xml.member "InstanceMarketOptions" xml)
               InstanceMarketOptionsRequest.parse);
          credit_specification =
            (Util.option_bind (Xml.member "CreditSpecification" xml)
               CreditSpecificationRequest.parse);
          cpu_options =
            (Util.option_bind (Xml.member "CpuOptions" xml)
               CpuOptionsRequest.parse);
          capacity_reservation_specification =
            (Util.option_bind
               (Xml.member "CapacityReservationSpecification" xml)
               CapacityReservationSpecification.parse);
          hibernation_options =
            (Util.option_bind (Xml.member "HibernationOptions" xml)
               HibernationOptionsRequest.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecification" xml)
                  LicenseSpecificationListRequest.parse));
          metadata_options =
            (Util.option_bind (Xml.member "MetadataOptions" xml)
               InstanceMetadataOptionsRequest.parse);
          enclave_options =
            (Util.option_bind (Xml.member "EnclaveOptions" xml)
               EnclaveOptionsRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 Query.Pair
                   ("EnclaveOptions", (EnclaveOptionsRequest.to_query f)));
           Util.option_map v.metadata_options
             (fun f ->
                Query.Pair
                  ("MetadataOptions",
                    (InstanceMetadataOptionsRequest.to_query f)));
           Some
             (Query.Pair
                ("LicenseSpecification",
                  (LicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.hibernation_options
             (fun f ->
                Query.Pair
                  ("HibernationOptions",
                    (HibernationOptionsRequest.to_query f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                Query.Pair
                  ("CapacityReservationSpecification",
                    (CapacityReservationSpecification.to_query f)));
           Util.option_map v.cpu_options
             (fun f ->
                Query.Pair ("CpuOptions", (CpuOptionsRequest.to_query f)));
           Util.option_map v.credit_specification
             (fun f ->
                Query.Pair
                  ("CreditSpecification",
                    (CreditSpecificationRequest.to_query f)));
           Util.option_map v.instance_market_options
             (fun f ->
                Query.Pair
                  ("InstanceMarketOptions",
                    (InstanceMarketOptionsRequest.to_query f)));
           Util.option_map v.launch_template
             (fun f ->
                Query.Pair
                  ("LaunchTemplate",
                    (LaunchTemplateSpecification.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("ElasticInferenceAccelerator",
                  (ElasticInferenceAccelerators.to_query
                     v.elastic_inference_accelerators)));
           Some
             (Query.Pair
                ("ElasticGpuSpecification",
                  (ElasticGpuSpecifications.to_query
                     v.elastic_gpu_specification)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterface",
                  (InstanceNetworkInterfaceSpecificationList.to_query
                     v.network_interfaces)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (ShutdownBehavior.to_query f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                Query.Pair
                  ("IamInstanceProfile",
                    (IamInstanceProfileSpecification.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f -> Query.Pair ("EbsOptimized", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair ("DisableApiTermination", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Util.option_map v.user_data
             (fun f -> Query.Pair ("UserData", (String.to_query f)));
           Util.option_map v.subnet_id
             (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroup",
                  (SecurityGroupStringList.to_query v.security_groups)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.security_group_ids)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("RamdiskId", (String.to_query f)));
           Util.option_map v.placement
             (fun f -> Query.Pair ("Placement", (Placement.to_query f)));
           Util.option_map v.monitoring
             (fun f ->
                Query.Pair
                  ("Monitoring", (RunInstancesMonitoringEnabled.to_query f)));
           Some (Query.Pair ("MinCount", (Integer.to_query v.min_count)));
           Some (Query.Pair ("MaxCount", (Integer.to_query v.max_count)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("KernelId", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Address",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingRequestList.to_query
                     v.block_device_mappings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enclave_options
              (fun f ->
                 ("enclave_options", (EnclaveOptionsRequest.to_json f)));
           Util.option_map v.metadata_options
             (fun f ->
                ("metadata_options",
                  (InstanceMetadataOptionsRequest.to_json f)));
           Some
             ("license_specifications",
               (LicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.hibernation_options
             (fun f ->
                ("hibernation_options",
                  (HibernationOptionsRequest.to_json f)));
           Util.option_map v.capacity_reservation_specification
             (fun f ->
                ("capacity_reservation_specification",
                  (CapacityReservationSpecification.to_json f)));
           Util.option_map v.cpu_options
             (fun f -> ("cpu_options", (CpuOptionsRequest.to_json f)));
           Util.option_map v.credit_specification
             (fun f ->
                ("credit_specification",
                  (CreditSpecificationRequest.to_json f)));
           Util.option_map v.instance_market_options
             (fun f ->
                ("instance_market_options",
                  (InstanceMarketOptionsRequest.to_json f)));
           Util.option_map v.launch_template
             (fun f ->
                ("launch_template", (LaunchTemplateSpecification.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("elastic_inference_accelerators",
               (ElasticInferenceAccelerators.to_json
                  v.elastic_inference_accelerators));
           Some
             ("elastic_gpu_specification",
               (ElasticGpuSpecifications.to_json v.elastic_gpu_specification));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Some
             ("network_interfaces",
               (InstanceNetworkInterfaceSpecificationList.to_json
                  v.network_interfaces));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (ShutdownBehavior.to_json f)));
           Util.option_map v.iam_instance_profile
             (fun f ->
                ("iam_instance_profile",
                  (IamInstanceProfileSpecification.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f -> ("disable_api_termination", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Util.option_map v.user_data
             (fun f -> ("user_data", (String.to_json f)));
           Util.option_map v.subnet_id
             (fun f -> ("subnet_id", (String.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupStringList.to_json v.security_groups));
           Some
             ("security_group_ids",
               (SecurityGroupIdStringList.to_json v.security_group_ids));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (String.to_json f)));
           Util.option_map v.placement
             (fun f -> ("placement", (Placement.to_json f)));
           Util.option_map v.monitoring
             (fun f ->
                ("monitoring", (RunInstancesMonitoringEnabled.to_json f)));
           Some ("min_count", (Integer.to_json v.min_count));
           Some ("max_count", (Integer.to_json v.max_count));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingRequestList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingRequestList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") String.of_json);
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        max_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_count")));
        min_count =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "min_count")));
        monitoring =
          (Util.option_map (Json.lookup j "monitoring")
             RunInstancesMonitoringEnabled.of_json);
        placement =
          (Util.option_map (Json.lookup j "placement") Placement.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id") String.of_json);
        security_group_ids =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        security_groups =
          (SecurityGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") String.of_json);
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized") Boolean.of_json);
        iam_instance_profile =
          (Util.option_map (Json.lookup j "iam_instance_profile")
             IamInstanceProfileSpecification.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             ShutdownBehavior.of_json);
        network_interfaces =
          (InstanceNetworkInterfaceSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "network_interfaces")));
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        elastic_gpu_specification =
          (ElasticGpuSpecifications.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_specification")));
        elastic_inference_accelerators =
          (ElasticInferenceAccelerators.of_json
             (Util.of_option_exn
                (Json.lookup j "elastic_inference_accelerators")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplateSpecification.of_json);
        instance_market_options =
          (Util.option_map (Json.lookup j "instance_market_options")
             InstanceMarketOptionsRequest.of_json);
        credit_specification =
          (Util.option_map (Json.lookup j "credit_specification")
             CreditSpecificationRequest.of_json);
        cpu_options =
          (Util.option_map (Json.lookup j "cpu_options")
             CpuOptionsRequest.of_json);
        capacity_reservation_specification =
          (Util.option_map
             (Json.lookup j "capacity_reservation_specification")
             CapacityReservationSpecification.of_json);
        hibernation_options =
          (Util.option_map (Json.lookup j "hibernation_options")
             HibernationOptionsRequest.of_json);
        license_specifications =
          (LicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        metadata_options =
          (Util.option_map (Json.lookup j "metadata_options")
             InstanceMetadataOptionsRequest.of_json);
        enclave_options =
          (Util.option_map (Json.lookup j "enclave_options")
             EnclaveOptionsRequest.of_json)
      }
  end
module StartInstancesResult =
  struct
    type t = {
      starting_instances: InstanceStateChangeList.t }
    let make ?(starting_instances= [])  () = { starting_instances }
    let parse xml =
      Some
        {
          starting_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.starting_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("starting_instances",
                (InstanceStateChangeList.to_json v.starting_instances))])
    let of_json j =
      {
        starting_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "starting_instances")))
      }
  end
module DescribeLocalGatewayVirtualInterfaceGroupsResult =
  struct
    type t =
      {
      local_gateway_virtual_interface_groups:
        LocalGatewayVirtualInterfaceGroupSet.t ;
      next_token: String.t option }
    let make ?(local_gateway_virtual_interface_groups= [])  ?next_token  () =
      { local_gateway_virtual_interface_groups; next_token }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_groups =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "localGatewayVirtualInterfaceGroupSet" xml)
                  LocalGatewayVirtualInterfaceGroupSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupSet",
                  (LocalGatewayVirtualInterfaceGroupSet.to_query
                     v.local_gateway_virtual_interface_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateway_virtual_interface_groups",
               (LocalGatewayVirtualInterfaceGroupSet.to_json
                  v.local_gateway_virtual_interface_groups))])
    let of_json j =
      {
        local_gateway_virtual_interface_groups =
          (LocalGatewayVirtualInterfaceGroupSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module CreateTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module DescribeImagesRequest =
  struct
    type t =
      {
      executable_users: ExecutableByStringList.t ;
      filters: FilterList.t ;
      image_ids: ImageIdStringList.t ;
      owners: OwnerStringList.t ;
      dry_run: Boolean.t option }
    let make ?(executable_users= [])  ?(filters= [])  ?(image_ids= []) 
      ?(owners= [])  ?dry_run  () =
      { executable_users; filters; image_ids; owners; dry_run }
    let parse xml =
      Some
        {
          executable_users =
            (Util.of_option []
               (Util.option_bind (Xml.member "ExecutableBy" xml)
                  ExecutableByStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          image_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImageId" xml)
                  ImageIdStringList.parse));
          owners =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Owner", (OwnerStringList.to_query v.owners)));
           Some
             (Query.Pair
                ("ImageId", (ImageIdStringList.to_query v.image_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ExecutableBy",
                  (ExecutableByStringList.to_query v.executable_users)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("owners", (OwnerStringList.to_json v.owners));
           Some ("image_ids", (ImageIdStringList.to_json v.image_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("executable_users",
               (ExecutableByStringList.to_json v.executable_users))])
    let of_json j =
      {
        executable_users =
          (ExecutableByStringList.of_json
             (Util.of_option_exn (Json.lookup j "executable_users")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        image_ids =
          (ImageIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "image_ids")));
        owners =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owners")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceNetworkAclAssociationRequest =
  struct
    type t =
      {
      association_id: String.t ;
      dry_run: Boolean.t option ;
      network_acl_id: String.t }
    let make ~association_id  ?dry_run  ~network_acl_id  () =
      { association_id; dry_run; network_acl_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_id =
            (Xml.required "networkAclId"
               (Util.option_bind (Xml.member "networkAclId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkAclId", (String.to_query v.network_acl_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("network_acl_id", (String.to_json v.network_acl_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_id")))
      }
  end
module AssociateEnclaveCertificateIamRoleResult =
  struct
    type t =
      {
      certificate_s3_bucket_name: String.t option ;
      certificate_s3_object_key: String.t option ;
      encryption_kms_key_id: String.t option }
    let make ?certificate_s3_bucket_name  ?certificate_s3_object_key 
      ?encryption_kms_key_id  () =
      {
        certificate_s3_bucket_name;
        certificate_s3_object_key;
        encryption_kms_key_id
      }
    let parse xml =
      Some
        {
          certificate_s3_bucket_name =
            (Util.option_bind (Xml.member "certificateS3BucketName" xml)
               String.parse);
          certificate_s3_object_key =
            (Util.option_bind (Xml.member "certificateS3ObjectKey" xml)
               String.parse);
          encryption_kms_key_id =
            (Util.option_bind (Xml.member "encryptionKmsKeyId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.encryption_kms_key_id
              (fun f ->
                 Query.Pair ("EncryptionKmsKeyId", (String.to_query f)));
           Util.option_map v.certificate_s3_object_key
             (fun f ->
                Query.Pair ("CertificateS3ObjectKey", (String.to_query f)));
           Util.option_map v.certificate_s3_bucket_name
             (fun f ->
                Query.Pair ("CertificateS3BucketName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.encryption_kms_key_id
              (fun f -> ("encryption_kms_key_id", (String.to_json f)));
           Util.option_map v.certificate_s3_object_key
             (fun f -> ("certificate_s3_object_key", (String.to_json f)));
           Util.option_map v.certificate_s3_bucket_name
             (fun f -> ("certificate_s3_bucket_name", (String.to_json f)))])
    let of_json j =
      {
        certificate_s3_bucket_name =
          (Util.option_map (Json.lookup j "certificate_s3_bucket_name")
             String.of_json);
        certificate_s3_object_key =
          (Util.option_map (Json.lookup j "certificate_s3_object_key")
             String.of_json);
        encryption_kms_key_id =
          (Util.option_map (Json.lookup j "encryption_kms_key_id")
             String.of_json)
      }
  end
module DescribeVpcEndpointsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_ids: VpcEndpointIdList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(vpc_endpoint_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; vpc_endpoint_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  VpcEndpointIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("VpcEndpointId",
                  (VpcEndpointIdList.to_query v.vpc_endpoint_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("vpc_endpoint_ids",
               (VpcEndpointIdList.to_json v.vpc_endpoint_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_ids =
          (VpcEndpointIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVpcPeeringConnectionsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      vpc_peering_connection_ids: VpcPeeringConnectionIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(vpc_peering_connection_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; vpc_peering_connection_ids; next_token; max_results
      }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VpcPeeringConnectionId" xml)
                  VpcPeeringConnectionIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("VpcPeeringConnectionId",
                  (VpcPeeringConnectionIdList.to_query
                     v.vpc_peering_connection_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("vpc_peering_connection_ids",
               (VpcPeeringConnectionIdList.to_json
                  v.vpc_peering_connection_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_ids =
          (VpcPeeringConnectionIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DisassociateTransitGatewayRouteTableResult =
  struct
    type t = {
      association: TransitGatewayAssociation.t option }
    let make ?association  () = { association }
    let parse xml =
      Some
        {
          association =
            (Util.option_bind (Xml.member "association" xml)
               TransitGatewayAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 Query.Pair
                   ("Association", (TransitGatewayAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association
              (fun f ->
                 ("association", (TransitGatewayAssociation.to_json f)))])
    let of_json j =
      {
        association =
          (Util.option_map (Json.lookup j "association")
             TransitGatewayAssociation.of_json)
      }
  end
module DescribeMovingAddressesResult =
  struct
    type t =
      {
      moving_address_statuses: MovingAddressStatusSet.t ;
      next_token: String.t option }
    let make ?(moving_address_statuses= [])  ?next_token  () =
      { moving_address_statuses; next_token }
    let parse xml =
      Some
        {
          moving_address_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "movingAddressStatusSet" xml)
                  MovingAddressStatusSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MovingAddressStatusSet",
                  (MovingAddressStatusSet.to_query v.moving_address_statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("moving_address_statuses",
               (MovingAddressStatusSet.to_json v.moving_address_statuses))])
    let of_json j =
      {
        moving_address_statuses =
          (MovingAddressStatusSet.of_json
             (Util.of_option_exn (Json.lookup j "moving_address_statuses")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeExportTasksRequest =
  struct
    type t =
      {
      export_task_ids: ExportTaskIdStringList.t ;
      filters: FilterList.t }
    let make ?(export_task_ids= [])  ?(filters= [])  () =
      { export_task_ids; filters }
    let parse xml =
      Some
        {
          export_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskId" xml)
                  ExportTaskIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ExportTaskId",
                  (ExportTaskIdStringList.to_query v.export_task_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some
             ("export_task_ids",
               (ExportTaskIdStringList.to_json v.export_task_ids))])
    let of_json j =
      {
        export_task_ids =
          (ExportTaskIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "export_task_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeReservedInstancesOfferingsRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      filters: FilterList.t ;
      include_marketplace: Boolean.t option ;
      instance_type: InstanceType.t option ;
      max_duration: Long.t option ;
      max_instance_count: Integer.t option ;
      min_duration: Long.t option ;
      offering_class: OfferingClassType.t option ;
      product_description: RIProductDescription.t option ;
      reserved_instances_offering_ids:
        ReservedInstancesOfferingIdStringList.t ;
      dry_run: Boolean.t option ;
      instance_tenancy: Tenancy.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      offering_type: OfferingTypeValues.t option }
    let make ?availability_zone  ?(filters= [])  ?include_marketplace 
      ?instance_type  ?max_duration  ?max_instance_count  ?min_duration 
      ?offering_class  ?product_description 
      ?(reserved_instances_offering_ids= [])  ?dry_run  ?instance_tenancy 
      ?max_results  ?next_token  ?offering_type  () =
      {
        availability_zone;
        filters;
        include_marketplace;
        instance_type;
        max_duration;
        max_instance_count;
        min_duration;
        offering_class;
        product_description;
        reserved_instances_offering_ids;
        dry_run;
        instance_tenancy;
        max_results;
        next_token;
        offering_type
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          include_marketplace =
            (Util.option_bind (Xml.member "IncludeMarketplace" xml)
               Boolean.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml)
               InstanceType.parse);
          max_duration =
            (Util.option_bind (Xml.member "MaxDuration" xml) Long.parse);
          max_instance_count =
            (Util.option_bind (Xml.member "MaxInstanceCount" xml)
               Integer.parse);
          min_duration =
            (Util.option_bind (Xml.member "MinDuration" xml) Long.parse);
          offering_class =
            (Util.option_bind (Xml.member "OfferingClass" xml)
               OfferingClassType.parse);
          product_description =
            (Util.option_bind (Xml.member "ProductDescription" xml)
               RIProductDescription.parse);
          reserved_instances_offering_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml)
                  ReservedInstancesOfferingIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_tenancy =
            (Util.option_bind (Xml.member "instanceTenancy" xml)
               Tenancy.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          offering_type =
            (Util.option_bind (Xml.member "offeringType" xml)
               OfferingTypeValues.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f ->
                 Query.Pair ("OfferingType", (OfferingTypeValues.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.instance_tenancy
             (fun f -> Query.Pair ("InstanceTenancy", (Tenancy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (ReservedInstancesOfferingIdStringList.to_query
                     v.reserved_instances_offering_ids)));
           Util.option_map v.product_description
             (fun f ->
                Query.Pair
                  ("ProductDescription", (RIProductDescription.to_query f)));
           Util.option_map v.offering_class
             (fun f ->
                Query.Pair ("OfferingClass", (OfferingClassType.to_query f)));
           Util.option_map v.min_duration
             (fun f -> Query.Pair ("MinDuration", (Long.to_query f)));
           Util.option_map v.max_instance_count
             (fun f -> Query.Pair ("MaxInstanceCount", (Integer.to_query f)));
           Util.option_map v.max_duration
             (fun f -> Query.Pair ("MaxDuration", (Long.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (InstanceType.to_query f)));
           Util.option_map v.include_marketplace
             (fun f ->
                Query.Pair ("IncludeMarketplace", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_type
              (fun f -> ("offering_type", (OfferingTypeValues.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.instance_tenancy
             (fun f -> ("instance_tenancy", (Tenancy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_offering_ids",
               (ReservedInstancesOfferingIdStringList.to_json
                  v.reserved_instances_offering_ids));
           Util.option_map v.product_description
             (fun f ->
                ("product_description", (RIProductDescription.to_json f)));
           Util.option_map v.offering_class
             (fun f -> ("offering_class", (OfferingClassType.to_json f)));
           Util.option_map v.min_duration
             (fun f -> ("min_duration", (Long.to_json f)));
           Util.option_map v.max_instance_count
             (fun f -> ("max_instance_count", (Integer.to_json f)));
           Util.option_map v.max_duration
             (fun f -> ("max_duration", (Long.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (InstanceType.to_json f)));
           Util.option_map v.include_marketplace
             (fun f -> ("include_marketplace", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        include_marketplace =
          (Util.option_map (Json.lookup j "include_marketplace")
             Boolean.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             InstanceType.of_json);
        max_duration =
          (Util.option_map (Json.lookup j "max_duration") Long.of_json);
        max_instance_count =
          (Util.option_map (Json.lookup j "max_instance_count")
             Integer.of_json);
        min_duration =
          (Util.option_map (Json.lookup j "min_duration") Long.of_json);
        offering_class =
          (Util.option_map (Json.lookup j "offering_class")
             OfferingClassType.of_json);
        product_description =
          (Util.option_map (Json.lookup j "product_description")
             RIProductDescription.of_json);
        reserved_instances_offering_ids =
          (ReservedInstancesOfferingIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tenancy =
          (Util.option_map (Json.lookup j "instance_tenancy") Tenancy.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_type =
          (Util.option_map (Json.lookup j "offering_type")
             OfferingTypeValues.of_json)
      }
  end
module CreateVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module CreateLaunchTemplateVersionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      source_version: String.t option ;
      version_description: String.t option ;
      launch_template_data: RequestLaunchTemplateData.t }
    let make ?dry_run  ?client_token  ?launch_template_id 
      ?launch_template_name  ?source_version  ?version_description 
      ~launch_template_data  () =
      {
        dry_run;
        client_token;
        launch_template_id;
        launch_template_name;
        source_version;
        version_description;
        launch_template_data
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          source_version =
            (Util.option_bind (Xml.member "SourceVersion" xml) String.parse);
          version_description =
            (Util.option_bind (Xml.member "VersionDescription" xml)
               String.parse);
          launch_template_data =
            (Xml.required "LaunchTemplateData"
               (Util.option_bind (Xml.member "LaunchTemplateData" xml)
                  RequestLaunchTemplateData.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LaunchTemplateData",
                   (RequestLaunchTemplateData.to_query v.launch_template_data)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Util.option_map v.source_version
             (fun f -> Query.Pair ("SourceVersion", (String.to_query f)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("launch_template_data",
                (RequestLaunchTemplateData.to_json v.launch_template_data));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Util.option_map v.source_version
             (fun f -> ("source_version", (String.to_json f)));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        source_version =
          (Util.option_map (Json.lookup j "source_version") String.of_json);
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        launch_template_data =
          (RequestLaunchTemplateData.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_data")))
      }
  end
module DescribeNetworkAclsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      network_acl_ids: NetworkAclIdStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(network_acl_ids= [])  ?next_token 
      ?max_results  () =
      { filters; dry_run; network_acl_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_acl_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkAclId" xml)
                  NetworkAclIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkAclId",
                  (NetworkAclIdStringList.to_query v.network_acl_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_acl_ids",
               (NetworkAclIdStringList.to_json v.network_acl_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_acl_ids =
          (NetworkAclIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "network_acl_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeTrafficMirrorSessionsResult =
  struct
    type t =
      {
      traffic_mirror_sessions: TrafficMirrorSessionSet.t ;
      next_token: String.t option }
    let make ?(traffic_mirror_sessions= [])  ?next_token  () =
      { traffic_mirror_sessions; next_token }
    let parse xml =
      Some
        {
          traffic_mirror_sessions =
            (Util.of_option []
               (Util.option_bind (Xml.member "trafficMirrorSessionSet" xml)
                  TrafficMirrorSessionSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionSet",
                  (TrafficMirrorSessionSet.to_query v.traffic_mirror_sessions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("traffic_mirror_sessions",
               (TrafficMirrorSessionSet.to_json v.traffic_mirror_sessions))])
    let of_json j =
      {
        traffic_mirror_sessions =
          (TrafficMirrorSessionSet.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_sessions")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyHostsRequest =
  struct
    type t =
      {
      auto_placement: AutoPlacement.t option ;
      host_ids: RequestHostIdList.t ;
      host_recovery: HostRecovery.t option ;
      instance_type: String.t option ;
      instance_family: String.t option }
    let make ?auto_placement  ~host_ids  ?host_recovery  ?instance_type 
      ?instance_family  () =
      {
        auto_placement;
        host_ids;
        host_recovery;
        instance_type;
        instance_family
      }
    let parse xml =
      Some
        {
          auto_placement =
            (Util.option_bind (Xml.member "autoPlacement" xml)
               AutoPlacement.parse);
          host_ids =
            (Xml.required "hostId"
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse));
          host_recovery =
            (Util.option_bind (Xml.member "HostRecovery" xml)
               HostRecovery.parse);
          instance_type =
            (Util.option_bind (Xml.member "InstanceType" xml) String.parse);
          instance_family =
            (Util.option_bind (Xml.member "InstanceFamily" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_family
              (fun f -> Query.Pair ("InstanceFamily", (String.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.host_recovery
             (fun f -> Query.Pair ("HostRecovery", (HostRecovery.to_query f)));
           Some
             (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)));
           Util.option_map v.auto_placement
             (fun f ->
                Query.Pair ("AutoPlacement", (AutoPlacement.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_family
              (fun f -> ("instance_family", (String.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.host_recovery
             (fun f -> ("host_recovery", (HostRecovery.to_json f)));
           Some ("host_ids", (RequestHostIdList.to_json v.host_ids));
           Util.option_map v.auto_placement
             (fun f -> ("auto_placement", (AutoPlacement.to_json f)))])
    let of_json j =
      {
        auto_placement =
          (Util.option_map (Json.lookup j "auto_placement")
             AutoPlacement.of_json);
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")));
        host_recovery =
          (Util.option_map (Json.lookup j "host_recovery")
             HostRecovery.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        instance_family =
          (Util.option_map (Json.lookup j "instance_family") String.of_json)
      }
  end
module RevokeClientVpnIngressRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_network_cidr: String.t ;
      access_group_id: String.t option ;
      revoke_all_groups: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~target_network_cidr  ?access_group_id 
      ?revoke_all_groups  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_network_cidr;
        access_group_id;
        revoke_all_groups;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_network_cidr =
            (Xml.required "TargetNetworkCidr"
               (Util.option_bind (Xml.member "TargetNetworkCidr" xml)
                  String.parse));
          access_group_id =
            (Util.option_bind (Xml.member "AccessGroupId" xml) String.parse);
          revoke_all_groups =
            (Util.option_bind (Xml.member "RevokeAllGroups" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.revoke_all_groups
             (fun f -> Query.Pair ("RevokeAllGroups", (Boolean.to_query f)));
           Util.option_map v.access_group_id
             (fun f -> Query.Pair ("AccessGroupId", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetNetworkCidr",
                  (String.to_query v.target_network_cidr)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.revoke_all_groups
             (fun f -> ("revoke_all_groups", (Boolean.to_json f)));
           Util.option_map v.access_group_id
             (fun f -> ("access_group_id", (String.to_json f)));
           Some
             ("target_network_cidr", (String.to_json v.target_network_cidr));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_network_cidr =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_network_cidr")));
        access_group_id =
          (Util.option_map (Json.lookup j "access_group_id") String.of_json);
        revoke_all_groups =
          (Util.option_map (Json.lookup j "revoke_all_groups")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeClientVpnEndpointsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_ids: ClientVpnEndpointIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      dry_run: Boolean.t option }
    let make ?(client_vpn_endpoint_ids= [])  ?max_results  ?next_token 
      ?(filters= [])  ?dry_run  () =
      { client_vpn_endpoint_ids; max_results; next_token; filters; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  ClientVpnEndpointIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (ClientVpnEndpointIdList.to_query v.client_vpn_endpoint_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("client_vpn_endpoint_ids",
               (ClientVpnEndpointIdList.to_json v.client_vpn_endpoint_ids))])
    let of_json j =
      {
        client_vpn_endpoint_ids =
          (ClientVpnEndpointIdList.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTrafficMirrorSessionRequest =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_session_id  ?dry_run  () =
      { traffic_mirror_session_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Xml.required "TrafficMirrorSessionId"
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (String.to_query v.traffic_mirror_session_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_session_id",
               (String.to_json v.traffic_mirror_session_id))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeTransitGatewayVpcAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyCapacityReservationResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyNetworkInterfaceAttributeRequest =
  struct
    type t =
      {
      attachment: NetworkInterfaceAttachmentChanges.t option ;
      description: AttributeValue.t option ;
      dry_run: Boolean.t option ;
      groups: SecurityGroupIdStringList.t ;
      network_interface_id: String.t ;
      source_dest_check: AttributeBooleanValue.t option }
    let make ?attachment  ?description  ?dry_run  ?(groups= []) 
      ~network_interface_id  ?source_dest_check  () =
      {
        attachment;
        description;
        dry_run;
        groups;
        network_interface_id;
        source_dest_check
      }
    let parse xml =
      Some
        {
          attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               NetworkInterfaceAttachmentChanges.parse);
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 Query.Pair
                   ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Util.option_map v.attachment
             (fun f ->
                Query.Pair
                  ("Attachment",
                    (NetworkInterfaceAttachmentChanges.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.source_dest_check
              (fun f ->
                 ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Util.option_map v.attachment
             (fun f ->
                ("attachment", (NetworkInterfaceAttachmentChanges.to_json f)))])
    let of_json j =
      {
        attachment =
          (Util.option_map (Json.lookup j "attachment")
             NetworkInterfaceAttachmentChanges.of_json);
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json)
      }
  end
module CreateVolumeRequest =
  struct
    type t =
      {
      availability_zone: String.t ;
      encrypted: Boolean.t option ;
      iops: Integer.t option ;
      kms_key_id: String.t option ;
      outpost_arn: String.t option ;
      size: Integer.t option ;
      snapshot_id: String.t option ;
      volume_type: VolumeType.t option ;
      dry_run: Boolean.t option ;
      tag_specifications: TagSpecificationList.t ;
      multi_attach_enabled: Boolean.t option }
    let make ~availability_zone  ?encrypted  ?iops  ?kms_key_id  ?outpost_arn
       ?size  ?snapshot_id  ?volume_type  ?dry_run  ?(tag_specifications= [])
       ?multi_attach_enabled  () =
      {
        availability_zone;
        encrypted;
        iops;
        kms_key_id;
        outpost_arn;
        size;
        snapshot_id;
        volume_type;
        dry_run;
        tag_specifications;
        multi_attach_enabled
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Xml.required "AvailabilityZone"
               (Util.option_bind (Xml.member "AvailabilityZone" xml)
                  String.parse));
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          iops = (Util.option_bind (Xml.member "Iops" xml) Integer.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          outpost_arn =
            (Util.option_bind (Xml.member "OutpostArn" xml) String.parse);
          size = (Util.option_bind (Xml.member "Size" xml) Integer.parse);
          snapshot_id =
            (Util.option_bind (Xml.member "SnapshotId" xml) String.parse);
          volume_type =
            (Util.option_bind (Xml.member "VolumeType" xml) VolumeType.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          multi_attach_enabled =
            (Util.option_bind (Xml.member "MultiAttachEnabled" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.multi_attach_enabled
              (fun f ->
                 Query.Pair ("MultiAttachEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.volume_type
             (fun f -> Query.Pair ("VolumeType", (VolumeType.to_query f)));
           Util.option_map v.snapshot_id
             (fun f -> Query.Pair ("SnapshotId", (String.to_query f)));
           Util.option_map v.size
             (fun f -> Query.Pair ("Size", (Integer.to_query f)));
           Util.option_map v.outpost_arn
             (fun f -> Query.Pair ("OutpostArn", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.iops
             (fun f -> Query.Pair ("Iops", (Integer.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AvailabilityZone", (String.to_query v.availability_zone)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.multi_attach_enabled
              (fun f -> ("multi_attach_enabled", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.volume_type
             (fun f -> ("volume_type", (VolumeType.to_json f)));
           Util.option_map v.snapshot_id
             (fun f -> ("snapshot_id", (String.to_json f)));
           Util.option_map v.size (fun f -> ("size", (Integer.to_json f)));
           Util.option_map v.outpost_arn
             (fun f -> ("outpost_arn", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.iops (fun f -> ("iops", (Integer.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Some ("availability_zone", (String.to_json v.availability_zone))])
    let of_json j =
      {
        availability_zone =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "availability_zone")));
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        iops = (Util.option_map (Json.lookup j "iops") Integer.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        outpost_arn =
          (Util.option_map (Json.lookup j "outpost_arn") String.of_json);
        size = (Util.option_map (Json.lookup j "size") Integer.of_json);
        snapshot_id =
          (Util.option_map (Json.lookup j "snapshot_id") String.of_json);
        volume_type =
          (Util.option_map (Json.lookup j "volume_type") VolumeType.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        multi_attach_enabled =
          (Util.option_map (Json.lookup j "multi_attach_enabled")
             Boolean.of_json)
      }
  end
module DescribePublicIpv4PoolsRequest =
  struct
    type t =
      {
      pool_ids: PublicIpv4PoolIdStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t }
    let make ?(pool_ids= [])  ?next_token  ?max_results  ?(filters= [])  () =
      { pool_ids; next_token; max_results; filters }
    let parse xml =
      Some
        {
          pool_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolId" xml)
                  PublicIpv4PoolIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PoolId", (PublicIpv4PoolIdStringList.to_query v.pool_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("pool_ids", (PublicIpv4PoolIdStringList.to_json v.pool_ids))])
    let of_json j =
      {
        pool_ids =
          (PublicIpv4PoolIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "pool_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module EnableVpcClassicLinkRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      vpc_id: String.t }
    let make ?dry_run  ~vpc_id  () = { dry_run; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DeleteClientVpnEndpointResult =
  struct
    type t = {
      status: ClientVpnEndpointStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnEndpointStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnEndpointStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnEndpointStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnEndpointStatus.of_json)
      }
  end
module DisassociateEnclaveCertificateIamRoleResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DisassociateRouteTableRequest =
  struct
    type t = {
      association_id: String.t ;
      dry_run: Boolean.t option }
    let make ~association_id  ?dry_run  () = { association_id; dry_run }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AdvertiseByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module CreateTransitGatewayRouteTableResult =
  struct
    type t =
      {
      transit_gateway_route_table: TransitGatewayRouteTable.t option }
    let make ?transit_gateway_route_table  () =
      { transit_gateway_route_table }
    let parse xml =
      Some
        {
          transit_gateway_route_table =
            (Util.option_bind (Xml.member "transitGatewayRouteTable" xml)
               TransitGatewayRouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 Query.Pair
                   ("TransitGatewayRouteTable",
                     (TransitGatewayRouteTable.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_route_table
              (fun f ->
                 ("transit_gateway_route_table",
                   (TransitGatewayRouteTable.to_json f)))])
    let of_json j =
      {
        transit_gateway_route_table =
          (Util.option_map (Json.lookup j "transit_gateway_route_table")
             TransitGatewayRouteTable.of_json)
      }
  end
module DescribeIpv6PoolsResult =
  struct
    type t = {
      ipv6_pools: Ipv6PoolSet.t ;
      next_token: String.t option }
    let make ?(ipv6_pools= [])  ?next_token  () = { ipv6_pools; next_token }
    let parse xml =
      Some
        {
          ipv6_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6PoolSet" xml)
                  Ipv6PoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair ("Ipv6PoolSet", (Ipv6PoolSet.to_query v.ipv6_pools)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("ipv6_pools", (Ipv6PoolSet.to_json v.ipv6_pools))])
    let of_json j =
      {
        ipv6_pools =
          (Ipv6PoolSet.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_pools")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteFpgaImageResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CreateCarrierGatewayRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~vpc_id  ?(tag_specifications= [])  ?dry_run  ?client_token  ()
      = { vpc_id; tag_specifications; dry_run; client_token }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module ResetFpgaImageAttributeResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option }
    let make ?dry_run  ?launch_template_id  ?launch_template_name  () =
      { dry_run; launch_template_id; launch_template_name }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_name
              (fun f ->
                 Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_name
              (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json)
      }
  end
module UnassignIpv6AddressesRequest =
  struct
    type t =
      {
      ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t }
    let make ~ipv6_addresses  ~network_interface_id  () =
      { ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          ipv6_addresses =
            (Xml.required "ipv6Addresses"
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (Ipv6AddressList.to_query v.ipv6_addresses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Some
             ("ipv6_addresses", (Ipv6AddressList.to_json v.ipv6_addresses))])
    let of_json j =
      {
        ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module GetTransitGatewayMulticastDomainAssociationsRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLaunchTemplateVersionsResult =
  struct
    type t =
      {
      successfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseSuccessSet.t ;
      unsuccessfully_deleted_launch_template_versions:
        DeleteLaunchTemplateVersionsResponseErrorSet.t }
    let make ?(successfully_deleted_launch_template_versions= []) 
      ?(unsuccessfully_deleted_launch_template_versions= [])  () =
      {
        successfully_deleted_launch_template_versions;
        unsuccessfully_deleted_launch_template_versions
      }
    let parse xml =
      Some
        {
          successfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfullyDeletedLaunchTemplateVersionSet"
                     xml)
                  DeleteLaunchTemplateVersionsResponseSuccessSet.parse));
          unsuccessfully_deleted_launch_template_versions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfullyDeletedLaunchTemplateVersionSet"
                     xml) DeleteLaunchTemplateVersionsResponseErrorSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfullyDeletedLaunchTemplateVersionSet",
                   (DeleteLaunchTemplateVersionsResponseErrorSet.to_query
                      v.unsuccessfully_deleted_launch_template_versions)));
           Some
             (Query.Pair
                ("SuccessfullyDeletedLaunchTemplateVersionSet",
                  (DeleteLaunchTemplateVersionsResponseSuccessSet.to_query
                     v.successfully_deleted_launch_template_versions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessfully_deleted_launch_template_versions",
                (DeleteLaunchTemplateVersionsResponseErrorSet.to_json
                   v.unsuccessfully_deleted_launch_template_versions));
           Some
             ("successfully_deleted_launch_template_versions",
               (DeleteLaunchTemplateVersionsResponseSuccessSet.to_json
                  v.successfully_deleted_launch_template_versions))])
    let of_json j =
      {
        successfully_deleted_launch_template_versions =
          (DeleteLaunchTemplateVersionsResponseSuccessSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "successfully_deleted_launch_template_versions")));
        unsuccessfully_deleted_launch_template_versions =
          (DeleteLaunchTemplateVersionsResponseErrorSet.of_json
             (Util.of_option_exn
                (Json.lookup j
                   "unsuccessfully_deleted_launch_template_versions")))
      }
  end
module DescribeKeyPairsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      key_names: KeyNameStringList.t ;
      key_pair_ids: KeyPairIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?(key_names= [])  ?(key_pair_ids= [])  ?dry_run 
      () = { filters; key_names; key_pair_ids; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          key_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "KeyName" xml)
                  KeyNameStringList.parse));
          key_pair_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "KeyPairId" xml)
                  KeyPairIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("KeyPairId", (KeyPairIdStringList.to_query v.key_pair_ids)));
           Some
             (Query.Pair
                ("KeyName", (KeyNameStringList.to_query v.key_names)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("key_pair_ids", (KeyPairIdStringList.to_json v.key_pair_ids));
           Some ("key_names", (KeyNameStringList.to_json v.key_names));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        key_names =
          (KeyNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "key_names")));
        key_pair_ids =
          (KeyPairIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "key_pair_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RegisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      registered_multicast_group_sources:
        TransitGatewayMulticastRegisteredGroupSources.t option }
    let make ?registered_multicast_group_sources  () =
      { registered_multicast_group_sources }
    let parse xml =
      Some
        {
          registered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "registeredMulticastGroupSources" xml)
               TransitGatewayMulticastRegisteredGroupSources.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("RegisteredMulticastGroupSources",
                     (TransitGatewayMulticastRegisteredGroupSources.to_query
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.registered_multicast_group_sources
              (fun f ->
                 ("registered_multicast_group_sources",
                   (TransitGatewayMulticastRegisteredGroupSources.to_json f)))])
    let of_json j =
      {
        registered_multicast_group_sources =
          (Util.option_map
             (Json.lookup j "registered_multicast_group_sources")
             TransitGatewayMulticastRegisteredGroupSources.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsEgressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_id  ?group_name  ~ip_permissions  () =
      { dry_run; group_id; group_name; ip_permissions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Xml.required "IpPermissions"
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end
module RequestSpotInstancesResult =
  struct
    type t = {
      spot_instance_requests: SpotInstanceRequestList.t }
    let make ?(spot_instance_requests= [])  () = { spot_instance_requests }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotInstanceRequestSet",
                   (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_instance_requests",
                (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")))
      }
  end
module ExportTransitGatewayRoutesRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      s3_bucket: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ~s3_bucket 
      ?dry_run  () =
      { transit_gateway_route_table_id; filters; s3_bucket; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          s3_bucket =
            (Xml.required "S3Bucket"
               (Util.option_bind (Xml.member "S3Bucket" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("S3Bucket", (String.to_query v.s3_bucket)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("s3_bucket", (String.to_json v.s3_bucket));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        s3_bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "s3_bucket")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeReservedInstancesListingsRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      reserved_instances_id: String.t option ;
      reserved_instances_listing_id: String.t option }
    let make ?(filters= [])  ?reserved_instances_id 
      ?reserved_instances_listing_id  () =
      { filters; reserved_instances_id; reserved_instances_listing_id }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          reserved_instances_id =
            (Util.option_bind (Xml.member "reservedInstancesId" xml)
               String.parse);
          reserved_instances_listing_id =
            (Util.option_bind (Xml.member "reservedInstancesListingId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_listing_id
              (fun f ->
                 Query.Pair
                   ("ReservedInstancesListingId", (String.to_query f)));
           Util.option_map v.reserved_instances_id
             (fun f ->
                Query.Pair ("ReservedInstancesId", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.reserved_instances_listing_id
              (fun f -> ("reserved_instances_listing_id", (String.to_json f)));
           Util.option_map v.reserved_instances_id
             (fun f -> ("reserved_instances_id", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        reserved_instances_id =
          (Util.option_map (Json.lookup j "reserved_instances_id")
             String.of_json);
        reserved_instances_listing_id =
          (Util.option_map (Json.lookup j "reserved_instances_listing_id")
             String.of_json)
      }
  end
module MoveAddressToVpcResult =
  struct
    type t = {
      allocation_id: String.t option ;
      status: Status.t option }
    let make ?allocation_id  ?status  () = { allocation_id; status }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "allocationId" xml) String.parse);
          status = (Util.option_bind (Xml.member "status" xml) Status.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (Status.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (Status.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        status = (Util.option_map (Json.lookup j "status") Status.of_json)
      }
  end
module DeleteRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t option ;
      destination_ipv6_cidr_block: String.t option ;
      destination_prefix_list_id: String.t option ;
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ?destination_cidr_block  ?destination_ipv6_cidr_block 
      ?destination_prefix_list_id  ?dry_run  ~route_table_id  () =
      {
        destination_cidr_block;
        destination_ipv6_cidr_block;
        destination_prefix_list_id;
        dry_run;
        route_table_id
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Util.option_bind (Xml.member "destinationCidrBlock" xml)
               String.parse);
          destination_ipv6_cidr_block =
            (Util.option_bind (Xml.member "destinationIpv6CidrBlock" xml)
               String.parse);
          destination_prefix_list_id =
            (Util.option_bind (Xml.member "DestinationPrefixListId" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.destination_prefix_list_id
             (fun f ->
                Query.Pair ("DestinationPrefixListId", (String.to_query f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f ->
                Query.Pair ("DestinationIpv6CidrBlock", (String.to_query f)));
           Util.option_map v.destination_cidr_block
             (fun f ->
                Query.Pair ("DestinationCidrBlock", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.destination_prefix_list_id
             (fun f -> ("destination_prefix_list_id", (String.to_json f)));
           Util.option_map v.destination_ipv6_cidr_block
             (fun f -> ("destination_ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.destination_cidr_block
             (fun f -> ("destination_cidr_block", (String.to_json f)))])
    let of_json j =
      {
        destination_cidr_block =
          (Util.option_map (Json.lookup j "destination_cidr_block")
             String.of_json);
        destination_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "destination_ipv6_cidr_block")
             String.of_json);
        destination_prefix_list_id =
          (Util.option_map (Json.lookup j "destination_prefix_list_id")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DeleteQueuedReservedInstancesResult =
  struct
    type t =
      {
      successful_queued_purchase_deletions:
        SuccessfulQueuedPurchaseDeletionSet.t ;
      failed_queued_purchase_deletions: FailedQueuedPurchaseDeletionSet.t }
    let make ?(successful_queued_purchase_deletions= []) 
      ?(failed_queued_purchase_deletions= [])  () =
      {
        successful_queued_purchase_deletions;
        failed_queued_purchase_deletions
      }
    let parse xml =
      Some
        {
          successful_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulQueuedPurchaseDeletionSet" xml)
                  SuccessfulQueuedPurchaseDeletionSet.parse));
          failed_queued_purchase_deletions =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "failedQueuedPurchaseDeletionSet" xml)
                  FailedQueuedPurchaseDeletionSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FailedQueuedPurchaseDeletionSet",
                   (FailedQueuedPurchaseDeletionSet.to_query
                      v.failed_queued_purchase_deletions)));
           Some
             (Query.Pair
                ("SuccessfulQueuedPurchaseDeletionSet",
                  (SuccessfulQueuedPurchaseDeletionSet.to_query
                     v.successful_queued_purchase_deletions)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("failed_queued_purchase_deletions",
                (FailedQueuedPurchaseDeletionSet.to_json
                   v.failed_queued_purchase_deletions));
           Some
             ("successful_queued_purchase_deletions",
               (SuccessfulQueuedPurchaseDeletionSet.to_json
                  v.successful_queued_purchase_deletions))])
    let of_json j =
      {
        successful_queued_purchase_deletions =
          (SuccessfulQueuedPurchaseDeletionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "successful_queued_purchase_deletions")));
        failed_queued_purchase_deletions =
          (FailedQueuedPurchaseDeletionSet.of_json
             (Util.of_option_exn
                (Json.lookup j "failed_queued_purchase_deletions")))
      }
  end
module GetLaunchTemplateDataResult =
  struct
    type t = {
      launch_template_data: ResponseLaunchTemplateData.t option }
    let make ?launch_template_data  () = { launch_template_data }
    let parse xml =
      Some
        {
          launch_template_data =
            (Util.option_bind (Xml.member "launchTemplateData" xml)
               ResponseLaunchTemplateData.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 Query.Pair
                   ("LaunchTemplateData",
                     (ResponseLaunchTemplateData.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template_data
              (fun f ->
                 ("launch_template_data",
                   (ResponseLaunchTemplateData.to_json f)))])
    let of_json j =
      {
        launch_template_data =
          (Util.option_map (Json.lookup j "launch_template_data")
             ResponseLaunchTemplateData.of_json)
      }
  end
module DeleteVpcRequest =
  struct
    type t = {
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ?dry_run  () = { vpc_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      associations: TransitGatewayMulticastDomainAssociations.t option }
    let make ?associations  () = { associations }
    let parse xml =
      Some
        {
          associations =
            (Util.option_bind (Xml.member "associations" xml)
               TransitGatewayMulticastDomainAssociations.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 Query.Pair
                   ("Associations",
                     (TransitGatewayMulticastDomainAssociations.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.associations
              (fun f ->
                 ("associations",
                   (TransitGatewayMulticastDomainAssociations.to_json f)))])
    let of_json j =
      {
        associations =
          (Util.option_map (Json.lookup j "associations")
             TransitGatewayMulticastDomainAssociations.of_json)
      }
  end
module DeleteNetworkInterfacePermissionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module CancelExportTaskRequest =
  struct
    type t = {
      export_task_id: String.t }
    let make ~export_task_id  () = { export_task_id }
    let parse xml =
      Some
        {
          export_task_id =
            (Xml.required "exportTaskId"
               (Util.option_bind (Xml.member "exportTaskId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskId", (String.to_query v.export_task_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_task_id", (String.to_json v.export_task_id))])
    let of_json j =
      {
        export_task_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "export_task_id")))
      }
  end
module DeleteTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_multicast_domain_id  ?dry_run  () =
      { transit_gateway_multicast_domain_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Xml.required "TransitGatewayMulticastDomainId"
               (Util.option_bind
                  (Xml.member "TransitGatewayMulticastDomainId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayMulticastDomainId",
                  (String.to_query v.transit_gateway_multicast_domain_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_multicast_domain_id",
               (String.to_json v.transit_gateway_multicast_domain_id))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_multicast_domain_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeExportTasksResult =
  struct
    type t = {
      export_tasks: ExportTaskList.t }
    let make ?(export_tasks= [])  () = { export_tasks }
    let parse xml =
      Some
        {
          export_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "exportTaskSet" xml)
                  ExportTaskList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ExportTaskSet", (ExportTaskList.to_query v.export_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("export_tasks", (ExportTaskList.to_json v.export_tasks))])
    let of_json j =
      {
        export_tasks =
          (ExportTaskList.of_json
             (Util.of_option_exn (Json.lookup j "export_tasks")))
      }
  end
module UnmonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module CreateTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module DescribeClientVpnAuthorizationRulesRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option }
    let make ~client_vpn_endpoint_id  ?dry_run  ?next_token  ?(filters= []) 
      ?max_results  () =
      { client_vpn_endpoint_id; dry_run; next_token; filters; max_results }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeSecurityGroupsResult =
  struct
    type t =
      {
      security_groups: SecurityGroupList.t ;
      next_token: String.t option }
    let make ?(security_groups= [])  ?next_token  () =
      { security_groups; next_token }
    let parse xml =
      Some
        {
          security_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "securityGroupInfo" xml)
                  SecurityGroupList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupInfo",
                  (SecurityGroupList.to_query v.security_groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("security_groups",
               (SecurityGroupList.to_json v.security_groups))])
    let of_json j =
      {
        security_groups =
          (SecurityGroupList.of_json
             (Util.of_option_exn (Json.lookup j "security_groups")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteLocalGatewayRouteTableVpcAssociationResult =
  struct
    type t =
      {
      local_gateway_route_table_vpc_association:
        LocalGatewayRouteTableVpcAssociation.t option }
    let make ?local_gateway_route_table_vpc_association  () =
      { local_gateway_route_table_vpc_association }
    let parse xml =
      Some
        {
          local_gateway_route_table_vpc_association =
            (Util.option_bind
               (Xml.member "localGatewayRouteTableVpcAssociation" xml)
               LocalGatewayRouteTableVpcAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 Query.Pair
                   ("LocalGatewayRouteTableVpcAssociation",
                     (LocalGatewayRouteTableVpcAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.local_gateway_route_table_vpc_association
              (fun f ->
                 ("local_gateway_route_table_vpc_association",
                   (LocalGatewayRouteTableVpcAssociation.to_json f)))])
    let of_json j =
      {
        local_gateway_route_table_vpc_association =
          (Util.option_map
             (Json.lookup j "local_gateway_route_table_vpc_association")
             LocalGatewayRouteTableVpcAssociation.of_json)
      }
  end
module ModifyVpnConnectionOptionsRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      local_ipv4_network_cidr: String.t option ;
      remote_ipv4_network_cidr: String.t option ;
      local_ipv6_network_cidr: String.t option ;
      remote_ipv6_network_cidr: String.t option ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ?local_ipv4_network_cidr 
      ?remote_ipv4_network_cidr  ?local_ipv6_network_cidr 
      ?remote_ipv6_network_cidr  ?dry_run  () =
      {
        vpn_connection_id;
        local_ipv4_network_cidr;
        remote_ipv4_network_cidr;
        local_ipv6_network_cidr;
        remote_ipv6_network_cidr;
        dry_run
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          local_ipv4_network_cidr =
            (Util.option_bind (Xml.member "LocalIpv4NetworkCidr" xml)
               String.parse);
          remote_ipv4_network_cidr =
            (Util.option_bind (Xml.member "RemoteIpv4NetworkCidr" xml)
               String.parse);
          local_ipv6_network_cidr =
            (Util.option_bind (Xml.member "LocalIpv6NetworkCidr" xml)
               String.parse);
          remote_ipv6_network_cidr =
            (Util.option_bind (Xml.member "RemoteIpv6NetworkCidr" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.remote_ipv6_network_cidr
             (fun f ->
                Query.Pair ("RemoteIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv6NetworkCidr", (String.to_query f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f ->
                Query.Pair ("RemoteIpv4NetworkCidr", (String.to_query f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f ->
                Query.Pair ("LocalIpv4NetworkCidr", (String.to_query f)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.remote_ipv6_network_cidr
             (fun f -> ("remote_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv6_network_cidr
             (fun f -> ("local_ipv6_network_cidr", (String.to_json f)));
           Util.option_map v.remote_ipv4_network_cidr
             (fun f -> ("remote_ipv4_network_cidr", (String.to_json f)));
           Util.option_map v.local_ipv4_network_cidr
             (fun f -> ("local_ipv4_network_cidr", (String.to_json f)));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        local_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv4_network_cidr")
             String.of_json);
        remote_ipv4_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv4_network_cidr")
             String.of_json);
        local_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "local_ipv6_network_cidr")
             String.of_json);
        remote_ipv6_network_cidr =
          (Util.option_map (Json.lookup j "remote_ipv6_network_cidr")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteSubnetRequest =
  struct
    type t = {
      subnet_id: String.t ;
      dry_run: Boolean.t option }
    let make ~subnet_id  ?dry_run  () = { subnet_id; dry_run }
    let parse xml =
      Some
        {
          subnet_id =
            (Xml.required "SubnetId"
               (Util.option_bind (Xml.member "SubnetId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_id", (String.to_json v.subnet_id))])
    let of_json j =
      {
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorTargetResult =
  struct
    type t =
      {
      traffic_mirror_target: TrafficMirrorTarget.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_target  ?client_token  () =
      { traffic_mirror_target; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_target =
            (Util.option_bind (Xml.member "trafficMirrorTarget" xml)
               TrafficMirrorTarget.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                Query.Pair
                  ("TrafficMirrorTarget", (TrafficMirrorTarget.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_target
             (fun f ->
                ("traffic_mirror_target", (TrafficMirrorTarget.to_json f)))])
    let of_json j =
      {
        traffic_mirror_target =
          (Util.option_map (Json.lookup j "traffic_mirror_target")
             TrafficMirrorTarget.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeVpcEndpointServicesResult =
  struct
    type t =
      {
      service_names: ValueStringList.t ;
      service_details: ServiceDetailSet.t ;
      next_token: String.t option }
    let make ?(service_names= [])  ?(service_details= [])  ?next_token  () =
      { service_names; service_details; next_token }
    let parse xml =
      Some
        {
          service_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceNameSet" xml)
                  ValueStringList.parse));
          service_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "serviceDetailSet" xml)
                  ServiceDetailSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ServiceDetailSet",
                  (ServiceDetailSet.to_query v.service_details)));
           Some
             (Query.Pair
                ("ServiceNameSet",
                  (ValueStringList.to_query v.service_names)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("service_details",
               (ServiceDetailSet.to_json v.service_details));
           Some ("service_names", (ValueStringList.to_json v.service_names))])
    let of_json j =
      {
        service_names =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "service_names")));
        service_details =
          (ServiceDetailSet.of_json
             (Util.of_option_exn (Json.lookup j "service_details")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module CancelCapacityReservationRequest =
  struct
    type t = {
      capacity_reservation_id: String.t ;
      dry_run: Boolean.t option }
    let make ~capacity_reservation_id  ?dry_run  () =
      { capacity_reservation_id; dry_run }
    let parse xml =
      Some
        {
          capacity_reservation_id =
            (Xml.required "CapacityReservationId"
               (Util.option_bind (Xml.member "CapacityReservationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CapacityReservationId",
                  (String.to_query v.capacity_reservation_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("capacity_reservation_id",
               (String.to_json v.capacity_reservation_id))])
    let of_json j =
      {
        capacity_reservation_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "capacity_reservation_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetConsoleOutputResult =
  struct
    type t =
      {
      instance_id: String.t option ;
      output: String.t option ;
      timestamp: DateTime.t option }
    let make ?instance_id  ?output  ?timestamp  () =
      { instance_id; output; timestamp }
    let parse xml =
      Some
        {
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          output = (Util.option_bind (Xml.member "output" xml) String.parse);
          timestamp =
            (Util.option_bind (Xml.member "timestamp" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> Query.Pair ("Timestamp", (DateTime.to_query f)));
           Util.option_map v.output
             (fun f -> Query.Pair ("Output", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.timestamp
              (fun f -> ("timestamp", (DateTime.to_json f)));
           Util.option_map v.output (fun f -> ("output", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)))])
    let of_json j =
      {
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        output = (Util.option_map (Json.lookup j "output") String.of_json);
        timestamp =
          (Util.option_map (Json.lookup j "timestamp") DateTime.of_json)
      }
  end
module DescribeClientVpnEndpointsResult =
  struct
    type t =
      {
      client_vpn_endpoints: EndpointSet.t ;
      next_token: String.t option }
    let make ?(client_vpn_endpoints= [])  ?next_token  () =
      { client_vpn_endpoints; next_token }
    let parse xml =
      Some
        {
          client_vpn_endpoints =
            (Util.of_option []
               (Util.option_bind (Xml.member "clientVpnEndpoint" xml)
                  EndpointSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpoint",
                  (EndpointSet.to_query v.client_vpn_endpoints)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("client_vpn_endpoints",
               (EndpointSet.to_json v.client_vpn_endpoints))])
    let of_json j =
      {
        client_vpn_endpoints =
          (EndpointSet.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoints")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceCapacityReservationAttributesResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteVpnConnectionRouteRequest =
  struct
    type t = {
      destination_cidr_block: String.t ;
      vpn_connection_id: String.t }
    let make ~destination_cidr_block  ~vpn_connection_id  () =
      { destination_cidr_block; vpn_connection_id }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpnConnectionId", (String.to_query v.vpn_connection_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpn_connection_id", (String.to_json v.vpn_connection_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")))
      }
  end
module CreateSpotDatafeedSubscriptionRequest =
  struct
    type t =
      {
      bucket: String.t ;
      dry_run: Boolean.t option ;
      prefix: String.t option }
    let make ~bucket  ?dry_run  ?prefix  () = { bucket; dry_run; prefix }
    let parse xml =
      Some
        {
          bucket =
            (Xml.required "bucket"
               (Util.option_bind (Xml.member "bucket" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          prefix = (Util.option_bind (Xml.member "prefix" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> Query.Pair ("Prefix", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Bucket", (String.to_query v.bucket)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix
              (fun f -> ("prefix", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("bucket", (String.to_json v.bucket))])
    let of_json j =
      {
        bucket =
          (String.of_json (Util.of_option_exn (Json.lookup j "bucket")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix = (Util.option_map (Json.lookup j "prefix") String.of_json)
      }
  end
module DescribeTransitGatewayAttachmentsRequest =
  struct
    type t =
      {
      transit_gateway_attachment_ids: TransitGatewayAttachmentIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_attachment_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        transit_gateway_attachment_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_attachment_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentIds" xml)
                  TransitGatewayAttachmentIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentIds",
                  (TransitGatewayAttachmentIdStringList.to_query
                     v.transit_gateway_attachment_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_attachment_ids",
               (TransitGatewayAttachmentIdStringList.to_json
                  v.transit_gateway_attachment_ids))])
    let of_json j =
      {
        transit_gateway_attachment_ids =
          (TransitGatewayAttachmentIdStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      spot_options: SpotOptionsRequest.t option ;
      on_demand_options: OnDemandOptionsRequest.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      launch_template_configs: FleetLaunchTemplateConfigListRequest.t ;
      target_capacity_specification: TargetCapacitySpecificationRequest.t ;
      terminate_instances_with_expiration: Boolean.t option ;
      type_: FleetType.t option ;
      valid_from: DateTime.t option ;
      valid_until: DateTime.t option ;
      replace_unhealthy_instances: Boolean.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?client_token  ?spot_options  ?on_demand_options 
      ?excess_capacity_termination_policy  ~launch_template_configs 
      ~target_capacity_specification  ?terminate_instances_with_expiration 
      ?type_  ?valid_from  ?valid_until  ?replace_unhealthy_instances 
      ?(tag_specifications= [])  () =
      {
        dry_run;
        client_token;
        spot_options;
        on_demand_options;
        excess_capacity_termination_policy;
        launch_template_configs;
        target_capacity_specification;
        terminate_instances_with_expiration;
        type_;
        valid_from;
        valid_until;
        replace_unhealthy_instances;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          spot_options =
            (Util.option_bind (Xml.member "SpotOptions" xml)
               SpotOptionsRequest.parse);
          on_demand_options =
            (Util.option_bind (Xml.member "OnDemandOptions" xml)
               OnDemandOptionsRequest.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "ExcessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          launch_template_configs =
            (Xml.required "LaunchTemplateConfigs"
               (Util.option_bind (Xml.member "LaunchTemplateConfigs" xml)
                  FleetLaunchTemplateConfigListRequest.parse));
          target_capacity_specification =
            (Xml.required "TargetCapacitySpecification"
               (Util.option_bind
                  (Xml.member "TargetCapacitySpecification" xml)
                  TargetCapacitySpecificationRequest.parse));
          terminate_instances_with_expiration =
            (Util.option_bind
               (Xml.member "TerminateInstancesWithExpiration" xml)
               Boolean.parse);
          type_ = (Util.option_bind (Xml.member "Type" xml) FleetType.parse);
          valid_from =
            (Util.option_bind (Xml.member "ValidFrom" xml) DateTime.parse);
          valid_until =
            (Util.option_bind (Xml.member "ValidUntil" xml) DateTime.parse);
          replace_unhealthy_instances =
            (Util.option_bind (Xml.member "ReplaceUnhealthyInstances" xml)
               Boolean.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.replace_unhealthy_instances
             (fun f ->
                Query.Pair
                  ("ReplaceUnhealthyInstances", (Boolean.to_query f)));
           Util.option_map v.valid_until
             (fun f -> Query.Pair ("ValidUntil", (DateTime.to_query f)));
           Util.option_map v.valid_from
             (fun f -> Query.Pair ("ValidFrom", (DateTime.to_query f)));
           Util.option_map v.type_
             (fun f -> Query.Pair ("Type", (FleetType.to_query f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                Query.Pair
                  ("TerminateInstancesWithExpiration", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TargetCapacitySpecification",
                  (TargetCapacitySpecificationRequest.to_query
                     v.target_capacity_specification)));
           Some
             (Query.Pair
                ("LaunchTemplateConfigs",
                  (FleetLaunchTemplateConfigListRequest.to_query
                     v.launch_template_configs)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.on_demand_options
             (fun f ->
                Query.Pair
                  ("OnDemandOptions", (OnDemandOptionsRequest.to_query f)));
           Util.option_map v.spot_options
             (fun f ->
                Query.Pair ("SpotOptions", (SpotOptionsRequest.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.replace_unhealthy_instances
             (fun f -> ("replace_unhealthy_instances", (Boolean.to_json f)));
           Util.option_map v.valid_until
             (fun f -> ("valid_until", (DateTime.to_json f)));
           Util.option_map v.valid_from
             (fun f -> ("valid_from", (DateTime.to_json f)));
           Util.option_map v.type_
             (fun f -> ("type_", (FleetType.to_json f)));
           Util.option_map v.terminate_instances_with_expiration
             (fun f ->
                ("terminate_instances_with_expiration", (Boolean.to_json f)));
           Some
             ("target_capacity_specification",
               (TargetCapacitySpecificationRequest.to_json
                  v.target_capacity_specification));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigListRequest.to_json
                  v.launch_template_configs));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.on_demand_options
             (fun f ->
                ("on_demand_options", (OnDemandOptionsRequest.to_json f)));
           Util.option_map v.spot_options
             (fun f -> ("spot_options", (SpotOptionsRequest.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        spot_options =
          (Util.option_map (Json.lookup j "spot_options")
             SpotOptionsRequest.of_json);
        on_demand_options =
          (Util.option_map (Json.lookup j "on_demand_options")
             OnDemandOptionsRequest.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        launch_template_configs =
          (FleetLaunchTemplateConfigListRequest.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        target_capacity_specification =
          (TargetCapacitySpecificationRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "target_capacity_specification")));
        terminate_instances_with_expiration =
          (Util.option_map
             (Json.lookup j "terminate_instances_with_expiration")
             Boolean.of_json);
        type_ = (Util.option_map (Json.lookup j "type_") FleetType.of_json);
        valid_from =
          (Util.option_map (Json.lookup j "valid_from") DateTime.of_json);
        valid_until =
          (Util.option_map (Json.lookup j "valid_until") DateTime.of_json);
        replace_unhealthy_instances =
          (Util.option_map (Json.lookup j "replace_unhealthy_instances")
             Boolean.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module RejectVpcEndpointConnectionsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module ResetEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteFlowLogsRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      flow_log_ids: FlowLogIdList.t }
    let make ?dry_run  ~flow_log_ids  () = { dry_run; flow_log_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          flow_log_ids =
            (Xml.required "FlowLogId"
               (Util.option_bind (Xml.member "FlowLogId" xml)
                  FlowLogIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("FlowLogId", (FlowLogIdList.to_query v.flow_log_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("flow_log_ids", (FlowLogIdList.to_json v.flow_log_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        flow_log_ids =
          (FlowLogIdList.of_json
             (Util.of_option_exn (Json.lookup j "flow_log_ids")))
      }
  end
module EnableVgwRoutePropagationRequest =
  struct
    type t =
      {
      gateway_id: String.t ;
      route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~gateway_id  ~route_table_id  ?dry_run  () =
      { gateway_id; route_table_id; dry_run }
    let parse xml =
      Some
        {
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse));
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("gateway_id", (String.to_json v.gateway_id))])
    let of_json j =
      {
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeregisterTransitGatewayMulticastGroupSourcesResult =
  struct
    type t =
      {
      deregistered_multicast_group_sources:
        TransitGatewayMulticastDeregisteredGroupSources.t option }
    let make ?deregistered_multicast_group_sources  () =
      { deregistered_multicast_group_sources }
    let parse xml =
      Some
        {
          deregistered_multicast_group_sources =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupSources" xml)
               TransitGatewayMulticastDeregisteredGroupSources.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupSources",
                     (TransitGatewayMulticastDeregisteredGroupSources.to_query
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_sources
              (fun f ->
                 ("deregistered_multicast_group_sources",
                   (TransitGatewayMulticastDeregisteredGroupSources.to_json f)))])
    let of_json j =
      {
        deregistered_multicast_group_sources =
          (Util.option_map
             (Json.lookup j "deregistered_multicast_group_sources")
             TransitGatewayMulticastDeregisteredGroupSources.of_json)
      }
  end
module DescribeInternetGatewaysResult =
  struct
    type t =
      {
      internet_gateways: InternetGatewayList.t ;
      next_token: String.t option }
    let make ?(internet_gateways= [])  ?next_token  () =
      { internet_gateways; next_token }
    let parse xml =
      Some
        {
          internet_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewaySet" xml)
                  InternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewaySet",
                  (InternetGatewayList.to_query v.internet_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("internet_gateways",
               (InternetGatewayList.to_json v.internet_gateways))])
    let of_json j =
      {
        internet_gateways =
          (InternetGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeNetworkInterfacesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      network_interface_ids: NetworkInterfaceIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(network_interface_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; network_interface_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  NetworkInterfaceIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (NetworkInterfaceIdList.to_query v.network_interface_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("network_interface_ids",
               (NetworkInterfaceIdList.to_json v.network_interface_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_ids =
          (NetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module CreateLaunchTemplateRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      launch_template_name: String.t ;
      version_description: String.t option ;
      launch_template_data: RequestLaunchTemplateData.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?client_token  ~launch_template_name 
      ?version_description  ~launch_template_data  ?(tag_specifications= []) 
      () =
      {
        dry_run;
        client_token;
        launch_template_name;
        version_description;
        launch_template_data;
        tag_specifications
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          launch_template_name =
            (Xml.required "LaunchTemplateName"
               (Util.option_bind (Xml.member "LaunchTemplateName" xml)
                  String.parse));
          version_description =
            (Util.option_bind (Xml.member "VersionDescription" xml)
               String.parse);
          launch_template_data =
            (Xml.required "LaunchTemplateData"
               (Util.option_bind (Xml.member "LaunchTemplateData" xml)
                  RequestLaunchTemplateData.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("LaunchTemplateData",
                  (RequestLaunchTemplateData.to_query v.launch_template_data)));
           Util.option_map v.version_description
             (fun f -> Query.Pair ("VersionDescription", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateName",
                  (String.to_query v.launch_template_name)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("launch_template_data",
               (RequestLaunchTemplateData.to_json v.launch_template_data));
           Util.option_map v.version_description
             (fun f -> ("version_description", (String.to_json f)));
           Some
             ("launch_template_name",
               (String.to_json v.launch_template_name));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        launch_template_name =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_name")));
        version_description =
          (Util.option_map (Json.lookup j "version_description")
             String.of_json);
        launch_template_data =
          (RequestLaunchTemplateData.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_data")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DescribeAccountAttributesRequest =
  struct
    type t =
      {
      attribute_names: AccountAttributeNameStringList.t ;
      dry_run: Boolean.t option }
    let make ?(attribute_names= [])  ?dry_run  () =
      { attribute_names; dry_run }
    let parse xml =
      Some
        {
          attribute_names =
            (Util.of_option []
               (Util.option_bind (Xml.member "attributeName" xml)
                  AccountAttributeNameStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AttributeName",
                  (AccountAttributeNameStringList.to_query v.attribute_names)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("attribute_names",
               (AccountAttributeNameStringList.to_json v.attribute_names))])
    let of_json j =
      {
        attribute_names =
          (AccountAttributeNameStringList.of_json
             (Util.of_option_exn (Json.lookup j "attribute_names")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeConversionTasksRequest =
  struct
    type t =
      {
      conversion_task_ids: ConversionIdStringList.t ;
      dry_run: Boolean.t option }
    let make ?(conversion_task_ids= [])  ?dry_run  () =
      { conversion_task_ids; dry_run }
    let parse xml =
      Some
        {
          conversion_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "conversionTaskId" xml)
                  ConversionIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ConversionTaskId",
                  (ConversionIdStringList.to_query v.conversion_task_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("conversion_task_ids",
               (ConversionIdStringList.to_json v.conversion_task_ids))])
    let of_json j =
      {
        conversion_task_ids =
          (ConversionIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "conversion_task_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisassociateTransitGatewayMulticastDomainRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      transit_gateway_attachment_id: String.t option ;
      subnet_ids: ValueStringList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id 
      ?transit_gateway_attachment_id  ?(subnet_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        transit_gateway_attachment_id;
        subnet_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "SubnetIds" xml)
                  ValueStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SubnetIds", (ValueStringList.to_query v.subnet_ids)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("subnet_ids", (ValueStringList.to_json v.subnet_ids));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        subnet_ids =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "subnet_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpcEndpointRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_endpoint_id: String.t ;
      reset_policy: Boolean.t option ;
      policy_document: String.t option ;
      add_route_table_ids: VpcEndpointRouteTableIdList.t ;
      remove_route_table_ids: VpcEndpointRouteTableIdList.t ;
      add_subnet_ids: VpcEndpointSubnetIdList.t ;
      remove_subnet_ids: VpcEndpointSubnetIdList.t ;
      add_security_group_ids: VpcEndpointSecurityGroupIdList.t ;
      remove_security_group_ids: VpcEndpointSecurityGroupIdList.t ;
      private_dns_enabled: Boolean.t option }
    let make ?dry_run  ~vpc_endpoint_id  ?reset_policy  ?policy_document 
      ?(add_route_table_ids= [])  ?(remove_route_table_ids= []) 
      ?(add_subnet_ids= [])  ?(remove_subnet_ids= []) 
      ?(add_security_group_ids= [])  ?(remove_security_group_ids= []) 
      ?private_dns_enabled  () =
      {
        dry_run;
        vpc_endpoint_id;
        reset_policy;
        policy_document;
        add_route_table_ids;
        remove_route_table_ids;
        add_subnet_ids;
        remove_subnet_ids;
        add_security_group_ids;
        remove_security_group_ids;
        private_dns_enabled
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_endpoint_id =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  String.parse));
          reset_policy =
            (Util.option_bind (Xml.member "ResetPolicy" xml) Boolean.parse);
          policy_document =
            (Util.option_bind (Xml.member "PolicyDocument" xml) String.parse);
          add_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddRouteTableId" xml)
                  VpcEndpointRouteTableIdList.parse));
          remove_route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveRouteTableId" xml)
                  VpcEndpointRouteTableIdList.parse));
          add_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSubnetId" xml)
                  VpcEndpointSubnetIdList.parse));
          remove_subnet_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSubnetId" xml)
                  VpcEndpointSubnetIdList.parse));
          add_security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddSecurityGroupId" xml)
                  VpcEndpointSecurityGroupIdList.parse));
          remove_security_group_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveSecurityGroupId" xml)
                  VpcEndpointSecurityGroupIdList.parse));
          private_dns_enabled =
            (Util.option_bind (Xml.member "PrivateDnsEnabled" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f ->
                 Query.Pair ("PrivateDnsEnabled", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveSecurityGroupId",
                  (VpcEndpointSecurityGroupIdList.to_query
                     v.remove_security_group_ids)));
           Some
             (Query.Pair
                ("AddSecurityGroupId",
                  (VpcEndpointSecurityGroupIdList.to_query
                     v.add_security_group_ids)));
           Some
             (Query.Pair
                ("RemoveSubnetId",
                  (VpcEndpointSubnetIdList.to_query v.remove_subnet_ids)));
           Some
             (Query.Pair
                ("AddSubnetId",
                  (VpcEndpointSubnetIdList.to_query v.add_subnet_ids)));
           Some
             (Query.Pair
                ("RemoveRouteTableId",
                  (VpcEndpointRouteTableIdList.to_query
                     v.remove_route_table_ids)));
           Some
             (Query.Pair
                ("AddRouteTableId",
                  (VpcEndpointRouteTableIdList.to_query v.add_route_table_ids)));
           Util.option_map v.policy_document
             (fun f -> Query.Pair ("PolicyDocument", (String.to_query f)));
           Util.option_map v.reset_policy
             (fun f -> Query.Pair ("ResetPolicy", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VpcEndpointId", (String.to_query v.vpc_endpoint_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_dns_enabled
              (fun f -> ("private_dns_enabled", (Boolean.to_json f)));
           Some
             ("remove_security_group_ids",
               (VpcEndpointSecurityGroupIdList.to_json
                  v.remove_security_group_ids));
           Some
             ("add_security_group_ids",
               (VpcEndpointSecurityGroupIdList.to_json
                  v.add_security_group_ids));
           Some
             ("remove_subnet_ids",
               (VpcEndpointSubnetIdList.to_json v.remove_subnet_ids));
           Some
             ("add_subnet_ids",
               (VpcEndpointSubnetIdList.to_json v.add_subnet_ids));
           Some
             ("remove_route_table_ids",
               (VpcEndpointRouteTableIdList.to_json v.remove_route_table_ids));
           Some
             ("add_route_table_ids",
               (VpcEndpointRouteTableIdList.to_json v.add_route_table_ids));
           Util.option_map v.policy_document
             (fun f -> ("policy_document", (String.to_json f)));
           Util.option_map v.reset_policy
             (fun f -> ("reset_policy", (Boolean.to_json f)));
           Some ("vpc_endpoint_id", (String.to_json v.vpc_endpoint_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_id")));
        reset_policy =
          (Util.option_map (Json.lookup j "reset_policy") Boolean.of_json);
        policy_document =
          (Util.option_map (Json.lookup j "policy_document") String.of_json);
        add_route_table_ids =
          (VpcEndpointRouteTableIdList.of_json
             (Util.of_option_exn (Json.lookup j "add_route_table_ids")));
        remove_route_table_ids =
          (VpcEndpointRouteTableIdList.of_json
             (Util.of_option_exn (Json.lookup j "remove_route_table_ids")));
        add_subnet_ids =
          (VpcEndpointSubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "add_subnet_ids")));
        remove_subnet_ids =
          (VpcEndpointSubnetIdList.of_json
             (Util.of_option_exn (Json.lookup j "remove_subnet_ids")));
        add_security_group_ids =
          (VpcEndpointSecurityGroupIdList.of_json
             (Util.of_option_exn (Json.lookup j "add_security_group_ids")));
        remove_security_group_ids =
          (VpcEndpointSecurityGroupIdList.of_json
             (Util.of_option_exn (Json.lookup j "remove_security_group_ids")));
        private_dns_enabled =
          (Util.option_map (Json.lookup j "private_dns_enabled")
             Boolean.of_json)
      }
  end
module ModifyVolumeAttributeRequest =
  struct
    type t =
      {
      auto_enable_i_o: AttributeBooleanValue.t option ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ?auto_enable_i_o  ~volume_id  ?dry_run  () =
      { auto_enable_i_o; volume_id; dry_run }
    let parse xml =
      Some
        {
          auto_enable_i_o =
            (Util.option_bind (Xml.member "AutoEnableIO" xml)
               AttributeBooleanValue.parse);
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json);
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DisableTransitGatewayRouteTablePropagationRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~transit_gateway_attachment_id 
      ?dry_run  () =
      {
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t option }
    let make ?dry_run  ?vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f ->
                 Query.Pair ("VpcPeeringConnectionId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection_id
              (fun f -> ("vpc_peering_connection_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (Util.option_map (Json.lookup j "vpc_peering_connection_id")
             String.of_json)
      }
  end
module RevokeSecurityGroupIngressResult =
  struct
    type t =
      {
      return: Boolean.t option ;
      unknown_ip_permissions: IpPermissionList.t }
    let make ?return  ?(unknown_ip_permissions= [])  () =
      { return; unknown_ip_permissions }
    let parse xml =
      Some
        {
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse);
          unknown_ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "unknownIpPermissionSet" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnknownIpPermissionSet",
                   (IpPermissionList.to_query v.unknown_ip_permissions)));
           Util.option_map v.return
             (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unknown_ip_permissions",
                (IpPermissionList.to_json v.unknown_ip_permissions));
           Util.option_map v.return
             (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      {
        return = (Util.option_map (Json.lookup j "return") Boolean.of_json);
        unknown_ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "unknown_ip_permissions")))
      }
  end
module CreateTrafficMirrorSessionResult =
  struct
    type t =
      {
      traffic_mirror_session: TrafficMirrorSession.t option ;
      client_token: String.t option }
    let make ?traffic_mirror_session  ?client_token  () =
      { traffic_mirror_session; client_token }
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                Query.Pair
                  ("TrafficMirrorSession", (TrafficMirrorSession.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.traffic_mirror_session
             (fun f ->
                ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session =
          (Util.option_map (Json.lookup j "traffic_mirror_session")
             TrafficMirrorSession.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DescribeCarrierGatewaysRequest =
  struct
    type t =
      {
      carrier_gateway_ids: CarrierGatewayIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(carrier_gateway_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { carrier_gateway_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          carrier_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "CarrierGatewayId" xml)
                  CarrierGatewayIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("CarrierGatewayId",
                  (CarrierGatewayIdSet.to_query v.carrier_gateway_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("carrier_gateway_ids",
               (CarrierGatewayIdSet.to_json v.carrier_gateway_ids))])
    let of_json j =
      {
        carrier_gateway_ids =
          (CarrierGatewayIdSet.of_json
             (Util.of_option_exn (Json.lookup j "carrier_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeFleetsResult =
  struct
    type t = {
      next_token: String.t option ;
      fleets: FleetSet.t }
    let make ?next_token  ?(fleets= [])  () = { next_token; fleets }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          fleets =
            (Util.of_option []
               (Util.option_bind (Xml.member "fleetSet" xml) FleetSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("FleetSet", (FleetSet.to_query v.fleets)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("fleets", (FleetSet.to_json v.fleets));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleets =
          (FleetSet.of_json (Util.of_option_exn (Json.lookup j "fleets")))
      }
  end
module DescribeImportImageTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      import_task_ids: ImportTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(import_task_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; import_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filters" xml) FilterList.parse));
          import_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ImportTaskId" xml)
                  ImportTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ImportTaskId",
                  (ImportTaskIdList.to_query v.import_task_ids)));
           Some (Query.Pair ("Filters", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("import_task_ids",
               (ImportTaskIdList.to_json v.import_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        import_task_ids =
          (ImportTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "import_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module UnmonitorInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportKeyPairRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      key_name: String.t ;
      public_key_material: Blob.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ~key_name  ~public_key_material  ?(tag_specifications=
      [])  () =
      { dry_run; key_name; public_key_material; tag_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          key_name =
            (Xml.required "keyName"
               (Util.option_bind (Xml.member "keyName" xml) String.parse));
          public_key_material =
            (Xml.required "publicKeyMaterial"
               (Util.option_bind (Xml.member "publicKeyMaterial" xml)
                  Blob.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("PublicKeyMaterial", (Blob.to_query v.public_key_material)));
           Some (Query.Pair ("KeyName", (String.to_query v.key_name)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("public_key_material", (Blob.to_json v.public_key_material));
           Some ("key_name", (String.to_json v.key_name));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        key_name =
          (String.of_json (Util.of_option_exn (Json.lookup j "key_name")));
        public_key_material =
          (Blob.of_json
             (Util.of_option_exn (Json.lookup j "public_key_material")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module DeleteTrafficMirrorSessionResult =
  struct
    type t = {
      traffic_mirror_session_id: String.t option }
    let make ?traffic_mirror_session_id  () = { traffic_mirror_session_id }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Util.option_bind (Xml.member "trafficMirrorSessionId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f ->
                 Query.Pair ("TrafficMirrorSessionId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session_id
              (fun f -> ("traffic_mirror_session_id", (String.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (Util.option_map (Json.lookup j "traffic_mirror_session_id")
             String.of_json)
      }
  end
module GetEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInternetGatewaysRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      internet_gateway_ids: InternetGatewayIdList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(internet_gateway_ids= []) 
      ?next_token  ?max_results  () =
      { filters; dry_run; internet_gateway_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  InternetGatewayIdList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (InternetGatewayIdList.to_query v.internet_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("internet_gateway_ids",
               (InternetGatewayIdList.to_json v.internet_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_ids =
          (InternetGatewayIdList.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DeleteVpcPeeringConnectionResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteQueuedReservedInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instances_ids: DeleteQueuedReservedInstancesIdList.t }
    let make ?dry_run  ~reserved_instances_ids  () =
      { dry_run; reserved_instances_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instances_ids =
            (Xml.required "ReservedInstancesId"
               (Util.option_bind (Xml.member "ReservedInstancesId" xml)
                  DeleteQueuedReservedInstancesIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesId",
                   (DeleteQueuedReservedInstancesIdList.to_query
                      v.reserved_instances_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_ids",
                (DeleteQueuedReservedInstancesIdList.to_json
                   v.reserved_instances_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instances_ids =
          (DeleteQueuedReservedInstancesIdList.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instances_ids")))
      }
  end
module WithdrawByoipCidrRequest =
  struct
    type t = {
      cidr: String.t ;
      dry_run: Boolean.t option }
    let make ~cidr  ?dry_run  () = { cidr; dry_run }
    let parse xml =
      Some
        {
          cidr =
            (Xml.required "Cidr"
               (Util.option_bind (Xml.member "Cidr" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Cidr", (String.to_query v.cidr)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("cidr", (String.to_json v.cidr))])
    let of_json j =
      {
        cidr = (String.of_json (Util.of_option_exn (Json.lookup j "cidr")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeSpotFleetRequestsResponse =
  struct
    type t =
      {
      next_token: String.t option ;
      spot_fleet_request_configs: SpotFleetRequestConfigSet.t }
    let make ?next_token  ?(spot_fleet_request_configs= [])  () =
      { next_token; spot_fleet_request_configs }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotFleetRequestConfigSet" xml)
                  SpotFleetRequestConfigSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestConfigSet",
                   (SpotFleetRequestConfigSet.to_query
                      v.spot_fleet_request_configs)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_configs",
                (SpotFleetRequestConfigSet.to_json
                   v.spot_fleet_request_configs));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_configs =
          (SpotFleetRequestConfigSet.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_configs")))
      }
  end
module ImportVolumeResult =
  struct
    type t = {
      conversion_task: ConversionTask.t option }
    let make ?conversion_task  () = { conversion_task }
    let parse xml =
      Some
        {
          conversion_task =
            (Util.option_bind (Xml.member "conversionTask" xml)
               ConversionTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f ->
                 Query.Pair ("ConversionTask", (ConversionTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.conversion_task
              (fun f -> ("conversion_task", (ConversionTask.to_json f)))])
    let of_json j =
      {
        conversion_task =
          (Util.option_map (Json.lookup j "conversion_task")
             ConversionTask.of_json)
      }
  end
module DescribeFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: FpgaImageAttributeName.t }
    let make ?dry_run  ~fpga_image_id  ~attribute  () =
      { dry_run; fpga_image_id; attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  FpgaImageAttributeName.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Attribute", (FpgaImageAttributeName.to_query v.attribute)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("attribute", (FpgaImageAttributeName.to_json v.attribute));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (FpgaImageAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")))
      }
  end
module DescribeVolumeAttributeRequest =
  struct
    type t =
      {
      attribute: VolumeAttributeName.t ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~attribute  ~volume_id  ?dry_run  () =
      { attribute; volume_id; dry_run }
    let parse xml =
      Some
        {
          attribute =
            (Xml.required "Attribute"
               (Util.option_bind (Xml.member "Attribute" xml)
                  VolumeAttributeName.parse));
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some
             (Query.Pair
                ("Attribute", (VolumeAttributeName.to_query v.attribute)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("attribute", (VolumeAttributeName.to_json v.attribute))])
    let of_json j =
      {
        attribute =
          (VolumeAttributeName.of_json
             (Util.of_option_exn (Json.lookup j "attribute")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseScheduledInstancesRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      purchase_requests: PurchaseRequestSet.t }
    let make ?client_token  ?dry_run  ~purchase_requests  () =
      { client_token; dry_run; purchase_requests }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          purchase_requests =
            (Xml.required "PurchaseRequest"
               (Util.option_bind (Xml.member "PurchaseRequest" xml)
                  PurchaseRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PurchaseRequest",
                   (PurchaseRequestSet.to_query v.purchase_requests)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("purchase_requests",
                (PurchaseRequestSet.to_json v.purchase_requests));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        purchase_requests =
          (PurchaseRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase_requests")))
      }
  end
module CreateNetworkAclResult =
  struct
    type t = {
      network_acl: NetworkAcl.t option }
    let make ?network_acl  () = { network_acl }
    let parse xml =
      Some
        {
          network_acl =
            (Util.option_bind (Xml.member "networkAcl" xml) NetworkAcl.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> Query.Pair ("NetworkAcl", (NetworkAcl.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_acl
              (fun f -> ("network_acl", (NetworkAcl.to_json f)))])
    let of_json j =
      {
        network_acl =
          (Util.option_map (Json.lookup j "network_acl") NetworkAcl.of_json)
      }
  end
module DisassociateIamInstanceProfileResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module CreateRouteTableResult =
  struct
    type t = {
      route_table: RouteTable.t option }
    let make ?route_table  () = { route_table }
    let parse xml =
      Some
        {
          route_table =
            (Util.option_bind (Xml.member "routeTable" xml) RouteTable.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> Query.Pair ("RouteTable", (RouteTable.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route_table
              (fun f -> ("route_table", (RouteTable.to_json f)))])
    let of_json j =
      {
        route_table =
          (Util.option_map (Json.lookup j "route_table") RouteTable.of_json)
      }
  end
module DeleteNetworkInterfaceRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      network_interface_id: String.t }
    let make ?dry_run  ~network_interface_id  () =
      { dry_run; network_interface_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("NetworkInterfaceId",
                   (String.to_query v.network_interface_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("network_interface_id",
                (String.to_json v.network_interface_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")))
      }
  end
module EnableEbsEncryptionByDefaultRequest =
  struct
    type t = {
      dry_run: Boolean.t option }
    let make ?dry_run  () = { dry_run }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      { dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeAvailabilityZonesResult =
  struct
    type t = {
      availability_zones: AvailabilityZoneList.t }
    let make ?(availability_zones= [])  () = { availability_zones }
    let parse xml =
      Some
        {
          availability_zones =
            (Util.of_option []
               (Util.option_bind (Xml.member "availabilityZoneInfo" xml)
                  AvailabilityZoneList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AvailabilityZoneInfo",
                   (AvailabilityZoneList.to_query v.availability_zones)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("availability_zones",
                (AvailabilityZoneList.to_json v.availability_zones))])
    let of_json j =
      {
        availability_zones =
          (AvailabilityZoneList.of_json
             (Util.of_option_exn (Json.lookup j "availability_zones")))
      }
  end
module DescribeCoipPoolsRequest =
  struct
    type t =
      {
      pool_ids: CoipPoolIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(pool_ids= [])  ?(filters= [])  ?max_results  ?next_token 
      ?dry_run  () = { pool_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          pool_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PoolId" xml)
                  CoipPoolIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("PoolId", (CoipPoolIdSet.to_query v.pool_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("pool_ids", (CoipPoolIdSet.to_json v.pool_ids))])
    let of_json j =
      {
        pool_ids =
          (CoipPoolIdSet.of_json
             (Util.of_option_exn (Json.lookup j "pool_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module StartInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      additional_info: String.t option ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?additional_info  ?dry_run  () =
      { instance_ids; additional_info; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          additional_info =
            (Util.option_bind (Xml.member "additionalInfo" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.additional_info
             (fun f -> Query.Pair ("AdditionalInfo", (String.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.additional_info
             (fun f -> ("additional_info", (String.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        additional_info =
          (Util.option_map (Json.lookup j "additional_info") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImportImageResult =
  struct
    type t =
      {
      architecture: String.t option ;
      description: String.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      image_id: String.t option ;
      import_task_id: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      progress: String.t option ;
      snapshot_details: SnapshotDetailList.t ;
      status: String.t option ;
      status_message: String.t option ;
      license_specifications: ImportImageLicenseSpecificationListResponse.t ;
      tags: TagList.t }
    let make ?architecture  ?description  ?encrypted  ?hypervisor  ?image_id 
      ?import_task_id  ?kms_key_id  ?license_type  ?platform  ?progress 
      ?(snapshot_details= [])  ?status  ?status_message 
      ?(license_specifications= [])  ?(tags= [])  () =
      {
        architecture;
        description;
        encrypted;
        hypervisor;
        image_id;
        import_task_id;
        kms_key_id;
        license_type;
        platform;
        progress;
        snapshot_details;
        status;
        status_message;
        license_specifications;
        tags
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "architecture" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          encrypted =
            (Util.option_bind (Xml.member "encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "hypervisor" xml) String.parse);
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          import_task_id =
            (Util.option_bind (Xml.member "importTaskId" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "licenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "platform" xml) String.parse);
          progress =
            (Util.option_bind (Xml.member "progress" xml) String.parse);
          snapshot_details =
            (Util.of_option []
               (Util.option_bind (Xml.member "snapshotDetailSet" xml)
                  SnapshotDetailList.parse));
          status = (Util.option_bind (Xml.member "status" xml) String.parse);
          status_message =
            (Util.option_bind (Xml.member "statusMessage" xml) String.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "licenseSpecifications" xml)
                  ImportImageLicenseSpecificationListResponse.parse));
          tags =
            (Util.of_option []
               (Util.option_bind (Xml.member "tagSet" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("TagSet", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("LicenseSpecifications",
                  (ImportImageLicenseSpecificationListResponse.to_query
                     v.license_specifications)));
           Util.option_map v.status_message
             (fun f -> Query.Pair ("StatusMessage", (String.to_query f)));
           Util.option_map v.status
             (fun f -> Query.Pair ("Status", (String.to_query f)));
           Some
             (Query.Pair
                ("SnapshotDetailSet",
                  (SnapshotDetailList.to_query v.snapshot_details)));
           Util.option_map v.progress
             (fun f -> Query.Pair ("Progress", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.import_task_id
             (fun f -> Query.Pair ("ImportTaskId", (String.to_query f)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some
             ("license_specifications",
               (ImportImageLicenseSpecificationListResponse.to_json
                  v.license_specifications));
           Util.option_map v.status_message
             (fun f -> ("status_message", (String.to_json f)));
           Util.option_map v.status (fun f -> ("status", (String.to_json f)));
           Some
             ("snapshot_details",
               (SnapshotDetailList.to_json v.snapshot_details));
           Util.option_map v.progress
             (fun f -> ("progress", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.import_task_id
             (fun f -> ("import_task_id", (String.to_json f)));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        import_task_id =
          (Util.option_map (Json.lookup j "import_task_id") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        progress =
          (Util.option_map (Json.lookup j "progress") String.of_json);
        snapshot_details =
          (SnapshotDetailList.of_json
             (Util.of_option_exn (Json.lookup j "snapshot_details")));
        status = (Util.option_map (Json.lookup j "status") String.of_json);
        status_message =
          (Util.option_map (Json.lookup j "status_message") String.of_json);
        license_specifications =
          (ImportImageLicenseSpecificationListResponse.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module DescribeCustomerGatewaysResult =
  struct
    type t = {
      customer_gateways: CustomerGatewayList.t }
    let make ?(customer_gateways= [])  () = { customer_gateways }
    let parse xml =
      Some
        {
          customer_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "customerGatewaySet" xml)
                  CustomerGatewayList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CustomerGatewaySet",
                   (CustomerGatewayList.to_query v.customer_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("customer_gateways",
                (CustomerGatewayList.to_json v.customer_gateways))])
    let of_json j =
      {
        customer_gateways =
          (CustomerGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateways")))
      }
  end
module DescribeSpotFleetRequestHistoryRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      event_type: EventType.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t ;
      start_time: DateTime.t }
    let make ?dry_run  ?event_type  ?max_results  ?next_token 
      ~spot_fleet_request_id  ~start_time  () =
      {
        dry_run;
        event_type;
        max_results;
        next_token;
        spot_fleet_request_id;
        start_time
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          event_type =
            (Util.option_bind (Xml.member "eventType" xml) EventType.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          start_time =
            (Xml.required "startTime"
               (Util.option_bind (Xml.member "startTime" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("StartTime", (DateTime.to_query v.start_time)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.event_type
             (fun f -> Query.Pair ("EventType", (EventType.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("start_time", (DateTime.to_json v.start_time));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.event_type
             (fun f -> ("event_type", (EventType.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        event_type =
          (Util.option_map (Json.lookup j "event_type") EventType.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        start_time =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "start_time")))
      }
  end
module ModifyVpnConnectionResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module DeleteVolumeRequest =
  struct
    type t = {
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~volume_id  ?dry_run  () = { volume_id; dry_run }
    let parse xml =
      Some
        {
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id))])
    let of_json j =
      {
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceIamInstanceProfileAssociationResult =
  struct
    type t =
      {
      iam_instance_profile_association:
        IamInstanceProfileAssociation.t option }
    let make ?iam_instance_profile_association  () =
      { iam_instance_profile_association }
    let parse xml =
      Some
        {
          iam_instance_profile_association =
            (Util.option_bind
               (Xml.member "iamInstanceProfileAssociation" xml)
               IamInstanceProfileAssociation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 Query.Pair
                   ("IamInstanceProfileAssociation",
                     (IamInstanceProfileAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.iam_instance_profile_association
              (fun f ->
                 ("iam_instance_profile_association",
                   (IamInstanceProfileAssociation.to_json f)))])
    let of_json j =
      {
        iam_instance_profile_association =
          (Util.option_map (Json.lookup j "iam_instance_profile_association")
             IamInstanceProfileAssociation.of_json)
      }
  end
module DescribeByoipCidrsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t ;
      next_token: String.t option }
    let make ?dry_run  ~max_results  ?next_token  () =
      { dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Xml.required "MaxResults"
               (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("MaxResults", (Integer.to_query v.max_results)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("max_results", (Integer.to_json v.max_results));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Integer.of_json (Util.of_option_exn (Json.lookup j "max_results")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeVolumeStatusResult =
  struct
    type t =
      {
      next_token: String.t option ;
      volume_statuses: VolumeStatusList.t }
    let make ?next_token  ?(volume_statuses= [])  () =
      { next_token; volume_statuses }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          volume_statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "volumeStatusSet" xml)
                  VolumeStatusList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VolumeStatusSet",
                   (VolumeStatusList.to_query v.volume_statuses)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("volume_statuses",
                (VolumeStatusList.to_json v.volume_statuses));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        volume_statuses =
          (VolumeStatusList.of_json
             (Util.of_option_exn (Json.lookup j "volume_statuses")))
      }
  end
module AssociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option ;
      status: AssociationStatus.t option }
    let make ?association_id  ?status  () = { association_id; status }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json)
      }
  end
module ReplaceTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module DeleteVpcEndpointServiceConfigurationsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module ModifyEbsDefaultKmsKeyIdResult =
  struct
    type t = {
      kms_key_id: String.t option }
    let make ?kms_key_id  () = { kms_key_id }
    let parse xml =
      Some
        {
          kms_key_id =
            (Util.option_bind (Xml.member "kmsKeyId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.kms_key_id
              (fun f -> ("kms_key_id", (String.to_json f)))])
    let of_json j =
      {
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json)
      }
  end
module DisableVpcClassicLinkResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteFlowLogsResult =
  struct
    type t = {
      unsuccessful: UnsuccessfulItemSet.t }
    let make ?(unsuccessful= [])  () = { unsuccessful }
    let parse xml =
      Some
        {
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemSet.to_query v.unsuccessful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemSet.to_json v.unsuccessful))])
    let of_json j =
      {
        unsuccessful =
          (UnsuccessfulItemSet.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module AttachVpnGatewayResult =
  struct
    type t = {
      vpc_attachment: VpcAttachment.t option }
    let make ?vpc_attachment  () = { vpc_attachment }
    let parse xml =
      Some
        {
          vpc_attachment =
            (Util.option_bind (Xml.member "attachment" xml)
               VpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> Query.Pair ("Attachment", (VpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_attachment
              (fun f -> ("vpc_attachment", (VpcAttachment.to_json f)))])
    let of_json j =
      {
        vpc_attachment =
          (Util.option_map (Json.lookup j "vpc_attachment")
             VpcAttachment.of_json)
      }
  end
module CreateTransitGatewayRequest =
  struct
    type t =
      {
      description: String.t option ;
      options: TransitGatewayRequestOptions.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ?description  ?options  ?(tag_specifications= [])  ?dry_run  ()
      = { description; options; tag_specifications; dry_run }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          options =
            (Util.option_bind (Xml.member "Options" xml)
               TransitGatewayRequestOptions.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.options
             (fun f ->
                Query.Pair
                  ("Options", (TransitGatewayRequestOptions.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.options
             (fun f -> ("options", (TransitGatewayRequestOptions.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        options =
          (Util.option_map (Json.lookup j "options")
             TransitGatewayRequestOptions.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ImageAttribute =
  struct
    type t =
      {
      block_device_mappings: BlockDeviceMappingList.t ;
      image_id: String.t option ;
      launch_permissions: LaunchPermissionList.t ;
      product_codes: ProductCodeList.t ;
      description: AttributeValue.t option ;
      kernel_id: AttributeValue.t option ;
      ramdisk_id: AttributeValue.t option ;
      sriov_net_support: AttributeValue.t option }
    let make ?(block_device_mappings= [])  ?image_id  ?(launch_permissions=
      [])  ?(product_codes= [])  ?description  ?kernel_id  ?ramdisk_id 
      ?sriov_net_support  () =
      {
        block_device_mappings;
        image_id;
        launch_permissions;
        product_codes;
        description;
        kernel_id;
        ramdisk_id;
        sriov_net_support
      }
    let parse xml =
      Some
        {
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  BlockDeviceMappingList.parse));
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse);
          launch_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "launchPermission" xml)
                  LaunchPermissionList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          description =
            (Util.option_bind (Xml.member "description" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f ->
                 Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.description
             (fun f ->
                Query.Pair ("Description", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("LaunchPermission",
                  (LaunchPermissionList.to_query v.launch_permissions)));
           Util.option_map v.image_id
             (fun f -> Query.Pair ("ImageId", (String.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (BlockDeviceMappingList.to_query v.block_device_mappings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.sriov_net_support
              (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Some
             ("launch_permissions",
               (LaunchPermissionList.to_json v.launch_permissions));
           Util.option_map v.image_id
             (fun f -> ("image_id", (String.to_json f)));
           Some
             ("block_device_mappings",
               (BlockDeviceMappingList.to_json v.block_device_mappings))])
    let of_json j =
      {
        block_device_mappings =
          (BlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json);
        launch_permissions =
          (LaunchPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "launch_permissions")));
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        description =
          (Util.option_map (Json.lookup j "description")
             AttributeValue.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json)
      }
  end
module DetachClassicLinkVpcResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module GetTransitGatewayRouteTableAssociationsResult =
  struct
    type t =
      {
      associations: TransitGatewayRouteTableAssociationList.t ;
      next_token: String.t option }
    let make ?(associations= [])  ?next_token  () =
      { associations; next_token }
    let parse xml =
      Some
        {
          associations =
            (Util.of_option []
               (Util.option_bind (Xml.member "associations" xml)
                  TransitGatewayRouteTableAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("Associations",
                  (TransitGatewayRouteTableAssociationList.to_query
                     v.associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("associations",
               (TransitGatewayRouteTableAssociationList.to_json
                  v.associations))])
    let of_json j =
      {
        associations =
          (TransitGatewayRouteTableAssociationList.of_json
             (Util.of_option_exn (Json.lookup j "associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyInstanceEventStartTimeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      instance_event_id: String.t ;
      not_before: DateTime.t }
    let make ?dry_run  ~instance_id  ~instance_event_id  ~not_before  () =
      { dry_run; instance_id; instance_event_id; not_before }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          instance_event_id =
            (Xml.required "InstanceEventId"
               (Util.option_bind (Xml.member "InstanceEventId" xml)
                  String.parse));
          not_before =
            (Xml.required "NotBefore"
               (Util.option_bind (Xml.member "NotBefore" xml) DateTime.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("NotBefore", (DateTime.to_query v.not_before)));
           Some
             (Query.Pair
                ("InstanceEventId", (String.to_query v.instance_event_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("not_before", (DateTime.to_json v.not_before));
           Some ("instance_event_id", (String.to_json v.instance_event_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        instance_event_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "instance_event_id")));
        not_before =
          (DateTime.of_json (Util.of_option_exn (Json.lookup j "not_before")))
      }
  end
module DeleteSnapshotRequest =
  struct
    type t = {
      snapshot_id: String.t ;
      dry_run: Boolean.t option }
    let make ~snapshot_id  ?dry_run  () = { snapshot_id; dry_run }
    let parse xml =
      Some
        {
          snapshot_id =
            (Xml.required "SnapshotId"
               (Util.option_bind (Xml.member "SnapshotId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("SnapshotId", (String.to_query v.snapshot_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("snapshot_id", (String.to_json v.snapshot_id))])
    let of_json j =
      {
        snapshot_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "snapshot_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ReplaceIamInstanceProfileAssociationRequest =
  struct
    type t =
      {
      iam_instance_profile: IamInstanceProfileSpecification.t ;
      association_id: String.t }
    let make ~iam_instance_profile  ~association_id  () =
      { iam_instance_profile; association_id }
    let parse xml =
      Some
        {
          iam_instance_profile =
            (Xml.required "IamInstanceProfile"
               (Util.option_bind (Xml.member "IamInstanceProfile" xml)
                  IamInstanceProfileSpecification.parse));
          association_id =
            (Xml.required "AssociationId"
               (Util.option_bind (Xml.member "AssociationId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("AssociationId", (String.to_query v.association_id)));
           Some
             (Query.Pair
                ("IamInstanceProfile",
                  (IamInstanceProfileSpecification.to_query
                     v.iam_instance_profile)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("association_id", (String.to_json v.association_id));
           Some
             ("iam_instance_profile",
               (IamInstanceProfileSpecification.to_json
                  v.iam_instance_profile))])
    let of_json j =
      {
        iam_instance_profile =
          (IamInstanceProfileSpecification.of_json
             (Util.of_option_exn (Json.lookup j "iam_instance_profile")));
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")))
      }
  end
module DisassociateEnclaveCertificateIamRoleRequest =
  struct
    type t =
      {
      certificate_arn: String.t option ;
      role_arn: String.t option ;
      dry_run: Boolean.t option }
    let make ?certificate_arn  ?role_arn  ?dry_run  () =
      { certificate_arn; role_arn; dry_run }
    let parse xml =
      Some
        {
          certificate_arn =
            (Util.option_bind (Xml.member "CertificateArn" xml) String.parse);
          role_arn =
            (Util.option_bind (Xml.member "RoleArn" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.role_arn
             (fun f -> Query.Pair ("RoleArn", (String.to_query f)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.role_arn
             (fun f -> ("role_arn", (String.to_json f)));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)))])
    let of_json j =
      {
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        role_arn =
          (Util.option_map (Json.lookup j "role_arn") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetAssociatedEnclaveCertificateIamRolesRequest =
  struct
    type t = {
      certificate_arn: String.t option ;
      dry_run: Boolean.t option }
    let make ?certificate_arn  ?dry_run  () = { certificate_arn; dry_run }
    let parse xml =
      Some
        {
          certificate_arn =
            (Util.option_bind (Xml.member "CertificateArn" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.certificate_arn
             (fun f -> Query.Pair ("CertificateArn", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.certificate_arn
             (fun f -> ("certificate_arn", (String.to_json f)))])
    let of_json j =
      {
        certificate_arn =
          (Util.option_map (Json.lookup j "certificate_arn") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeHostReservationOfferingsResult =
  struct
    type t = {
      next_token: String.t option ;
      offering_set: HostOfferingSet.t }
    let make ?next_token  ?(offering_set= [])  () =
      { next_token; offering_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          offering_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "offeringSet" xml)
                  HostOfferingSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("OfferingSet", (HostOfferingSet.to_query v.offering_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("offering_set", (HostOfferingSet.to_json v.offering_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_set =
          (HostOfferingSet.of_json
             (Util.of_option_exn (Json.lookup j "offering_set")))
      }
  end
module DescribeTransitGatewaysRequest =
  struct
    type t =
      {
      transit_gateway_ids: TransitGatewayIdStringList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(transit_gateway_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      { transit_gateway_ids; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TransitGatewayIds" xml)
                  TransitGatewayIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayIds",
                  (TransitGatewayIdStringList.to_query v.transit_gateway_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_ids",
               (TransitGatewayIdStringList.to_json v.transit_gateway_ids))])
    let of_json j =
      {
        transit_gateway_ids =
          (TransitGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstancePlacementRequest =
  struct
    type t =
      {
      affinity: Affinity.t option ;
      group_name: String.t option ;
      host_id: String.t option ;
      instance_id: String.t ;
      tenancy: HostTenancy.t option ;
      partition_number: Integer.t option ;
      host_resource_group_arn: String.t option }
    let make ?affinity  ?group_name  ?host_id  ~instance_id  ?tenancy 
      ?partition_number  ?host_resource_group_arn  () =
      {
        affinity;
        group_name;
        host_id;
        instance_id;
        tenancy;
        partition_number;
        host_resource_group_arn
      }
    let parse xml =
      Some
        {
          affinity =
            (Util.option_bind (Xml.member "affinity" xml) Affinity.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          host_id = (Util.option_bind (Xml.member "hostId" xml) String.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          tenancy =
            (Util.option_bind (Xml.member "tenancy" xml) HostTenancy.parse);
          partition_number =
            (Util.option_bind (Xml.member "PartitionNumber" xml)
               Integer.parse);
          host_resource_group_arn =
            (Util.option_bind (Xml.member "HostResourceGroupArn" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f ->
                 Query.Pair ("HostResourceGroupArn", (String.to_query f)));
           Util.option_map v.partition_number
             (fun f -> Query.Pair ("PartitionNumber", (Integer.to_query f)));
           Util.option_map v.tenancy
             (fun f -> Query.Pair ("Tenancy", (HostTenancy.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.host_id
             (fun f -> Query.Pair ("HostId", (String.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.affinity
             (fun f -> Query.Pair ("Affinity", (Affinity.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.host_resource_group_arn
              (fun f -> ("host_resource_group_arn", (String.to_json f)));
           Util.option_map v.partition_number
             (fun f -> ("partition_number", (Integer.to_json f)));
           Util.option_map v.tenancy
             (fun f -> ("tenancy", (HostTenancy.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.host_id
             (fun f -> ("host_id", (String.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.affinity
             (fun f -> ("affinity", (Affinity.to_json f)))])
    let of_json j =
      {
        affinity =
          (Util.option_map (Json.lookup j "affinity") Affinity.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        host_id = (Util.option_map (Json.lookup j "host_id") String.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        tenancy =
          (Util.option_map (Json.lookup j "tenancy") HostTenancy.of_json);
        partition_number =
          (Util.option_map (Json.lookup j "partition_number") Integer.of_json);
        host_resource_group_arn =
          (Util.option_map (Json.lookup j "host_resource_group_arn")
             String.of_json)
      }
  end
module DescribeNatGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filter: FilterList.t ;
      max_results: Integer.t option ;
      nat_gateway_ids: NatGatewayIdStringList.t ;
      next_token: String.t option }
    let make ?dry_run  ?(filter= [])  ?max_results  ?(nat_gateway_ids= []) 
      ?next_token  () =
      { dry_run; filter; max_results; nat_gateway_ids; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          nat_gateway_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NatGatewayId" xml)
                  NatGatewayIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewayId",
                  (NatGatewayIdStringList.to_query v.nat_gateway_ids)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("nat_gateway_ids",
               (NatGatewayIdStringList.to_json v.nat_gateway_ids));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filter", (FilterList.to_json v.filter));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        nat_gateway_ids =
          (NatGatewayIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateway_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeEgressOnlyInternetGatewaysRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      egress_only_internet_gateway_ids: EgressOnlyInternetGatewayIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      filters: FilterList.t }
    let make ?dry_run  ?(egress_only_internet_gateway_ids= [])  ?max_results 
      ?next_token  ?(filters= [])  () =
      {
        dry_run;
        egress_only_internet_gateway_ids;
        max_results;
        next_token;
        filters
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          egress_only_internet_gateway_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "EgressOnlyInternetGatewayId" xml)
                  EgressOnlyInternetGatewayIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("EgressOnlyInternetGatewayId",
                  (EgressOnlyInternetGatewayIdList.to_query
                     v.egress_only_internet_gateway_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("egress_only_internet_gateway_ids",
               (EgressOnlyInternetGatewayIdList.to_json
                  v.egress_only_internet_gateway_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        egress_only_internet_gateway_ids =
          (EgressOnlyInternetGatewayIdList.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateway_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module DescribeSpotInstanceRequestsResult =
  struct
    type t =
      {
      spot_instance_requests: SpotInstanceRequestList.t ;
      next_token: String.t option }
    let make ?(spot_instance_requests= [])  ?next_token  () =
      { spot_instance_requests; next_token }
    let parse xml =
      Some
        {
          spot_instance_requests =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotInstanceRequestSet" xml)
                  SpotInstanceRequestList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("SpotInstanceRequestSet",
                  (SpotInstanceRequestList.to_query v.spot_instance_requests)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("spot_instance_requests",
               (SpotInstanceRequestList.to_json v.spot_instance_requests))])
    let of_json j =
      {
        spot_instance_requests =
          (SpotInstanceRequestList.of_json
             (Util.of_option_exn (Json.lookup j "spot_instance_requests")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTransitGatewayVpcAttachmentResult =
  struct
    type t =
      {
      transit_gateway_vpc_attachment: TransitGatewayVpcAttachment.t option }
    let make ?transit_gateway_vpc_attachment  () =
      { transit_gateway_vpc_attachment }
    let parse xml =
      Some
        {
          transit_gateway_vpc_attachment =
            (Util.option_bind (Xml.member "transitGatewayVpcAttachment" xml)
               TransitGatewayVpcAttachment.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 Query.Pair
                   ("TransitGatewayVpcAttachment",
                     (TransitGatewayVpcAttachment.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_vpc_attachment
              (fun f ->
                 ("transit_gateway_vpc_attachment",
                   (TransitGatewayVpcAttachment.to_json f)))])
    let of_json j =
      {
        transit_gateway_vpc_attachment =
          (Util.option_map (Json.lookup j "transit_gateway_vpc_attachment")
             TransitGatewayVpcAttachment.of_json)
      }
  end
module ModifyFpgaImageAttributeResult =
  struct
    type t = {
      fpga_image_attribute: FpgaImageAttribute.t option }
    let make ?fpga_image_attribute  () = { fpga_image_attribute }
    let parse xml =
      Some
        {
          fpga_image_attribute =
            (Util.option_bind (Xml.member "fpgaImageAttribute" xml)
               FpgaImageAttribute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 Query.Pair
                   ("FpgaImageAttribute", (FpgaImageAttribute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_attribute
              (fun f ->
                 ("fpga_image_attribute", (FpgaImageAttribute.to_json f)))])
    let of_json j =
      {
        fpga_image_attribute =
          (Util.option_map (Json.lookup j "fpga_image_attribute")
             FpgaImageAttribute.of_json)
      }
  end
module DeleteFpgaImageRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t }
    let make ?dry_run  ~fpga_image_id  () = { dry_run; fpga_image_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")))
      }
  end
module GetManagedPrefixListAssociationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_id: String.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ~prefix_list_id  ?max_results  ?next_token  () =
      { dry_run; prefix_list_id; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeFastSnapshotRestoresRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(filters= [])  ?max_results  ?next_token  ?dry_run  () =
      { filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AcceptVpcPeeringConnectionResult =
  struct
    type t = {
      vpc_peering_connection: VpcPeeringConnection.t option }
    let make ?vpc_peering_connection  () = { vpc_peering_connection }
    let parse xml =
      Some
        {
          vpc_peering_connection =
            (Util.option_bind (Xml.member "vpcPeeringConnection" xml)
               VpcPeeringConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 Query.Pair
                   ("VpcPeeringConnection",
                     (VpcPeeringConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc_peering_connection
              (fun f ->
                 ("vpc_peering_connection", (VpcPeeringConnection.to_json f)))])
    let of_json j =
      {
        vpc_peering_connection =
          (Util.option_map (Json.lookup j "vpc_peering_connection")
             VpcPeeringConnection.of_json)
      }
  end
module GetTransitGatewayRouteTablePropagationsRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateNetworkInterfacePermissionResult =
  struct
    type t = {
      interface_permission: NetworkInterfacePermission.t option }
    let make ?interface_permission  () = { interface_permission }
    let parse xml =
      Some
        {
          interface_permission =
            (Util.option_bind (Xml.member "interfacePermission" xml)
               NetworkInterfacePermission.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 Query.Pair
                   ("InterfacePermission",
                     (NetworkInterfacePermission.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.interface_permission
              (fun f ->
                 ("interface_permission",
                   (NetworkInterfacePermission.to_json f)))])
    let of_json j =
      {
        interface_permission =
          (Util.option_map (Json.lookup j "interface_permission")
             NetworkInterfacePermission.of_json)
      }
  end
module AuthorizeClientVpnIngressRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_network_cidr: String.t ;
      access_group_id: String.t option ;
      authorize_all_groups: Boolean.t option ;
      description: String.t option ;
      client_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~target_network_cidr  ?access_group_id 
      ?authorize_all_groups  ?description  ?client_token  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_network_cidr;
        access_group_id;
        authorize_all_groups;
        description;
        client_token;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_network_cidr =
            (Xml.required "TargetNetworkCidr"
               (Util.option_bind (Xml.member "TargetNetworkCidr" xml)
                  String.parse));
          access_group_id =
            (Util.option_bind (Xml.member "AccessGroupId" xml) String.parse);
          authorize_all_groups =
            (Util.option_bind (Xml.member "AuthorizeAllGroups" xml)
               Boolean.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.authorize_all_groups
             (fun f ->
                Query.Pair ("AuthorizeAllGroups", (Boolean.to_query f)));
           Util.option_map v.access_group_id
             (fun f -> Query.Pair ("AccessGroupId", (String.to_query f)));
           Some
             (Query.Pair
                ("TargetNetworkCidr",
                  (String.to_query v.target_network_cidr)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.authorize_all_groups
             (fun f -> ("authorize_all_groups", (Boolean.to_json f)));
           Util.option_map v.access_group_id
             (fun f -> ("access_group_id", (String.to_json f)));
           Some
             ("target_network_cidr", (String.to_json v.target_network_cidr));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_network_cidr =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "target_network_cidr")));
        access_group_id =
          (Util.option_map (Json.lookup j "access_group_id") String.of_json);
        authorize_all_groups =
          (Util.option_map (Json.lookup j "authorize_all_groups")
             Boolean.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeNetworkInterfacePermissionsRequest =
  struct
    type t =
      {
      network_interface_permission_ids: NetworkInterfacePermissionIdList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(network_interface_permission_ids= [])  ?(filters= []) 
      ?next_token  ?max_results  () =
      { network_interface_permission_ids; filters; next_token; max_results }
    let parse xml =
      Some
        {
          network_interface_permission_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "NetworkInterfacePermissionId" xml)
                  NetworkInterfacePermissionIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissionId",
                  (NetworkInterfacePermissionIdList.to_query
                     v.network_interface_permission_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("network_interface_permission_ids",
               (NetworkInterfacePermissionIdList.to_json
                  v.network_interface_permission_ids))])
    let of_json j =
      {
        network_interface_permission_ids =
          (NetworkInterfacePermissionIdList.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permission_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module DescribeTrafficMirrorFiltersRequest =
  struct
    type t =
      {
      traffic_mirror_filter_ids: TrafficMirrorFilterIdList.t ;
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(traffic_mirror_filter_ids= [])  ?dry_run  ?(filters= []) 
      ?max_results  ?next_token  () =
      { traffic_mirror_filter_ids; dry_run; filters; max_results; next_token
      }
    let parse xml =
      Some
        {
          traffic_mirror_filter_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  TrafficMirrorFilterIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (TrafficMirrorFilterIdList.to_query
                     v.traffic_mirror_filter_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_ids",
               (TrafficMirrorFilterIdList.to_json v.traffic_mirror_filter_ids))])
    let of_json j =
      {
        traffic_mirror_filter_ids =
          (TrafficMirrorFilterIdList.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ReplaceTransitGatewayRouteRequest =
  struct
    type t =
      {
      destination_cidr_block: String.t ;
      transit_gateway_route_table_id: String.t ;
      transit_gateway_attachment_id: String.t option ;
      blackhole: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~destination_cidr_block  ~transit_gateway_route_table_id 
      ?transit_gateway_attachment_id  ?blackhole  ?dry_run  () =
      {
        destination_cidr_block;
        transit_gateway_route_table_id;
        transit_gateway_attachment_id;
        blackhole;
        dry_run
      }
    let parse xml =
      Some
        {
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          transit_gateway_attachment_id =
            (Util.option_bind (Xml.member "TransitGatewayAttachmentId" xml)
               String.parse);
          blackhole =
            (Util.option_bind (Xml.member "Blackhole" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.blackhole
             (fun f -> Query.Pair ("Blackhole", (Boolean.to_query f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayAttachmentId", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.blackhole
             (fun f -> ("blackhole", (Boolean.to_json f)));
           Util.option_map v.transit_gateway_attachment_id
             (fun f -> ("transit_gateway_attachment_id", (String.to_json f)));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block))])
    let of_json j =
      {
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        transit_gateway_attachment_id =
          (Util.option_map (Json.lookup j "transit_gateway_attachment_id")
             String.of_json);
        blackhole =
          (Util.option_map (Json.lookup j "blackhole") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateVpnGatewayRequest =
  struct
    type t =
      {
      availability_zone: String.t option ;
      type_: GatewayType.t ;
      tag_specifications: TagSpecificationList.t ;
      amazon_side_asn: Long.t option ;
      dry_run: Boolean.t option }
    let make ?availability_zone  ~type_  ?(tag_specifications= []) 
      ?amazon_side_asn  ?dry_run  () =
      {
        availability_zone;
        type_;
        tag_specifications;
        amazon_side_asn;
        dry_run
      }
    let parse xml =
      Some
        {
          availability_zone =
            (Util.option_bind (Xml.member "AvailabilityZone" xml)
               String.parse);
          type_ =
            (Xml.required "Type"
               (Util.option_bind (Xml.member "Type" xml) GatewayType.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          amazon_side_asn =
            (Util.option_bind (Xml.member "AmazonSideAsn" xml) Long.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.amazon_side_asn
             (fun f -> Query.Pair ("AmazonSideAsn", (Long.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("Type", (GatewayType.to_query v.type_)));
           Util.option_map v.availability_zone
             (fun f -> Query.Pair ("AvailabilityZone", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.amazon_side_asn
             (fun f -> ("amazon_side_asn", (Long.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("type_", (GatewayType.to_json v.type_));
           Util.option_map v.availability_zone
             (fun f -> ("availability_zone", (String.to_json f)))])
    let of_json j =
      {
        availability_zone =
          (Util.option_map (Json.lookup j "availability_zone") String.of_json);
        type_ =
          (GatewayType.of_json (Util.of_option_exn (Json.lookup j "type_")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        amazon_side_asn =
          (Util.option_map (Json.lookup j "amazon_side_asn") Long.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetManagedPrefixListEntriesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_id: String.t ;
      target_version: Long.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ~prefix_list_id  ?target_version  ?max_results 
      ?next_token  () =
      { dry_run; prefix_list_id; target_version; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          target_version =
            (Util.option_bind (Xml.member "TargetVersion" xml) Long.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.target_version
             (fun f -> Query.Pair ("TargetVersion", (Long.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.target_version
             (fun f -> ("target_version", (Long.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        target_version =
          (Util.option_map (Json.lookup j "target_version") Long.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTrafficMirrorSessionResult =
  struct
    type t = {
      traffic_mirror_session: TrafficMirrorSession.t option }
    let make ?traffic_mirror_session  () = { traffic_mirror_session }
    let parse xml =
      Some
        {
          traffic_mirror_session =
            (Util.option_bind (Xml.member "trafficMirrorSession" xml)
               TrafficMirrorSession.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 Query.Pair
                   ("TrafficMirrorSession",
                     (TrafficMirrorSession.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.traffic_mirror_session
              (fun f ->
                 ("traffic_mirror_session", (TrafficMirrorSession.to_json f)))])
    let of_json j =
      {
        traffic_mirror_session =
          (Util.option_map (Json.lookup j "traffic_mirror_session")
             TrafficMirrorSession.of_json)
      }
  end
module DisableVpcClassicLinkDnsSupportResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module RegisterImageResult =
  struct
    type t = {
      image_id: String.t option }
    let make ?image_id  () = { image_id }
    let parse xml =
      Some
        {
          image_id =
            (Util.option_bind (Xml.member "imageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> Query.Pair ("ImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.image_id
              (fun f -> ("image_id", (String.to_json f)))])
    let of_json j =
      {
        image_id =
          (Util.option_map (Json.lookup j "image_id") String.of_json)
      }
  end
module AttachVolumeRequest =
  struct
    type t =
      {
      device: String.t ;
      instance_id: String.t ;
      volume_id: String.t ;
      dry_run: Boolean.t option }
    let make ~device  ~instance_id  ~volume_id  ?dry_run  () =
      { device; instance_id; volume_id; dry_run }
    let parse xml =
      Some
        {
          device =
            (Xml.required "Device"
               (Util.option_bind (Xml.member "Device" xml) String.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          volume_id =
            (Xml.required "VolumeId"
               (Util.option_bind (Xml.member "VolumeId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VolumeId", (String.to_query v.volume_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some (Query.Pair ("Device", (String.to_query v.device)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_id", (String.to_json v.volume_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Some ("device", (String.to_json v.device))])
    let of_json j =
      {
        device =
          (String.of_json (Util.of_option_exn (Json.lookup j "device")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        volume_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "volume_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteLocalGatewayRouteResult =
  struct
    type t = {
      route: LocalGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               LocalGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> Query.Pair ("Route", (LocalGatewayRoute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (LocalGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route") LocalGatewayRoute.of_json)
      }
  end
module CancelReservedInstancesListingResult =
  struct
    type t = {
      reserved_instances_listings: ReservedInstancesListingList.t }
    let make ?(reserved_instances_listings= [])  () =
      { reserved_instances_listings }
    let parse xml =
      Some
        {
          reserved_instances_listings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesListingsSet" xml)
                  ReservedInstancesListingList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ReservedInstancesListingsSet",
                   (ReservedInstancesListingList.to_query
                      v.reserved_instances_listings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("reserved_instances_listings",
                (ReservedInstancesListingList.to_json
                   v.reserved_instances_listings))])
    let of_json j =
      {
        reserved_instances_listings =
          (ReservedInstancesListingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_listings")))
      }
  end
module CreateTagsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      resources: ResourceIdList.t ;
      tags: TagList.t }
    let make ?dry_run  ~resources  ~tags  () = { dry_run; resources; tags }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          resources =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  ResourceIdList.parse));
          tags =
            (Xml.required "Tag"
               (Util.option_bind (Xml.member "Tag" xml) TagList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Tag", (TagList.to_query v.tags)));
           Some
             (Query.Pair
                ("ResourceId", (ResourceIdList.to_query v.resources)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("tags", (TagList.to_json v.tags));
           Some ("resources", (ResourceIdList.to_json v.resources));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        resources =
          (ResourceIdList.of_json
             (Util.of_option_exn (Json.lookup j "resources")));
        tags = (TagList.of_json (Util.of_option_exn (Json.lookup j "tags")))
      }
  end
module RegisterTransitGatewayMulticastGroupMembersRequest =
  struct
    type t =
      {
      transit_gateway_multicast_domain_id: String.t option ;
      group_ip_address: String.t option ;
      network_interface_ids: TransitGatewayNetworkInterfaceIdList.t ;
      dry_run: Boolean.t option }
    let make ?transit_gateway_multicast_domain_id  ?group_ip_address 
      ?(network_interface_ids= [])  ?dry_run  () =
      {
        transit_gateway_multicast_domain_id;
        group_ip_address;
        network_interface_ids;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain_id =
            (Util.option_bind
               (Xml.member "TransitGatewayMulticastDomainId" xml)
               String.parse);
          group_ip_address =
            (Util.option_bind (Xml.member "GroupIpAddress" xml) String.parse);
          network_interface_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "NetworkInterfaceIds" xml)
                  TransitGatewayNetworkInterfaceIdList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceIds",
                  (TransitGatewayNetworkInterfaceIdList.to_query
                     v.network_interface_ids)));
           Util.option_map v.group_ip_address
             (fun f -> Query.Pair ("GroupIpAddress", (String.to_query f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                Query.Pair
                  ("TransitGatewayMulticastDomainId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("network_interface_ids",
               (TransitGatewayNetworkInterfaceIdList.to_json
                  v.network_interface_ids));
           Util.option_map v.group_ip_address
             (fun f -> ("group_ip_address", (String.to_json f)));
           Util.option_map v.transit_gateway_multicast_domain_id
             (fun f ->
                ("transit_gateway_multicast_domain_id", (String.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain_id =
          (Util.option_map
             (Json.lookup j "transit_gateway_multicast_domain_id")
             String.of_json);
        group_ip_address =
          (Util.option_map (Json.lookup j "group_ip_address") String.of_json);
        network_interface_ids =
          (TransitGatewayNetworkInterfaceIdList.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreatePlacementGroupRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_name: String.t option ;
      strategy: PlacementStrategy.t option ;
      partition_count: Integer.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ?group_name  ?strategy  ?partition_count 
      ?(tag_specifications= [])  () =
      { dry_run; group_name; strategy; partition_count; tag_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          group_name =
            (Util.option_bind (Xml.member "groupName" xml) String.parse);
          strategy =
            (Util.option_bind (Xml.member "strategy" xml)
               PlacementStrategy.parse);
          partition_count =
            (Util.option_bind (Xml.member "PartitionCount" xml) Integer.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.partition_count
             (fun f -> Query.Pair ("PartitionCount", (Integer.to_query f)));
           Util.option_map v.strategy
             (fun f ->
                Query.Pair ("Strategy", (PlacementStrategy.to_query f)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.partition_count
             (fun f -> ("partition_count", (Integer.to_json f)));
           Util.option_map v.strategy
             (fun f -> ("strategy", (PlacementStrategy.to_json f)));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        strategy =
          (Util.option_map (Json.lookup j "strategy")
             PlacementStrategy.of_json);
        partition_count =
          (Util.option_map (Json.lookup j "partition_count") Integer.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module RejectTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AssociateAddressRequest =
  struct
    type t =
      {
      allocation_id: String.t option ;
      instance_id: String.t option ;
      public_ip: String.t option ;
      allow_reassociation: Boolean.t option ;
      dry_run: Boolean.t option ;
      network_interface_id: String.t option ;
      private_ip_address: String.t option }
    let make ?allocation_id  ?instance_id  ?public_ip  ?allow_reassociation 
      ?dry_run  ?network_interface_id  ?private_ip_address  () =
      {
        allocation_id;
        instance_id;
        public_ip;
        allow_reassociation;
        dry_run;
        network_interface_id;
        private_ip_address
      }
    let parse xml =
      Some
        {
          allocation_id =
            (Util.option_bind (Xml.member "AllocationId" xml) String.parse);
          instance_id =
            (Util.option_bind (Xml.member "InstanceId" xml) String.parse);
          public_ip =
            (Util.option_bind (Xml.member "PublicIp" xml) String.parse);
          allow_reassociation =
            (Util.option_bind (Xml.member "allowReassociation" xml)
               Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse);
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Util.option_map v.network_interface_id
             (fun f -> Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.allow_reassociation
             (fun f ->
                Query.Pair ("AllowReassociation", (Boolean.to_query f)));
           Util.option_map v.public_ip
             (fun f -> Query.Pair ("PublicIp", (String.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.allocation_id
             (fun f -> Query.Pair ("AllocationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.private_ip_address
              (fun f -> ("private_ip_address", (String.to_json f)));
           Util.option_map v.network_interface_id
             (fun f -> ("network_interface_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.allow_reassociation
             (fun f -> ("allow_reassociation", (Boolean.to_json f)));
           Util.option_map v.public_ip
             (fun f -> ("public_ip", (String.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.allocation_id
             (fun f -> ("allocation_id", (String.to_json f)))])
    let of_json j =
      {
        allocation_id =
          (Util.option_map (Json.lookup j "allocation_id") String.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        public_ip =
          (Util.option_map (Json.lookup j "public_ip") String.of_json);
        allow_reassociation =
          (Util.option_map (Json.lookup j "allow_reassociation")
             Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json);
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json)
      }
  end
module DeleteTrafficMirrorFilterRuleRequest =
  struct
    type t =
      {
      traffic_mirror_filter_rule_id: String.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_filter_rule_id  ?dry_run  () =
      { traffic_mirror_filter_rule_id; dry_run }
    let parse xml =
      Some
        {
          traffic_mirror_filter_rule_id =
            (Xml.required "TrafficMirrorFilterRuleId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterRuleId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterRuleId",
                  (String.to_query v.traffic_mirror_filter_rule_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("traffic_mirror_filter_rule_id",
               (String.to_json v.traffic_mirror_filter_rule_id))])
    let of_json j =
      {
        traffic_mirror_filter_rule_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "traffic_mirror_filter_rule_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyVpnConnectionOptionsResult =
  struct
    type t = {
      vpn_connection: VpnConnection.t option }
    let make ?vpn_connection  () = { vpn_connection }
    let parse xml =
      Some
        {
          vpn_connection =
            (Util.option_bind (Xml.member "vpnConnection" xml)
               VpnConnection.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f ->
                 Query.Pair ("VpnConnection", (VpnConnection.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpn_connection
              (fun f -> ("vpn_connection", (VpnConnection.to_json f)))])
    let of_json j =
      {
        vpn_connection =
          (Util.option_map (Json.lookup j "vpn_connection")
             VpnConnection.of_json)
      }
  end
module ModifyVpnTunnelOptionsRequest =
  struct
    type t =
      {
      vpn_connection_id: String.t ;
      vpn_tunnel_outside_ip_address: String.t ;
      tunnel_options: ModifyVpnTunnelOptionsSpecification.t ;
      dry_run: Boolean.t option }
    let make ~vpn_connection_id  ~vpn_tunnel_outside_ip_address 
      ~tunnel_options  ?dry_run  () =
      {
        vpn_connection_id;
        vpn_tunnel_outside_ip_address;
        tunnel_options;
        dry_run
      }
    let parse xml =
      Some
        {
          vpn_connection_id =
            (Xml.required "VpnConnectionId"
               (Util.option_bind (Xml.member "VpnConnectionId" xml)
                  String.parse));
          vpn_tunnel_outside_ip_address =
            (Xml.required "VpnTunnelOutsideIpAddress"
               (Util.option_bind (Xml.member "VpnTunnelOutsideIpAddress" xml)
                  String.parse));
          tunnel_options =
            (Xml.required "TunnelOptions"
               (Util.option_bind (Xml.member "TunnelOptions" xml)
                  ModifyVpnTunnelOptionsSpecification.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TunnelOptions",
                  (ModifyVpnTunnelOptionsSpecification.to_query
                     v.tunnel_options)));
           Some
             (Query.Pair
                ("VpnTunnelOutsideIpAddress",
                  (String.to_query v.vpn_tunnel_outside_ip_address)));
           Some
             (Query.Pair
                ("VpnConnectionId", (String.to_query v.vpn_connection_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tunnel_options",
               (ModifyVpnTunnelOptionsSpecification.to_json v.tunnel_options));
           Some
             ("vpn_tunnel_outside_ip_address",
               (String.to_json v.vpn_tunnel_outside_ip_address));
           Some ("vpn_connection_id", (String.to_json v.vpn_connection_id))])
    let of_json j =
      {
        vpn_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_connection_id")));
        vpn_tunnel_outside_ip_address =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "vpn_tunnel_outside_ip_address")));
        tunnel_options =
          (ModifyVpnTunnelOptionsSpecification.of_json
             (Util.of_option_exn (Json.lookup j "tunnel_options")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RejectVpcPeeringConnectionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_peering_connection_id: String.t }
    let make ?dry_run  ~vpc_peering_connection_id  () =
      { dry_run; vpc_peering_connection_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_peering_connection_id =
            (Xml.required "vpcPeeringConnectionId"
               (Util.option_bind (Xml.member "vpcPeeringConnectionId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcPeeringConnectionId",
                   (String.to_query v.vpc_peering_connection_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_peering_connection_id",
                (String.to_json v.vpc_peering_connection_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_peering_connection_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpc_peering_connection_id")))
      }
  end
module AllocateAddressRequest =
  struct
    type t =
      {
      domain: DomainType.t option ;
      address: String.t option ;
      public_ipv4_pool: String.t option ;
      network_border_group: String.t option ;
      customer_owned_ipv4_pool: String.t option ;
      dry_run: Boolean.t option }
    let make ?domain  ?address  ?public_ipv4_pool  ?network_border_group 
      ?customer_owned_ipv4_pool  ?dry_run  () =
      {
        domain;
        address;
        public_ipv4_pool;
        network_border_group;
        customer_owned_ipv4_pool;
        dry_run
      }
    let parse xml =
      Some
        {
          domain =
            (Util.option_bind (Xml.member "Domain" xml) DomainType.parse);
          address =
            (Util.option_bind (Xml.member "Address" xml) String.parse);
          public_ipv4_pool =
            (Util.option_bind (Xml.member "PublicIpv4Pool" xml) String.parse);
          network_border_group =
            (Util.option_bind (Xml.member "NetworkBorderGroup" xml)
               String.parse);
          customer_owned_ipv4_pool =
            (Util.option_bind (Xml.member "CustomerOwnedIpv4Pool" xml)
               String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f ->
                Query.Pair ("CustomerOwnedIpv4Pool", (String.to_query f)));
           Util.option_map v.network_border_group
             (fun f -> Query.Pair ("NetworkBorderGroup", (String.to_query f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> Query.Pair ("PublicIpv4Pool", (String.to_query f)));
           Util.option_map v.address
             (fun f -> Query.Pair ("Address", (String.to_query f)));
           Util.option_map v.domain
             (fun f -> Query.Pair ("Domain", (DomainType.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.customer_owned_ipv4_pool
             (fun f -> ("customer_owned_ipv4_pool", (String.to_json f)));
           Util.option_map v.network_border_group
             (fun f -> ("network_border_group", (String.to_json f)));
           Util.option_map v.public_ipv4_pool
             (fun f -> ("public_ipv4_pool", (String.to_json f)));
           Util.option_map v.address
             (fun f -> ("address", (String.to_json f)));
           Util.option_map v.domain
             (fun f -> ("domain", (DomainType.to_json f)))])
    let of_json j =
      {
        domain =
          (Util.option_map (Json.lookup j "domain") DomainType.of_json);
        address = (Util.option_map (Json.lookup j "address") String.of_json);
        public_ipv4_pool =
          (Util.option_map (Json.lookup j "public_ipv4_pool") String.of_json);
        network_border_group =
          (Util.option_map (Json.lookup j "network_border_group")
             String.of_json);
        customer_owned_ipv4_pool =
          (Util.option_map (Json.lookup j "customer_owned_ipv4_pool")
             String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTrafficMirrorSessionRequest =
  struct
    type t =
      {
      network_interface_id: String.t ;
      traffic_mirror_target_id: String.t ;
      traffic_mirror_filter_id: String.t ;
      packet_length: Integer.t option ;
      session_number: Integer.t ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option ;
      client_token: String.t option }
    let make ~network_interface_id  ~traffic_mirror_target_id 
      ~traffic_mirror_filter_id  ?packet_length  ~session_number 
      ?virtual_network_id  ?description  ?(tag_specifications= [])  ?dry_run 
      ?client_token  () =
      {
        network_interface_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        tag_specifications;
        dry_run;
        client_token
      }
    let parse xml =
      Some
        {
          network_interface_id =
            (Xml.required "NetworkInterfaceId"
               (Util.option_bind (Xml.member "NetworkInterfaceId" xml)
                  String.parse));
          traffic_mirror_target_id =
            (Xml.required "TrafficMirrorTargetId"
               (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
                  String.parse));
          traffic_mirror_filter_id =
            (Xml.required "TrafficMirrorFilterId"
               (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
                  String.parse));
          packet_length =
            (Util.option_bind (Xml.member "PacketLength" xml) Integer.parse);
          session_number =
            (Xml.required "SessionNumber"
               (Util.option_bind (Xml.member "SessionNumber" xml)
                  Integer.parse));
          virtual_network_id =
            (Util.option_bind (Xml.member "VirtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SessionNumber", (Integer.to_query v.session_number)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorFilterId",
                  (String.to_query v.traffic_mirror_filter_id)));
           Some
             (Query.Pair
                ("TrafficMirrorTargetId",
                  (String.to_query v.traffic_mirror_target_id)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Some ("session_number", (Integer.to_json v.session_number));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Some
             ("traffic_mirror_filter_id",
               (String.to_json v.traffic_mirror_filter_id));
           Some
             ("traffic_mirror_target_id",
               (String.to_json v.traffic_mirror_target_id));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id))])
    let of_json j =
      {
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        traffic_mirror_target_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_target_id")));
        traffic_mirror_filter_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_filter_id")));
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "session_number")));
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module BundleInstanceResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module DescribeTransitGatewayRouteTablesResult =
  struct
    type t =
      {
      transit_gateway_route_tables: TransitGatewayRouteTableList.t ;
      next_token: String.t option }
    let make ?(transit_gateway_route_tables= [])  ?next_token  () =
      { transit_gateway_route_tables; next_token }
    let parse xml =
      Some
        {
          transit_gateway_route_tables =
            (Util.of_option []
               (Util.option_bind (Xml.member "transitGatewayRouteTables" xml)
                  TransitGatewayRouteTableList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTables",
                  (TransitGatewayRouteTableList.to_query
                     v.transit_gateway_route_tables)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("transit_gateway_route_tables",
               (TransitGatewayRouteTableList.to_json
                  v.transit_gateway_route_tables))])
    let of_json j =
      {
        transit_gateway_route_tables =
          (TransitGatewayRouteTableList.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_tables")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateSubnetCidrBlockResult =
  struct
    type t =
      {
      ipv6_cidr_block_association: SubnetIpv6CidrBlockAssociation.t option ;
      subnet_id: String.t option }
    let make ?ipv6_cidr_block_association  ?subnet_id  () =
      { ipv6_cidr_block_association; subnet_id }
    let parse xml =
      Some
        {
          ipv6_cidr_block_association =
            (Util.option_bind (Xml.member "ipv6CidrBlockAssociation" xml)
               SubnetIpv6CidrBlockAssociation.parse);
          subnet_id =
            (Util.option_bind (Xml.member "subnetId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> Query.Pair ("SubnetId", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockAssociation",
                    (SubnetIpv6CidrBlockAssociation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.subnet_id
              (fun f -> ("subnet_id", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_association
             (fun f ->
                ("ipv6_cidr_block_association",
                  (SubnetIpv6CidrBlockAssociation.to_json f)))])
    let of_json j =
      {
        ipv6_cidr_block_association =
          (Util.option_map (Json.lookup j "ipv6_cidr_block_association")
             SubnetIpv6CidrBlockAssociation.of_json);
        subnet_id =
          (Util.option_map (Json.lookup j "subnet_id") String.of_json)
      }
  end
module CreateRouteTableRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?dry_run  ~vpc_id  ?(tag_specifications= [])  () =
      { dry_run; vpc_id; tag_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module InstanceAttribute =
  struct
    type t =
      {
      groups: GroupIdentifierList.t ;
      block_device_mappings: InstanceBlockDeviceMappingList.t ;
      disable_api_termination: AttributeBooleanValue.t option ;
      ena_support: AttributeBooleanValue.t option ;
      enclave_options: EnclaveOptions.t option ;
      ebs_optimized: AttributeBooleanValue.t option ;
      instance_id: String.t option ;
      instance_initiated_shutdown_behavior: AttributeValue.t option ;
      instance_type: AttributeValue.t option ;
      kernel_id: AttributeValue.t option ;
      product_codes: ProductCodeList.t ;
      ramdisk_id: AttributeValue.t option ;
      root_device_name: AttributeValue.t option ;
      source_dest_check: AttributeBooleanValue.t option ;
      sriov_net_support: AttributeValue.t option ;
      user_data: AttributeValue.t option }
    let make ?(groups= [])  ?(block_device_mappings= []) 
      ?disable_api_termination  ?ena_support  ?enclave_options 
      ?ebs_optimized  ?instance_id  ?instance_initiated_shutdown_behavior 
      ?instance_type  ?kernel_id  ?(product_codes= [])  ?ramdisk_id 
      ?root_device_name  ?source_dest_check  ?sriov_net_support  ?user_data 
      () =
      {
        groups;
        block_device_mappings;
        disable_api_termination;
        ena_support;
        enclave_options;
        ebs_optimized;
        instance_id;
        instance_initiated_shutdown_behavior;
        instance_type;
        kernel_id;
        product_codes;
        ramdisk_id;
        root_device_name;
        source_dest_check;
        sriov_net_support;
        user_data
      }
    let parse xml =
      Some
        {
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "groupSet" xml)
                  GroupIdentifierList.parse));
          block_device_mappings =
            (Util.of_option []
               (Util.option_bind (Xml.member "blockDeviceMapping" xml)
                  InstanceBlockDeviceMappingList.parse));
          disable_api_termination =
            (Util.option_bind (Xml.member "disableApiTermination" xml)
               AttributeBooleanValue.parse);
          ena_support =
            (Util.option_bind (Xml.member "enaSupport" xml)
               AttributeBooleanValue.parse);
          enclave_options =
            (Util.option_bind (Xml.member "enclaveOptions" xml)
               EnclaveOptions.parse);
          ebs_optimized =
            (Util.option_bind (Xml.member "ebsOptimized" xml)
               AttributeBooleanValue.parse);
          instance_id =
            (Util.option_bind (Xml.member "instanceId" xml) String.parse);
          instance_initiated_shutdown_behavior =
            (Util.option_bind
               (Xml.member "instanceInitiatedShutdownBehavior" xml)
               AttributeValue.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml)
               AttributeValue.parse);
          kernel_id =
            (Util.option_bind (Xml.member "kernel" xml) AttributeValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          ramdisk_id =
            (Util.option_bind (Xml.member "ramdisk" xml) AttributeValue.parse);
          root_device_name =
            (Util.option_bind (Xml.member "rootDeviceName" xml)
               AttributeValue.parse);
          source_dest_check =
            (Util.option_bind (Xml.member "sourceDestCheck" xml)
               AttributeBooleanValue.parse);
          sriov_net_support =
            (Util.option_bind (Xml.member "sriovNetSupport" xml)
               AttributeValue.parse);
          user_data =
            (Util.option_bind (Xml.member "userData" xml)
               AttributeValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> Query.Pair ("UserData", (AttributeValue.to_query f)));
           Util.option_map v.sriov_net_support
             (fun f ->
                Query.Pair ("SriovNetSupport", (AttributeValue.to_query f)));
           Util.option_map v.source_dest_check
             (fun f ->
                Query.Pair
                  ("SourceDestCheck", (AttributeBooleanValue.to_query f)));
           Util.option_map v.root_device_name
             (fun f ->
                Query.Pair ("RootDeviceName", (AttributeValue.to_query f)));
           Util.option_map v.ramdisk_id
             (fun f -> Query.Pair ("Ramdisk", (AttributeValue.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.kernel_id
             (fun f -> Query.Pair ("Kernel", (AttributeValue.to_query f)));
           Util.option_map v.instance_type
             (fun f ->
                Query.Pair ("InstanceType", (AttributeValue.to_query f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                Query.Pair
                  ("InstanceInitiatedShutdownBehavior",
                    (AttributeValue.to_query f)));
           Util.option_map v.instance_id
             (fun f -> Query.Pair ("InstanceId", (String.to_query f)));
           Util.option_map v.ebs_optimized
             (fun f ->
                Query.Pair
                  ("EbsOptimized", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enclave_options
             (fun f ->
                Query.Pair ("EnclaveOptions", (EnclaveOptions.to_query f)));
           Util.option_map v.ena_support
             (fun f ->
                Query.Pair ("EnaSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                Query.Pair
                  ("DisableApiTermination",
                    (AttributeBooleanValue.to_query f)));
           Some
             (Query.Pair
                ("BlockDeviceMapping",
                  (InstanceBlockDeviceMappingList.to_query
                     v.block_device_mappings)));
           Some
             (Query.Pair
                ("GroupSet", (GroupIdentifierList.to_query v.groups)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.user_data
              (fun f -> ("user_data", (AttributeValue.to_json f)));
           Util.option_map v.sriov_net_support
             (fun f -> ("sriov_net_support", (AttributeValue.to_json f)));
           Util.option_map v.source_dest_check
             (fun f ->
                ("source_dest_check", (AttributeBooleanValue.to_json f)));
           Util.option_map v.root_device_name
             (fun f -> ("root_device_name", (AttributeValue.to_json f)));
           Util.option_map v.ramdisk_id
             (fun f -> ("ramdisk_id", (AttributeValue.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.kernel_id
             (fun f -> ("kernel_id", (AttributeValue.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (AttributeValue.to_json f)));
           Util.option_map v.instance_initiated_shutdown_behavior
             (fun f ->
                ("instance_initiated_shutdown_behavior",
                  (AttributeValue.to_json f)));
           Util.option_map v.instance_id
             (fun f -> ("instance_id", (String.to_json f)));
           Util.option_map v.ebs_optimized
             (fun f -> ("ebs_optimized", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enclave_options
             (fun f -> ("enclave_options", (EnclaveOptions.to_json f)));
           Util.option_map v.ena_support
             (fun f -> ("ena_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.disable_api_termination
             (fun f ->
                ("disable_api_termination",
                  (AttributeBooleanValue.to_json f)));
           Some
             ("block_device_mappings",
               (InstanceBlockDeviceMappingList.to_json
                  v.block_device_mappings));
           Some ("groups", (GroupIdentifierList.to_json v.groups))])
    let of_json j =
      {
        groups =
          (GroupIdentifierList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        block_device_mappings =
          (InstanceBlockDeviceMappingList.of_json
             (Util.of_option_exn (Json.lookup j "block_device_mappings")));
        disable_api_termination =
          (Util.option_map (Json.lookup j "disable_api_termination")
             AttributeBooleanValue.of_json);
        ena_support =
          (Util.option_map (Json.lookup j "ena_support")
             AttributeBooleanValue.of_json);
        enclave_options =
          (Util.option_map (Json.lookup j "enclave_options")
             EnclaveOptions.of_json);
        ebs_optimized =
          (Util.option_map (Json.lookup j "ebs_optimized")
             AttributeBooleanValue.of_json);
        instance_id =
          (Util.option_map (Json.lookup j "instance_id") String.of_json);
        instance_initiated_shutdown_behavior =
          (Util.option_map
             (Json.lookup j "instance_initiated_shutdown_behavior")
             AttributeValue.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type")
             AttributeValue.of_json);
        kernel_id =
          (Util.option_map (Json.lookup j "kernel_id") AttributeValue.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        ramdisk_id =
          (Util.option_map (Json.lookup j "ramdisk_id")
             AttributeValue.of_json);
        root_device_name =
          (Util.option_map (Json.lookup j "root_device_name")
             AttributeValue.of_json);
        source_dest_check =
          (Util.option_map (Json.lookup j "source_dest_check")
             AttributeBooleanValue.of_json);
        sriov_net_support =
          (Util.option_map (Json.lookup j "sriov_net_support")
             AttributeValue.of_json);
        user_data =
          (Util.option_map (Json.lookup j "user_data") AttributeValue.of_json)
      }
  end
module CreateEgressOnlyInternetGatewayRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      vpc_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?client_token  ?dry_run  ~vpc_id  ?(tag_specifications= [])  ()
      = { client_token; dry_run; vpc_id; tag_specifications }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module ModifyTransitGatewayResult =
  struct
    type t = {
      transit_gateway: TransitGateway.t option }
    let make ?transit_gateway  () = { transit_gateway }
    let parse xml =
      Some
        {
          transit_gateway =
            (Util.option_bind (Xml.member "transitGateway" xml)
               TransitGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f ->
                 Query.Pair ("TransitGateway", (TransitGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway
              (fun f -> ("transit_gateway", (TransitGateway.to_json f)))])
    let of_json j =
      {
        transit_gateway =
          (Util.option_map (Json.lookup j "transit_gateway")
             TransitGateway.of_json)
      }
  end
module ModifyManagedPrefixListRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_id: String.t ;
      current_version: Long.t option ;
      prefix_list_name: String.t option ;
      add_entries: AddPrefixListEntries.t ;
      remove_entries: RemovePrefixListEntries.t }
    let make ?dry_run  ~prefix_list_id  ?current_version  ?prefix_list_name 
      ?(add_entries= [])  ?(remove_entries= [])  () =
      {
        dry_run;
        prefix_list_id;
        current_version;
        prefix_list_name;
        add_entries;
        remove_entries
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          current_version =
            (Util.option_bind (Xml.member "CurrentVersion" xml) Long.parse);
          prefix_list_name =
            (Util.option_bind (Xml.member "PrefixListName" xml) String.parse);
          add_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddEntry" xml)
                  AddPrefixListEntries.parse));
          remove_entries =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveEntry" xml)
                  RemovePrefixListEntries.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveEntry",
                   (RemovePrefixListEntries.to_query v.remove_entries)));
           Some
             (Query.Pair
                ("AddEntry", (AddPrefixListEntries.to_query v.add_entries)));
           Util.option_map v.prefix_list_name
             (fun f -> Query.Pair ("PrefixListName", (String.to_query f)));
           Util.option_map v.current_version
             (fun f -> Query.Pair ("CurrentVersion", (Long.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_entries",
                (RemovePrefixListEntries.to_json v.remove_entries));
           Some ("add_entries", (AddPrefixListEntries.to_json v.add_entries));
           Util.option_map v.prefix_list_name
             (fun f -> ("prefix_list_name", (String.to_json f)));
           Util.option_map v.current_version
             (fun f -> ("current_version", (Long.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        current_version =
          (Util.option_map (Json.lookup j "current_version") Long.of_json);
        prefix_list_name =
          (Util.option_map (Json.lookup j "prefix_list_name") String.of_json);
        add_entries =
          (AddPrefixListEntries.of_json
             (Util.of_option_exn (Json.lookup j "add_entries")));
        remove_entries =
          (RemovePrefixListEntries.of_json
             (Util.of_option_exn (Json.lookup j "remove_entries")))
      }
  end
module DescribeRouteTablesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      route_table_ids: RouteTableIdStringList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(filters= [])  ?dry_run  ?(route_table_ids= [])  ?next_token 
      ?max_results  () =
      { filters; dry_run; route_table_ids; next_token; max_results }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "RouteTableId" xml)
                  RouteTableIdStringList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteTableId",
                  (RouteTableIdStringList.to_query v.route_table_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some
             ("route_table_ids",
               (RouteTableIdStringList.to_json v.route_table_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_ids =
          (RouteTableIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "route_table_ids")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ImportSnapshotRequest =
  struct
    type t =
      {
      client_data: ClientData.t option ;
      client_token: String.t option ;
      description: String.t option ;
      disk_container: SnapshotDiskContainer.t option ;
      dry_run: Boolean.t option ;
      encrypted: Boolean.t option ;
      kms_key_id: String.t option ;
      role_name: String.t option ;
      tag_specifications: TagSpecificationList.t }
    let make ?client_data  ?client_token  ?description  ?disk_container 
      ?dry_run  ?encrypted  ?kms_key_id  ?role_name  ?(tag_specifications=
      [])  () =
      {
        client_data;
        client_token;
        description;
        disk_container;
        dry_run;
        encrypted;
        kms_key_id;
        role_name;
        tag_specifications
      }
    let parse xml =
      Some
        {
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_container =
            (Util.option_bind (Xml.member "DiskContainer" xml)
               SnapshotDiskContainer.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.disk_container
             (fun f ->
                Query.Pair
                  ("DiskContainer", (SnapshotDiskContainer.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.disk_container
             (fun f -> ("disk_container", (SnapshotDiskContainer.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)))])
    let of_json j =
      {
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_container =
          (Util.option_map (Json.lookup j "disk_container")
             SnapshotDiskContainer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module ModifyHostsResult =
  struct
    type t =
      {
      successful: ResponseHostIdList.t ;
      unsuccessful: UnsuccessfulItemList.t }
    let make ?(successful= [])  ?(unsuccessful= [])  () =
      { successful; unsuccessful }
    let parse xml =
      Some
        {
          successful =
            (Util.of_option []
               (Util.option_bind (Xml.member "successful" xml)
                  ResponseHostIdList.parse));
          unsuccessful =
            (Util.of_option []
               (Util.option_bind (Xml.member "unsuccessful" xml)
                  UnsuccessfulItemList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Unsuccessful",
                   (UnsuccessfulItemList.to_query v.unsuccessful)));
           Some
             (Query.Pair
                ("Successful", (ResponseHostIdList.to_query v.successful)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful", (UnsuccessfulItemList.to_json v.unsuccessful));
           Some ("successful", (ResponseHostIdList.to_json v.successful))])
    let of_json j =
      {
        successful =
          (ResponseHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "successful")));
        unsuccessful =
          (UnsuccessfulItemList.of_json
             (Util.of_option_exn (Json.lookup j "unsuccessful")))
      }
  end
module DeregisterTransitGatewayMulticastGroupMembersResult =
  struct
    type t =
      {
      deregistered_multicast_group_members:
        TransitGatewayMulticastDeregisteredGroupMembers.t option }
    let make ?deregistered_multicast_group_members  () =
      { deregistered_multicast_group_members }
    let parse xml =
      Some
        {
          deregistered_multicast_group_members =
            (Util.option_bind
               (Xml.member "deregisteredMulticastGroupMembers" xml)
               TransitGatewayMulticastDeregisteredGroupMembers.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 Query.Pair
                   ("DeregisteredMulticastGroupMembers",
                     (TransitGatewayMulticastDeregisteredGroupMembers.to_query
                        f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.deregistered_multicast_group_members
              (fun f ->
                 ("deregistered_multicast_group_members",
                   (TransitGatewayMulticastDeregisteredGroupMembers.to_json f)))])
    let of_json j =
      {
        deregistered_multicast_group_members =
          (Util.option_map
             (Json.lookup j "deregistered_multicast_group_members")
             TransitGatewayMulticastDeregisteredGroupMembers.of_json)
      }
  end
module DescribeClientVpnAuthorizationRulesResult =
  struct
    type t =
      {
      authorization_rules: AuthorizationRuleSet.t ;
      next_token: String.t option }
    let make ?(authorization_rules= [])  ?next_token  () =
      { authorization_rules; next_token }
    let parse xml =
      Some
        {
          authorization_rules =
            (Util.of_option []
               (Util.option_bind (Xml.member "authorizationRule" xml)
                  AuthorizationRuleSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("AuthorizationRule",
                  (AuthorizationRuleSet.to_query v.authorization_rules)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("authorization_rules",
               (AuthorizationRuleSet.to_json v.authorization_rules))])
    let of_json j =
      {
        authorization_rules =
          (AuthorizationRuleSet.of_json
             (Util.of_option_exn (Json.lookup j "authorization_rules")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeFleetInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      fleet_id: String.t ;
      filters: FilterList.t }
    let make ?dry_run  ?max_results  ?next_token  ~fleet_id  ?(filters= []) 
      () = { dry_run; max_results; next_token; fleet_id; filters }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module StopInstancesResult =
  struct
    type t = {
      stopping_instances: InstanceStateChangeList.t }
    let make ?(stopping_instances= [])  () = { stopping_instances }
    let parse xml =
      Some
        {
          stopping_instances =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceStateChangeList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceStateChangeList.to_query v.stopping_instances)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("stopping_instances",
                (InstanceStateChangeList.to_json v.stopping_instances))])
    let of_json j =
      {
        stopping_instances =
          (InstanceStateChangeList.of_json
             (Util.of_option_exn (Json.lookup j "stopping_instances")))
      }
  end
module RequestSpotFleetResponse =
  struct
    type t = {
      spot_fleet_request_id: String.t option }
    let make ?spot_fleet_request_id  () = { spot_fleet_request_id }
    let parse xml =
      Some
        {
          spot_fleet_request_id =
            (Util.option_bind (Xml.member "spotFleetRequestId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f ->
                 Query.Pair ("SpotFleetRequestId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.spot_fleet_request_id
              (fun f -> ("spot_fleet_request_id", (String.to_json f)))])
    let of_json j =
      {
        spot_fleet_request_id =
          (Util.option_map (Json.lookup j "spot_fleet_request_id")
             String.of_json)
      }
  end
module GetTransitGatewayMulticastDomainAssociationsResult =
  struct
    type t =
      {
      multicast_domain_associations:
        TransitGatewayMulticastDomainAssociationList.t ;
      next_token: String.t option }
    let make ?(multicast_domain_associations= [])  ?next_token  () =
      { multicast_domain_associations; next_token }
    let parse xml =
      Some
        {
          multicast_domain_associations =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "multicastDomainAssociations" xml)
                  TransitGatewayMulticastDomainAssociationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("MulticastDomainAssociations",
                  (TransitGatewayMulticastDomainAssociationList.to_query
                     v.multicast_domain_associations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("multicast_domain_associations",
               (TransitGatewayMulticastDomainAssociationList.to_json
                  v.multicast_domain_associations))])
    let of_json j =
      {
        multicast_domain_associations =
          (TransitGatewayMulticastDomainAssociationList.of_json
             (Util.of_option_exn
                (Json.lookup j "multicast_domain_associations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyTrafficMirrorSessionRequest =
  struct
    type t =
      {
      traffic_mirror_session_id: String.t ;
      traffic_mirror_target_id: String.t option ;
      traffic_mirror_filter_id: String.t option ;
      packet_length: Integer.t option ;
      session_number: Integer.t option ;
      virtual_network_id: Integer.t option ;
      description: String.t option ;
      remove_fields: TrafficMirrorSessionFieldList.t ;
      dry_run: Boolean.t option }
    let make ~traffic_mirror_session_id  ?traffic_mirror_target_id 
      ?traffic_mirror_filter_id  ?packet_length  ?session_number 
      ?virtual_network_id  ?description  ?(remove_fields= [])  ?dry_run  () =
      {
        traffic_mirror_session_id;
        traffic_mirror_target_id;
        traffic_mirror_filter_id;
        packet_length;
        session_number;
        virtual_network_id;
        description;
        remove_fields;
        dry_run
      }
    let parse xml =
      Some
        {
          traffic_mirror_session_id =
            (Xml.required "TrafficMirrorSessionId"
               (Util.option_bind (Xml.member "TrafficMirrorSessionId" xml)
                  String.parse));
          traffic_mirror_target_id =
            (Util.option_bind (Xml.member "TrafficMirrorTargetId" xml)
               String.parse);
          traffic_mirror_filter_id =
            (Util.option_bind (Xml.member "TrafficMirrorFilterId" xml)
               String.parse);
          packet_length =
            (Util.option_bind (Xml.member "PacketLength" xml) Integer.parse);
          session_number =
            (Util.option_bind (Xml.member "SessionNumber" xml) Integer.parse);
          virtual_network_id =
            (Util.option_bind (Xml.member "VirtualNetworkId" xml)
               Integer.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          remove_fields =
            (Util.of_option []
               (Util.option_bind (Xml.member "RemoveField" xml)
                  TrafficMirrorSessionFieldList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("RemoveField",
                  (TrafficMirrorSessionFieldList.to_query v.remove_fields)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.virtual_network_id
             (fun f -> Query.Pair ("VirtualNetworkId", (Integer.to_query f)));
           Util.option_map v.session_number
             (fun f -> Query.Pair ("SessionNumber", (Integer.to_query f)));
           Util.option_map v.packet_length
             (fun f -> Query.Pair ("PacketLength", (Integer.to_query f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f ->
                Query.Pair ("TrafficMirrorFilterId", (String.to_query f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f ->
                Query.Pair ("TrafficMirrorTargetId", (String.to_query f)));
           Some
             (Query.Pair
                ("TrafficMirrorSessionId",
                  (String.to_query v.traffic_mirror_session_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("remove_fields",
               (TrafficMirrorSessionFieldList.to_json v.remove_fields));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.virtual_network_id
             (fun f -> ("virtual_network_id", (Integer.to_json f)));
           Util.option_map v.session_number
             (fun f -> ("session_number", (Integer.to_json f)));
           Util.option_map v.packet_length
             (fun f -> ("packet_length", (Integer.to_json f)));
           Util.option_map v.traffic_mirror_filter_id
             (fun f -> ("traffic_mirror_filter_id", (String.to_json f)));
           Util.option_map v.traffic_mirror_target_id
             (fun f -> ("traffic_mirror_target_id", (String.to_json f)));
           Some
             ("traffic_mirror_session_id",
               (String.to_json v.traffic_mirror_session_id))])
    let of_json j =
      {
        traffic_mirror_session_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "traffic_mirror_session_id")));
        traffic_mirror_target_id =
          (Util.option_map (Json.lookup j "traffic_mirror_target_id")
             String.of_json);
        traffic_mirror_filter_id =
          (Util.option_map (Json.lookup j "traffic_mirror_filter_id")
             String.of_json);
        packet_length =
          (Util.option_map (Json.lookup j "packet_length") Integer.of_json);
        session_number =
          (Util.option_map (Json.lookup j "session_number") Integer.of_json);
        virtual_network_id =
          (Util.option_map (Json.lookup j "virtual_network_id")
             Integer.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        remove_fields =
          (TrafficMirrorSessionFieldList.of_json
             (Util.of_option_exn (Json.lookup j "remove_fields")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateTransitGatewayPeeringAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_id: String.t ;
      peer_transit_gateway_id: String.t ;
      peer_account_id: String.t ;
      peer_region: String.t ;
      tag_specifications: TagSpecificationList.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_id  ~peer_transit_gateway_id  ~peer_account_id 
      ~peer_region  ?(tag_specifications= [])  ?dry_run  () =
      {
        transit_gateway_id;
        peer_transit_gateway_id;
        peer_account_id;
        peer_region;
        tag_specifications;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_id =
            (Xml.required "TransitGatewayId"
               (Util.option_bind (Xml.member "TransitGatewayId" xml)
                  String.parse));
          peer_transit_gateway_id =
            (Xml.required "PeerTransitGatewayId"
               (Util.option_bind (Xml.member "PeerTransitGatewayId" xml)
                  String.parse));
          peer_account_id =
            (Xml.required "PeerAccountId"
               (Util.option_bind (Xml.member "PeerAccountId" xml)
                  String.parse));
          peer_region =
            (Xml.required "PeerRegion"
               (Util.option_bind (Xml.member "PeerRegion" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("PeerRegion", (String.to_query v.peer_region)));
           Some
             (Query.Pair
                ("PeerAccountId", (String.to_query v.peer_account_id)));
           Some
             (Query.Pair
                ("PeerTransitGatewayId",
                  (String.to_query v.peer_transit_gateway_id)));
           Some
             (Query.Pair
                ("TransitGatewayId", (String.to_query v.transit_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Some ("peer_region", (String.to_json v.peer_region));
           Some ("peer_account_id", (String.to_json v.peer_account_id));
           Some
             ("peer_transit_gateway_id",
               (String.to_json v.peer_transit_gateway_id));
           Some ("transit_gateway_id", (String.to_json v.transit_gateway_id))])
    let of_json j =
      {
        transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "transit_gateway_id")));
        peer_transit_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "peer_transit_gateway_id")));
        peer_account_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "peer_account_id")));
        peer_region =
          (String.of_json (Util.of_option_exn (Json.lookup j "peer_region")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyInstanceCreditSpecificationResult =
  struct
    type t =
      {
      successful_instance_credit_specifications:
        SuccessfulInstanceCreditSpecificationSet.t ;
      unsuccessful_instance_credit_specifications:
        UnsuccessfulInstanceCreditSpecificationSet.t }
    let make ?(successful_instance_credit_specifications= []) 
      ?(unsuccessful_instance_credit_specifications= [])  () =
      {
        successful_instance_credit_specifications;
        unsuccessful_instance_credit_specifications
      }
    let parse xml =
      Some
        {
          successful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "successfulInstanceCreditSpecificationSet" xml)
                  SuccessfulInstanceCreditSpecificationSet.parse));
          unsuccessful_instance_credit_specifications =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "unsuccessfulInstanceCreditSpecificationSet"
                     xml) UnsuccessfulInstanceCreditSpecificationSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnsuccessfulInstanceCreditSpecificationSet",
                   (UnsuccessfulInstanceCreditSpecificationSet.to_query
                      v.unsuccessful_instance_credit_specifications)));
           Some
             (Query.Pair
                ("SuccessfulInstanceCreditSpecificationSet",
                  (SuccessfulInstanceCreditSpecificationSet.to_query
                     v.successful_instance_credit_specifications)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unsuccessful_instance_credit_specifications",
                (UnsuccessfulInstanceCreditSpecificationSet.to_json
                   v.unsuccessful_instance_credit_specifications));
           Some
             ("successful_instance_credit_specifications",
               (SuccessfulInstanceCreditSpecificationSet.to_json
                  v.successful_instance_credit_specifications))])
    let of_json j =
      {
        successful_instance_credit_specifications =
          (SuccessfulInstanceCreditSpecificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "successful_instance_credit_specifications")));
        unsuccessful_instance_credit_specifications =
          (UnsuccessfulInstanceCreditSpecificationSet.of_json
             (Util.of_option_exn
                (Json.lookup j "unsuccessful_instance_credit_specifications")))
      }
  end
module ModifyTransitGatewayPrefixListReferenceResult =
  struct
    type t =
      {
      transit_gateway_prefix_list_reference:
        TransitGatewayPrefixListReference.t option }
    let make ?transit_gateway_prefix_list_reference  () =
      { transit_gateway_prefix_list_reference }
    let parse xml =
      Some
        {
          transit_gateway_prefix_list_reference =
            (Util.option_bind
               (Xml.member "transitGatewayPrefixListReference" xml)
               TransitGatewayPrefixListReference.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPrefixListReference",
                     (TransitGatewayPrefixListReference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 ("transit_gateway_prefix_list_reference",
                   (TransitGatewayPrefixListReference.to_json f)))])
    let of_json j =
      {
        transit_gateway_prefix_list_reference =
          (Util.option_map
             (Json.lookup j "transit_gateway_prefix_list_reference")
             TransitGatewayPrefixListReference.of_json)
      }
  end
module DescribeReservedInstancesOfferingsResult =
  struct
    type t =
      {
      reserved_instances_offerings: ReservedInstancesOfferingList.t ;
      next_token: String.t option }
    let make ?(reserved_instances_offerings= [])  ?next_token  () =
      { reserved_instances_offerings; next_token }
    let parse xml =
      Some
        {
          reserved_instances_offerings =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "reservedInstancesOfferingsSet" xml)
                  ReservedInstancesOfferingList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingsSet",
                  (ReservedInstancesOfferingList.to_query
                     v.reserved_instances_offerings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("reserved_instances_offerings",
               (ReservedInstancesOfferingList.to_json
                  v.reserved_instances_offerings))])
    let of_json j =
      {
        reserved_instances_offerings =
          (ReservedInstancesOfferingList.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offerings")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module AssociateDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_options_id: String.t ;
      vpc_id: String.t ;
      dry_run: Boolean.t option }
    let make ~dhcp_options_id  ~vpc_id  ?dry_run  () =
      { dhcp_options_id; vpc_id; dry_run }
    let parse xml =
      Some
        {
          dhcp_options_id =
            (Xml.required "DhcpOptionsId"
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("DhcpOptionsId", (String.to_query v.dhcp_options_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some ("dhcp_options_id", (String.to_json v.dhcp_options_id))])
    let of_json j =
      {
        dhcp_options_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module AuthorizeClientVpnIngressResult =
  struct
    type t = {
      status: ClientVpnAuthorizationRuleStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnAuthorizationRuleStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair
                   ("Status", (ClientVpnAuthorizationRuleStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 ("status", (ClientVpnAuthorizationRuleStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnAuthorizationRuleStatus.of_json)
      }
  end
module DeleteKeyPairRequest =
  struct
    type t =
      {
      key_name: String.t option ;
      key_pair_id: String.t option ;
      dry_run: Boolean.t option }
    let make ?key_name  ?key_pair_id  ?dry_run  () =
      { key_name; key_pair_id; dry_run }
    let parse xml =
      Some
        {
          key_name =
            (Util.option_bind (Xml.member "KeyName" xml) String.parse);
          key_pair_id =
            (Util.option_bind (Xml.member "KeyPairId" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.key_pair_id
             (fun f -> Query.Pair ("KeyPairId", (String.to_query f)));
           Util.option_map v.key_name
             (fun f -> Query.Pair ("KeyName", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.key_pair_id
             (fun f -> ("key_pair_id", (String.to_json f)));
           Util.option_map v.key_name
             (fun f -> ("key_name", (String.to_json f)))])
    let of_json j =
      {
        key_name =
          (Util.option_map (Json.lookup j "key_name") String.of_json);
        key_pair_id =
          (Util.option_map (Json.lookup j "key_pair_id") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeScheduledInstanceAvailabilityResult =
  struct
    type t =
      {
      next_token: String.t option ;
      scheduled_instance_availability_set: ScheduledInstanceAvailabilitySet.t }
    let make ?next_token  ?(scheduled_instance_availability_set= [])  () =
      { next_token; scheduled_instance_availability_set }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          scheduled_instance_availability_set =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "scheduledInstanceAvailabilitySet" xml)
                  ScheduledInstanceAvailabilitySet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceAvailabilitySet",
                   (ScheduledInstanceAvailabilitySet.to_query
                      v.scheduled_instance_availability_set)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_availability_set",
                (ScheduledInstanceAvailabilitySet.to_json
                   v.scheduled_instance_availability_set));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        scheduled_instance_availability_set =
          (ScheduledInstanceAvailabilitySet.of_json
             (Util.of_option_exn
                (Json.lookup j "scheduled_instance_availability_set")))
      }
  end
module RestoreManagedPrefixListVersionResult =
  struct
    type t = {
      prefix_list: ManagedPrefixList.t option }
    let make ?prefix_list  () = { prefix_list }
    let parse xml =
      Some
        {
          prefix_list =
            (Util.option_bind (Xml.member "prefixList" xml)
               ManagedPrefixList.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f ->
                 Query.Pair ("PrefixList", (ManagedPrefixList.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.prefix_list
              (fun f -> ("prefix_list", (ManagedPrefixList.to_json f)))])
    let of_json j =
      {
        prefix_list =
          (Util.option_map (Json.lookup j "prefix_list")
             ManagedPrefixList.of_json)
      }
  end
module DescribeInstancesResult =
  struct
    type t = {
      reservations: ReservationList.t ;
      next_token: String.t option }
    let make ?(reservations= [])  ?next_token  () =
      { reservations; next_token }
    let parse xml =
      Some
        {
          reservations =
            (Util.of_option []
               (Util.option_bind (Xml.member "reservationSet" xml)
                  ReservationList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ReservationSet", (ReservationList.to_query v.reservations)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("reservations", (ReservationList.to_json v.reservations))])
    let of_json j =
      {
        reservations =
          (ReservationList.of_json
             (Util.of_option_exn (Json.lookup j "reservations")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteClientVpnRouteResult =
  struct
    type t = {
      status: ClientVpnRouteStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json)
      }
  end
module DeleteFleetsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fleet_ids: FleetIdSet.t ;
      terminate_instances: Boolean.t }
    let make ?dry_run  ~fleet_ids  ~terminate_instances  () =
      { dry_run; fleet_ids; terminate_instances }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fleet_ids =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) FleetIdSet.parse));
          terminate_instances =
            (Xml.required "TerminateInstances"
               (Util.option_bind (Xml.member "TerminateInstances" xml)
                  Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TerminateInstances",
                   (Boolean.to_query v.terminate_instances)));
           Some (Query.Pair ("FleetId", (FleetIdSet.to_query v.fleet_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("terminate_instances",
                (Boolean.to_json v.terminate_instances));
           Some ("fleet_ids", (FleetIdSet.to_json v.fleet_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fleet_ids =
          (FleetIdSet.of_json
             (Util.of_option_exn (Json.lookup j "fleet_ids")));
        terminate_instances =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "terminate_instances")))
      }
  end
module DeleteTransitGatewayPrefixListReferenceResult =
  struct
    type t =
      {
      transit_gateway_prefix_list_reference:
        TransitGatewayPrefixListReference.t option }
    let make ?transit_gateway_prefix_list_reference  () =
      { transit_gateway_prefix_list_reference }
    let parse xml =
      Some
        {
          transit_gateway_prefix_list_reference =
            (Util.option_bind
               (Xml.member "transitGatewayPrefixListReference" xml)
               TransitGatewayPrefixListReference.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 Query.Pair
                   ("TransitGatewayPrefixListReference",
                     (TransitGatewayPrefixListReference.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_prefix_list_reference
              (fun f ->
                 ("transit_gateway_prefix_list_reference",
                   (TransitGatewayPrefixListReference.to_json f)))])
    let of_json j =
      {
        transit_gateway_prefix_list_reference =
          (Util.option_map
             (Json.lookup j "transit_gateway_prefix_list_reference")
             TransitGatewayPrefixListReference.of_json)
      }
  end
module DescribeLocalGatewayVirtualInterfaceGroupsRequest =
  struct
    type t =
      {
      local_gateway_virtual_interface_group_ids:
        LocalGatewayVirtualInterfaceGroupIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_virtual_interface_group_ids= [])  ?(filters= [])
       ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_virtual_interface_group_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_group_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceGroupId" xml)
                  LocalGatewayVirtualInterfaceGroupIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceGroupId",
                  (LocalGatewayVirtualInterfaceGroupIdSet.to_query
                     v.local_gateway_virtual_interface_group_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_virtual_interface_group_ids",
               (LocalGatewayVirtualInterfaceGroupIdSet.to_json
                  v.local_gateway_virtual_interface_group_ids))])
    let of_json j =
      {
        local_gateway_virtual_interface_group_ids =
          (LocalGatewayVirtualInterfaceGroupIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_group_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIdentityIdFormatResult =
  struct
    type t = {
      statuses: IdFormatList.t }
    let make ?(statuses= [])  () = { statuses }
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let of_json j =
      {
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module CreateVpcResult =
  struct
    type t = {
      vpc: Vpc.t option }
    let make ?vpc  () = { vpc }
    let parse xml =
      Some { vpc = (Util.option_bind (Xml.member "vpc" xml) Vpc.parse) }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.vpc
              (fun f -> Query.Pair ("Vpc", (Vpc.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.vpc (fun f -> ("vpc", (Vpc.to_json f)))])
    let of_json j =
      { vpc = (Util.option_map (Json.lookup j "vpc") Vpc.of_json) }
  end
module DescribeVolumesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      volume_ids: VolumeIdStringList.t ;
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?(volume_ids= [])  ?dry_run  ?max_results 
      ?next_token  () =
      { filters; volume_ids; dry_run; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          volume_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "VolumeId" xml)
                  VolumeIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("VolumeId", (VolumeIdStringList.to_query v.volume_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("volume_ids", (VolumeIdStringList.to_json v.volume_ids));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        volume_ids =
          (VolumeIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "volume_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module MonitorInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module PurchaseHostReservationResult =
  struct
    type t =
      {
      client_token: String.t option ;
      currency_code: CurrencyCodeValues.t option ;
      purchase: PurchaseSet.t ;
      total_hourly_price: String.t option ;
      total_upfront_price: String.t option }
    let make ?client_token  ?currency_code  ?(purchase= []) 
      ?total_hourly_price  ?total_upfront_price  () =
      {
        client_token;
        currency_code;
        purchase;
        total_hourly_price;
        total_upfront_price
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          currency_code =
            (Util.option_bind (Xml.member "currencyCode" xml)
               CurrencyCodeValues.parse);
          purchase =
            (Util.of_option []
               (Util.option_bind (Xml.member "purchase" xml)
                  PurchaseSet.parse));
          total_hourly_price =
            (Util.option_bind (Xml.member "totalHourlyPrice" xml)
               String.parse);
          total_upfront_price =
            (Util.option_bind (Xml.member "totalUpfrontPrice" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> Query.Pair ("TotalUpfrontPrice", (String.to_query f)));
           Util.option_map v.total_hourly_price
             (fun f -> Query.Pair ("TotalHourlyPrice", (String.to_query f)));
           Some (Query.Pair ("Purchase", (PurchaseSet.to_query v.purchase)));
           Util.option_map v.currency_code
             (fun f ->
                Query.Pair ("CurrencyCode", (CurrencyCodeValues.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.total_upfront_price
              (fun f -> ("total_upfront_price", (String.to_json f)));
           Util.option_map v.total_hourly_price
             (fun f -> ("total_hourly_price", (String.to_json f)));
           Some ("purchase", (PurchaseSet.to_json v.purchase));
           Util.option_map v.currency_code
             (fun f -> ("currency_code", (CurrencyCodeValues.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        currency_code =
          (Util.option_map (Json.lookup j "currency_code")
             CurrencyCodeValues.of_json);
        purchase =
          (PurchaseSet.of_json
             (Util.of_option_exn (Json.lookup j "purchase")));
        total_hourly_price =
          (Util.option_map (Json.lookup j "total_hourly_price")
             String.of_json);
        total_upfront_price =
          (Util.option_map (Json.lookup j "total_upfront_price")
             String.of_json)
      }
  end
module CreateClientVpnRouteResult =
  struct
    type t = {
      status: ClientVpnRouteStatus.t option }
    let make ?status  () = { status }
    let parse xml =
      Some
        {
          status =
            (Util.option_bind (Xml.member "status" xml)
               ClientVpnRouteStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f ->
                 Query.Pair ("Status", (ClientVpnRouteStatus.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (ClientVpnRouteStatus.to_json f)))])
    let of_json j =
      {
        status =
          (Util.option_map (Json.lookup j "status")
             ClientVpnRouteStatus.of_json)
      }
  end
module ModifyEbsDefaultKmsKeyIdRequest =
  struct
    type t = {
      kms_key_id: String.t ;
      dry_run: Boolean.t option }
    let make ~kms_key_id  ?dry_run  () = { kms_key_id; dry_run }
    let parse xml =
      Some
        {
          kms_key_id =
            (Xml.required "KmsKeyId"
               (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("KmsKeyId", (String.to_query v.kms_key_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("kms_key_id", (String.to_json v.kms_key_id))])
    let of_json j =
      {
        kms_key_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "kms_key_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeIdFormatRequest =
  struct
    type t = {
      resource: String.t option }
    let make ?resource  () = { resource }
    let parse xml =
      Some
        {
          resource =
            (Util.option_bind (Xml.member "Resource" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> Query.Pair ("Resource", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.resource
              (fun f -> ("resource", (String.to_json f)))])
    let of_json j =
      {
        resource =
          (Util.option_map (Json.lookup j "resource") String.of_json)
      }
  end
module DescribePublicIpv4PoolsResult =
  struct
    type t =
      {
      public_ipv4_pools: PublicIpv4PoolSet.t ;
      next_token: String.t option }
    let make ?(public_ipv4_pools= [])  ?next_token  () =
      { public_ipv4_pools; next_token }
    let parse xml =
      Some
        {
          public_ipv4_pools =
            (Util.of_option []
               (Util.option_bind (Xml.member "publicIpv4PoolSet" xml)
                  PublicIpv4PoolSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("PublicIpv4PoolSet",
                  (PublicIpv4PoolSet.to_query v.public_ipv4_pools)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("public_ipv4_pools",
               (PublicIpv4PoolSet.to_json v.public_ipv4_pools))])
    let of_json j =
      {
        public_ipv4_pools =
          (PublicIpv4PoolSet.of_json
             (Util.of_option_exn (Json.lookup j "public_ipv4_pools")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetLaunchTemplateDataRequest =
  struct
    type t = {
      dry_run: Boolean.t option ;
      instance_id: String.t }
    let make ?dry_run  ~instance_id  () = { dry_run; instance_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DescribeLocalGatewayVirtualInterfacesRequest =
  struct
    type t =
      {
      local_gateway_virtual_interface_ids:
        LocalGatewayVirtualInterfaceIdSet.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ?(local_gateway_virtual_interface_ids= [])  ?(filters= []) 
      ?max_results  ?next_token  ?dry_run  () =
      {
        local_gateway_virtual_interface_ids;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          local_gateway_virtual_interface_ids =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "LocalGatewayVirtualInterfaceId" xml)
                  LocalGatewayVirtualInterfaceIdSet.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("LocalGatewayVirtualInterfaceId",
                  (LocalGatewayVirtualInterfaceIdSet.to_query
                     v.local_gateway_virtual_interface_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("local_gateway_virtual_interface_ids",
               (LocalGatewayVirtualInterfaceIdSet.to_json
                  v.local_gateway_virtual_interface_ids))])
    let of_json j =
      {
        local_gateway_virtual_interface_ids =
          (LocalGatewayVirtualInterfaceIdSet.of_json
             (Util.of_option_exn
                (Json.lookup j "local_gateway_virtual_interface_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeVolumeAttributeResult =
  struct
    type t =
      {
      auto_enable_i_o: AttributeBooleanValue.t option ;
      product_codes: ProductCodeList.t ;
      volume_id: String.t option }
    let make ?auto_enable_i_o  ?(product_codes= [])  ?volume_id  () =
      { auto_enable_i_o; product_codes; volume_id }
    let parse xml =
      Some
        {
          auto_enable_i_o =
            (Util.option_bind (Xml.member "autoEnableIO" xml)
               AttributeBooleanValue.parse);
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "productCodes" xml)
                  ProductCodeList.parse));
          volume_id =
            (Util.option_bind (Xml.member "volumeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> Query.Pair ("VolumeId", (String.to_query f)));
           Some
             (Query.Pair
                ("ProductCodes", (ProductCodeList.to_query v.product_codes)));
           Util.option_map v.auto_enable_i_o
             (fun f ->
                Query.Pair
                  ("AutoEnableIO", (AttributeBooleanValue.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.volume_id
              (fun f -> ("volume_id", (String.to_json f)));
           Some ("product_codes", (ProductCodeList.to_json v.product_codes));
           Util.option_map v.auto_enable_i_o
             (fun f -> ("auto_enable_i_o", (AttributeBooleanValue.to_json f)))])
    let of_json j =
      {
        auto_enable_i_o =
          (Util.option_map (Json.lookup j "auto_enable_i_o")
             AttributeBooleanValue.of_json);
        product_codes =
          (ProductCodeList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        volume_id =
          (Util.option_map (Json.lookup j "volume_id") String.of_json)
      }
  end
module DescribeVpcsResult =
  struct
    type t = {
      vpcs: VpcList.t ;
      next_token: String.t option }
    let make ?(vpcs= [])  ?next_token  () = { vpcs; next_token }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml) VpcList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("VpcSet", (VpcList.to_query v.vpcs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("vpcs", (VpcList.to_json v.vpcs))])
    let of_json j =
      {
        vpcs = (VpcList.of_json (Util.of_option_exn (Json.lookup j "vpcs")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeLocalGatewaysResult =
  struct
    type t =
      {
      local_gateways: LocalGatewaySet.t ;
      next_token: String.t option }
    let make ?(local_gateways= [])  ?next_token  () =
      { local_gateways; next_token }
    let parse xml =
      Some
        {
          local_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "localGatewaySet" xml)
                  LocalGatewaySet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("LocalGatewaySet",
                  (LocalGatewaySet.to_query v.local_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("local_gateways", (LocalGatewaySet.to_json v.local_gateways))])
    let of_json j =
      {
        local_gateways =
          (LocalGatewaySet.of_json
             (Util.of_option_exn (Json.lookup j "local_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribePrefixListsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      prefix_list_ids: PrefixListResourceIdStringList.t }
    let make ?dry_run  ?(filters= [])  ?max_results  ?next_token 
      ?(prefix_list_ids= [])  () =
      { dry_run; filters; max_results; next_token; prefix_list_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          prefix_list_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "PrefixListId" xml)
                  PrefixListResourceIdStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("PrefixListId",
                   (PrefixListResourceIdStringList.to_query v.prefix_list_ids)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("prefix_list_ids",
                (PrefixListResourceIdStringList.to_json v.prefix_list_ids));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        prefix_list_ids =
          (PrefixListResourceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_ids")))
      }
  end
module ModifyLaunchTemplateResult =
  struct
    type t = {
      launch_template: LaunchTemplate.t option }
    let make ?launch_template  () = { launch_template }
    let parse xml =
      Some
        {
          launch_template =
            (Util.option_bind (Xml.member "launchTemplate" xml)
               LaunchTemplate.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f ->
                 Query.Pair ("LaunchTemplate", (LaunchTemplate.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.launch_template
              (fun f -> ("launch_template", (LaunchTemplate.to_json f)))])
    let of_json j =
      {
        launch_template =
          (Util.option_map (Json.lookup j "launch_template")
             LaunchTemplate.of_json)
      }
  end
module DescribeSubnetsResult =
  struct
    type t = {
      subnets: SubnetList.t ;
      next_token: String.t option }
    let make ?(subnets= [])  ?next_token  () = { subnets; next_token }
    let parse xml =
      Some
        {
          subnets =
            (Util.of_option []
               (Util.option_bind (Xml.member "subnetSet" xml)
                  SubnetList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("SubnetSet", (SubnetList.to_query v.subnets)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("subnets", (SubnetList.to_json v.subnets))])
    let of_json j =
      {
        subnets =
          (SubnetList.of_json (Util.of_option_exn (Json.lookup j "subnets")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module GetTransitGatewayRouteTableAssociationsRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ?(filters= [])  ?max_results 
      ?next_token  ?dry_run  () =
      {
        transit_gateway_route_table_id;
        filters;
        max_results;
        next_token;
        dry_run
      }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CancelBundleTaskResult =
  struct
    type t = {
      bundle_task: BundleTask.t option }
    let make ?bundle_task  () = { bundle_task }
    let parse xml =
      Some
        {
          bundle_task =
            (Util.option_bind (Xml.member "bundleInstanceTask" xml)
               BundleTask.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f ->
                 Query.Pair ("BundleInstanceTask", (BundleTask.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.bundle_task
              (fun f -> ("bundle_task", (BundleTask.to_json f)))])
    let of_json j =
      {
        bundle_task =
          (Util.option_map (Json.lookup j "bundle_task") BundleTask.of_json)
      }
  end
module ModifySpotFleetRequestRequest =
  struct
    type t =
      {
      excess_capacity_termination_policy:
        ExcessCapacityTerminationPolicy.t option ;
      launch_template_configs: LaunchTemplateConfigList.t ;
      spot_fleet_request_id: String.t ;
      target_capacity: Integer.t option ;
      on_demand_target_capacity: Integer.t option }
    let make ?excess_capacity_termination_policy  ?(launch_template_configs=
      [])  ~spot_fleet_request_id  ?target_capacity 
      ?on_demand_target_capacity  () =
      {
        excess_capacity_termination_policy;
        launch_template_configs;
        spot_fleet_request_id;
        target_capacity;
        on_demand_target_capacity
      }
    let parse xml =
      Some
        {
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "excessCapacityTerminationPolicy" xml)
               ExcessCapacityTerminationPolicy.parse);
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateConfig" xml)
                  LaunchTemplateConfigList.parse));
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse));
          target_capacity =
            (Util.option_bind (Xml.member "targetCapacity" xml) Integer.parse);
          on_demand_target_capacity =
            (Util.option_bind (Xml.member "OnDemandTargetCapacity" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.on_demand_target_capacity
              (fun f ->
                 Query.Pair ("OnDemandTargetCapacity", (Integer.to_query f)));
           Util.option_map v.target_capacity
             (fun f -> Query.Pair ("TargetCapacity", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SpotFleetRequestId",
                  (String.to_query v.spot_fleet_request_id)));
           Some
             (Query.Pair
                ("LaunchTemplateConfig",
                  (LaunchTemplateConfigList.to_query
                     v.launch_template_configs)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (ExcessCapacityTerminationPolicy.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.on_demand_target_capacity
              (fun f -> ("on_demand_target_capacity", (Integer.to_json f)));
           Util.option_map v.target_capacity
             (fun f -> ("target_capacity", (Integer.to_json f)));
           Some
             ("spot_fleet_request_id",
               (String.to_json v.spot_fleet_request_id));
           Some
             ("launch_template_configs",
               (LaunchTemplateConfigList.to_json v.launch_template_configs));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (ExcessCapacityTerminationPolicy.to_json f)))])
    let of_json j =
      {
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             ExcessCapacityTerminationPolicy.of_json);
        launch_template_configs =
          (LaunchTemplateConfigList.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")));
        target_capacity =
          (Util.option_map (Json.lookup j "target_capacity") Integer.of_json);
        on_demand_target_capacity =
          (Util.option_map (Json.lookup j "on_demand_target_capacity")
             Integer.of_json)
      }
  end
module AssignIpv6AddressesResult =
  struct
    type t =
      {
      assigned_ipv6_addresses: Ipv6AddressList.t ;
      network_interface_id: String.t option }
    let make ?(assigned_ipv6_addresses= [])  ?network_interface_id  () =
      { assigned_ipv6_addresses; network_interface_id }
    let parse xml =
      Some
        {
          assigned_ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "assignedIpv6Addresses" xml)
                  Ipv6AddressList.parse));
          network_interface_id =
            (Util.option_bind (Xml.member "networkInterfaceId" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f ->
                 Query.Pair ("NetworkInterfaceId", (String.to_query f)));
           Some
             (Query.Pair
                ("AssignedIpv6Addresses",
                  (Ipv6AddressList.to_query v.assigned_ipv6_addresses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_interface_id
              (fun f -> ("network_interface_id", (String.to_json f)));
           Some
             ("assigned_ipv6_addresses",
               (Ipv6AddressList.to_json v.assigned_ipv6_addresses))])
    let of_json j =
      {
        assigned_ipv6_addresses =
          (Ipv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "assigned_ipv6_addresses")));
        network_interface_id =
          (Util.option_map (Json.lookup j "network_interface_id")
             String.of_json)
      }
  end
module DetachInternetGatewayRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      internet_gateway_id: String.t ;
      vpc_id: String.t }
    let make ?dry_run  ~internet_gateway_id  ~vpc_id  () =
      { dry_run; internet_gateway_id; vpc_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          internet_gateway_id =
            (Xml.required "internetGatewayId"
               (Util.option_bind (Xml.member "internetGatewayId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("InternetGatewayId",
                  (String.to_query v.internet_gateway_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("internet_gateway_id", (String.to_json v.internet_gateway_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        internet_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "internet_gateway_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")))
      }
  end
module DescribeElasticGpusResult =
  struct
    type t =
      {
      elastic_gpu_set: ElasticGpuSet.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(elastic_gpu_set= [])  ?max_results  ?next_token  () =
      { elastic_gpu_set; max_results; next_token }
    let parse xml =
      Some
        {
          elastic_gpu_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "elasticGpuSet" xml)
                  ElasticGpuSet.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ElasticGpuSet", (ElasticGpuSet.to_query v.elastic_gpu_set)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("elastic_gpu_set", (ElasticGpuSet.to_json v.elastic_gpu_set))])
    let of_json j =
      {
        elastic_gpu_set =
          (ElasticGpuSet.of_json
             (Util.of_option_exn (Json.lookup j "elastic_gpu_set")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DisassociateClientVpnTargetNetworkResult =
  struct
    type t =
      {
      association_id: String.t option ;
      status: AssociationStatus.t option }
    let make ?association_id  ?status  () = { association_id; status }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          status =
            (Util.option_bind (Xml.member "status" xml)
               AssociationStatus.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> Query.Pair ("Status", (AssociationStatus.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.status
              (fun f -> ("status", (AssociationStatus.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        status =
          (Util.option_map (Json.lookup j "status") AssociationStatus.of_json)
      }
  end
module DescribeVpcClassicLinkResult =
  struct
    type t = {
      vpcs: VpcClassicLinkList.t }
    let make ?(vpcs= [])  () = { vpcs }
    let parse xml =
      Some
        {
          vpcs =
            (Util.of_option []
               (Util.option_bind (Xml.member "vpcSet" xml)
                  VpcClassicLinkList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("VpcSet", (VpcClassicLinkList.to_query v.vpcs)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("vpcs", (VpcClassicLinkList.to_json v.vpcs))])
    let of_json j =
      {
        vpcs =
          (VpcClassicLinkList.of_json
             (Util.of_option_exn (Json.lookup j "vpcs")))
      }
  end
module DescribeImportImageTasksResult =
  struct
    type t =
      {
      import_image_tasks: ImportImageTaskList.t ;
      next_token: String.t option }
    let make ?(import_image_tasks= [])  ?next_token  () =
      { import_image_tasks; next_token }
    let parse xml =
      Some
        {
          import_image_tasks =
            (Util.of_option []
               (Util.option_bind (Xml.member "importImageTaskSet" xml)
                  ImportImageTaskList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("ImportImageTaskSet",
                  (ImportImageTaskList.to_query v.import_image_tasks)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("import_image_tasks",
               (ImportImageTaskList.to_json v.import_image_tasks))])
    let of_json j =
      {
        import_image_tasks =
          (ImportImageTaskList.of_json
             (Util.of_option_exn (Json.lookup j "import_image_tasks")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DisableEbsEncryptionByDefaultResult =
  struct
    type t = {
      ebs_encryption_by_default: Boolean.t option }
    let make ?ebs_encryption_by_default  () = { ebs_encryption_by_default }
    let parse xml =
      Some
        {
          ebs_encryption_by_default =
            (Util.option_bind (Xml.member "ebsEncryptionByDefault" xml)
               Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f ->
                 Query.Pair ("EbsEncryptionByDefault", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ebs_encryption_by_default
              (fun f -> ("ebs_encryption_by_default", (Boolean.to_json f)))])
    let of_json j =
      {
        ebs_encryption_by_default =
          (Util.option_map (Json.lookup j "ebs_encryption_by_default")
             Boolean.of_json)
      }
  end
module ModifyIdFormatRequest =
  struct
    type t = {
      resource: String.t ;
      use_long_ids: Boolean.t }
    let make ~resource  ~use_long_ids  () = { resource; use_long_ids }
    let parse xml =
      Some
        {
          resource =
            (Xml.required "Resource"
               (Util.option_bind (Xml.member "Resource" xml) String.parse));
          use_long_ids =
            (Xml.required "UseLongIds"
               (Util.option_bind (Xml.member "UseLongIds" xml) Boolean.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("UseLongIds", (Boolean.to_query v.use_long_ids)));
           Some (Query.Pair ("Resource", (String.to_query v.resource)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("use_long_ids", (Boolean.to_json v.use_long_ids));
           Some ("resource", (String.to_json v.resource))])
    let of_json j =
      {
        resource =
          (String.of_json (Util.of_option_exn (Json.lookup j "resource")));
        use_long_ids =
          (Boolean.of_json
             (Util.of_option_exn (Json.lookup j "use_long_ids")))
      }
  end
module ProvisionByoipCidrResult =
  struct
    type t = {
      byoip_cidr: ByoipCidr.t option }
    let make ?byoip_cidr  () = { byoip_cidr }
    let parse xml =
      Some
        {
          byoip_cidr =
            (Util.option_bind (Xml.member "byoipCidr" xml) ByoipCidr.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> Query.Pair ("ByoipCidr", (ByoipCidr.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.byoip_cidr
              (fun f -> ("byoip_cidr", (ByoipCidr.to_json f)))])
    let of_json j =
      {
        byoip_cidr =
          (Util.option_map (Json.lookup j "byoip_cidr") ByoipCidr.of_json)
      }
  end
module CreateFlowLogsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      deliver_logs_permission_arn: String.t option ;
      log_group_name: String.t option ;
      resource_ids: FlowLogResourceIds.t ;
      resource_type: FlowLogsResourceType.t ;
      traffic_type: TrafficType.t ;
      log_destination_type: LogDestinationType.t option ;
      log_destination: String.t option ;
      log_format: String.t option ;
      tag_specifications: TagSpecificationList.t ;
      max_aggregation_interval: Integer.t option }
    let make ?dry_run  ?client_token  ?deliver_logs_permission_arn 
      ?log_group_name  ~resource_ids  ~resource_type  ~traffic_type 
      ?log_destination_type  ?log_destination  ?log_format 
      ?(tag_specifications= [])  ?max_aggregation_interval  () =
      {
        dry_run;
        client_token;
        deliver_logs_permission_arn;
        log_group_name;
        resource_ids;
        resource_type;
        traffic_type;
        log_destination_type;
        log_destination;
        log_format;
        tag_specifications;
        max_aggregation_interval
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          deliver_logs_permission_arn =
            (Util.option_bind (Xml.member "DeliverLogsPermissionArn" xml)
               String.parse);
          log_group_name =
            (Util.option_bind (Xml.member "LogGroupName" xml) String.parse);
          resource_ids =
            (Xml.required "ResourceId"
               (Util.option_bind (Xml.member "ResourceId" xml)
                  FlowLogResourceIds.parse));
          resource_type =
            (Xml.required "ResourceType"
               (Util.option_bind (Xml.member "ResourceType" xml)
                  FlowLogsResourceType.parse));
          traffic_type =
            (Xml.required "TrafficType"
               (Util.option_bind (Xml.member "TrafficType" xml)
                  TrafficType.parse));
          log_destination_type =
            (Util.option_bind (Xml.member "LogDestinationType" xml)
               LogDestinationType.parse);
          log_destination =
            (Util.option_bind (Xml.member "LogDestination" xml) String.parse);
          log_format =
            (Util.option_bind (Xml.member "LogFormat" xml) String.parse);
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse));
          max_aggregation_interval =
            (Util.option_bind (Xml.member "MaxAggregationInterval" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_aggregation_interval
              (fun f ->
                 Query.Pair ("MaxAggregationInterval", (Integer.to_query f)));
           Some
             (Query.Pair
                ("TagSpecification",
                  (TagSpecificationList.to_query v.tag_specifications)));
           Util.option_map v.log_format
             (fun f -> Query.Pair ("LogFormat", (String.to_query f)));
           Util.option_map v.log_destination
             (fun f -> Query.Pair ("LogDestination", (String.to_query f)));
           Util.option_map v.log_destination_type
             (fun f ->
                Query.Pair
                  ("LogDestinationType", (LogDestinationType.to_query f)));
           Some
             (Query.Pair
                ("TrafficType", (TrafficType.to_query v.traffic_type)));
           Some
             (Query.Pair
                ("ResourceType",
                  (FlowLogsResourceType.to_query v.resource_type)));
           Some
             (Query.Pair
                ("ResourceId", (FlowLogResourceIds.to_query v.resource_ids)));
           Util.option_map v.log_group_name
             (fun f -> Query.Pair ("LogGroupName", (String.to_query f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f ->
                Query.Pair ("DeliverLogsPermissionArn", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_aggregation_interval
              (fun f -> ("max_aggregation_interval", (Integer.to_json f)));
           Some
             ("tag_specifications",
               (TagSpecificationList.to_json v.tag_specifications));
           Util.option_map v.log_format
             (fun f -> ("log_format", (String.to_json f)));
           Util.option_map v.log_destination
             (fun f -> ("log_destination", (String.to_json f)));
           Util.option_map v.log_destination_type
             (fun f ->
                ("log_destination_type", (LogDestinationType.to_json f)));
           Some ("traffic_type", (TrafficType.to_json v.traffic_type));
           Some
             ("resource_type",
               (FlowLogsResourceType.to_json v.resource_type));
           Some ("resource_ids", (FlowLogResourceIds.to_json v.resource_ids));
           Util.option_map v.log_group_name
             (fun f -> ("log_group_name", (String.to_json f)));
           Util.option_map v.deliver_logs_permission_arn
             (fun f -> ("deliver_logs_permission_arn", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        deliver_logs_permission_arn =
          (Util.option_map (Json.lookup j "deliver_logs_permission_arn")
             String.of_json);
        log_group_name =
          (Util.option_map (Json.lookup j "log_group_name") String.of_json);
        resource_ids =
          (FlowLogResourceIds.of_json
             (Util.of_option_exn (Json.lookup j "resource_ids")));
        resource_type =
          (FlowLogsResourceType.of_json
             (Util.of_option_exn (Json.lookup j "resource_type")));
        traffic_type =
          (TrafficType.of_json
             (Util.of_option_exn (Json.lookup j "traffic_type")));
        log_destination_type =
          (Util.option_map (Json.lookup j "log_destination_type")
             LogDestinationType.of_json);
        log_destination =
          (Util.option_map (Json.lookup j "log_destination") String.of_json);
        log_format =
          (Util.option_map (Json.lookup j "log_format") String.of_json);
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")));
        max_aggregation_interval =
          (Util.option_map (Json.lookup j "max_aggregation_interval")
             Integer.of_json)
      }
  end
module CreateEgressOnlyInternetGatewayResult =
  struct
    type t =
      {
      client_token: String.t option ;
      egress_only_internet_gateway: EgressOnlyInternetGateway.t option }
    let make ?client_token  ?egress_only_internet_gateway  () =
      { client_token; egress_only_internet_gateway }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse);
          egress_only_internet_gateway =
            (Util.option_bind (Xml.member "egressOnlyInternetGateway" xml)
               EgressOnlyInternetGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 Query.Pair
                   ("EgressOnlyInternetGateway",
                     (EgressOnlyInternetGateway.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.egress_only_internet_gateway
              (fun f ->
                 ("egress_only_internet_gateway",
                   (EgressOnlyInternetGateway.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        egress_only_internet_gateway =
          (Util.option_map (Json.lookup j "egress_only_internet_gateway")
             EgressOnlyInternetGateway.of_json)
      }
  end
module ModifySpotFleetRequestResponse =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module AssociateIamInstanceProfileRequest =
  struct
    type t =
      {
      iam_instance_profile: IamInstanceProfileSpecification.t ;
      instance_id: String.t }
    let make ~iam_instance_profile  ~instance_id  () =
      { iam_instance_profile; instance_id }
    let parse xml =
      Some
        {
          iam_instance_profile =
            (Xml.required "IamInstanceProfile"
               (Util.option_bind (Xml.member "IamInstanceProfile" xml)
                  IamInstanceProfileSpecification.parse));
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Some
             (Query.Pair
                ("IamInstanceProfile",
                  (IamInstanceProfileSpecification.to_query
                     v.iam_instance_profile)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("instance_id", (String.to_json v.instance_id));
           Some
             ("iam_instance_profile",
               (IamInstanceProfileSpecification.to_json
                  v.iam_instance_profile))])
    let of_json j =
      {
        iam_instance_profile =
          (IamInstanceProfileSpecification.of_json
             (Util.of_option_exn (Json.lookup j "iam_instance_profile")));
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")))
      }
  end
module DescribeVpcEndpointServiceConfigurationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_ids: VpcEndpointServiceIdList.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(service_ids= [])  ?(filters= [])  ?max_results 
      ?next_token  () =
      { dry_run; service_ids; filters; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ServiceId" xml)
                  VpcEndpointServiceIdList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("ServiceId",
                  (VpcEndpointServiceIdList.to_query v.service_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("service_ids",
               (VpcEndpointServiceIdList.to_json v.service_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_ids =
          (VpcEndpointServiceIdList.of_json
             (Util.of_option_exn (Json.lookup j "service_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyVpcEndpointConnectionNotificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_id: String.t ;
      connection_notification_arn: String.t option ;
      connection_events: ValueStringList.t }
    let make ?dry_run  ~connection_notification_id 
      ?connection_notification_arn  ?(connection_events= [])  () =
      {
        dry_run;
        connection_notification_id;
        connection_notification_arn;
        connection_events
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_id =
            (Xml.required "ConnectionNotificationId"
               (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
                  String.parse));
          connection_notification_arn =
            (Util.option_bind (Xml.member "ConnectionNotificationArn" xml)
               String.parse);
          connection_events =
            (Util.of_option []
               (Util.option_bind (Xml.member "ConnectionEvents" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionEvents",
                   (ValueStringList.to_query v.connection_events)));
           Util.option_map v.connection_notification_arn
             (fun f ->
                Query.Pair ("ConnectionNotificationArn", (String.to_query f)));
           Some
             (Query.Pair
                ("ConnectionNotificationId",
                  (String.to_query v.connection_notification_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_events",
                (ValueStringList.to_json v.connection_events));
           Util.option_map v.connection_notification_arn
             (fun f -> ("connection_notification_arn", (String.to_json f)));
           Some
             ("connection_notification_id",
               (String.to_json v.connection_notification_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "connection_notification_id")));
        connection_notification_arn =
          (Util.option_map (Json.lookup j "connection_notification_arn")
             String.of_json);
        connection_events =
          (ValueStringList.of_json
             (Util.of_option_exn (Json.lookup j "connection_events")))
      }
  end
module ModifyVpcTenancyRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      instance_tenancy: VpcTenancy.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~instance_tenancy  ?dry_run  () =
      { vpc_id; instance_tenancy; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          instance_tenancy =
            (Xml.required "InstanceTenancy"
               (Util.option_bind (Xml.member "InstanceTenancy" xml)
                  VpcTenancy.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceTenancy", (VpcTenancy.to_query v.instance_tenancy)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_tenancy", (VpcTenancy.to_json v.instance_tenancy));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        instance_tenancy =
          (VpcTenancy.of_json
             (Util.of_option_exn (Json.lookup j "instance_tenancy")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeFpgaImagesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_ids: FpgaImageIdList.t ;
      owners: OwnerStringList.t ;
      filters: FilterList.t ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?dry_run  ?(fpga_image_ids= [])  ?(owners= [])  ?(filters= []) 
      ?next_token  ?max_results  () =
      { dry_run; fpga_image_ids; owners; filters; next_token; max_results }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "FpgaImageId" xml)
                  FpgaImageIdList.parse));
          owners =
            (Util.of_option []
               (Util.option_bind (Xml.member "Owner" xml)
                  OwnerStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("Owner", (OwnerStringList.to_query v.owners)));
           Some
             (Query.Pair
                ("FpgaImageId", (FpgaImageIdList.to_query v.fpga_image_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("owners", (OwnerStringList.to_json v.owners));
           Some
             ("fpga_image_ids", (FpgaImageIdList.to_json v.fpga_image_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_ids =
          (FpgaImageIdList.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_ids")));
        owners =
          (OwnerStringList.of_json
             (Util.of_option_exn (Json.lookup j "owners")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ModifyAvailabilityZoneGroupResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ApplySecurityGroupsToClientVpnTargetNetworkRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      vpc_id: String.t ;
      security_group_ids: ClientVpnSecurityGroupIdSet.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ~vpc_id  ~security_group_ids  ?dry_run 
      () = { client_vpn_endpoint_id; vpc_id; security_group_ids; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          security_group_ids =
            (Xml.required "SecurityGroupId"
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  ClientVpnSecurityGroupIdSet.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (ClientVpnSecurityGroupIdSet.to_query v.security_group_ids)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("security_group_ids",
               (ClientVpnSecurityGroupIdSet.to_json v.security_group_ids));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        security_group_ids =
          (ClientVpnSecurityGroupIdSet.of_json
             (Util.of_option_exn (Json.lookup j "security_group_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CopyFpgaImageResult =
  struct
    type t = {
      fpga_image_id: String.t option }
    let make ?fpga_image_id  () = { fpga_image_id }
    let parse xml =
      Some
        {
          fpga_image_id =
            (Util.option_bind (Xml.member "fpgaImageId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> Query.Pair ("FpgaImageId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.fpga_image_id
              (fun f -> ("fpga_image_id", (String.to_json f)))])
    let of_json j =
      {
        fpga_image_id =
          (Util.option_map (Json.lookup j "fpga_image_id") String.of_json)
      }
  end
module AcceptReservedInstancesExchangeQuoteResult =
  struct
    type t = {
      exchange_id: String.t option }
    let make ?exchange_id  () = { exchange_id }
    let parse xml =
      Some
        {
          exchange_id =
            (Util.option_bind (Xml.member "exchangeId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> Query.Pair ("ExchangeId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.exchange_id
              (fun f -> ("exchange_id", (String.to_json f)))])
    let of_json j =
      {
        exchange_id =
          (Util.option_map (Json.lookup j "exchange_id") String.of_json)
      }
  end
module DeleteTransitGatewayPrefixListReferenceRequest =
  struct
    type t =
      {
      transit_gateway_route_table_id: String.t ;
      prefix_list_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_route_table_id  ~prefix_list_id  ?dry_run  () =
      { transit_gateway_route_table_id; prefix_list_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_route_table_id =
            (Xml.required "TransitGatewayRouteTableId"
               (Util.option_bind
                  (Xml.member "TransitGatewayRouteTableId" xml) String.parse));
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Some
             (Query.Pair
                ("TransitGatewayRouteTableId",
                  (String.to_query v.transit_gateway_route_table_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Some
             ("transit_gateway_route_table_id",
               (String.to_json v.transit_gateway_route_table_id))])
    let of_json j =
      {
        transit_gateway_route_table_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_route_table_id")));
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeDhcpOptionsRequest =
  struct
    type t =
      {
      dhcp_options_ids: DhcpOptionsIdStringList.t ;
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      next_token: String.t option ;
      max_results: Integer.t option }
    let make ?(dhcp_options_ids= [])  ?(filters= [])  ?dry_run  ?next_token 
      ?max_results  () =
      { dhcp_options_ids; filters; dry_run; next_token; max_results }
    let parse xml =
      Some
        {
          dhcp_options_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "DhcpOptionsId" xml)
                  DhcpOptionsIdStringList.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some
             (Query.Pair
                ("DhcpOptionsId",
                  (DhcpOptionsIdStringList.to_query v.dhcp_options_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.max_results
              (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some
             ("dhcp_options_ids",
               (DhcpOptionsIdStringList.to_json v.dhcp_options_ids))])
    let of_json j =
      {
        dhcp_options_ids =
          (DhcpOptionsIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "dhcp_options_ids")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json)
      }
  end
module ModifyDefaultCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_family: UnlimitedSupportedInstanceFamily.t ;
      cpu_credits: String.t }
    let make ?dry_run  ~instance_family  ~cpu_credits  () =
      { dry_run; instance_family; cpu_credits }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_family =
            (Xml.required "InstanceFamily"
               (Util.option_bind (Xml.member "InstanceFamily" xml)
                  UnlimitedSupportedInstanceFamily.parse));
          cpu_credits =
            (Xml.required "CpuCredits"
               (Util.option_bind (Xml.member "CpuCredits" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("CpuCredits", (String.to_query v.cpu_credits)));
           Some
             (Query.Pair
                ("InstanceFamily",
                  (UnlimitedSupportedInstanceFamily.to_query
                     v.instance_family)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("cpu_credits", (String.to_json v.cpu_credits));
           Some
             ("instance_family",
               (UnlimitedSupportedInstanceFamily.to_json v.instance_family));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_family =
          (UnlimitedSupportedInstanceFamily.of_json
             (Util.of_option_exn (Json.lookup j "instance_family")));
        cpu_credits =
          (String.of_json (Util.of_option_exn (Json.lookup j "cpu_credits")))
      }
  end
module AssociateVpcCidrBlockRequest =
  struct
    type t =
      {
      amazon_provided_ipv6_cidr_block: Boolean.t option ;
      cidr_block: String.t option ;
      vpc_id: String.t ;
      ipv6_cidr_block_network_border_group: String.t option ;
      ipv6_pool: String.t option ;
      ipv6_cidr_block: String.t option }
    let make ?amazon_provided_ipv6_cidr_block  ?cidr_block  ~vpc_id 
      ?ipv6_cidr_block_network_border_group  ?ipv6_pool  ?ipv6_cidr_block  ()
      =
      {
        amazon_provided_ipv6_cidr_block;
        cidr_block;
        vpc_id;
        ipv6_cidr_block_network_border_group;
        ipv6_pool;
        ipv6_cidr_block
      }
    let parse xml =
      Some
        {
          amazon_provided_ipv6_cidr_block =
            (Util.option_bind (Xml.member "amazonProvidedIpv6CidrBlock" xml)
               Boolean.parse);
          cidr_block =
            (Util.option_bind (Xml.member "CidrBlock" xml) String.parse);
          vpc_id =
            (Xml.required "vpcId"
               (Util.option_bind (Xml.member "vpcId" xml) String.parse));
          ipv6_cidr_block_network_border_group =
            (Util.option_bind
               (Xml.member "Ipv6CidrBlockNetworkBorderGroup" xml)
               String.parse);
          ipv6_pool =
            (Util.option_bind (Xml.member "Ipv6Pool" xml) String.parse);
          ipv6_cidr_block =
            (Util.option_bind (Xml.member "Ipv6CidrBlock" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> Query.Pair ("Ipv6CidrBlock", (String.to_query f)));
           Util.option_map v.ipv6_pool
             (fun f -> Query.Pair ("Ipv6Pool", (String.to_query f)));
           Util.option_map v.ipv6_cidr_block_network_border_group
             (fun f ->
                Query.Pair
                  ("Ipv6CidrBlockNetworkBorderGroup", (String.to_query f)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)));
           Util.option_map v.cidr_block
             (fun f -> Query.Pair ("CidrBlock", (String.to_query f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                Query.Pair
                  ("AmazonProvidedIpv6CidrBlock", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.ipv6_cidr_block
              (fun f -> ("ipv6_cidr_block", (String.to_json f)));
           Util.option_map v.ipv6_pool
             (fun f -> ("ipv6_pool", (String.to_json f)));
           Util.option_map v.ipv6_cidr_block_network_border_group
             (fun f ->
                ("ipv6_cidr_block_network_border_group", (String.to_json f)));
           Some ("vpc_id", (String.to_json v.vpc_id));
           Util.option_map v.cidr_block
             (fun f -> ("cidr_block", (String.to_json f)));
           Util.option_map v.amazon_provided_ipv6_cidr_block
             (fun f ->
                ("amazon_provided_ipv6_cidr_block", (Boolean.to_json f)))])
    let of_json j =
      {
        amazon_provided_ipv6_cidr_block =
          (Util.option_map (Json.lookup j "amazon_provided_ipv6_cidr_block")
             Boolean.of_json);
        cidr_block =
          (Util.option_map (Json.lookup j "cidr_block") String.of_json);
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        ipv6_cidr_block_network_border_group =
          (Util.option_map
             (Json.lookup j "ipv6_cidr_block_network_border_group")
             String.of_json);
        ipv6_pool =
          (Util.option_map (Json.lookup j "ipv6_pool") String.of_json);
        ipv6_cidr_block =
          (Util.option_map (Json.lookup j "ipv6_cidr_block") String.of_json)
      }
  end
module DescribeAggregateIdFormatResult =
  struct
    type t =
      {
      use_long_ids_aggregated: Boolean.t option ;
      statuses: IdFormatList.t }
    let make ?use_long_ids_aggregated  ?(statuses= [])  () =
      { use_long_ids_aggregated; statuses }
    let parse xml =
      Some
        {
          use_long_ids_aggregated =
            (Util.option_bind (Xml.member "useLongIdsAggregated" xml)
               Boolean.parse);
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)));
           Util.option_map v.use_long_ids_aggregated
             (fun f ->
                Query.Pair ("UseLongIdsAggregated", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses));
           Util.option_map v.use_long_ids_aggregated
             (fun f -> ("use_long_ids_aggregated", (Boolean.to_json f)))])
    let of_json j =
      {
        use_long_ids_aggregated =
          (Util.option_map (Json.lookup j "use_long_ids_aggregated")
             Boolean.of_json);
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module DescribeHostsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      host_ids: RequestHostIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filter= [])  ?(host_ids= [])  ?max_results  ?next_token  () =
      { filter; host_ids; max_results; next_token }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "filter" xml) FilterList.parse));
          host_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "hostId" xml)
                  RequestHostIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair ("HostId", (RequestHostIdList.to_query v.host_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("host_ids", (RequestHostIdList.to_json v.host_ids));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        host_ids =
          (RequestHostIdList.of_json
             (Util.of_option_exn (Json.lookup j "host_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeSpotPriceHistoryResult =
  struct
    type t =
      {
      next_token: String.t option ;
      spot_price_history: SpotPriceHistoryList.t }
    let make ?next_token  ?(spot_price_history= [])  () =
      { next_token; spot_price_history }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_price_history =
            (Util.of_option []
               (Util.option_bind (Xml.member "spotPriceHistorySet" xml)
                  SpotPriceHistoryList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotPriceHistorySet",
                   (SpotPriceHistoryList.to_query v.spot_price_history)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_price_history",
                (SpotPriceHistoryList.to_json v.spot_price_history));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_price_history =
          (SpotPriceHistoryList.of_json
             (Util.of_option_exn (Json.lookup j "spot_price_history")))
      }
  end
module ReportInstanceStatusRequest =
  struct
    type t =
      {
      description: String.t option ;
      dry_run: Boolean.t option ;
      end_time: DateTime.t option ;
      instances: InstanceIdStringList.t ;
      reason_codes: ReasonCodesList.t ;
      start_time: DateTime.t option ;
      status: ReportStatusType.t }
    let make ?description  ?dry_run  ?end_time  ~instances  ~reason_codes 
      ?start_time  ~status  () =
      {
        description;
        dry_run;
        end_time;
        instances;
        reason_codes;
        start_time;
        status
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          end_time =
            (Util.option_bind (Xml.member "endTime" xml) DateTime.parse);
          instances =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml)
                  InstanceIdStringList.parse));
          reason_codes =
            (Xml.required "reasonCode"
               (Util.option_bind (Xml.member "reasonCode" xml)
                  ReasonCodesList.parse));
          start_time =
            (Util.option_bind (Xml.member "startTime" xml) DateTime.parse);
          status =
            (Xml.required "status"
               (Util.option_bind (Xml.member "status" xml)
                  ReportStatusType.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("Status", (ReportStatusType.to_query v.status)));
           Util.option_map v.start_time
             (fun f -> Query.Pair ("StartTime", (DateTime.to_query f)));
           Some
             (Query.Pair
                ("ReasonCode", (ReasonCodesList.to_query v.reason_codes)));
           Some
             (Query.Pair
                ("InstanceId", (InstanceIdStringList.to_query v.instances)));
           Util.option_map v.end_time
             (fun f -> Query.Pair ("EndTime", (DateTime.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("status", (ReportStatusType.to_json v.status));
           Util.option_map v.start_time
             (fun f -> ("start_time", (DateTime.to_json f)));
           Some ("reason_codes", (ReasonCodesList.to_json v.reason_codes));
           Some ("instances", (InstanceIdStringList.to_json v.instances));
           Util.option_map v.end_time
             (fun f -> ("end_time", (DateTime.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        end_time =
          (Util.option_map (Json.lookup j "end_time") DateTime.of_json);
        instances =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instances")));
        reason_codes =
          (ReasonCodesList.of_json
             (Util.of_option_exn (Json.lookup j "reason_codes")));
        start_time =
          (Util.option_map (Json.lookup j "start_time") DateTime.of_json);
        status =
          (ReportStatusType.of_json
             (Util.of_option_exn (Json.lookup j "status")))
      }
  end
module ImportClientVpnClientCertificateRevocationListResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module ModifyInstanceCreditSpecificationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      client_token: String.t option ;
      instance_credit_specifications:
        InstanceCreditSpecificationListRequest.t }
    let make ?dry_run  ?client_token  ~instance_credit_specifications  () =
      { dry_run; client_token; instance_credit_specifications }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          instance_credit_specifications =
            (Xml.required "InstanceCreditSpecification"
               (Util.option_bind
                  (Xml.member "InstanceCreditSpecification" xml)
                  InstanceCreditSpecificationListRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceCreditSpecification",
                   (InstanceCreditSpecificationListRequest.to_query
                      v.instance_credit_specifications)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_credit_specifications",
                (InstanceCreditSpecificationListRequest.to_json
                   v.instance_credit_specifications));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        instance_credit_specifications =
          (InstanceCreditSpecificationListRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "instance_credit_specifications")))
      }
  end
module AssociateRouteTableResult =
  struct
    type t =
      {
      association_id: String.t option ;
      association_state: RouteTableAssociationState.t option }
    let make ?association_id  ?association_state  () =
      { association_id; association_state }
    let parse xml =
      Some
        {
          association_id =
            (Util.option_bind (Xml.member "associationId" xml) String.parse);
          association_state =
            (Util.option_bind (Xml.member "associationState" xml)
               RouteTableAssociationState.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 Query.Pair
                   ("AssociationState",
                     (RouteTableAssociationState.to_query f)));
           Util.option_map v.association_id
             (fun f -> Query.Pair ("AssociationId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.association_state
              (fun f ->
                 ("association_state",
                   (RouteTableAssociationState.to_json f)));
           Util.option_map v.association_id
             (fun f -> ("association_id", (String.to_json f)))])
    let of_json j =
      {
        association_id =
          (Util.option_map (Json.lookup j "association_id") String.of_json);
        association_state =
          (Util.option_map (Json.lookup j "association_state")
             RouteTableAssociationState.of_json)
      }
  end
module CreateVpcEndpointConnectionNotificationResult =
  struct
    type t =
      {
      connection_notification: ConnectionNotification.t option ;
      client_token: String.t option }
    let make ?connection_notification  ?client_token  () =
      { connection_notification; client_token }
    let parse xml =
      Some
        {
          connection_notification =
            (Util.option_bind (Xml.member "connectionNotification" xml)
               ConnectionNotification.parse);
          client_token =
            (Util.option_bind (Xml.member "clientToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.connection_notification
             (fun f ->
                Query.Pair
                  ("ConnectionNotification",
                    (ConnectionNotification.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_token
              (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.connection_notification
             (fun f ->
                ("connection_notification",
                  (ConnectionNotification.to_json f)))])
    let of_json j =
      {
        connection_notification =
          (Util.option_map (Json.lookup j "connection_notification")
             ConnectionNotification.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json)
      }
  end
module DeleteClientVpnRouteRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      target_vpc_subnet_id: String.t option ;
      destination_cidr_block: String.t ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?target_vpc_subnet_id 
      ~destination_cidr_block  ?dry_run  () =
      {
        client_vpn_endpoint_id;
        target_vpc_subnet_id;
        destination_cidr_block;
        dry_run
      }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          target_vpc_subnet_id =
            (Util.option_bind (Xml.member "TargetVpcSubnetId" xml)
               String.parse);
          destination_cidr_block =
            (Xml.required "DestinationCidrBlock"
               (Util.option_bind (Xml.member "DestinationCidrBlock" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DestinationCidrBlock",
                  (String.to_query v.destination_cidr_block)));
           Util.option_map v.target_vpc_subnet_id
             (fun f -> Query.Pair ("TargetVpcSubnetId", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("destination_cidr_block",
               (String.to_json v.destination_cidr_block));
           Util.option_map v.target_vpc_subnet_id
             (fun f -> ("target_vpc_subnet_id", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        target_vpc_subnet_id =
          (Util.option_map (Json.lookup j "target_vpc_subnet_id")
             String.of_json);
        destination_cidr_block =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "destination_cidr_block")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module ModifyFleetRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      excess_capacity_termination_policy:
        FleetExcessCapacityTerminationPolicy.t option ;
      launch_template_configs: FleetLaunchTemplateConfigListRequest.t ;
      fleet_id: String.t ;
      target_capacity_specification:
        TargetCapacitySpecificationRequest.t option }
    let make ?dry_run  ?excess_capacity_termination_policy 
      ?(launch_template_configs= [])  ~fleet_id 
      ?target_capacity_specification  () =
      {
        dry_run;
        excess_capacity_termination_policy;
        launch_template_configs;
        fleet_id;
        target_capacity_specification
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          excess_capacity_termination_policy =
            (Util.option_bind
               (Xml.member "ExcessCapacityTerminationPolicy" xml)
               FleetExcessCapacityTerminationPolicy.parse);
          launch_template_configs =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateConfig" xml)
                  FleetLaunchTemplateConfigListRequest.parse));
          fleet_id =
            (Xml.required "FleetId"
               (Util.option_bind (Xml.member "FleetId" xml) String.parse));
          target_capacity_specification =
            (Util.option_bind (Xml.member "TargetCapacitySpecification" xml)
               TargetCapacitySpecificationRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.target_capacity_specification
              (fun f ->
                 Query.Pair
                   ("TargetCapacitySpecification",
                     (TargetCapacitySpecificationRequest.to_query f)));
           Some (Query.Pair ("FleetId", (String.to_query v.fleet_id)));
           Some
             (Query.Pair
                ("LaunchTemplateConfig",
                  (FleetLaunchTemplateConfigListRequest.to_query
                     v.launch_template_configs)));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                Query.Pair
                  ("ExcessCapacityTerminationPolicy",
                    (FleetExcessCapacityTerminationPolicy.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.target_capacity_specification
              (fun f ->
                 ("target_capacity_specification",
                   (TargetCapacitySpecificationRequest.to_json f)));
           Some ("fleet_id", (String.to_json v.fleet_id));
           Some
             ("launch_template_configs",
               (FleetLaunchTemplateConfigListRequest.to_json
                  v.launch_template_configs));
           Util.option_map v.excess_capacity_termination_policy
             (fun f ->
                ("excess_capacity_termination_policy",
                  (FleetExcessCapacityTerminationPolicy.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        excess_capacity_termination_policy =
          (Util.option_map
             (Json.lookup j "excess_capacity_termination_policy")
             FleetExcessCapacityTerminationPolicy.of_json);
        launch_template_configs =
          (FleetLaunchTemplateConfigListRequest.of_json
             (Util.of_option_exn (Json.lookup j "launch_template_configs")));
        fleet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "fleet_id")));
        target_capacity_specification =
          (Util.option_map (Json.lookup j "target_capacity_specification")
             TargetCapacitySpecificationRequest.of_json)
      }
  end
module DetachNetworkInterfaceRequest =
  struct
    type t =
      {
      attachment_id: String.t ;
      dry_run: Boolean.t option ;
      force: Boolean.t option }
    let make ~attachment_id  ?dry_run  ?force  () =
      { attachment_id; dry_run; force }
    let parse xml =
      Some
        {
          attachment_id =
            (Xml.required "attachmentId"
               (Util.option_bind (Xml.member "attachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          force = (Util.option_bind (Xml.member "force" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.force
              (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("AttachmentId", (String.to_query v.attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("attachment_id", (String.to_json v.attachment_id))])
    let of_json j =
      {
        attachment_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json)
      }
  end
module DescribeLaunchTemplateVersionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      versions: VersionStringList.t ;
      min_version: String.t option ;
      max_version: String.t option ;
      next_token: String.t option ;
      max_results: Integer.t option ;
      filters: FilterList.t }
    let make ?dry_run  ?launch_template_id  ?launch_template_name 
      ?(versions= [])  ?min_version  ?max_version  ?next_token  ?max_results 
      ?(filters= [])  () =
      {
        dry_run;
        launch_template_id;
        launch_template_name;
        versions;
        min_version;
        max_version;
        next_token;
        max_results;
        filters
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          versions =
            (Util.of_option []
               (Util.option_bind (Xml.member "LaunchTemplateVersion" xml)
                  VersionStringList.parse));
          min_version =
            (Util.option_bind (Xml.member "MinVersion" xml) String.parse);
          max_version =
            (Util.option_bind (Xml.member "MaxVersion" xml) String.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_version
             (fun f -> Query.Pair ("MaxVersion", (String.to_query f)));
           Util.option_map v.min_version
             (fun f -> Query.Pair ("MinVersion", (String.to_query f)));
           Some
             (Query.Pair
                ("LaunchTemplateVersion",
                  (VersionStringList.to_query v.versions)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_version
             (fun f -> ("max_version", (String.to_json f)));
           Util.option_map v.min_version
             (fun f -> ("min_version", (String.to_json f)));
           Some ("versions", (VersionStringList.to_json v.versions));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        versions =
          (VersionStringList.of_json
             (Util.of_option_exn (Json.lookup j "versions")));
        min_version =
          (Util.option_map (Json.lookup j "min_version") String.of_json);
        max_version =
          (Util.option_map (Json.lookup j "max_version") String.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")))
      }
  end
module CreateNetworkInterfaceRequest =
  struct
    type t =
      {
      description: String.t option ;
      dry_run: Boolean.t option ;
      groups: SecurityGroupIdStringList.t ;
      ipv6_address_count: Integer.t option ;
      ipv6_addresses: InstanceIpv6AddressList.t ;
      private_ip_address: String.t option ;
      private_ip_addresses: PrivateIpAddressSpecificationList.t ;
      secondary_private_ip_address_count: Integer.t option ;
      interface_type: NetworkInterfaceCreationType.t option ;
      subnet_id: String.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?description  ?dry_run  ?(groups= [])  ?ipv6_address_count 
      ?(ipv6_addresses= [])  ?private_ip_address  ?(private_ip_addresses= [])
       ?secondary_private_ip_address_count  ?interface_type  ~subnet_id 
      ?(tag_specifications= [])  () =
      {
        description;
        dry_run;
        groups;
        ipv6_address_count;
        ipv6_addresses;
        private_ip_address;
        private_ip_addresses;
        secondary_private_ip_address_count;
        interface_type;
        subnet_id;
        tag_specifications
      }
    let parse xml =
      Some
        {
          description =
            (Util.option_bind (Xml.member "description" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "SecurityGroupId" xml)
                  SecurityGroupIdStringList.parse));
          ipv6_address_count =
            (Util.option_bind (Xml.member "ipv6AddressCount" xml)
               Integer.parse);
          ipv6_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "ipv6Addresses" xml)
                  InstanceIpv6AddressList.parse));
          private_ip_address =
            (Util.option_bind (Xml.member "privateIpAddress" xml)
               String.parse);
          private_ip_addresses =
            (Util.of_option []
               (Util.option_bind (Xml.member "privateIpAddresses" xml)
                  PrivateIpAddressSpecificationList.parse));
          secondary_private_ip_address_count =
            (Util.option_bind
               (Xml.member "secondaryPrivateIpAddressCount" xml)
               Integer.parse);
          interface_type =
            (Util.option_bind (Xml.member "InterfaceType" xml)
               NetworkInterfaceCreationType.parse);
          subnet_id =
            (Xml.required "subnetId"
               (Util.option_bind (Xml.member "subnetId" xml) String.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some (Query.Pair ("SubnetId", (String.to_query v.subnet_id)));
           Util.option_map v.interface_type
             (fun f ->
                Query.Pair
                  ("InterfaceType",
                    (NetworkInterfaceCreationType.to_query f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                Query.Pair
                  ("SecondaryPrivateIpAddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("PrivateIpAddresses",
                  (PrivateIpAddressSpecificationList.to_query
                     v.private_ip_addresses)));
           Util.option_map v.private_ip_address
             (fun f -> Query.Pair ("PrivateIpAddress", (String.to_query f)));
           Some
             (Query.Pair
                ("Ipv6Addresses",
                  (InstanceIpv6AddressList.to_query v.ipv6_addresses)));
           Util.option_map v.ipv6_address_count
             (fun f -> Query.Pair ("Ipv6AddressCount", (Integer.to_query f)));
           Some
             (Query.Pair
                ("SecurityGroupId",
                  (SecurityGroupIdStringList.to_query v.groups)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some ("subnet_id", (String.to_json v.subnet_id));
           Util.option_map v.interface_type
             (fun f ->
                ("interface_type", (NetworkInterfaceCreationType.to_json f)));
           Util.option_map v.secondary_private_ip_address_count
             (fun f ->
                ("secondary_private_ip_address_count", (Integer.to_json f)));
           Some
             ("private_ip_addresses",
               (PrivateIpAddressSpecificationList.to_json
                  v.private_ip_addresses));
           Util.option_map v.private_ip_address
             (fun f -> ("private_ip_address", (String.to_json f)));
           Some
             ("ipv6_addresses",
               (InstanceIpv6AddressList.to_json v.ipv6_addresses));
           Util.option_map v.ipv6_address_count
             (fun f -> ("ipv6_address_count", (Integer.to_json f)));
           Some ("groups", (SecurityGroupIdStringList.to_json v.groups));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)))])
    let of_json j =
      {
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        groups =
          (SecurityGroupIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "groups")));
        ipv6_address_count =
          (Util.option_map (Json.lookup j "ipv6_address_count")
             Integer.of_json);
        ipv6_addresses =
          (InstanceIpv6AddressList.of_json
             (Util.of_option_exn (Json.lookup j "ipv6_addresses")));
        private_ip_address =
          (Util.option_map (Json.lookup j "private_ip_address")
             String.of_json);
        private_ip_addresses =
          (PrivateIpAddressSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "private_ip_addresses")));
        secondary_private_ip_address_count =
          (Util.option_map
             (Json.lookup j "secondary_private_ip_address_count")
             Integer.of_json);
        interface_type =
          (Util.option_map (Json.lookup j "interface_type")
             NetworkInterfaceCreationType.of_json);
        subnet_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "subnet_id")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module GetReservedInstancesExchangeQuoteRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      reserved_instance_ids: ReservedInstanceIdSet.t ;
      target_configurations: TargetConfigurationRequestSet.t }
    let make ?dry_run  ~reserved_instance_ids  ?(target_configurations= []) 
      () = { dry_run; reserved_instance_ids; target_configurations }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          reserved_instance_ids =
            (Xml.required "ReservedInstanceId"
               (Util.option_bind (Xml.member "ReservedInstanceId" xml)
                  ReservedInstanceIdSet.parse));
          target_configurations =
            (Util.of_option []
               (Util.option_bind (Xml.member "TargetConfiguration" xml)
                  TargetConfigurationRequestSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TargetConfiguration",
                   (TargetConfigurationRequestSet.to_query
                      v.target_configurations)));
           Some
             (Query.Pair
                ("ReservedInstanceId",
                  (ReservedInstanceIdSet.to_query v.reserved_instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("target_configurations",
                (TargetConfigurationRequestSet.to_json
                   v.target_configurations));
           Some
             ("reserved_instance_ids",
               (ReservedInstanceIdSet.to_json v.reserved_instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        reserved_instance_ids =
          (ReservedInstanceIdSet.of_json
             (Util.of_option_exn (Json.lookup j "reserved_instance_ids")));
        target_configurations =
          (TargetConfigurationRequestSet.of_json
             (Util.of_option_exn (Json.lookup j "target_configurations")))
      }
  end
module GetPasswordDataRequest =
  struct
    type t = {
      instance_id: String.t ;
      dry_run: Boolean.t option }
    let make ~instance_id  ?dry_run  () = { instance_id; dry_run }
    let parse xml =
      Some
        {
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id))])
    let of_json j =
      {
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeregisterImageRequest =
  struct
    type t = {
      image_id: String.t ;
      dry_run: Boolean.t option }
    let make ~image_id  ?dry_run  () = { image_id; dry_run }
    let parse xml =
      Some
        {
          image_id =
            (Xml.required "ImageId"
               (Util.option_bind (Xml.member "ImageId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("ImageId", (String.to_query v.image_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("image_id", (String.to_json v.image_id))])
    let of_json j =
      {
        image_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "image_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeHostReservationsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      host_reservation_id_set: HostReservationIdSet.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filter= [])  ?(host_reservation_id_set= [])  ?max_results 
      ?next_token  () =
      { filter; host_reservation_id_set; max_results; next_token }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          host_reservation_id_set =
            (Util.of_option []
               (Util.option_bind (Xml.member "HostReservationIdSet" xml)
                  HostReservationIdSet.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("HostReservationIdSet",
                  (HostReservationIdSet.to_query v.host_reservation_id_set)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("host_reservation_id_set",
               (HostReservationIdSet.to_json v.host_reservation_id_set));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        host_reservation_id_set =
          (HostReservationIdSet.of_json
             (Util.of_option_exn (Json.lookup j "host_reservation_id_set")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteTransitGatewayRouteResult =
  struct
    type t = {
      route: TransitGatewayRoute.t option }
    let make ?route  () = { route }
    let parse xml =
      Some
        {
          route =
            (Util.option_bind (Xml.member "route" xml)
               TransitGatewayRoute.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f ->
                 Query.Pair ("Route", (TransitGatewayRoute.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.route
              (fun f -> ("route", (TransitGatewayRoute.to_json f)))])
    let of_json j =
      {
        route =
          (Util.option_map (Json.lookup j "route")
             TransitGatewayRoute.of_json)
      }
  end
module RebootInstancesRequest =
  struct
    type t =
      {
      instance_ids: InstanceIdStringList.t ;
      dry_run: Boolean.t option }
    let make ~instance_ids  ?dry_run  () = { instance_ids; dry_run }
    let parse xml =
      Some
        {
          instance_ids =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids))])
    let of_json j =
      {
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RestoreManagedPrefixListVersionRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      prefix_list_id: String.t ;
      previous_version: Long.t ;
      current_version: Long.t }
    let make ?dry_run  ~prefix_list_id  ~previous_version  ~current_version 
      () = { dry_run; prefix_list_id; previous_version; current_version }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          prefix_list_id =
            (Xml.required "PrefixListId"
               (Util.option_bind (Xml.member "PrefixListId" xml) String.parse));
          previous_version =
            (Xml.required "PreviousVersion"
               (Util.option_bind (Xml.member "PreviousVersion" xml)
                  Long.parse));
          current_version =
            (Xml.required "CurrentVersion"
               (Util.option_bind (Xml.member "CurrentVersion" xml) Long.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("CurrentVersion", (Long.to_query v.current_version)));
           Some
             (Query.Pair
                ("PreviousVersion", (Long.to_query v.previous_version)));
           Some
             (Query.Pair ("PrefixListId", (String.to_query v.prefix_list_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("current_version", (Long.to_json v.current_version));
           Some ("previous_version", (Long.to_json v.previous_version));
           Some ("prefix_list_id", (String.to_json v.prefix_list_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        prefix_list_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "prefix_list_id")));
        previous_version =
          (Long.of_json
             (Util.of_option_exn (Json.lookup j "previous_version")));
        current_version =
          (Long.of_json
             (Util.of_option_exn (Json.lookup j "current_version")))
      }
  end
module ReplaceRouteTableAssociationRequest =
  struct
    type t =
      {
      association_id: String.t ;
      dry_run: Boolean.t option ;
      route_table_id: String.t }
    let make ~association_id  ?dry_run  ~route_table_id  () =
      { association_id; dry_run; route_table_id }
    let parse xml =
      Some
        {
          association_id =
            (Xml.required "associationId"
               (Util.option_bind (Xml.member "associationId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          route_table_id =
            (Xml.required "routeTableId"
               (Util.option_bind (Xml.member "routeTableId" xml) String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RouteTableId", (String.to_query v.route_table_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("AssociationId", (String.to_query v.association_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("route_table_id", (String.to_json v.route_table_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("association_id", (String.to_json v.association_id))])
    let of_json j =
      {
        association_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "association_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")))
      }
  end
module DescribeClassicLinkInstancesRequest =
  struct
    type t =
      {
      filters: FilterList.t ;
      dry_run: Boolean.t option ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?(filters= [])  ?dry_run  ?(instance_ids= [])  ?max_results 
      ?next_token  () =
      { filters; dry_run; instance_ids; max_results; next_token }
    let parse xml =
      Some
        {
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("filters", (FilterList.to_json v.filters))])
    let of_json j =
      {
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RevokeSecurityGroupEgressResult =
  struct
    type t =
      {
      return: Boolean.t option ;
      unknown_ip_permissions: IpPermissionList.t }
    let make ?return  ?(unknown_ip_permissions= [])  () =
      { return; unknown_ip_permissions }
    let parse xml =
      Some
        {
          return = (Util.option_bind (Xml.member "return" xml) Boolean.parse);
          unknown_ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "unknownIpPermissionSet" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("UnknownIpPermissionSet",
                   (IpPermissionList.to_query v.unknown_ip_permissions)));
           Util.option_map v.return
             (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("unknown_ip_permissions",
                (IpPermissionList.to_json v.unknown_ip_permissions));
           Util.option_map v.return
             (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      {
        return = (Util.option_map (Json.lookup j "return") Boolean.of_json);
        unknown_ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "unknown_ip_permissions")))
      }
  end
module GetCoipPoolUsageRequest =
  struct
    type t =
      {
      pool_id: String.t ;
      filters: FilterList.t ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      dry_run: Boolean.t option }
    let make ~pool_id  ?(filters= [])  ?max_results  ?next_token  ?dry_run 
      () = { pool_id; filters; max_results; next_token; dry_run }
    let parse xml =
      Some
        {
          pool_id =
            (Xml.required "PoolId"
               (Util.option_bind (Xml.member "PoolId" xml) String.parse));
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Some (Query.Pair ("PoolId", (String.to_query v.pool_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some ("filters", (FilterList.to_json v.filters));
           Some ("pool_id", (String.to_json v.pool_id))])
    let of_json j =
      {
        pool_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "pool_id")));
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module CreateInternetGatewayResult =
  struct
    type t = {
      internet_gateway: InternetGateway.t option }
    let make ?internet_gateway  () = { internet_gateway }
    let parse xml =
      Some
        {
          internet_gateway =
            (Util.option_bind (Xml.member "internetGateway" xml)
               InternetGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f ->
                 Query.Pair ("InternetGateway", (InternetGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.internet_gateway
              (fun f -> ("internet_gateway", (InternetGateway.to_json f)))])
    let of_json j =
      {
        internet_gateway =
          (Util.option_map (Json.lookup j "internet_gateway")
             InternetGateway.of_json)
      }
  end
module DescribeIdFormatResult =
  struct
    type t = {
      statuses: IdFormatList.t }
    let make ?(statuses= [])  () = { statuses }
    let parse xml =
      Some
        {
          statuses =
            (Util.of_option []
               (Util.option_bind (Xml.member "statusSet" xml)
                  IdFormatList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair ("StatusSet", (IdFormatList.to_query v.statuses)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("statuses", (IdFormatList.to_json v.statuses))])
    let of_json j =
      {
        statuses =
          (IdFormatList.of_json
             (Util.of_option_exn (Json.lookup j "statuses")))
      }
  end
module DescribeScheduledInstanceAvailabilityRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      first_slot_start_time_range: SlotDateTimeRangeRequest.t ;
      max_results: Integer.t option ;
      max_slot_duration_in_hours: Integer.t option ;
      min_slot_duration_in_hours: Integer.t option ;
      next_token: String.t option ;
      recurrence: ScheduledInstanceRecurrenceRequest.t }
    let make ?dry_run  ?(filters= [])  ~first_slot_start_time_range 
      ?max_results  ?max_slot_duration_in_hours  ?min_slot_duration_in_hours 
      ?next_token  ~recurrence  () =
      {
        dry_run;
        filters;
        first_slot_start_time_range;
        max_results;
        max_slot_duration_in_hours;
        min_slot_duration_in_hours;
        next_token;
        recurrence
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          first_slot_start_time_range =
            (Xml.required "FirstSlotStartTimeRange"
               (Util.option_bind (Xml.member "FirstSlotStartTimeRange" xml)
                  SlotDateTimeRangeRequest.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          max_slot_duration_in_hours =
            (Util.option_bind (Xml.member "MaxSlotDurationInHours" xml)
               Integer.parse);
          min_slot_duration_in_hours =
            (Util.option_bind (Xml.member "MinSlotDurationInHours" xml)
               Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          recurrence =
            (Xml.required "Recurrence"
               (Util.option_bind (Xml.member "Recurrence" xml)
                  ScheduledInstanceRecurrenceRequest.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("Recurrence",
                   (ScheduledInstanceRecurrenceRequest.to_query v.recurrence)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.min_slot_duration_in_hours
             (fun f ->
                Query.Pair ("MinSlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.max_slot_duration_in_hours
             (fun f ->
                Query.Pair ("MaxSlotDurationInHours", (Integer.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("FirstSlotStartTimeRange",
                  (SlotDateTimeRangeRequest.to_query
                     v.first_slot_start_time_range)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("recurrence",
                (ScheduledInstanceRecurrenceRequest.to_json v.recurrence));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.min_slot_duration_in_hours
             (fun f -> ("min_slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.max_slot_duration_in_hours
             (fun f -> ("max_slot_duration_in_hours", (Integer.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("first_slot_start_time_range",
               (SlotDateTimeRangeRequest.to_json
                  v.first_slot_start_time_range));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        first_slot_start_time_range =
          (SlotDateTimeRangeRequest.of_json
             (Util.of_option_exn
                (Json.lookup j "first_slot_start_time_range")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        max_slot_duration_in_hours =
          (Util.option_map (Json.lookup j "max_slot_duration_in_hours")
             Integer.of_json);
        min_slot_duration_in_hours =
          (Util.option_map (Json.lookup j "min_slot_duration_in_hours")
             Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        recurrence =
          (ScheduledInstanceRecurrenceRequest.of_json
             (Util.of_option_exn (Json.lookup j "recurrence")))
      }
  end
module ImportImageRequest =
  struct
    type t =
      {
      architecture: String.t option ;
      client_data: ClientData.t option ;
      client_token: String.t option ;
      description: String.t option ;
      disk_containers: ImageDiskContainerList.t ;
      dry_run: Boolean.t option ;
      encrypted: Boolean.t option ;
      hypervisor: String.t option ;
      kms_key_id: String.t option ;
      license_type: String.t option ;
      platform: String.t option ;
      role_name: String.t option ;
      license_specifications: ImportImageLicenseSpecificationListRequest.t ;
      tag_specifications: TagSpecificationList.t }
    let make ?architecture  ?client_data  ?client_token  ?description 
      ?(disk_containers= [])  ?dry_run  ?encrypted  ?hypervisor  ?kms_key_id 
      ?license_type  ?platform  ?role_name  ?(license_specifications= []) 
      ?(tag_specifications= [])  () =
      {
        architecture;
        client_data;
        client_token;
        description;
        disk_containers;
        dry_run;
        encrypted;
        hypervisor;
        kms_key_id;
        license_type;
        platform;
        role_name;
        license_specifications;
        tag_specifications
      }
    let parse xml =
      Some
        {
          architecture =
            (Util.option_bind (Xml.member "Architecture" xml) String.parse);
          client_data =
            (Util.option_bind (Xml.member "ClientData" xml) ClientData.parse);
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          disk_containers =
            (Util.of_option []
               (Util.option_bind (Xml.member "DiskContainer" xml)
                  ImageDiskContainerList.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          encrypted =
            (Util.option_bind (Xml.member "Encrypted" xml) Boolean.parse);
          hypervisor =
            (Util.option_bind (Xml.member "Hypervisor" xml) String.parse);
          kms_key_id =
            (Util.option_bind (Xml.member "KmsKeyId" xml) String.parse);
          license_type =
            (Util.option_bind (Xml.member "LicenseType" xml) String.parse);
          platform =
            (Util.option_bind (Xml.member "Platform" xml) String.parse);
          role_name =
            (Util.option_bind (Xml.member "RoleName" xml) String.parse);
          license_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "LicenseSpecifications" xml)
                  ImportImageLicenseSpecificationListRequest.parse));
          tag_specifications =
            (Util.of_option []
               (Util.option_bind (Xml.member "TagSpecification" xml)
                  TagSpecificationList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("TagSpecification",
                   (TagSpecificationList.to_query v.tag_specifications)));
           Some
             (Query.Pair
                ("LicenseSpecifications",
                  (ImportImageLicenseSpecificationListRequest.to_query
                     v.license_specifications)));
           Util.option_map v.role_name
             (fun f -> Query.Pair ("RoleName", (String.to_query f)));
           Util.option_map v.platform
             (fun f -> Query.Pair ("Platform", (String.to_query f)));
           Util.option_map v.license_type
             (fun f -> Query.Pair ("LicenseType", (String.to_query f)));
           Util.option_map v.kms_key_id
             (fun f -> Query.Pair ("KmsKeyId", (String.to_query f)));
           Util.option_map v.hypervisor
             (fun f -> Query.Pair ("Hypervisor", (String.to_query f)));
           Util.option_map v.encrypted
             (fun f -> Query.Pair ("Encrypted", (Boolean.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("DiskContainer",
                  (ImageDiskContainerList.to_query v.disk_containers)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)));
           Util.option_map v.client_data
             (fun f -> Query.Pair ("ClientData", (ClientData.to_query f)));
           Util.option_map v.architecture
             (fun f -> Query.Pair ("Architecture", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("tag_specifications",
                (TagSpecificationList.to_json v.tag_specifications));
           Some
             ("license_specifications",
               (ImportImageLicenseSpecificationListRequest.to_json
                  v.license_specifications));
           Util.option_map v.role_name
             (fun f -> ("role_name", (String.to_json f)));
           Util.option_map v.platform
             (fun f -> ("platform", (String.to_json f)));
           Util.option_map v.license_type
             (fun f -> ("license_type", (String.to_json f)));
           Util.option_map v.kms_key_id
             (fun f -> ("kms_key_id", (String.to_json f)));
           Util.option_map v.hypervisor
             (fun f -> ("hypervisor", (String.to_json f)));
           Util.option_map v.encrypted
             (fun f -> ("encrypted", (Boolean.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("disk_containers",
               (ImageDiskContainerList.to_json v.disk_containers));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)));
           Util.option_map v.client_data
             (fun f -> ("client_data", (ClientData.to_json f)));
           Util.option_map v.architecture
             (fun f -> ("architecture", (String.to_json f)))])
    let of_json j =
      {
        architecture =
          (Util.option_map (Json.lookup j "architecture") String.of_json);
        client_data =
          (Util.option_map (Json.lookup j "client_data") ClientData.of_json);
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        disk_containers =
          (ImageDiskContainerList.of_json
             (Util.of_option_exn (Json.lookup j "disk_containers")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        encrypted =
          (Util.option_map (Json.lookup j "encrypted") Boolean.of_json);
        hypervisor =
          (Util.option_map (Json.lookup j "hypervisor") String.of_json);
        kms_key_id =
          (Util.option_map (Json.lookup j "kms_key_id") String.of_json);
        license_type =
          (Util.option_map (Json.lookup j "license_type") String.of_json);
        platform =
          (Util.option_map (Json.lookup j "platform") String.of_json);
        role_name =
          (Util.option_map (Json.lookup j "role_name") String.of_json);
        license_specifications =
          (ImportImageLicenseSpecificationListRequest.of_json
             (Util.of_option_exn (Json.lookup j "license_specifications")));
        tag_specifications =
          (TagSpecificationList.of_json
             (Util.of_option_exn (Json.lookup j "tag_specifications")))
      }
  end
module ModifyVpcEndpointServiceConfigurationRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      private_dns_name: String.t option ;
      remove_private_dns_name: Boolean.t option ;
      acceptance_required: Boolean.t option ;
      add_network_load_balancer_arns: ValueStringList.t ;
      remove_network_load_balancer_arns: ValueStringList.t ;
      add_gateway_load_balancer_arns: ValueStringList.t ;
      remove_gateway_load_balancer_arns: ValueStringList.t }
    let make ?dry_run  ~service_id  ?private_dns_name 
      ?remove_private_dns_name  ?acceptance_required 
      ?(add_network_load_balancer_arns= []) 
      ?(remove_network_load_balancer_arns= []) 
      ?(add_gateway_load_balancer_arns= []) 
      ?(remove_gateway_load_balancer_arns= [])  () =
      {
        dry_run;
        service_id;
        private_dns_name;
        remove_private_dns_name;
        acceptance_required;
        add_network_load_balancer_arns;
        remove_network_load_balancer_arns;
        add_gateway_load_balancer_arns;
        remove_gateway_load_balancer_arns
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          private_dns_name =
            (Util.option_bind (Xml.member "PrivateDnsName" xml) String.parse);
          remove_private_dns_name =
            (Util.option_bind (Xml.member "RemovePrivateDnsName" xml)
               Boolean.parse);
          acceptance_required =
            (Util.option_bind (Xml.member "AcceptanceRequired" xml)
               Boolean.parse);
          add_network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddNetworkLoadBalancerArn" xml)
                  ValueStringList.parse));
          remove_network_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "RemoveNetworkLoadBalancerArn" xml)
                  ValueStringList.parse));
          add_gateway_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind (Xml.member "AddGatewayLoadBalancerArn" xml)
                  ValueStringList.parse));
          remove_gateway_load_balancer_arns =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "RemoveGatewayLoadBalancerArn" xml)
                  ValueStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("RemoveGatewayLoadBalancerArn",
                   (ValueStringList.to_query
                      v.remove_gateway_load_balancer_arns)));
           Some
             (Query.Pair
                ("AddGatewayLoadBalancerArn",
                  (ValueStringList.to_query v.add_gateway_load_balancer_arns)));
           Some
             (Query.Pair
                ("RemoveNetworkLoadBalancerArn",
                  (ValueStringList.to_query
                     v.remove_network_load_balancer_arns)));
           Some
             (Query.Pair
                ("AddNetworkLoadBalancerArn",
                  (ValueStringList.to_query v.add_network_load_balancer_arns)));
           Util.option_map v.acceptance_required
             (fun f ->
                Query.Pair ("AcceptanceRequired", (Boolean.to_query f)));
           Util.option_map v.remove_private_dns_name
             (fun f ->
                Query.Pair ("RemovePrivateDnsName", (Boolean.to_query f)));
           Util.option_map v.private_dns_name
             (fun f -> Query.Pair ("PrivateDnsName", (String.to_query f)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("remove_gateway_load_balancer_arns",
                (ValueStringList.to_json v.remove_gateway_load_balancer_arns));
           Some
             ("add_gateway_load_balancer_arns",
               (ValueStringList.to_json v.add_gateway_load_balancer_arns));
           Some
             ("remove_network_load_balancer_arns",
               (ValueStringList.to_json v.remove_network_load_balancer_arns));
           Some
             ("add_network_load_balancer_arns",
               (ValueStringList.to_json v.add_network_load_balancer_arns));
           Util.option_map v.acceptance_required
             (fun f -> ("acceptance_required", (Boolean.to_json f)));
           Util.option_map v.remove_private_dns_name
             (fun f -> ("remove_private_dns_name", (Boolean.to_json f)));
           Util.option_map v.private_dns_name
             (fun f -> ("private_dns_name", (String.to_json f)));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        private_dns_name =
          (Util.option_map (Json.lookup j "private_dns_name") String.of_json);
        remove_private_dns_name =
          (Util.option_map (Json.lookup j "remove_private_dns_name")
             Boolean.of_json);
        acceptance_required =
          (Util.option_map (Json.lookup j "acceptance_required")
             Boolean.of_json);
        add_network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "add_network_load_balancer_arns")));
        remove_network_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "remove_network_load_balancer_arns")));
        add_gateway_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "add_gateway_load_balancer_arns")));
        remove_gateway_load_balancer_arns =
          (ValueStringList.of_json
             (Util.of_option_exn
                (Json.lookup j "remove_gateway_load_balancer_arns")))
      }
  end
module AcceptTransitGatewayVpcAttachmentRequest =
  struct
    type t =
      {
      transit_gateway_attachment_id: String.t ;
      dry_run: Boolean.t option }
    let make ~transit_gateway_attachment_id  ?dry_run  () =
      { transit_gateway_attachment_id; dry_run }
    let parse xml =
      Some
        {
          transit_gateway_attachment_id =
            (Xml.required "TransitGatewayAttachmentId"
               (Util.option_bind
                  (Xml.member "TransitGatewayAttachmentId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("TransitGatewayAttachmentId",
                  (String.to_query v.transit_gateway_attachment_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("transit_gateway_attachment_id",
               (String.to_json v.transit_gateway_attachment_id))])
    let of_json j =
      {
        transit_gateway_attachment_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "transit_gateway_attachment_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DescribeInstanceCreditSpecificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      instance_ids: InstanceIdStringList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(instance_ids= [])  ?max_results 
      ?next_token  () =
      { dry_run; filters; instance_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          instance_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "InstanceId" xml)
                  InstanceIdStringList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("InstanceId",
                  (InstanceIdStringList.to_query v.instance_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("instance_ids", (InstanceIdStringList.to_json v.instance_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        instance_ids =
          (InstanceIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module EnableTransitGatewayRouteTablePropagationResult =
  struct
    type t = {
      propagation: TransitGatewayPropagation.t option }
    let make ?propagation  () = { propagation }
    let parse xml =
      Some
        {
          propagation =
            (Util.option_bind (Xml.member "propagation" xml)
               TransitGatewayPropagation.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 Query.Pair
                   ("Propagation", (TransitGatewayPropagation.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.propagation
              (fun f ->
                 ("propagation", (TransitGatewayPropagation.to_json f)))])
    let of_json j =
      {
        propagation =
          (Util.option_map (Json.lookup j "propagation")
             TransitGatewayPropagation.of_json)
      }
  end
module GetConsoleScreenshotRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      wake_up: Boolean.t option }
    let make ?dry_run  ~instance_id  ?wake_up  () =
      { dry_run; instance_id; wake_up }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "InstanceId"
               (Util.option_bind (Xml.member "InstanceId" xml) String.parse));
          wake_up =
            (Util.option_bind (Xml.member "WakeUp" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.wake_up
              (fun f -> Query.Pair ("WakeUp", (Boolean.to_query f)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.wake_up
              (fun f -> ("wake_up", (Boolean.to_json f)));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        wake_up = (Util.option_map (Json.lookup j "wake_up") Boolean.of_json)
      }
  end
module RejectVpcEndpointConnectionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      service_id: String.t ;
      vpc_endpoint_ids: VpcEndpointIdList.t }
    let make ?dry_run  ~service_id  ~vpc_endpoint_ids  () =
      { dry_run; service_id; vpc_endpoint_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          service_id =
            (Xml.required "ServiceId"
               (Util.option_bind (Xml.member "ServiceId" xml) String.parse));
          vpc_endpoint_ids =
            (Xml.required "VpcEndpointId"
               (Util.option_bind (Xml.member "VpcEndpointId" xml)
                  VpcEndpointIdList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("VpcEndpointId",
                   (VpcEndpointIdList.to_query v.vpc_endpoint_ids)));
           Some (Query.Pair ("ServiceId", (String.to_query v.service_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("vpc_endpoint_ids",
                (VpcEndpointIdList.to_json v.vpc_endpoint_ids));
           Some ("service_id", (String.to_json v.service_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        service_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "service_id")));
        vpc_endpoint_ids =
          (VpcEndpointIdList.of_json
             (Util.of_option_exn (Json.lookup j "vpc_endpoint_ids")))
      }
  end
module DescribeSpotFleetInstancesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      max_results: Integer.t option ;
      next_token: String.t option ;
      spot_fleet_request_id: String.t }
    let make ?dry_run  ?max_results  ?next_token  ~spot_fleet_request_id  ()
      = { dry_run; max_results; next_token; spot_fleet_request_id }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          max_results =
            (Util.option_bind (Xml.member "maxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          spot_fleet_request_id =
            (Xml.required "spotFleetRequestId"
               (Util.option_bind (Xml.member "spotFleetRequestId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("SpotFleetRequestId",
                   (String.to_query v.spot_fleet_request_id)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("spot_fleet_request_id",
                (String.to_json v.spot_fleet_request_id));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        spot_fleet_request_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "spot_fleet_request_id")))
      }
  end
module DetachVpnGatewayRequest =
  struct
    type t =
      {
      vpc_id: String.t ;
      vpn_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~vpc_id  ~vpn_gateway_id  ?dry_run  () =
      { vpc_id; vpn_gateway_id; dry_run }
    let parse xml =
      Some
        {
          vpc_id =
            (Xml.required "VpcId"
               (Util.option_bind (Xml.member "VpcId" xml) String.parse));
          vpn_gateway_id =
            (Xml.required "VpnGatewayId"
               (Util.option_bind (Xml.member "VpnGatewayId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("VpnGatewayId", (String.to_query v.vpn_gateway_id)));
           Some (Query.Pair ("VpcId", (String.to_query v.vpc_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("vpn_gateway_id", (String.to_json v.vpn_gateway_id));
           Some ("vpc_id", (String.to_json v.vpc_id))])
    let of_json j =
      {
        vpc_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "vpc_id")));
        vpn_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "vpn_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module MonitorInstancesResult =
  struct
    type t = {
      instance_monitorings: InstanceMonitoringList.t }
    let make ?(instance_monitorings= [])  () = { instance_monitorings }
    let parse xml =
      Some
        {
          instance_monitorings =
            (Util.of_option []
               (Util.option_bind (Xml.member "instancesSet" xml)
                  InstanceMonitoringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstancesSet",
                   (InstanceMonitoringList.to_query v.instance_monitorings)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_monitorings",
                (InstanceMonitoringList.to_json v.instance_monitorings))])
    let of_json j =
      {
        instance_monitorings =
          (InstanceMonitoringList.of_json
             (Util.of_option_exn (Json.lookup j "instance_monitorings")))
      }
  end
module AuthorizeSecurityGroupIngressRequest =
  struct
    type t =
      {
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t ;
      ip_protocol: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      to_port: Integer.t option ;
      dry_run: Boolean.t option }
    let make ?cidr_ip  ?from_port  ?group_id  ?group_name  ?(ip_permissions=
      [])  ?ip_protocol  ?source_security_group_name 
      ?source_security_group_owner_id  ?to_port  ?dry_run  () =
      {
        cidr_ip;
        from_port;
        group_id;
        group_name;
        ip_permissions;
        ip_protocol;
        source_security_group_name;
        source_security_group_owner_id;
        to_port;
        dry_run
      }
    let parse xml =
      Some
        {
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse));
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)))])
    let of_json j =
      {
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module DeleteTransitGatewayMulticastDomainResult =
  struct
    type t =
      {
      transit_gateway_multicast_domain:
        TransitGatewayMulticastDomain.t option }
    let make ?transit_gateway_multicast_domain  () =
      { transit_gateway_multicast_domain }
    let parse xml =
      Some
        {
          transit_gateway_multicast_domain =
            (Util.option_bind
               (Xml.member "transitGatewayMulticastDomain" xml)
               TransitGatewayMulticastDomain.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 Query.Pair
                   ("TransitGatewayMulticastDomain",
                     (TransitGatewayMulticastDomain.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.transit_gateway_multicast_domain
              (fun f ->
                 ("transit_gateway_multicast_domain",
                   (TransitGatewayMulticastDomain.to_json f)))])
    let of_json j =
      {
        transit_gateway_multicast_domain =
          (Util.option_map (Json.lookup j "transit_gateway_multicast_domain")
             TransitGatewayMulticastDomain.of_json)
      }
  end
module SearchLocalGatewayRoutesResult =
  struct
    type t = {
      routes: LocalGatewayRouteList.t ;
      next_token: String.t option }
    let make ?(routes= [])  ?next_token  () = { routes; next_token }
    let parse xml =
      Some
        {
          routes =
            (Util.of_option []
               (Util.option_bind (Xml.member "routeSet" xml)
                  LocalGatewayRouteList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("RouteSet", (LocalGatewayRouteList.to_query v.routes)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("routes", (LocalGatewayRouteList.to_json v.routes))])
    let of_json j =
      {
        routes =
          (LocalGatewayRouteList.of_json
             (Util.of_option_exn (Json.lookup j "routes")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module RunScheduledInstancesRequest =
  struct
    type t =
      {
      client_token: String.t option ;
      dry_run: Boolean.t option ;
      instance_count: Integer.t option ;
      launch_specification: ScheduledInstancesLaunchSpecification.t ;
      scheduled_instance_id: String.t }
    let make ?client_token  ?dry_run  ?instance_count  ~launch_specification 
      ~scheduled_instance_id  () =
      {
        client_token;
        dry_run;
        instance_count;
        launch_specification;
        scheduled_instance_id
      }
    let parse xml =
      Some
        {
          client_token =
            (Util.option_bind (Xml.member "ClientToken" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_count =
            (Util.option_bind (Xml.member "InstanceCount" xml) Integer.parse);
          launch_specification =
            (Xml.required "LaunchSpecification"
               (Util.option_bind (Xml.member "LaunchSpecification" xml)
                  ScheduledInstancesLaunchSpecification.parse));
          scheduled_instance_id =
            (Xml.required "ScheduledInstanceId"
               (Util.option_bind (Xml.member "ScheduledInstanceId" xml)
                  String.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ScheduledInstanceId",
                   (String.to_query v.scheduled_instance_id)));
           Some
             (Query.Pair
                ("LaunchSpecification",
                  (ScheduledInstancesLaunchSpecification.to_query
                     v.launch_specification)));
           Util.option_map v.instance_count
             (fun f -> Query.Pair ("InstanceCount", (Integer.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.client_token
             (fun f -> Query.Pair ("ClientToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("scheduled_instance_id",
                (String.to_json v.scheduled_instance_id));
           Some
             ("launch_specification",
               (ScheduledInstancesLaunchSpecification.to_json
                  v.launch_specification));
           Util.option_map v.instance_count
             (fun f -> ("instance_count", (Integer.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.client_token
             (fun f -> ("client_token", (String.to_json f)))])
    let of_json j =
      {
        client_token =
          (Util.option_map (Json.lookup j "client_token") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_count =
          (Util.option_map (Json.lookup j "instance_count") Integer.of_json);
        launch_specification =
          (ScheduledInstancesLaunchSpecification.of_json
             (Util.of_option_exn (Json.lookup j "launch_specification")));
        scheduled_instance_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "scheduled_instance_id")))
      }
  end
module DescribeExportImageTasksRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      filters: FilterList.t ;
      export_image_task_ids: ExportImageTaskIdList.t ;
      max_results: Integer.t option ;
      next_token: String.t option }
    let make ?dry_run  ?(filters= [])  ?(export_image_task_ids= []) 
      ?max_results  ?next_token  () =
      { dry_run; filters; export_image_task_ids; max_results; next_token }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          filters =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          export_image_task_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "ExportImageTaskId" xml)
                  ExportImageTaskIdList.parse));
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Some
             (Query.Pair
                ("ExportImageTaskId",
                  (ExportImageTaskIdList.to_query v.export_image_task_ids)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filters)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Some
             ("export_image_task_ids",
               (ExportImageTaskIdList.to_json v.export_image_task_ids));
           Some ("filters", (FilterList.to_json v.filters));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        filters =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filters")));
        export_image_task_ids =
          (ExportImageTaskIdList.of_json
             (Util.of_option_exn (Json.lookup j "export_image_task_ids")));
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DeleteCustomerGatewayRequest =
  struct
    type t = {
      customer_gateway_id: String.t ;
      dry_run: Boolean.t option }
    let make ~customer_gateway_id  ?dry_run  () =
      { customer_gateway_id; dry_run }
    let parse xml =
      Some
        {
          customer_gateway_id =
            (Xml.required "CustomerGatewayId"
               (Util.option_bind (Xml.member "CustomerGatewayId" xml)
                  String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("CustomerGatewayId",
                  (String.to_query v.customer_gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("customer_gateway_id", (String.to_json v.customer_gateway_id))])
    let of_json j =
      {
        customer_gateway_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "customer_gateway_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RevokeSecurityGroupIngressRequest =
  struct
    type t =
      {
      cidr_ip: String.t option ;
      from_port: Integer.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t ;
      ip_protocol: String.t option ;
      source_security_group_name: String.t option ;
      source_security_group_owner_id: String.t option ;
      to_port: Integer.t option ;
      dry_run: Boolean.t option }
    let make ?cidr_ip  ?from_port  ?group_id  ?group_name  ?(ip_permissions=
      [])  ?ip_protocol  ?source_security_group_name 
      ?source_security_group_owner_id  ?to_port  ?dry_run  () =
      {
        cidr_ip;
        from_port;
        group_id;
        group_name;
        ip_permissions;
        ip_protocol;
        source_security_group_name;
        source_security_group_owner_id;
        to_port;
        dry_run
      }
    let parse xml =
      Some
        {
          cidr_ip = (Util.option_bind (Xml.member "CidrIp" xml) String.parse);
          from_port =
            (Util.option_bind (Xml.member "FromPort" xml) Integer.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Util.of_option []
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse));
          ip_protocol =
            (Util.option_bind (Xml.member "IpProtocol" xml) String.parse);
          source_security_group_name =
            (Util.option_bind (Xml.member "SourceSecurityGroupName" xml)
               String.parse);
          source_security_group_owner_id =
            (Util.option_bind (Xml.member "SourceSecurityGroupOwnerId" xml)
               String.parse);
          to_port =
            (Util.option_bind (Xml.member "ToPort" xml) Integer.parse);
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.to_port
             (fun f -> Query.Pair ("ToPort", (Integer.to_query f)));
           Util.option_map v.source_security_group_owner_id
             (fun f ->
                Query.Pair
                  ("SourceSecurityGroupOwnerId", (String.to_query f)));
           Util.option_map v.source_security_group_name
             (fun f ->
                Query.Pair ("SourceSecurityGroupName", (String.to_query f)));
           Util.option_map v.ip_protocol
             (fun f -> Query.Pair ("IpProtocol", (String.to_query f)));
           Some
             (Query.Pair
                ("IpPermissions",
                  (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.from_port
             (fun f -> Query.Pair ("FromPort", (Integer.to_query f)));
           Util.option_map v.cidr_ip
             (fun f -> Query.Pair ("CidrIp", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.to_port
             (fun f -> ("to_port", (Integer.to_json f)));
           Util.option_map v.source_security_group_owner_id
             (fun f -> ("source_security_group_owner_id", (String.to_json f)));
           Util.option_map v.source_security_group_name
             (fun f -> ("source_security_group_name", (String.to_json f)));
           Util.option_map v.ip_protocol
             (fun f -> ("ip_protocol", (String.to_json f)));
           Some
             ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.from_port
             (fun f -> ("from_port", (Integer.to_json f)));
           Util.option_map v.cidr_ip
             (fun f -> ("cidr_ip", (String.to_json f)))])
    let of_json j =
      {
        cidr_ip = (Util.option_map (Json.lookup j "cidr_ip") String.of_json);
        from_port =
          (Util.option_map (Json.lookup j "from_port") Integer.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")));
        ip_protocol =
          (Util.option_map (Json.lookup j "ip_protocol") String.of_json);
        source_security_group_name =
          (Util.option_map (Json.lookup j "source_security_group_name")
             String.of_json);
        source_security_group_owner_id =
          (Util.option_map (Json.lookup j "source_security_group_owner_id")
             String.of_json);
        to_port = (Util.option_map (Json.lookup j "to_port") Integer.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsEgressResult =
  struct
    type t = {
      return: Boolean.t option }
    let make ?return  () = { return }
    let parse xml =
      Some
        { return = (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return
              (fun f -> ("return", (Boolean.to_json f)))])
    let of_json j =
      { return = (Util.option_map (Json.lookup j "return") Boolean.of_json) }
  end
module DeleteCarrierGatewayResult =
  struct
    type t = {
      carrier_gateway: CarrierGateway.t option }
    let make ?carrier_gateway  () = { carrier_gateway }
    let parse xml =
      Some
        {
          carrier_gateway =
            (Util.option_bind (Xml.member "carrierGateway" xml)
               CarrierGateway.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.carrier_gateway
              (fun f ->
                 Query.Pair ("CarrierGateway", (CarrierGateway.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.carrier_gateway
              (fun f -> ("carrier_gateway", (CarrierGateway.to_json f)))])
    let of_json j =
      {
        carrier_gateway =
          (Util.option_map (Json.lookup j "carrier_gateway")
             CarrierGateway.of_json)
      }
  end
module DisableVgwRoutePropagationRequest =
  struct
    type t =
      {
      gateway_id: String.t ;
      route_table_id: String.t ;
      dry_run: Boolean.t option }
    let make ~gateway_id  ~route_table_id  ?dry_run  () =
      { gateway_id; route_table_id; dry_run }
    let parse xml =
      Some
        {
          gateway_id =
            (Xml.required "GatewayId"
               (Util.option_bind (Xml.member "GatewayId" xml) String.parse));
          route_table_id =
            (Xml.required "RouteTableId"
               (Util.option_bind (Xml.member "RouteTableId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("RouteTableId", (String.to_query v.route_table_id)));
           Some (Query.Pair ("GatewayId", (String.to_query v.gateway_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("route_table_id", (String.to_json v.route_table_id));
           Some ("gateway_id", (String.to_json v.gateway_id))])
    let of_json j =
      {
        gateway_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "gateway_id")));
        route_table_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "route_table_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module RegisterInstanceEventNotificationAttributesRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      instance_tag_attribute: RegisterInstanceTagAttributeRequest.t option }
    let make ?dry_run  ?instance_tag_attribute  () =
      { dry_run; instance_tag_attribute }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          instance_tag_attribute =
            (Util.option_bind (Xml.member "InstanceTagAttribute" xml)
               RegisterInstanceTagAttributeRequest.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 Query.Pair
                   ("InstanceTagAttribute",
                     (RegisterInstanceTagAttributeRequest.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.instance_tag_attribute
              (fun f ->
                 ("instance_tag_attribute",
                   (RegisterInstanceTagAttributeRequest.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_tag_attribute =
          (Util.option_map (Json.lookup j "instance_tag_attribute")
             RegisterInstanceTagAttributeRequest.of_json)
      }
  end
module DescribeVpcAttributeResult =
  struct
    type t =
      {
      vpc_id: String.t option ;
      enable_dns_hostnames: AttributeBooleanValue.t option ;
      enable_dns_support: AttributeBooleanValue.t option }
    let make ?vpc_id  ?enable_dns_hostnames  ?enable_dns_support  () =
      { vpc_id; enable_dns_hostnames; enable_dns_support }
    let parse xml =
      Some
        {
          vpc_id = (Util.option_bind (Xml.member "vpcId" xml) String.parse);
          enable_dns_hostnames =
            (Util.option_bind (Xml.member "enableDnsHostnames" xml)
               AttributeBooleanValue.parse);
          enable_dns_support =
            (Util.option_bind (Xml.member "enableDnsSupport" xml)
               AttributeBooleanValue.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 Query.Pair
                   ("EnableDnsSupport", (AttributeBooleanValue.to_query f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                Query.Pair
                  ("EnableDnsHostnames", (AttributeBooleanValue.to_query f)));
           Util.option_map v.vpc_id
             (fun f -> Query.Pair ("VpcId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.enable_dns_support
              (fun f ->
                 ("enable_dns_support", (AttributeBooleanValue.to_json f)));
           Util.option_map v.enable_dns_hostnames
             (fun f ->
                ("enable_dns_hostnames", (AttributeBooleanValue.to_json f)));
           Util.option_map v.vpc_id (fun f -> ("vpc_id", (String.to_json f)))])
    let of_json j =
      {
        vpc_id = (Util.option_map (Json.lookup j "vpc_id") String.of_json);
        enable_dns_hostnames =
          (Util.option_map (Json.lookup j "enable_dns_hostnames")
             AttributeBooleanValue.of_json);
        enable_dns_support =
          (Util.option_map (Json.lookup j "enable_dns_support")
             AttributeBooleanValue.of_json)
      }
  end
module DeleteLaunchTemplateVersionsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      launch_template_id: String.t option ;
      launch_template_name: String.t option ;
      versions: VersionStringList.t }
    let make ?dry_run  ?launch_template_id  ?launch_template_name  ~versions 
      () = { dry_run; launch_template_id; launch_template_name; versions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          launch_template_id =
            (Util.option_bind (Xml.member "LaunchTemplateId" xml)
               String.parse);
          launch_template_name =
            (Util.option_bind (Xml.member "LaunchTemplateName" xml)
               String.parse);
          versions =
            (Xml.required "LaunchTemplateVersion"
               (Util.option_bind (Xml.member "LaunchTemplateVersion" xml)
                  VersionStringList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("LaunchTemplateVersion",
                   (VersionStringList.to_query v.versions)));
           Util.option_map v.launch_template_name
             (fun f -> Query.Pair ("LaunchTemplateName", (String.to_query f)));
           Util.option_map v.launch_template_id
             (fun f -> Query.Pair ("LaunchTemplateId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some ("versions", (VersionStringList.to_json v.versions));
           Util.option_map v.launch_template_name
             (fun f -> ("launch_template_name", (String.to_json f)));
           Util.option_map v.launch_template_id
             (fun f -> ("launch_template_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        launch_template_id =
          (Util.option_map (Json.lookup j "launch_template_id")
             String.of_json);
        launch_template_name =
          (Util.option_map (Json.lookup j "launch_template_name")
             String.of_json);
        versions =
          (VersionStringList.of_json
             (Util.of_option_exn (Json.lookup j "versions")))
      }
  end
module DescribeNatGatewaysResult =
  struct
    type t = {
      nat_gateways: NatGatewayList.t ;
      next_token: String.t option }
    let make ?(nat_gateways= [])  ?next_token  () =
      { nat_gateways; next_token }
    let parse xml =
      Some
        {
          nat_gateways =
            (Util.of_option []
               (Util.option_bind (Xml.member "natGatewaySet" xml)
                  NatGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("NatGatewaySet", (NatGatewayList.to_query v.nat_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some ("nat_gateways", (NatGatewayList.to_json v.nat_gateways))])
    let of_json j =
      {
        nat_gateways =
          (NatGatewayList.of_json
             (Util.of_option_exn (Json.lookup j "nat_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module TerminateClientVpnConnectionsRequest =
  struct
    type t =
      {
      client_vpn_endpoint_id: String.t ;
      connection_id: String.t option ;
      username: String.t option ;
      dry_run: Boolean.t option }
    let make ~client_vpn_endpoint_id  ?connection_id  ?username  ?dry_run  ()
      = { client_vpn_endpoint_id; connection_id; username; dry_run }
    let parse xml =
      Some
        {
          client_vpn_endpoint_id =
            (Xml.required "ClientVpnEndpointId"
               (Util.option_bind (Xml.member "ClientVpnEndpointId" xml)
                  String.parse));
          connection_id =
            (Util.option_bind (Xml.member "ConnectionId" xml) String.parse);
          username =
            (Util.option_bind (Xml.member "Username" xml) String.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.username
             (fun f -> Query.Pair ("Username", (String.to_query f)));
           Util.option_map v.connection_id
             (fun f -> Query.Pair ("ConnectionId", (String.to_query f)));
           Some
             (Query.Pair
                ("ClientVpnEndpointId",
                  (String.to_query v.client_vpn_endpoint_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.username
             (fun f -> ("username", (String.to_json f)));
           Util.option_map v.connection_id
             (fun f -> ("connection_id", (String.to_json f)));
           Some
             ("client_vpn_endpoint_id",
               (String.to_json v.client_vpn_endpoint_id))])
    let of_json j =
      {
        client_vpn_endpoint_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "client_vpn_endpoint_id")));
        connection_id =
          (Util.option_map (Json.lookup j "connection_id") String.of_json);
        username =
          (Util.option_map (Json.lookup j "username") String.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module GetCapacityReservationUsageResult =
  struct
    type t =
      {
      next_token: String.t option ;
      capacity_reservation_id: String.t option ;
      instance_type: String.t option ;
      total_instance_count: Integer.t option ;
      available_instance_count: Integer.t option ;
      state: CapacityReservationState.t option ;
      instance_usages: InstanceUsageSet.t }
    let make ?next_token  ?capacity_reservation_id  ?instance_type 
      ?total_instance_count  ?available_instance_count  ?state 
      ?(instance_usages= [])  () =
      {
        next_token;
        capacity_reservation_id;
        instance_type;
        total_instance_count;
        available_instance_count;
        state;
        instance_usages
      }
    let parse xml =
      Some
        {
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse);
          capacity_reservation_id =
            (Util.option_bind (Xml.member "capacityReservationId" xml)
               String.parse);
          instance_type =
            (Util.option_bind (Xml.member "instanceType" xml) String.parse);
          total_instance_count =
            (Util.option_bind (Xml.member "totalInstanceCount" xml)
               Integer.parse);
          available_instance_count =
            (Util.option_bind (Xml.member "availableInstanceCount" xml)
               Integer.parse);
          state =
            (Util.option_bind (Xml.member "state" xml)
               CapacityReservationState.parse);
          instance_usages =
            (Util.of_option []
               (Util.option_bind (Xml.member "instanceUsageSet" xml)
                  InstanceUsageSet.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("InstanceUsageSet",
                   (InstanceUsageSet.to_query v.instance_usages)));
           Util.option_map v.state
             (fun f ->
                Query.Pair ("State", (CapacityReservationState.to_query f)));
           Util.option_map v.available_instance_count
             (fun f ->
                Query.Pair ("AvailableInstanceCount", (Integer.to_query f)));
           Util.option_map v.total_instance_count
             (fun f ->
                Query.Pair ("TotalInstanceCount", (Integer.to_query f)));
           Util.option_map v.instance_type
             (fun f -> Query.Pair ("InstanceType", (String.to_query f)));
           Util.option_map v.capacity_reservation_id
             (fun f ->
                Query.Pair ("CapacityReservationId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("instance_usages",
                (InstanceUsageSet.to_json v.instance_usages));
           Util.option_map v.state
             (fun f -> ("state", (CapacityReservationState.to_json f)));
           Util.option_map v.available_instance_count
             (fun f -> ("available_instance_count", (Integer.to_json f)));
           Util.option_map v.total_instance_count
             (fun f -> ("total_instance_count", (Integer.to_json f)));
           Util.option_map v.instance_type
             (fun f -> ("instance_type", (String.to_json f)));
           Util.option_map v.capacity_reservation_id
             (fun f -> ("capacity_reservation_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)))])
    let of_json j =
      {
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        capacity_reservation_id =
          (Util.option_map (Json.lookup j "capacity_reservation_id")
             String.of_json);
        instance_type =
          (Util.option_map (Json.lookup j "instance_type") String.of_json);
        total_instance_count =
          (Util.option_map (Json.lookup j "total_instance_count")
             Integer.of_json);
        available_instance_count =
          (Util.option_map (Json.lookup j "available_instance_count")
             Integer.of_json);
        state =
          (Util.option_map (Json.lookup j "state")
             CapacityReservationState.of_json);
        instance_usages =
          (InstanceUsageSet.of_json
             (Util.of_option_exn (Json.lookup j "instance_usages")))
      }
  end
module DescribeFastSnapshotRestoresResult =
  struct
    type t =
      {
      fast_snapshot_restores: DescribeFastSnapshotRestoreSuccessSet.t ;
      next_token: String.t option }
    let make ?(fast_snapshot_restores= [])  ?next_token  () =
      { fast_snapshot_restores; next_token }
    let parse xml =
      Some
        {
          fast_snapshot_restores =
            (Util.of_option []
               (Util.option_bind (Xml.member "fastSnapshotRestoreSet" xml)
                  DescribeFastSnapshotRestoreSuccessSet.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("FastSnapshotRestoreSet",
                  (DescribeFastSnapshotRestoreSuccessSet.to_query
                     v.fast_snapshot_restores)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("fast_snapshot_restores",
               (DescribeFastSnapshotRestoreSuccessSet.to_json
                  v.fast_snapshot_restores))])
    let of_json j =
      {
        fast_snapshot_restores =
          (DescribeFastSnapshotRestoreSuccessSet.of_json
             (Util.of_option_exn (Json.lookup j "fast_snapshot_restores")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module DescribeHostReservationOfferingsRequest =
  struct
    type t =
      {
      filter: FilterList.t ;
      max_duration: Integer.t option ;
      max_results: Integer.t option ;
      min_duration: Integer.t option ;
      next_token: String.t option ;
      offering_id: String.t option }
    let make ?(filter= [])  ?max_duration  ?max_results  ?min_duration 
      ?next_token  ?offering_id  () =
      {
        filter;
        max_duration;
        max_results;
        min_duration;
        next_token;
        offering_id
      }
    let parse xml =
      Some
        {
          filter =
            (Util.of_option []
               (Util.option_bind (Xml.member "Filter" xml) FilterList.parse));
          max_duration =
            (Util.option_bind (Xml.member "MaxDuration" xml) Integer.parse);
          max_results =
            (Util.option_bind (Xml.member "MaxResults" xml) Integer.parse);
          min_duration =
            (Util.option_bind (Xml.member "MinDuration" xml) Integer.parse);
          next_token =
            (Util.option_bind (Xml.member "NextToken" xml) String.parse);
          offering_id =
            (Util.option_bind (Xml.member "OfferingId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> Query.Pair ("OfferingId", (String.to_query f)));
           Util.option_map v.next_token
             (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Util.option_map v.min_duration
             (fun f -> Query.Pair ("MinDuration", (Integer.to_query f)));
           Util.option_map v.max_results
             (fun f -> Query.Pair ("MaxResults", (Integer.to_query f)));
           Util.option_map v.max_duration
             (fun f -> Query.Pair ("MaxDuration", (Integer.to_query f)));
           Some (Query.Pair ("Filter", (FilterList.to_query v.filter)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.offering_id
              (fun f -> ("offering_id", (String.to_json f)));
           Util.option_map v.next_token
             (fun f -> ("next_token", (String.to_json f)));
           Util.option_map v.min_duration
             (fun f -> ("min_duration", (Integer.to_json f)));
           Util.option_map v.max_results
             (fun f -> ("max_results", (Integer.to_json f)));
           Util.option_map v.max_duration
             (fun f -> ("max_duration", (Integer.to_json f)));
           Some ("filter", (FilterList.to_json v.filter))])
    let of_json j =
      {
        filter =
          (FilterList.of_json (Util.of_option_exn (Json.lookup j "filter")));
        max_duration =
          (Util.option_map (Json.lookup j "max_duration") Integer.of_json);
        max_results =
          (Util.option_map (Json.lookup j "max_results") Integer.of_json);
        min_duration =
          (Util.option_map (Json.lookup j "min_duration") Integer.of_json);
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json);
        offering_id =
          (Util.option_map (Json.lookup j "offering_id") String.of_json)
      }
  end
module PurchaseReservedInstancesOfferingRequest =
  struct
    type t =
      {
      instance_count: Integer.t ;
      reserved_instances_offering_id: String.t ;
      dry_run: Boolean.t option ;
      limit_price: ReservedInstanceLimitPrice.t option ;
      purchase_time: DateTime.t option }
    let make ~instance_count  ~reserved_instances_offering_id  ?dry_run 
      ?limit_price  ?purchase_time  () =
      {
        instance_count;
        reserved_instances_offering_id;
        dry_run;
        limit_price;
        purchase_time
      }
    let parse xml =
      Some
        {
          instance_count =
            (Xml.required "InstanceCount"
               (Util.option_bind (Xml.member "InstanceCount" xml)
                  Integer.parse));
          reserved_instances_offering_id =
            (Xml.required "ReservedInstancesOfferingId"
               (Util.option_bind
                  (Xml.member "ReservedInstancesOfferingId" xml) String.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          limit_price =
            (Util.option_bind (Xml.member "limitPrice" xml)
               ReservedInstanceLimitPrice.parse);
          purchase_time =
            (Util.option_bind (Xml.member "PurchaseTime" xml) DateTime.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.purchase_time
              (fun f -> Query.Pair ("PurchaseTime", (DateTime.to_query f)));
           Util.option_map v.limit_price
             (fun f ->
                Query.Pair
                  ("LimitPrice", (ReservedInstanceLimitPrice.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("ReservedInstancesOfferingId",
                  (String.to_query v.reserved_instances_offering_id)));
           Some
             (Query.Pair
                ("InstanceCount", (Integer.to_query v.instance_count)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.purchase_time
              (fun f -> ("purchase_time", (DateTime.to_json f)));
           Util.option_map v.limit_price
             (fun f ->
                ("limit_price", (ReservedInstanceLimitPrice.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some
             ("reserved_instances_offering_id",
               (String.to_json v.reserved_instances_offering_id));
           Some ("instance_count", (Integer.to_json v.instance_count))])
    let of_json j =
      {
        instance_count =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "instance_count")));
        reserved_instances_offering_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "reserved_instances_offering_id")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        limit_price =
          (Util.option_map (Json.lookup j "limit_price")
             ReservedInstanceLimitPrice.of_json);
        purchase_time =
          (Util.option_map (Json.lookup j "purchase_time") DateTime.of_json)
      }
  end
module DeleteNatGatewayResult =
  struct
    type t = {
      nat_gateway_id: String.t option }
    let make ?nat_gateway_id  () = { nat_gateway_id }
    let parse xml =
      Some
        {
          nat_gateway_id =
            (Util.option_bind (Xml.member "natGatewayId" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> Query.Pair ("NatGatewayId", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.nat_gateway_id
              (fun f -> ("nat_gateway_id", (String.to_json f)))])
    let of_json j =
      {
        nat_gateway_id =
          (Util.option_map (Json.lookup j "nat_gateway_id") String.of_json)
      }
  end
module ExportClientVpnClientConfigurationResult =
  struct
    type t = {
      client_configuration: String.t option }
    let make ?client_configuration  () = { client_configuration }
    let parse xml =
      Some
        {
          client_configuration =
            (Util.option_bind (Xml.member "clientConfiguration" xml)
               String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f ->
                 Query.Pair ("ClientConfiguration", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.client_configuration
              (fun f -> ("client_configuration", (String.to_json f)))])
    let of_json j =
      {
        client_configuration =
          (Util.option_map (Json.lookup j "client_configuration")
             String.of_json)
      }
  end
module DeleteVpcEndpointConnectionNotificationsRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      connection_notification_ids: ConnectionNotificationIdsList.t }
    let make ?dry_run  ~connection_notification_ids  () =
      { dry_run; connection_notification_ids }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          connection_notification_ids =
            (Xml.required "ConnectionNotificationId"
               (Util.option_bind (Xml.member "ConnectionNotificationId" xml)
                  ConnectionNotificationIdsList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("ConnectionNotificationId",
                   (ConnectionNotificationIdsList.to_query
                      v.connection_notification_ids)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("connection_notification_ids",
                (ConnectionNotificationIdsList.to_json
                   v.connection_notification_ids));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        connection_notification_ids =
          (ConnectionNotificationIdsList.of_json
             (Util.of_option_exn
                (Json.lookup j "connection_notification_ids")))
      }
  end
module DescribeEgressOnlyInternetGatewaysResult =
  struct
    type t =
      {
      egress_only_internet_gateways: EgressOnlyInternetGatewayList.t ;
      next_token: String.t option }
    let make ?(egress_only_internet_gateways= [])  ?next_token  () =
      { egress_only_internet_gateways; next_token }
    let parse xml =
      Some
        {
          egress_only_internet_gateways =
            (Util.of_option []
               (Util.option_bind
                  (Xml.member "egressOnlyInternetGatewaySet" xml)
                  EgressOnlyInternetGatewayList.parse));
          next_token =
            (Util.option_bind (Xml.member "nextToken" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> Query.Pair ("NextToken", (String.to_query f)));
           Some
             (Query.Pair
                ("EgressOnlyInternetGatewaySet",
                  (EgressOnlyInternetGatewayList.to_query
                     v.egress_only_internet_gateways)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.next_token
              (fun f -> ("next_token", (String.to_json f)));
           Some
             ("egress_only_internet_gateways",
               (EgressOnlyInternetGatewayList.to_json
                  v.egress_only_internet_gateways))])
    let of_json j =
      {
        egress_only_internet_gateways =
          (EgressOnlyInternetGatewayList.of_json
             (Util.of_option_exn
                (Json.lookup j "egress_only_internet_gateways")));
        next_token =
          (Util.option_map (Json.lookup j "next_token") String.of_json)
      }
  end
module ModifyFpgaImageAttributeRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      fpga_image_id: String.t ;
      attribute: FpgaImageAttributeName.t option ;
      operation_type: OperationType.t option ;
      user_ids: UserIdStringList.t ;
      user_groups: UserGroupStringList.t ;
      product_codes: ProductCodeStringList.t ;
      load_permission: LoadPermissionModifications.t option ;
      description: String.t option ;
      name: String.t option }
    let make ?dry_run  ~fpga_image_id  ?attribute  ?operation_type 
      ?(user_ids= [])  ?(user_groups= [])  ?(product_codes= []) 
      ?load_permission  ?description  ?name  () =
      {
        dry_run;
        fpga_image_id;
        attribute;
        operation_type;
        user_ids;
        user_groups;
        product_codes;
        load_permission;
        description;
        name
      }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          fpga_image_id =
            (Xml.required "FpgaImageId"
               (Util.option_bind (Xml.member "FpgaImageId" xml) String.parse));
          attribute =
            (Util.option_bind (Xml.member "Attribute" xml)
               FpgaImageAttributeName.parse);
          operation_type =
            (Util.option_bind (Xml.member "OperationType" xml)
               OperationType.parse);
          user_ids =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserId" xml)
                  UserIdStringList.parse));
          user_groups =
            (Util.of_option []
               (Util.option_bind (Xml.member "UserGroup" xml)
                  UserGroupStringList.parse));
          product_codes =
            (Util.of_option []
               (Util.option_bind (Xml.member "ProductCode" xml)
                  ProductCodeStringList.parse));
          load_permission =
            (Util.option_bind (Xml.member "LoadPermission" xml)
               LoadPermissionModifications.parse);
          description =
            (Util.option_bind (Xml.member "Description" xml) String.parse);
          name = (Util.option_bind (Xml.member "Name" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.name
              (fun f -> Query.Pair ("Name", (String.to_query f)));
           Util.option_map v.description
             (fun f -> Query.Pair ("Description", (String.to_query f)));
           Util.option_map v.load_permission
             (fun f ->
                Query.Pair
                  ("LoadPermission",
                    (LoadPermissionModifications.to_query f)));
           Some
             (Query.Pair
                ("ProductCode",
                  (ProductCodeStringList.to_query v.product_codes)));
           Some
             (Query.Pair
                ("UserGroup", (UserGroupStringList.to_query v.user_groups)));
           Some
             (Query.Pair ("UserId", (UserIdStringList.to_query v.user_ids)));
           Util.option_map v.operation_type
             (fun f ->
                Query.Pair ("OperationType", (OperationType.to_query f)));
           Util.option_map v.attribute
             (fun f ->
                Query.Pair ("Attribute", (FpgaImageAttributeName.to_query f)));
           Some
             (Query.Pair ("FpgaImageId", (String.to_query v.fpga_image_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.name (fun f -> ("name", (String.to_json f)));
           Util.option_map v.description
             (fun f -> ("description", (String.to_json f)));
           Util.option_map v.load_permission
             (fun f ->
                ("load_permission", (LoadPermissionModifications.to_json f)));
           Some
             ("product_codes",
               (ProductCodeStringList.to_json v.product_codes));
           Some ("user_groups", (UserGroupStringList.to_json v.user_groups));
           Some ("user_ids", (UserIdStringList.to_json v.user_ids));
           Util.option_map v.operation_type
             (fun f -> ("operation_type", (OperationType.to_json f)));
           Util.option_map v.attribute
             (fun f -> ("attribute", (FpgaImageAttributeName.to_json f)));
           Some ("fpga_image_id", (String.to_json v.fpga_image_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        fpga_image_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "fpga_image_id")));
        attribute =
          (Util.option_map (Json.lookup j "attribute")
             FpgaImageAttributeName.of_json);
        operation_type =
          (Util.option_map (Json.lookup j "operation_type")
             OperationType.of_json);
        user_ids =
          (UserIdStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_ids")));
        user_groups =
          (UserGroupStringList.of_json
             (Util.of_option_exn (Json.lookup j "user_groups")));
        product_codes =
          (ProductCodeStringList.of_json
             (Util.of_option_exn (Json.lookup j "product_codes")));
        load_permission =
          (Util.option_map (Json.lookup j "load_permission")
             LoadPermissionModifications.of_json);
        description =
          (Util.option_map (Json.lookup j "description") String.of_json);
        name = (Util.option_map (Json.lookup j "name") String.of_json)
      }
  end
module ModifyVpcTenancyResult =
  struct
    type t = {
      return_value: Boolean.t option }
    let make ?return_value  () = { return_value }
    let parse xml =
      Some
        {
          return_value =
            (Util.option_bind (Xml.member "return" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> Query.Pair ("Return", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.return_value
              (fun f -> ("return_value", (Boolean.to_json f)))])
    let of_json j =
      {
        return_value =
          (Util.option_map (Json.lookup j "return_value") Boolean.of_json)
      }
  end
module ExportTransitGatewayRoutesResult =
  struct
    type t = {
      s3_location: String.t option }
    let make ?s3_location  () = { s3_location }
    let parse xml =
      Some
        {
          s3_location =
            (Util.option_bind (Xml.member "s3Location" xml) String.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> Query.Pair ("S3Location", (String.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.s3_location
              (fun f -> ("s3_location", (String.to_json f)))])
    let of_json j =
      {
        s3_location =
          (Util.option_map (Json.lookup j "s3_location") String.of_json)
      }
  end
module AttachNetworkInterfaceRequest =
  struct
    type t =
      {
      device_index: Integer.t ;
      dry_run: Boolean.t option ;
      instance_id: String.t ;
      network_interface_id: String.t ;
      network_card_index: Integer.t option }
    let make ~device_index  ?dry_run  ~instance_id  ~network_interface_id 
      ?network_card_index  () =
      {
        device_index;
        dry_run;
        instance_id;
        network_interface_id;
        network_card_index
      }
    let parse xml =
      Some
        {
          device_index =
            (Xml.required "deviceIndex"
               (Util.option_bind (Xml.member "deviceIndex" xml) Integer.parse));
          dry_run =
            (Util.option_bind (Xml.member "dryRun" xml) Boolean.parse);
          instance_id =
            (Xml.required "instanceId"
               (Util.option_bind (Xml.member "instanceId" xml) String.parse));
          network_interface_id =
            (Xml.required "networkInterfaceId"
               (Util.option_bind (Xml.member "networkInterfaceId" xml)
                  String.parse));
          network_card_index =
            (Util.option_bind (Xml.member "NetworkCardIndex" xml)
               Integer.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> Query.Pair ("NetworkCardIndex", (Integer.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfaceId",
                  (String.to_query v.network_interface_id)));
           Some (Query.Pair ("InstanceId", (String.to_query v.instance_id)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Some
             (Query.Pair ("DeviceIndex", (Integer.to_query v.device_index)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.network_card_index
              (fun f -> ("network_card_index", (Integer.to_json f)));
           Some
             ("network_interface_id",
               (String.to_json v.network_interface_id));
           Some ("instance_id", (String.to_json v.instance_id));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)));
           Some ("device_index", (Integer.to_json v.device_index))])
    let of_json j =
      {
        device_index =
          (Integer.of_json
             (Util.of_option_exn (Json.lookup j "device_index")));
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        instance_id =
          (String.of_json (Util.of_option_exn (Json.lookup j "instance_id")));
        network_interface_id =
          (String.of_json
             (Util.of_option_exn (Json.lookup j "network_interface_id")));
        network_card_index =
          (Util.option_map (Json.lookup j "network_card_index")
             Integer.of_json)
      }
  end
module DeleteNetworkInterfacePermissionRequest =
  struct
    type t =
      {
      network_interface_permission_id: String.t ;
      force: Boolean.t option ;
      dry_run: Boolean.t option }
    let make ~network_interface_permission_id  ?force  ?dry_run  () =
      { network_interface_permission_id; force; dry_run }
    let parse xml =
      Some
        {
          network_interface_permission_id =
            (Xml.required "NetworkInterfacePermissionId"
               (Util.option_bind
                  (Xml.member "NetworkInterfacePermissionId" xml)
                  String.parse));
          force = (Util.option_bind (Xml.member "Force" xml) Boolean.parse);
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse)
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)));
           Util.option_map v.force
             (fun f -> Query.Pair ("Force", (Boolean.to_query f)));
           Some
             (Query.Pair
                ("NetworkInterfacePermissionId",
                  (String.to_query v.network_interface_permission_id)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Util.option_map v.dry_run
              (fun f -> ("dry_run", (Boolean.to_json f)));
           Util.option_map v.force (fun f -> ("force", (Boolean.to_json f)));
           Some
             ("network_interface_permission_id",
               (String.to_json v.network_interface_permission_id))])
    let of_json j =
      {
        network_interface_permission_id =
          (String.of_json
             (Util.of_option_exn
                (Json.lookup j "network_interface_permission_id")));
        force = (Util.option_map (Json.lookup j "force") Boolean.of_json);
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json)
      }
  end
module UpdateSecurityGroupRuleDescriptionsIngressRequest =
  struct
    type t =
      {
      dry_run: Boolean.t option ;
      group_id: String.t option ;
      group_name: String.t option ;
      ip_permissions: IpPermissionList.t }
    let make ?dry_run  ?group_id  ?group_name  ~ip_permissions  () =
      { dry_run; group_id; group_name; ip_permissions }
    let parse xml =
      Some
        {
          dry_run =
            (Util.option_bind (Xml.member "DryRun" xml) Boolean.parse);
          group_id =
            (Util.option_bind (Xml.member "GroupId" xml) String.parse);
          group_name =
            (Util.option_bind (Xml.member "GroupName" xml) String.parse);
          ip_permissions =
            (Xml.required "IpPermissions"
               (Util.option_bind (Xml.member "IpPermissions" xml)
                  IpPermissionList.parse))
        }
    let to_query v =
      Query.List
        (Util.list_filter_opt
           [Some
              (Query.Pair
                 ("IpPermissions",
                   (IpPermissionList.to_query v.ip_permissions)));
           Util.option_map v.group_name
             (fun f -> Query.Pair ("GroupName", (String.to_query f)));
           Util.option_map v.group_id
             (fun f -> Query.Pair ("GroupId", (String.to_query f)));
           Util.option_map v.dry_run
             (fun f -> Query.Pair ("DryRun", (Boolean.to_query f)))])
    let to_json v =
      `Assoc
        (Util.list_filter_opt
           [Some
              ("ip_permissions", (IpPermissionList.to_json v.ip_permissions));
           Util.option_map v.group_name
             (fun f -> ("group_name", (String.to_json f)));
           Util.option_map v.group_id
             (fun f -> ("group_id", (String.to_json f)));
           Util.option_map v.dry_run
             (fun f -> ("dry_run", (Boolean.to_json f)))])
    let of_json j =
      {
        dry_run = (Util.option_map (Json.lookup j "dry_run") Boolean.of_json);
        group_id =
          (Util.option_map (Json.lookup j "group_id") String.of_json);
        group_name =
          (Util.option_map (Json.lookup j "group_name") String.of_json);
        ip_permissions =
          (IpPermissionList.of_json
             (Util.of_option_exn (Json.lookup j "ip_permissions")))
      }
  end